'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const js = "var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop2 in b || (b = {}))\n    if (__hasOwnProp.call(b, prop2))\n      __defNormalProp(a, prop2, b[prop2]);\n  if (__getOwnPropSymbols)\n    for (var prop2 of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop2))\n        __defNormalProp(a, prop2, b[prop2]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction _mergeNamespaces(n2, m2) {\n  m2.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n2)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n2, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n2);\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x2) {\n  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace(n2) {\n  if (n2.__esModule)\n    return n2;\n  var a = Object.defineProperty({}, \"__esModule\", { value: true });\n  Object.keys(n2).forEach(function(k) {\n    var d = Object.getOwnPropertyDescriptor(n2, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function() {\n        return n2[k];\n      }\n    });\n  });\n  return a;\n}\nvar react = { exports: {} };\nvar react_production_min = {};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\nfunction toObject(val) {\n  if (val === null || val === void 0) {\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  }\n  return Object(val);\n}\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    }\n    var test1 = new String(\"abc\");\n    test1[5] = \"de\";\n    if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n      return false;\n    }\n    var test2 = {};\n    for (var i = 0; i < 10; i++) {\n      test2[\"_\" + String.fromCharCode(i)] = i;\n    }\n    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {\n      return test2[n2];\n    });\n    if (order2.join(\"\") !== \"0123456789\") {\n      return false;\n    }\n    var test3 = {};\n    \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n      test3[letter] = letter;\n    });\n    if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n      return false;\n    }\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nvar objectAssign = shouldUseNative() ? Object.assign : function(target2, source) {\n  var from;\n  var to = toObject(target2);\n  var symbols;\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n    for (var key in from) {\n      if (hasOwnProperty$3.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n  return to;\n};\n/** @license React v17.0.2\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar l = objectAssign, n = 60103, p$1 = 60106;\nreact_production_min.Fragment = 60107;\nreact_production_min.StrictMode = 60108;\nreact_production_min.Profiler = 60114;\nvar q = 60109, r$1 = 60110, t$1 = 60112;\nreact_production_min.Suspense = 60113;\nvar u = 60115, v = 60116;\nif (typeof Symbol === \"function\" && Symbol.for) {\n  var w = Symbol.for;\n  n = w(\"react.element\");\n  p$1 = w(\"react.portal\");\n  react_production_min.Fragment = w(\"react.fragment\");\n  react_production_min.StrictMode = w(\"react.strict_mode\");\n  react_production_min.Profiler = w(\"react.profiler\");\n  q = w(\"react.provider\");\n  r$1 = w(\"react.context\");\n  t$1 = w(\"react.forward_ref\");\n  react_production_min.Suspense = w(\"react.suspense\");\n  u = w(\"react.memo\");\n  v = w(\"react.lazy\");\n}\nvar x = typeof Symbol === \"function\" && Symbol.iterator;\nfunction y$1(a) {\n  if (a === null || typeof a !== \"object\")\n    return null;\n  a = x && a[x] || a[\"@@iterator\"];\n  return typeof a === \"function\" ? a : null;\n}\nfunction z(a) {\n  for (var b = \"https://reactjs.org/docs/error-decoder.html?invariant=\" + a, c = 1; c < arguments.length; c++)\n    b += \"&args[]=\" + encodeURIComponent(arguments[c]);\n  return \"Minified React error #\" + a + \"; visit \" + b + \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\";\n}\nvar A = { isMounted: function() {\n  return false;\n}, enqueueForceUpdate: function() {\n}, enqueueReplaceState: function() {\n}, enqueueSetState: function() {\n} }, B$1 = {};\nfunction C(a, b, c) {\n  this.props = a;\n  this.context = b;\n  this.refs = B$1;\n  this.updater = c || A;\n}\nC.prototype.isReactComponent = {};\nC.prototype.setState = function(a, b) {\n  if (typeof a !== \"object\" && typeof a !== \"function\" && a != null)\n    throw Error(z(85));\n  this.updater.enqueueSetState(this, a, b, \"setState\");\n};\nC.prototype.forceUpdate = function(a) {\n  this.updater.enqueueForceUpdate(this, a, \"forceUpdate\");\n};\nfunction D$1() {\n}\nD$1.prototype = C.prototype;\nfunction E$1(a, b, c) {\n  this.props = a;\n  this.context = b;\n  this.refs = B$1;\n  this.updater = c || A;\n}\nvar F$1 = E$1.prototype = new D$1();\nF$1.constructor = E$1;\nl(F$1, C.prototype);\nF$1.isPureReactComponent = true;\nvar G$1 = { current: null }, H$1 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };\nfunction J(a, b, c) {\n  var e, d = {}, k = null, h = null;\n  if (b != null)\n    for (e in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = \"\" + b.key), b)\n      H$1.call(b, e) && !I$1.hasOwnProperty(e) && (d[e] = b[e]);\n  var g = arguments.length - 2;\n  if (g === 1)\n    d.children = c;\n  else if (1 < g) {\n    for (var f = Array(g), m2 = 0; m2 < g; m2++)\n      f[m2] = arguments[m2 + 2];\n    d.children = f;\n  }\n  if (a && a.defaultProps)\n    for (e in g = a.defaultProps, g)\n      d[e] === void 0 && (d[e] = g[e]);\n  return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G$1.current };\n}\nfunction K(a, b) {\n  return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };\n}\nfunction L(a) {\n  return typeof a === \"object\" && a !== null && a.$$typeof === n;\n}\nfunction escape(a) {\n  var b = { \"=\": \"=0\", \":\": \"=2\" };\n  return \"$\" + a.replace(/[=:]/g, function(a2) {\n    return b[a2];\n  });\n}\nvar M$1 = /\\/+/g;\nfunction N$1(a, b) {\n  return typeof a === \"object\" && a !== null && a.key != null ? escape(\"\" + a.key) : b.toString(36);\n}\nfunction O$1(a, b, c, e, d) {\n  var k = typeof a;\n  if (k === \"undefined\" || k === \"boolean\")\n    a = null;\n  var h = false;\n  if (a === null)\n    h = true;\n  else\n    switch (k) {\n      case \"string\":\n      case \"number\":\n        h = true;\n        break;\n      case \"object\":\n        switch (a.$$typeof) {\n          case n:\n          case p$1:\n            h = true;\n        }\n    }\n  if (h)\n    return h = a, d = d(h), a = e === \"\" ? \".\" + N$1(h, 0) : e, Array.isArray(d) ? (c = \"\", a != null && (c = a.replace(M$1, \"$&/\") + \"/\"), O$1(d, b, c, \"\", function(a2) {\n      return a2;\n    })) : d != null && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? \"\" : (\"\" + d.key).replace(M$1, \"$&/\") + \"/\") + a)), b.push(d)), 1;\n  h = 0;\n  e = e === \"\" ? \".\" : e + \":\";\n  if (Array.isArray(a))\n    for (var g = 0; g < a.length; g++) {\n      k = a[g];\n      var f = e + N$1(k, g);\n      h += O$1(k, b, c, f, d);\n    }\n  else if (f = y$1(a), typeof f === \"function\")\n    for (a = f.call(a), g = 0; !(k = a.next()).done; )\n      k = k.value, f = e + N$1(k, g++), h += O$1(k, b, c, f, d);\n  else if (k === \"object\")\n    throw b = \"\" + a, Error(z(31, b === \"[object Object]\" ? \"object with keys {\" + Object.keys(a).join(\", \") + \"}\" : b));\n  return h;\n}\nfunction P$1(a, b, c) {\n  if (a == null)\n    return a;\n  var e = [], d = 0;\n  O$1(a, e, \"\", \"\", function(a2) {\n    return b.call(c, a2, d++);\n  });\n  return e;\n}\nfunction Q(a) {\n  if (a._status === -1) {\n    var b = a._result;\n    b = b();\n    a._status = 0;\n    a._result = b;\n    b.then(function(b2) {\n      a._status === 0 && (b2 = b2.default, a._status = 1, a._result = b2);\n    }, function(b2) {\n      a._status === 0 && (a._status = 2, a._result = b2);\n    });\n  }\n  if (a._status === 1)\n    return a._result;\n  throw a._result;\n}\nvar R$1 = { current: null };\nfunction S$1() {\n  var a = R$1.current;\n  if (a === null)\n    throw Error(z(321));\n  return a;\n}\nvar T$1 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l };\nreact_production_min.Children = { map: P$1, forEach: function(a, b, c) {\n  P$1(a, function() {\n    b.apply(this, arguments);\n  }, c);\n}, count: function(a) {\n  var b = 0;\n  P$1(a, function() {\n    b++;\n  });\n  return b;\n}, toArray: function(a) {\n  return P$1(a, function(a2) {\n    return a2;\n  }) || [];\n}, only: function(a) {\n  if (!L(a))\n    throw Error(z(143));\n  return a;\n} };\nreact_production_min.Component = C;\nreact_production_min.PureComponent = E$1;\nreact_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;\nreact_production_min.cloneElement = function(a, b, c) {\n  if (a === null || a === void 0)\n    throw Error(z(267, a));\n  var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;\n  if (b != null) {\n    b.ref !== void 0 && (k = b.ref, h = G$1.current);\n    b.key !== void 0 && (d = \"\" + b.key);\n    if (a.type && a.type.defaultProps)\n      var g = a.type.defaultProps;\n    for (f in b)\n      H$1.call(b, f) && !I$1.hasOwnProperty(f) && (e[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);\n  }\n  var f = arguments.length - 2;\n  if (f === 1)\n    e.children = c;\n  else if (1 < f) {\n    g = Array(f);\n    for (var m2 = 0; m2 < f; m2++)\n      g[m2] = arguments[m2 + 2];\n    e.children = g;\n  }\n  return {\n    $$typeof: n,\n    type: a.type,\n    key: d,\n    ref: k,\n    props: e,\n    _owner: h\n  };\n};\nreact_production_min.createContext = function(a, b) {\n  b === void 0 && (b = null);\n  a = { $$typeof: r$1, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };\n  a.Provider = { $$typeof: q, _context: a };\n  return a.Consumer = a;\n};\nreact_production_min.createElement = J;\nreact_production_min.createFactory = function(a) {\n  var b = J.bind(null, a);\n  b.type = a;\n  return b;\n};\nreact_production_min.createRef = function() {\n  return { current: null };\n};\nreact_production_min.forwardRef = function(a) {\n  return { $$typeof: t$1, render: a };\n};\nreact_production_min.isValidElement = L;\nreact_production_min.lazy = function(a) {\n  return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };\n};\nreact_production_min.memo = function(a, b) {\n  return { $$typeof: u, type: a, compare: b === void 0 ? null : b };\n};\nreact_production_min.useCallback = function(a, b) {\n  return S$1().useCallback(a, b);\n};\nreact_production_min.useContext = function(a, b) {\n  return S$1().useContext(a, b);\n};\nreact_production_min.useDebugValue = function() {\n};\nreact_production_min.useEffect = function(a, b) {\n  return S$1().useEffect(a, b);\n};\nreact_production_min.useImperativeHandle = function(a, b, c) {\n  return S$1().useImperativeHandle(a, b, c);\n};\nreact_production_min.useLayoutEffect = function(a, b) {\n  return S$1().useLayoutEffect(a, b);\n};\nreact_production_min.useMemo = function(a, b) {\n  return S$1().useMemo(a, b);\n};\nreact_production_min.useReducer = function(a, b, c) {\n  return S$1().useReducer(a, b, c);\n};\nreact_production_min.useRef = function(a) {\n  return S$1().useRef(a);\n};\nreact_production_min.useState = function(a) {\n  return S$1().useState(a);\n};\nreact_production_min.version = \"17.0.2\";\n{\n  react.exports = react_production_min;\n}\nvar React$1 = react.exports;\nvar reactDom = { exports: {} };\nvar reactDom_production_min = {};\nvar scheduler = { exports: {} };\nvar scheduler_production_min = {};\n/** @license React v0.20.2\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n(function(exports) {\n  var f, g, h, k;\n  if (typeof performance === \"object\" && typeof performance.now === \"function\") {\n    var l2 = performance;\n    exports.unstable_now = function() {\n      return l2.now();\n    };\n  } else {\n    var p2 = Date, q2 = p2.now();\n    exports.unstable_now = function() {\n      return p2.now() - q2;\n    };\n  }\n  if (typeof window === \"undefined\" || typeof MessageChannel !== \"function\") {\n    var t2 = null, u2 = null, w = function() {\n      if (t2 !== null)\n        try {\n          var a = exports.unstable_now();\n          t2(true, a);\n          t2 = null;\n        } catch (b) {\n          throw setTimeout(w, 0), b;\n        }\n    };\n    f = function(a) {\n      t2 !== null ? setTimeout(f, 0, a) : (t2 = a, setTimeout(w, 0));\n    };\n    g = function(a, b) {\n      u2 = setTimeout(a, b);\n    };\n    h = function() {\n      clearTimeout(u2);\n    };\n    exports.unstable_shouldYield = function() {\n      return false;\n    };\n    k = exports.unstable_forceFrameRate = function() {\n    };\n  } else {\n    var x2 = window.setTimeout, y2 = window.clearTimeout;\n    if (typeof console !== \"undefined\") {\n      var z2 = window.cancelAnimationFrame;\n      typeof window.requestAnimationFrame !== \"function\" && console.error(\"This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\");\n      typeof z2 !== \"function\" && console.error(\"This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\");\n    }\n    var A2 = false, B2 = null, C2 = -1, D2 = 5, E = 0;\n    exports.unstable_shouldYield = function() {\n      return exports.unstable_now() >= E;\n    };\n    k = function() {\n    };\n    exports.unstable_forceFrameRate = function(a) {\n      0 > a || 125 < a ? console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;\n    };\n    var F2 = new MessageChannel(), G2 = F2.port2;\n    F2.port1.onmessage = function() {\n      if (B2 !== null) {\n        var a = exports.unstable_now();\n        E = a + D2;\n        try {\n          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);\n        } catch (b) {\n          throw G2.postMessage(null), b;\n        }\n      } else\n        A2 = false;\n    };\n    f = function(a) {\n      B2 = a;\n      A2 || (A2 = true, G2.postMessage(null));\n    };\n    g = function(a, b) {\n      C2 = x2(function() {\n        a(exports.unstable_now());\n      }, b);\n    };\n    h = function() {\n      y2(C2);\n      C2 = -1;\n    };\n  }\n  function H2(a, b) {\n    var c = a.length;\n    a.push(b);\n    a:\n      for (; ; ) {\n        var d = c - 1 >>> 1, e = a[d];\n        if (e !== void 0 && 0 < I2(e, b))\n          a[d] = b, a[c] = e, c = d;\n        else\n          break a;\n      }\n  }\n  function J2(a) {\n    a = a[0];\n    return a === void 0 ? null : a;\n  }\n  function K2(a) {\n    var b = a[0];\n    if (b !== void 0) {\n      var c = a.pop();\n      if (c !== b) {\n        a[0] = c;\n        a:\n          for (var d = 0, e = a.length; d < e; ) {\n            var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];\n            if (n2 !== void 0 && 0 > I2(n2, c))\n              r2 !== void 0 && 0 > I2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);\n            else if (r2 !== void 0 && 0 > I2(r2, c))\n              a[d] = r2, a[v2] = c, d = v2;\n            else\n              break a;\n          }\n      }\n      return b;\n    }\n    return null;\n  }\n  function I2(a, b) {\n    var c = a.sortIndex - b.sortIndex;\n    return c !== 0 ? c : a.id - b.id;\n  }\n  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;\n  function T2(a) {\n    for (var b = J2(M2); b !== null; ) {\n      if (b.callback === null)\n        K2(M2);\n      else if (b.startTime <= a)\n        K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);\n      else\n        break;\n      b = J2(M2);\n    }\n  }\n  function U2(a) {\n    S2 = false;\n    T2(a);\n    if (!R2)\n      if (J2(L2) !== null)\n        R2 = true, f(V2);\n      else {\n        var b = J2(M2);\n        b !== null && g(U2, b.startTime - a);\n      }\n  }\n  function V2(a, b) {\n    R2 = false;\n    S2 && (S2 = false, h());\n    Q2 = true;\n    var c = P2;\n    try {\n      T2(b);\n      for (O2 = J2(L2); O2 !== null && (!(O2.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {\n        var d = O2.callback;\n        if (typeof d === \"function\") {\n          O2.callback = null;\n          P2 = O2.priorityLevel;\n          var e = d(O2.expirationTime <= b);\n          b = exports.unstable_now();\n          typeof e === \"function\" ? O2.callback = e : O2 === J2(L2) && K2(L2);\n          T2(b);\n        } else\n          K2(L2);\n        O2 = J2(L2);\n      }\n      if (O2 !== null)\n        var m2 = true;\n      else {\n        var n2 = J2(M2);\n        n2 !== null && g(U2, n2.startTime - b);\n        m2 = false;\n      }\n      return m2;\n    } finally {\n      O2 = null, P2 = c, Q2 = false;\n    }\n  }\n  var W2 = k;\n  exports.unstable_IdlePriority = 5;\n  exports.unstable_ImmediatePriority = 1;\n  exports.unstable_LowPriority = 4;\n  exports.unstable_NormalPriority = 3;\n  exports.unstable_Profiling = null;\n  exports.unstable_UserBlockingPriority = 2;\n  exports.unstable_cancelCallback = function(a) {\n    a.callback = null;\n  };\n  exports.unstable_continueExecution = function() {\n    R2 || Q2 || (R2 = true, f(V2));\n  };\n  exports.unstable_getCurrentPriorityLevel = function() {\n    return P2;\n  };\n  exports.unstable_getFirstCallbackNode = function() {\n    return J2(L2);\n  };\n  exports.unstable_next = function(a) {\n    switch (P2) {\n      case 1:\n      case 2:\n      case 3:\n        var b = 3;\n        break;\n      default:\n        b = P2;\n    }\n    var c = P2;\n    P2 = b;\n    try {\n      return a();\n    } finally {\n      P2 = c;\n    }\n  };\n  exports.unstable_pauseExecution = function() {\n  };\n  exports.unstable_requestPaint = W2;\n  exports.unstable_runWithPriority = function(a, b) {\n    switch (a) {\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n        break;\n      default:\n        a = 3;\n    }\n    var c = P2;\n    P2 = a;\n    try {\n      return b();\n    } finally {\n      P2 = c;\n    }\n  };\n  exports.unstable_scheduleCallback = function(a, b, c) {\n    var d = exports.unstable_now();\n    typeof c === \"object\" && c !== null ? (c = c.delay, c = typeof c === \"number\" && 0 < c ? d + c : d) : c = d;\n    switch (a) {\n      case 1:\n        var e = -1;\n        break;\n      case 2:\n        e = 250;\n        break;\n      case 5:\n        e = 1073741823;\n        break;\n      case 4:\n        e = 1e4;\n        break;\n      default:\n        e = 5e3;\n    }\n    e = c + e;\n    a = { id: N2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };\n    c > d ? (a.sortIndex = c, H2(M2, a), J2(L2) === null && a === J2(M2) && (S2 ? h() : S2 = true, g(U2, c - d))) : (a.sortIndex = e, H2(L2, a), R2 || Q2 || (R2 = true, f(V2)));\n    return a;\n  };\n  exports.unstable_wrapCallback = function(a) {\n    var b = P2;\n    return function() {\n      var c = P2;\n      P2 = b;\n      try {\n        return a.apply(this, arguments);\n      } finally {\n        P2 = c;\n      }\n    };\n  };\n})(scheduler_production_min);\n{\n  scheduler.exports = scheduler_production_min;\n}\n/** @license React v17.0.2\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar aa = react.exports, m = objectAssign, r = scheduler.exports;\nfunction y(a) {\n  for (var b = \"https://reactjs.org/docs/error-decoder.html?invariant=\" + a, c = 1; c < arguments.length; c++)\n    b += \"&args[]=\" + encodeURIComponent(arguments[c]);\n  return \"Minified React error #\" + a + \"; visit \" + b + \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\";\n}\nif (!aa)\n  throw Error(y(227));\nvar ba = /* @__PURE__ */ new Set(), ca = {};\nfunction da(a, b) {\n  ea(a, b);\n  ea(a + \"Capture\", b);\n}\nfunction ea(a, b) {\n  ca[a] = b;\n  for (a = 0; a < b.length; a++)\n    ba.add(b[a]);\n}\nvar fa = !(typeof window === \"undefined\" || typeof window.document === \"undefined\" || typeof window.document.createElement === \"undefined\"), ha = /^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};\nfunction la(a) {\n  if (ia.call(ka, a))\n    return true;\n  if (ia.call(ja, a))\n    return false;\n  if (ha.test(a))\n    return ka[a] = true;\n  ja[a] = true;\n  return false;\n}\nfunction ma(a, b, c, d) {\n  if (c !== null && c.type === 0)\n    return false;\n  switch (typeof b) {\n    case \"function\":\n    case \"symbol\":\n      return true;\n    case \"boolean\":\n      if (d)\n        return false;\n      if (c !== null)\n        return !c.acceptsBooleans;\n      a = a.toLowerCase().slice(0, 5);\n      return a !== \"data-\" && a !== \"aria-\";\n    default:\n      return false;\n  }\n}\nfunction na(a, b, c, d) {\n  if (b === null || typeof b === \"undefined\" || ma(a, b, c, d))\n    return true;\n  if (d)\n    return false;\n  if (c !== null)\n    switch (c.type) {\n      case 3:\n        return !b;\n      case 4:\n        return b === false;\n      case 5:\n        return isNaN(b);\n      case 6:\n        return isNaN(b) || 1 > b;\n    }\n  return false;\n}\nfunction B(a, b, c, d, e, f, g) {\n  this.acceptsBooleans = b === 2 || b === 3 || b === 4;\n  this.attributeName = d;\n  this.attributeNamespace = e;\n  this.mustUseProperty = c;\n  this.propertyName = a;\n  this.type = b;\n  this.sanitizeURL = f;\n  this.removeEmptyString = g;\n}\nvar D = {};\n\"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(a) {\n  D[a] = new B(a, 0, false, a, null, false, false);\n});\n[[\"acceptCharset\", \"accept-charset\"], [\"className\", \"class\"], [\"htmlFor\", \"for\"], [\"httpEquiv\", \"http-equiv\"]].forEach(function(a) {\n  var b = a[0];\n  D[b] = new B(b, 1, false, a[1], null, false, false);\n});\n[\"contentEditable\", \"draggable\", \"spellCheck\", \"value\"].forEach(function(a) {\n  D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);\n});\n[\"autoReverse\", \"externalResourcesRequired\", \"focusable\", \"preserveAlpha\"].forEach(function(a) {\n  D[a] = new B(a, 2, false, a, null, false, false);\n});\n\"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(a) {\n  D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);\n});\n[\"checked\", \"multiple\", \"muted\", \"selected\"].forEach(function(a) {\n  D[a] = new B(a, 3, true, a, null, false, false);\n});\n[\"capture\", \"download\"].forEach(function(a) {\n  D[a] = new B(a, 4, false, a, null, false, false);\n});\n[\"cols\", \"rows\", \"size\", \"span\"].forEach(function(a) {\n  D[a] = new B(a, 6, false, a, null, false, false);\n});\n[\"rowSpan\", \"start\"].forEach(function(a) {\n  D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);\n});\nvar oa = /[\\-:]([a-z])/g;\nfunction pa(a) {\n  return a[1].toUpperCase();\n}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(a) {\n  var b = a.replace(oa, pa);\n  D[b] = new B(b, 1, false, a, null, false, false);\n});\n\"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(a) {\n  var b = a.replace(oa, pa);\n  D[b] = new B(b, 1, false, a, \"http://www.w3.org/1999/xlink\", false, false);\n});\n[\"xml:base\", \"xml:lang\", \"xml:space\"].forEach(function(a) {\n  var b = a.replace(oa, pa);\n  D[b] = new B(b, 1, false, a, \"http://www.w3.org/XML/1998/namespace\", false, false);\n});\n[\"tabIndex\", \"crossOrigin\"].forEach(function(a) {\n  D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);\n});\nD.xlinkHref = new B(\"xlinkHref\", 1, false, \"xlink:href\", \"http://www.w3.org/1999/xlink\", true, false);\n[\"src\", \"href\", \"action\", \"formAction\"].forEach(function(a) {\n  D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);\n});\nfunction qa(a, b, c, d) {\n  var e = D.hasOwnProperty(b) ? D[b] : null;\n  var f = e !== null ? e.type === 0 : d ? false : !(2 < b.length) || b[0] !== \"o\" && b[0] !== \"O\" || b[1] !== \"n\" && b[1] !== \"N\" ? false : true;\n  f || (na(b, c, e, d) && (c = null), d || e === null ? la(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, \"\" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? false : \"\" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === true ? \"\" : \"\" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));\n}\nvar ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;\nif (typeof Symbol === \"function\" && Symbol.for) {\n  var E = Symbol.for;\n  sa = E(\"react.element\");\n  ta = E(\"react.portal\");\n  ua = E(\"react.fragment\");\n  wa = E(\"react.strict_mode\");\n  xa = E(\"react.profiler\");\n  ya = E(\"react.provider\");\n  za = E(\"react.context\");\n  Aa = E(\"react.forward_ref\");\n  Ba = E(\"react.suspense\");\n  Ca = E(\"react.suspense_list\");\n  Da = E(\"react.memo\");\n  Ea = E(\"react.lazy\");\n  Fa = E(\"react.block\");\n  E(\"react.scope\");\n  Ga = E(\"react.opaque.id\");\n  Ha = E(\"react.debug_trace_mode\");\n  Ia = E(\"react.offscreen\");\n  Ja = E(\"react.legacy_hidden\");\n}\nvar Ka = typeof Symbol === \"function\" && Symbol.iterator;\nfunction La(a) {\n  if (a === null || typeof a !== \"object\")\n    return null;\n  a = Ka && a[Ka] || a[\"@@iterator\"];\n  return typeof a === \"function\" ? a : null;\n}\nvar Ma;\nfunction Na(a) {\n  if (Ma === void 0)\n    try {\n      throw Error();\n    } catch (c) {\n      var b = c.stack.trim().match(/\\n( *(at )?)/);\n      Ma = b && b[1] || \"\";\n    }\n  return \"\\n\" + Ma + a;\n}\nvar Oa = false;\nfunction Pa(a, b) {\n  if (!a || Oa)\n    return \"\";\n  Oa = true;\n  var c = Error.prepareStackTrace;\n  Error.prepareStackTrace = void 0;\n  try {\n    if (b)\n      if (b = function() {\n        throw Error();\n      }, Object.defineProperty(b.prototype, \"props\", { set: function() {\n        throw Error();\n      } }), typeof Reflect === \"object\" && Reflect.construct) {\n        try {\n          Reflect.construct(b, []);\n        } catch (k) {\n          var d = k;\n        }\n        Reflect.construct(a, [], b);\n      } else {\n        try {\n          b.call();\n        } catch (k) {\n          d = k;\n        }\n        a.call(b.prototype);\n      }\n    else {\n      try {\n        throw Error();\n      } catch (k) {\n        d = k;\n      }\n      a();\n    }\n  } catch (k) {\n    if (k && d && typeof k.stack === \"string\") {\n      for (var e = k.stack.split(\"\\n\"), f = d.stack.split(\"\\n\"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )\n        h--;\n      for (; 1 <= g && 0 <= h; g--, h--)\n        if (e[g] !== f[h]) {\n          if (g !== 1 || h !== 1) {\n            do\n              if (g--, h--, 0 > h || e[g] !== f[h])\n                return \"\\n\" + e[g].replace(\" at new \", \" at \");\n            while (1 <= g && 0 <= h);\n          }\n          break;\n        }\n    }\n  } finally {\n    Oa = false, Error.prepareStackTrace = c;\n  }\n  return (a = a ? a.displayName || a.name : \"\") ? Na(a) : \"\";\n}\nfunction Qa(a) {\n  switch (a.tag) {\n    case 5:\n      return Na(a.type);\n    case 16:\n      return Na(\"Lazy\");\n    case 13:\n      return Na(\"Suspense\");\n    case 19:\n      return Na(\"SuspenseList\");\n    case 0:\n    case 2:\n    case 15:\n      return a = Pa(a.type, false), a;\n    case 11:\n      return a = Pa(a.type.render, false), a;\n    case 22:\n      return a = Pa(a.type._render, false), a;\n    case 1:\n      return a = Pa(a.type, true), a;\n    default:\n      return \"\";\n  }\n}\nfunction Ra(a) {\n  if (a == null)\n    return null;\n  if (typeof a === \"function\")\n    return a.displayName || a.name || null;\n  if (typeof a === \"string\")\n    return a;\n  switch (a) {\n    case ua:\n      return \"Fragment\";\n    case ta:\n      return \"Portal\";\n    case xa:\n      return \"Profiler\";\n    case wa:\n      return \"StrictMode\";\n    case Ba:\n      return \"Suspense\";\n    case Ca:\n      return \"SuspenseList\";\n  }\n  if (typeof a === \"object\")\n    switch (a.$$typeof) {\n      case za:\n        return (a.displayName || \"Context\") + \".Consumer\";\n      case ya:\n        return (a._context.displayName || \"Context\") + \".Provider\";\n      case Aa:\n        var b = a.render;\n        b = b.displayName || b.name || \"\";\n        return a.displayName || (b !== \"\" ? \"ForwardRef(\" + b + \")\" : \"ForwardRef\");\n      case Da:\n        return Ra(a.type);\n      case Fa:\n        return Ra(a._render);\n      case Ea:\n        b = a._payload;\n        a = a._init;\n        try {\n          return Ra(a(b));\n        } catch (c) {\n        }\n    }\n  return null;\n}\nfunction Sa(a) {\n  switch (typeof a) {\n    case \"boolean\":\n    case \"number\":\n    case \"object\":\n    case \"string\":\n    case \"undefined\":\n      return a;\n    default:\n      return \"\";\n  }\n}\nfunction Ta(a) {\n  var b = a.type;\n  return (a = a.nodeName) && a.toLowerCase() === \"input\" && (b === \"checkbox\" || b === \"radio\");\n}\nfunction Ua(a) {\n  var b = Ta(a) ? \"checked\" : \"value\", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = \"\" + a[b];\n  if (!a.hasOwnProperty(b) && typeof c !== \"undefined\" && typeof c.get === \"function\" && typeof c.set === \"function\") {\n    var e = c.get, f = c.set;\n    Object.defineProperty(a, b, { configurable: true, get: function() {\n      return e.call(this);\n    }, set: function(a2) {\n      d = \"\" + a2;\n      f.call(this, a2);\n    } });\n    Object.defineProperty(a, b, { enumerable: c.enumerable });\n    return { getValue: function() {\n      return d;\n    }, setValue: function(a2) {\n      d = \"\" + a2;\n    }, stopTracking: function() {\n      a._valueTracker = null;\n      delete a[b];\n    } };\n  }\n}\nfunction Va(a) {\n  a._valueTracker || (a._valueTracker = Ua(a));\n}\nfunction Wa(a) {\n  if (!a)\n    return false;\n  var b = a._valueTracker;\n  if (!b)\n    return true;\n  var c = b.getValue();\n  var d = \"\";\n  a && (d = Ta(a) ? a.checked ? \"true\" : \"false\" : a.value);\n  a = d;\n  return a !== c ? (b.setValue(a), true) : false;\n}\nfunction Xa(a) {\n  a = a || (typeof document !== \"undefined\" ? document : void 0);\n  if (typeof a === \"undefined\")\n    return null;\n  try {\n    return a.activeElement || a.body;\n  } catch (b) {\n    return a.body;\n  }\n}\nfunction Ya(a, b) {\n  var c = b.checked;\n  return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c != null ? c : a._wrapperState.initialChecked });\n}\nfunction Za(a, b) {\n  var c = b.defaultValue == null ? \"\" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;\n  c = Sa(b.value != null ? b.value : c);\n  a._wrapperState = { initialChecked: d, initialValue: c, controlled: b.type === \"checkbox\" || b.type === \"radio\" ? b.checked != null : b.value != null };\n}\nfunction $a(a, b) {\n  b = b.checked;\n  b != null && qa(a, \"checked\", b, false);\n}\nfunction ab(a, b) {\n  $a(a, b);\n  var c = Sa(b.value), d = b.type;\n  if (c != null)\n    if (d === \"number\") {\n      if (c === 0 && a.value === \"\" || a.value != c)\n        a.value = \"\" + c;\n    } else\n      a.value !== \"\" + c && (a.value = \"\" + c);\n  else if (d === \"submit\" || d === \"reset\") {\n    a.removeAttribute(\"value\");\n    return;\n  }\n  b.hasOwnProperty(\"value\") ? bb(a, b.type, c) : b.hasOwnProperty(\"defaultValue\") && bb(a, b.type, Sa(b.defaultValue));\n  b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);\n}\nfunction cb(a, b, c) {\n  if (b.hasOwnProperty(\"value\") || b.hasOwnProperty(\"defaultValue\")) {\n    var d = b.type;\n    if (!(d !== \"submit\" && d !== \"reset\" || b.value !== void 0 && b.value !== null))\n      return;\n    b = \"\" + a._wrapperState.initialValue;\n    c || b === a.value || (a.value = b);\n    a.defaultValue = b;\n  }\n  c = a.name;\n  c !== \"\" && (a.name = \"\");\n  a.defaultChecked = !!a._wrapperState.initialChecked;\n  c !== \"\" && (a.name = c);\n}\nfunction bb(a, b, c) {\n  if (b !== \"number\" || Xa(a.ownerDocument) !== a)\n    c == null ? a.defaultValue = \"\" + a._wrapperState.initialValue : a.defaultValue !== \"\" + c && (a.defaultValue = \"\" + c);\n}\nfunction db(a) {\n  var b = \"\";\n  aa.Children.forEach(a, function(a2) {\n    a2 != null && (b += a2);\n  });\n  return b;\n}\nfunction eb(a, b) {\n  a = m({ children: void 0 }, b);\n  if (b = db(b.children))\n    a.children = b;\n  return a;\n}\nfunction fb(a, b, c, d) {\n  a = a.options;\n  if (b) {\n    b = {};\n    for (var e = 0; e < c.length; e++)\n      b[\"$\" + c[e]] = true;\n    for (c = 0; c < a.length; c++)\n      e = b.hasOwnProperty(\"$\" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);\n  } else {\n    c = \"\" + Sa(c);\n    b = null;\n    for (e = 0; e < a.length; e++) {\n      if (a[e].value === c) {\n        a[e].selected = true;\n        d && (a[e].defaultSelected = true);\n        return;\n      }\n      b !== null || a[e].disabled || (b = a[e]);\n    }\n    b !== null && (b.selected = true);\n  }\n}\nfunction gb(a, b) {\n  if (b.dangerouslySetInnerHTML != null)\n    throw Error(y(91));\n  return m({}, b, { value: void 0, defaultValue: void 0, children: \"\" + a._wrapperState.initialValue });\n}\nfunction hb(a, b) {\n  var c = b.value;\n  if (c == null) {\n    c = b.children;\n    b = b.defaultValue;\n    if (c != null) {\n      if (b != null)\n        throw Error(y(92));\n      if (Array.isArray(c)) {\n        if (!(1 >= c.length))\n          throw Error(y(93));\n        c = c[0];\n      }\n      b = c;\n    }\n    b == null && (b = \"\");\n    c = b;\n  }\n  a._wrapperState = { initialValue: Sa(c) };\n}\nfunction ib(a, b) {\n  var c = Sa(b.value), d = Sa(b.defaultValue);\n  c != null && (c = \"\" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c));\n  d != null && (a.defaultValue = \"\" + d);\n}\nfunction jb(a) {\n  var b = a.textContent;\n  b === a._wrapperState.initialValue && b !== \"\" && b !== null && (a.value = b);\n}\nvar kb = { html: \"http://www.w3.org/1999/xhtml\", mathml: \"http://www.w3.org/1998/Math/MathML\", svg: \"http://www.w3.org/2000/svg\" };\nfunction lb(a) {\n  switch (a) {\n    case \"svg\":\n      return \"http://www.w3.org/2000/svg\";\n    case \"math\":\n      return \"http://www.w3.org/1998/Math/MathML\";\n    default:\n      return \"http://www.w3.org/1999/xhtml\";\n  }\n}\nfunction mb(a, b) {\n  return a == null || a === \"http://www.w3.org/1999/xhtml\" ? lb(b) : a === \"http://www.w3.org/2000/svg\" && b === \"foreignObject\" ? \"http://www.w3.org/1999/xhtml\" : a;\n}\nvar nb, ob = function(a) {\n  return typeof MSApp !== \"undefined\" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {\n    MSApp.execUnsafeLocalFunction(function() {\n      return a(b, c, d, e);\n    });\n  } : a;\n}(function(a, b) {\n  if (a.namespaceURI !== kb.svg || \"innerHTML\" in a)\n    a.innerHTML = b;\n  else {\n    nb = nb || document.createElement(\"div\");\n    nb.innerHTML = \"<svg>\" + b.valueOf().toString() + \"</svg>\";\n    for (b = nb.firstChild; a.firstChild; )\n      a.removeChild(a.firstChild);\n    for (; b.firstChild; )\n      a.appendChild(b.firstChild);\n  }\n});\nfunction pb(a, b) {\n  if (b) {\n    var c = a.firstChild;\n    if (c && c === a.lastChild && c.nodeType === 3) {\n      c.nodeValue = b;\n      return;\n    }\n  }\n  a.textContent = b;\n}\nvar qb = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridArea: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n}, rb = [\"Webkit\", \"ms\", \"Moz\", \"O\"];\nObject.keys(qb).forEach(function(a) {\n  rb.forEach(function(b) {\n    b = b + a.charAt(0).toUpperCase() + a.substring(1);\n    qb[b] = qb[a];\n  });\n});\nfunction sb(a, b, c) {\n  return b == null || typeof b === \"boolean\" || b === \"\" ? \"\" : c || typeof b !== \"number\" || b === 0 || qb.hasOwnProperty(a) && qb[a] ? (\"\" + b).trim() : b + \"px\";\n}\nfunction tb(a, b) {\n  a = a.style;\n  for (var c in b)\n    if (b.hasOwnProperty(c)) {\n      var d = c.indexOf(\"--\") === 0, e = sb(c, b[c], d);\n      c === \"float\" && (c = \"cssFloat\");\n      d ? a.setProperty(c, e) : a[c] = e;\n    }\n}\nvar ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });\nfunction vb(a, b) {\n  if (b) {\n    if (ub[a] && (b.children != null || b.dangerouslySetInnerHTML != null))\n      throw Error(y(137, a));\n    if (b.dangerouslySetInnerHTML != null) {\n      if (b.children != null)\n        throw Error(y(60));\n      if (!(typeof b.dangerouslySetInnerHTML === \"object\" && \"__html\" in b.dangerouslySetInnerHTML))\n        throw Error(y(61));\n    }\n    if (b.style != null && typeof b.style !== \"object\")\n      throw Error(y(62));\n  }\n}\nfunction wb(a, b) {\n  if (a.indexOf(\"-\") === -1)\n    return typeof b.is === \"string\";\n  switch (a) {\n    case \"annotation-xml\":\n    case \"color-profile\":\n    case \"font-face\":\n    case \"font-face-src\":\n    case \"font-face-uri\":\n    case \"font-face-format\":\n    case \"font-face-name\":\n    case \"missing-glyph\":\n      return false;\n    default:\n      return true;\n  }\n}\nfunction xb(a) {\n  a = a.target || a.srcElement || window;\n  a.correspondingUseElement && (a = a.correspondingUseElement);\n  return a.nodeType === 3 ? a.parentNode : a;\n}\nvar yb = null, zb = null, Ab = null;\nfunction Bb(a) {\n  if (a = Cb(a)) {\n    if (typeof yb !== \"function\")\n      throw Error(y(280));\n    var b = a.stateNode;\n    b && (b = Db(b), yb(a.stateNode, a.type, b));\n  }\n}\nfunction Eb(a) {\n  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;\n}\nfunction Fb() {\n  if (zb) {\n    var a = zb, b = Ab;\n    Ab = zb = null;\n    Bb(a);\n    if (b)\n      for (a = 0; a < b.length; a++)\n        Bb(b[a]);\n  }\n}\nfunction Gb(a, b) {\n  return a(b);\n}\nfunction Hb(a, b, c, d, e) {\n  return a(b, c, d, e);\n}\nfunction Ib() {\n}\nvar Jb = Gb, Kb = false, Lb = false;\nfunction Mb() {\n  if (zb !== null || Ab !== null)\n    Ib(), Fb();\n}\nfunction Nb(a, b, c) {\n  if (Lb)\n    return a(b, c);\n  Lb = true;\n  try {\n    return Jb(a, b, c);\n  } finally {\n    Lb = false, Mb();\n  }\n}\nfunction Ob(a, b) {\n  var c = a.stateNode;\n  if (c === null)\n    return null;\n  var d = Db(c);\n  if (d === null)\n    return null;\n  c = d[b];\n  a:\n    switch (b) {\n      case \"onClick\":\n      case \"onClickCapture\":\n      case \"onDoubleClick\":\n      case \"onDoubleClickCapture\":\n      case \"onMouseDown\":\n      case \"onMouseDownCapture\":\n      case \"onMouseMove\":\n      case \"onMouseMoveCapture\":\n      case \"onMouseUp\":\n      case \"onMouseUpCapture\":\n      case \"onMouseEnter\":\n        (d = !d.disabled) || (a = a.type, d = !(a === \"button\" || a === \"input\" || a === \"select\" || a === \"textarea\"));\n        a = !d;\n        break a;\n      default:\n        a = false;\n    }\n  if (a)\n    return null;\n  if (c && typeof c !== \"function\")\n    throw Error(y(231, b, typeof c));\n  return c;\n}\nvar Pb = false;\nif (fa)\n  try {\n    var Qb = {};\n    Object.defineProperty(Qb, \"passive\", { get: function() {\n      Pb = true;\n    } });\n    window.addEventListener(\"test\", Qb, Qb);\n    window.removeEventListener(\"test\", Qb, Qb);\n  } catch (a) {\n    Pb = false;\n  }\nfunction Rb(a, b, c, d, e, f, g, h, k) {\n  var l2 = Array.prototype.slice.call(arguments, 3);\n  try {\n    b.apply(c, l2);\n  } catch (n2) {\n    this.onError(n2);\n  }\n}\nvar Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {\n  Sb = true;\n  Tb = a;\n} };\nfunction Xb(a, b, c, d, e, f, g, h, k) {\n  Sb = false;\n  Tb = null;\n  Rb.apply(Wb, arguments);\n}\nfunction Yb(a, b, c, d, e, f, g, h, k) {\n  Xb.apply(this, arguments);\n  if (Sb) {\n    if (Sb) {\n      var l2 = Tb;\n      Sb = false;\n      Tb = null;\n    } else\n      throw Error(y(198));\n    Ub || (Ub = true, Vb = l2);\n  }\n}\nfunction Zb(a) {\n  var b = a, c = a;\n  if (a.alternate)\n    for (; b.return; )\n      b = b.return;\n  else {\n    a = b;\n    do\n      b = a, (b.flags & 1026) !== 0 && (c = b.return), a = b.return;\n    while (a);\n  }\n  return b.tag === 3 ? c : null;\n}\nfunction $b(a) {\n  if (a.tag === 13) {\n    var b = a.memoizedState;\n    b === null && (a = a.alternate, a !== null && (b = a.memoizedState));\n    if (b !== null)\n      return b.dehydrated;\n  }\n  return null;\n}\nfunction ac$1(a) {\n  if (Zb(a) !== a)\n    throw Error(y(188));\n}\nfunction bc(a) {\n  var b = a.alternate;\n  if (!b) {\n    b = Zb(a);\n    if (b === null)\n      throw Error(y(188));\n    return b !== a ? null : a;\n  }\n  for (var c = a, d = b; ; ) {\n    var e = c.return;\n    if (e === null)\n      break;\n    var f = e.alternate;\n    if (f === null) {\n      d = e.return;\n      if (d !== null) {\n        c = d;\n        continue;\n      }\n      break;\n    }\n    if (e.child === f.child) {\n      for (f = e.child; f; ) {\n        if (f === c)\n          return ac$1(e), a;\n        if (f === d)\n          return ac$1(e), b;\n        f = f.sibling;\n      }\n      throw Error(y(188));\n    }\n    if (c.return !== d.return)\n      c = e, d = f;\n    else {\n      for (var g = false, h = e.child; h; ) {\n        if (h === c) {\n          g = true;\n          c = e;\n          d = f;\n          break;\n        }\n        if (h === d) {\n          g = true;\n          d = e;\n          c = f;\n          break;\n        }\n        h = h.sibling;\n      }\n      if (!g) {\n        for (h = f.child; h; ) {\n          if (h === c) {\n            g = true;\n            c = f;\n            d = e;\n            break;\n          }\n          if (h === d) {\n            g = true;\n            d = f;\n            c = e;\n            break;\n          }\n          h = h.sibling;\n        }\n        if (!g)\n          throw Error(y(189));\n      }\n    }\n    if (c.alternate !== d)\n      throw Error(y(190));\n  }\n  if (c.tag !== 3)\n    throw Error(y(188));\n  return c.stateNode.current === c ? a : b;\n}\nfunction cc(a) {\n  a = bc(a);\n  if (!a)\n    return null;\n  for (var b = a; ; ) {\n    if (b.tag === 5 || b.tag === 6)\n      return b;\n    if (b.child)\n      b.child.return = b, b = b.child;\n    else {\n      if (b === a)\n        break;\n      for (; !b.sibling; ) {\n        if (!b.return || b.return === a)\n          return null;\n        b = b.return;\n      }\n      b.sibling.return = b.return;\n      b = b.sibling;\n    }\n  }\n  return null;\n}\nfunction dc(a, b) {\n  for (var c = a.alternate; b !== null; ) {\n    if (b === a || b === c)\n      return true;\n    b = b.return;\n  }\n  return false;\n}\nvar ec, fc, gc, hc, ic$1 = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = \"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit\".split(\" \");\nfunction rc(a, b, c, d, e) {\n  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };\n}\nfunction sc$1(a, b) {\n  switch (a) {\n    case \"focusin\":\n    case \"focusout\":\n      kc = null;\n      break;\n    case \"dragenter\":\n    case \"dragleave\":\n      lc = null;\n      break;\n    case \"mouseover\":\n    case \"mouseout\":\n      mc = null;\n      break;\n    case \"pointerover\":\n    case \"pointerout\":\n      nc.delete(b.pointerId);\n      break;\n    case \"gotpointercapture\":\n    case \"lostpointercapture\":\n      oc.delete(b.pointerId);\n  }\n}\nfunction tc(a, b, c, d, e, f) {\n  if (a === null || a.nativeEvent !== f)\n    return a = rc(b, c, d, e, f), b !== null && (b = Cb(b), b !== null && fc(b)), a;\n  a.eventSystemFlags |= d;\n  b = a.targetContainers;\n  e !== null && b.indexOf(e) === -1 && b.push(e);\n  return a;\n}\nfunction uc(a, b, c, d, e) {\n  switch (b) {\n    case \"focusin\":\n      return kc = tc(kc, a, b, c, d, e), true;\n    case \"dragenter\":\n      return lc = tc(lc, a, b, c, d, e), true;\n    case \"mouseover\":\n      return mc = tc(mc, a, b, c, d, e), true;\n    case \"pointerover\":\n      var f = e.pointerId;\n      nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));\n      return true;\n    case \"gotpointercapture\":\n      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;\n  }\n  return false;\n}\nfunction vc(a) {\n  var b = wc(a.target);\n  if (b !== null) {\n    var c = Zb(b);\n    if (c !== null) {\n      if (b = c.tag, b === 13) {\n        if (b = $b(c), b !== null) {\n          a.blockedOn = b;\n          hc(a.lanePriority, function() {\n            r.unstable_runWithPriority(a.priority, function() {\n              gc(c);\n            });\n          });\n          return;\n        }\n      } else if (b === 3 && c.stateNode.hydrate) {\n        a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;\n        return;\n      }\n    }\n  }\n  a.blockedOn = null;\n}\nfunction xc(a) {\n  if (a.blockedOn !== null)\n    return false;\n  for (var b = a.targetContainers; 0 < b.length; ) {\n    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);\n    if (c !== null)\n      return b = Cb(c), b !== null && fc(b), a.blockedOn = c, false;\n    b.shift();\n  }\n  return true;\n}\nfunction zc(a, b, c) {\n  xc(a) && c.delete(b);\n}\nfunction Ac() {\n  for (ic$1 = false; 0 < jc.length; ) {\n    var a = jc[0];\n    if (a.blockedOn !== null) {\n      a = Cb(a.blockedOn);\n      a !== null && ec(a);\n      break;\n    }\n    for (var b = a.targetContainers; 0 < b.length; ) {\n      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);\n      if (c !== null) {\n        a.blockedOn = c;\n        break;\n      }\n      b.shift();\n    }\n    a.blockedOn === null && jc.shift();\n  }\n  kc !== null && xc(kc) && (kc = null);\n  lc !== null && xc(lc) && (lc = null);\n  mc !== null && xc(mc) && (mc = null);\n  nc.forEach(zc);\n  oc.forEach(zc);\n}\nfunction Bc(a, b) {\n  a.blockedOn === b && (a.blockedOn = null, ic$1 || (ic$1 = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));\n}\nfunction Cc(a) {\n  function b(b2) {\n    return Bc(b2, a);\n  }\n  if (0 < jc.length) {\n    Bc(jc[0], a);\n    for (var c = 1; c < jc.length; c++) {\n      var d = jc[c];\n      d.blockedOn === a && (d.blockedOn = null);\n    }\n  }\n  kc !== null && Bc(kc, a);\n  lc !== null && Bc(lc, a);\n  mc !== null && Bc(mc, a);\n  nc.forEach(b);\n  oc.forEach(b);\n  for (c = 0; c < pc.length; c++)\n    d = pc[c], d.blockedOn === a && (d.blockedOn = null);\n  for (; 0 < pc.length && (c = pc[0], c.blockedOn === null); )\n    vc(c), c.blockedOn === null && pc.shift();\n}\nfunction Dc(a, b) {\n  var c = {};\n  c[a.toLowerCase()] = b.toLowerCase();\n  c[\"Webkit\" + a] = \"webkit\" + b;\n  c[\"Moz\" + a] = \"moz\" + b;\n  return c;\n}\nvar Ec = { animationend: Dc(\"Animation\", \"AnimationEnd\"), animationiteration: Dc(\"Animation\", \"AnimationIteration\"), animationstart: Dc(\"Animation\", \"AnimationStart\"), transitionend: Dc(\"Transition\", \"TransitionEnd\") }, Fc = {}, Gc = {};\nfa && (Gc = document.createElement(\"div\").style, \"AnimationEvent\" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), \"TransitionEvent\" in window || delete Ec.transitionend.transition);\nfunction Hc(a) {\n  if (Fc[a])\n    return Fc[a];\n  if (!Ec[a])\n    return a;\n  var b = Ec[a], c;\n  for (c in b)\n    if (b.hasOwnProperty(c) && c in Gc)\n      return Fc[a] = b[c];\n  return a;\n}\nvar Ic = Hc(\"animationend\"), Jc = Hc(\"animationiteration\"), Kc = Hc(\"animationstart\"), Lc = Hc(\"transitionend\"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [\n  \"abort\",\n  \"abort\",\n  Ic,\n  \"animationEnd\",\n  Jc,\n  \"animationIteration\",\n  Kc,\n  \"animationStart\",\n  \"canplay\",\n  \"canPlay\",\n  \"canplaythrough\",\n  \"canPlayThrough\",\n  \"durationchange\",\n  \"durationChange\",\n  \"emptied\",\n  \"emptied\",\n  \"encrypted\",\n  \"encrypted\",\n  \"ended\",\n  \"ended\",\n  \"error\",\n  \"error\",\n  \"gotpointercapture\",\n  \"gotPointerCapture\",\n  \"load\",\n  \"load\",\n  \"loadeddata\",\n  \"loadedData\",\n  \"loadedmetadata\",\n  \"loadedMetadata\",\n  \"loadstart\",\n  \"loadStart\",\n  \"lostpointercapture\",\n  \"lostPointerCapture\",\n  \"playing\",\n  \"playing\",\n  \"progress\",\n  \"progress\",\n  \"seeking\",\n  \"seeking\",\n  \"stalled\",\n  \"stalled\",\n  \"suspend\",\n  \"suspend\",\n  \"timeupdate\",\n  \"timeUpdate\",\n  Lc,\n  \"transitionEnd\",\n  \"waiting\",\n  \"waiting\"\n];\nfunction Pc(a, b) {\n  for (var c = 0; c < a.length; c += 2) {\n    var d = a[c], e = a[c + 1];\n    e = \"on\" + (e[0].toUpperCase() + e.slice(1));\n    Nc.set(d, b);\n    Mc.set(d, e);\n    da(e, [d]);\n  }\n}\nvar Qc = r.unstable_now;\nQc();\nvar F = 8;\nfunction Rc(a) {\n  if ((1 & a) !== 0)\n    return F = 15, 1;\n  if ((2 & a) !== 0)\n    return F = 14, 2;\n  if ((4 & a) !== 0)\n    return F = 13, 4;\n  var b = 24 & a;\n  if (b !== 0)\n    return F = 12, b;\n  if ((a & 32) !== 0)\n    return F = 11, 32;\n  b = 192 & a;\n  if (b !== 0)\n    return F = 10, b;\n  if ((a & 256) !== 0)\n    return F = 9, 256;\n  b = 3584 & a;\n  if (b !== 0)\n    return F = 8, b;\n  if ((a & 4096) !== 0)\n    return F = 7, 4096;\n  b = 4186112 & a;\n  if (b !== 0)\n    return F = 6, b;\n  b = 62914560 & a;\n  if (b !== 0)\n    return F = 5, b;\n  if (a & 67108864)\n    return F = 4, 67108864;\n  if ((a & 134217728) !== 0)\n    return F = 3, 134217728;\n  b = 805306368 & a;\n  if (b !== 0)\n    return F = 2, b;\n  if ((1073741824 & a) !== 0)\n    return F = 1, 1073741824;\n  F = 8;\n  return a;\n}\nfunction Sc$1(a) {\n  switch (a) {\n    case 99:\n      return 15;\n    case 98:\n      return 10;\n    case 97:\n    case 96:\n      return 8;\n    case 95:\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction Tc(a) {\n  switch (a) {\n    case 15:\n    case 14:\n      return 99;\n    case 13:\n    case 12:\n    case 11:\n    case 10:\n      return 98;\n    case 9:\n    case 8:\n    case 7:\n    case 6:\n    case 4:\n    case 5:\n      return 97;\n    case 3:\n    case 2:\n    case 1:\n      return 95;\n    case 0:\n      return 90;\n    default:\n      throw Error(y(358, a));\n  }\n}\nfunction Uc(a, b) {\n  var c = a.pendingLanes;\n  if (c === 0)\n    return F = 0;\n  var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;\n  if (f !== 0)\n    d = f, e = F = 15;\n  else if (f = c & 134217727, f !== 0) {\n    var k = f & ~g;\n    k !== 0 ? (d = Rc(k), e = F) : (h &= f, h !== 0 && (d = Rc(h), e = F));\n  } else\n    f = c & ~g, f !== 0 ? (d = Rc(f), e = F) : h !== 0 && (d = Rc(h), e = F);\n  if (d === 0)\n    return 0;\n  d = 31 - Vc(d);\n  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;\n  if (b !== 0 && b !== d && (b & g) === 0) {\n    Rc(b);\n    if (e <= F)\n      return b;\n    F = e;\n  }\n  b = a.entangledLanes;\n  if (b !== 0)\n    for (a = a.entanglements, b &= d; 0 < b; )\n      c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;\n  return d;\n}\nfunction Wc(a) {\n  a = a.pendingLanes & -1073741825;\n  return a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;\n}\nfunction Xc(a, b) {\n  switch (a) {\n    case 15:\n      return 1;\n    case 14:\n      return 2;\n    case 12:\n      return a = Yc(24 & ~b), a === 0 ? Xc(10, b) : a;\n    case 10:\n      return a = Yc(192 & ~b), a === 0 ? Xc(8, b) : a;\n    case 8:\n      return a = Yc(3584 & ~b), a === 0 && (a = Yc(4186112 & ~b), a === 0 && (a = 512)), a;\n    case 2:\n      return b = Yc(805306368 & ~b), b === 0 && (b = 268435456), b;\n  }\n  throw Error(y(358, a));\n}\nfunction Yc(a) {\n  return a & -a;\n}\nfunction Zc(a) {\n  for (var b = [], c = 0; 31 > c; c++)\n    b.push(a);\n  return b;\n}\nfunction $c(a, b, c) {\n  a.pendingLanes |= b;\n  var d = b - 1;\n  a.suspendedLanes &= d;\n  a.pingedLanes &= d;\n  a = a.eventTimes;\n  b = 31 - Vc(b);\n  a[b] = c;\n}\nvar Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;\nfunction ad(a) {\n  return a === 0 ? 32 : 31 - (bd(a) / cd | 0) | 0;\n}\nvar dd$1 = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;\nfunction gd(a, b, c, d) {\n  Kb || Ib();\n  var e = hd, f = Kb;\n  Kb = true;\n  try {\n    Hb(e, a, b, c, d);\n  } finally {\n    (Kb = f) || Mb();\n  }\n}\nfunction id(a, b, c, d) {\n  ed(dd$1, hd.bind(null, a, b, c, d));\n}\nfunction hd(a, b, c, d) {\n  if (fd) {\n    var e;\n    if ((e = (b & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a))\n      a = rc(null, a, b, c, d), jc.push(a);\n    else {\n      var f = yc(a, b, c, d);\n      if (f === null)\n        e && sc$1(a, d);\n      else {\n        if (e) {\n          if (-1 < qc.indexOf(a)) {\n            a = rc(f, a, b, c, d);\n            jc.push(a);\n            return;\n          }\n          if (uc(f, a, b, c, d))\n            return;\n          sc$1(a, d);\n        }\n        jd(a, b, d, null, c);\n      }\n    }\n  }\n}\nfunction yc(a, b, c, d) {\n  var e = xb(d);\n  e = wc(e);\n  if (e !== null) {\n    var f = Zb(e);\n    if (f === null)\n      e = null;\n    else {\n      var g = f.tag;\n      if (g === 13) {\n        e = $b(f);\n        if (e !== null)\n          return e;\n        e = null;\n      } else if (g === 3) {\n        if (f.stateNode.hydrate)\n          return f.tag === 3 ? f.stateNode.containerInfo : null;\n        e = null;\n      } else\n        f !== e && (e = null);\n    }\n  }\n  jd(a, b, d, e, c);\n  return null;\n}\nvar kd = null, ld = null, md$3 = null;\nfunction nd() {\n  if (md$3)\n    return md$3;\n  var a, b = ld, c = b.length, d, e = \"value\" in kd ? kd.value : kd.textContent, f = e.length;\n  for (a = 0; a < c && b[a] === e[a]; a++)\n    ;\n  var g = c - a;\n  for (d = 1; d <= g && b[c - d] === e[f - d]; d++)\n    ;\n  return md$3 = e.slice(a, 1 < d ? 1 - d : void 0);\n}\nfunction od(a) {\n  var b = a.keyCode;\n  \"charCode\" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b;\n  a === 10 && (a = 13);\n  return 32 <= a || a === 13 ? a : 0;\n}\nfunction pd() {\n  return true;\n}\nfunction qd() {\n  return false;\n}\nfunction rd(a) {\n  function b(b2, d, e, f, g) {\n    this._reactName = b2;\n    this._targetInst = e;\n    this.type = d;\n    this.nativeEvent = f;\n    this.target = g;\n    this.currentTarget = null;\n    for (var c in a)\n      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);\n    this.isDefaultPrevented = (f.defaultPrevented != null ? f.defaultPrevented : f.returnValue === false) ? pd : qd;\n    this.isPropagationStopped = qd;\n    return this;\n  }\n  m(b.prototype, { preventDefault: function() {\n    this.defaultPrevented = true;\n    var a2 = this.nativeEvent;\n    a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue !== \"unknown\" && (a2.returnValue = false), this.isDefaultPrevented = pd);\n  }, stopPropagation: function() {\n    var a2 = this.nativeEvent;\n    a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble !== \"unknown\" && (a2.cancelBubble = true), this.isPropagationStopped = pd);\n  }, persist: function() {\n  }, isPersistent: pd });\n  return b;\n}\nvar sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {\n  return a.timeStamp || Date.now();\n}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {\n  return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;\n}, movementX: function(a) {\n  if (\"movementX\" in a)\n    return a.movementX;\n  a !== yd && (yd && a.type === \"mousemove\" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);\n  return wd;\n}, movementY: function(a) {\n  return \"movementY\" in a ? a.movementY : xd;\n} }), Bd = rd(Ad), Cd = m({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m({}, sd, { clipboardData: function(a) {\n  return \"clipboardData\" in a ? a.clipboardData : window.clipboardData;\n} }), Jd = rd(Id), Kd = m({}, sd, { data: 0 }), Ld = rd(Kd), Md = {\n  Esc: \"Escape\",\n  Spacebar: \" \",\n  Left: \"ArrowLeft\",\n  Up: \"ArrowUp\",\n  Right: \"ArrowRight\",\n  Down: \"ArrowDown\",\n  Del: \"Delete\",\n  Win: \"OS\",\n  Menu: \"ContextMenu\",\n  Apps: \"ContextMenu\",\n  Scroll: \"ScrollLock\",\n  MozPrintableKey: \"Unidentified\"\n}, Nd = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  12: \"Clear\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  19: \"Pause\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  45: \"Insert\",\n  46: \"Delete\",\n  112: \"F1\",\n  113: \"F2\",\n  114: \"F3\",\n  115: \"F4\",\n  116: \"F5\",\n  117: \"F6\",\n  118: \"F7\",\n  119: \"F8\",\n  120: \"F9\",\n  121: \"F10\",\n  122: \"F11\",\n  123: \"F12\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  224: \"Meta\"\n}, Od = { Alt: \"altKey\", Control: \"ctrlKey\", Meta: \"metaKey\", Shift: \"shiftKey\" };\nfunction Pd(a) {\n  var b = this.nativeEvent;\n  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;\n}\nfunction zd() {\n  return Pd;\n}\nvar Qd = m({}, ud, { key: function(a) {\n  if (a.key) {\n    var b = Md[a.key] || a.key;\n    if (b !== \"Unidentified\")\n      return b;\n  }\n  return a.type === \"keypress\" ? (a = od(a), a === 13 ? \"Enter\" : String.fromCharCode(a)) : a.type === \"keydown\" || a.type === \"keyup\" ? Nd[a.keyCode] || \"Unidentified\" : \"\";\n}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {\n  return a.type === \"keypress\" ? od(a) : 0;\n}, keyCode: function(a) {\n  return a.type === \"keydown\" || a.type === \"keyup\" ? a.keyCode : 0;\n}, which: function(a) {\n  return a.type === \"keypress\" ? od(a) : a.type === \"keydown\" || a.type === \"keyup\" ? a.keyCode : 0;\n} }), Rd = rd(Qd), Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m({}, Ad, {\n  deltaX: function(a) {\n    return \"deltaX\" in a ? a.deltaX : \"wheelDeltaX\" in a ? -a.wheelDeltaX : 0;\n  },\n  deltaY: function(a) {\n    return \"deltaY\" in a ? a.deltaY : \"wheelDeltaY\" in a ? -a.wheelDeltaY : \"wheelDelta\" in a ? -a.wheelDelta : 0;\n  },\n  deltaZ: 0,\n  deltaMode: 0\n}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && \"CompositionEvent\" in window, be = null;\nfa && \"documentMode\" in document && (be = document.documentMode);\nvar ce = fa && \"TextEvent\" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee$1 = String.fromCharCode(32), fe = false;\nfunction ge$1(a, b) {\n  switch (a) {\n    case \"keyup\":\n      return $d.indexOf(b.keyCode) !== -1;\n    case \"keydown\":\n      return b.keyCode !== 229;\n    case \"keypress\":\n    case \"mousedown\":\n    case \"focusout\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction he(a) {\n  a = a.detail;\n  return typeof a === \"object\" && \"data\" in a ? a.data : null;\n}\nvar ie = false;\nfunction je(a, b) {\n  switch (a) {\n    case \"compositionend\":\n      return he(b);\n    case \"keypress\":\n      if (b.which !== 32)\n        return null;\n      fe = true;\n      return ee$1;\n    case \"textInput\":\n      return a = b.data, a === ee$1 && fe ? null : a;\n    default:\n      return null;\n  }\n}\nfunction ke(a, b) {\n  if (ie)\n    return a === \"compositionend\" || !ae && ge$1(a, b) ? (a = nd(), md$3 = ld = kd = null, ie = false, a) : null;\n  switch (a) {\n    case \"paste\":\n      return null;\n    case \"keypress\":\n      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {\n        if (b.char && 1 < b.char.length)\n          return b.char;\n        if (b.which)\n          return String.fromCharCode(b.which);\n      }\n      return null;\n    case \"compositionend\":\n      return de && b.locale !== \"ko\" ? null : b.data;\n    default:\n      return null;\n  }\n}\nvar le$1 = { color: true, date: true, datetime: true, \"datetime-local\": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };\nfunction me(a) {\n  var b = a && a.nodeName && a.nodeName.toLowerCase();\n  return b === \"input\" ? !!le$1[a.type] : b === \"textarea\" ? true : false;\n}\nfunction ne$1(a, b, c, d) {\n  Eb(d);\n  b = oe(b, \"onChange\");\n  0 < b.length && (c = new td(\"onChange\", \"change\", null, c, d), a.push({ event: c, listeners: b }));\n}\nvar pe = null, qe = null;\nfunction re$1(a) {\n  se(a, 0);\n}\nfunction te(a) {\n  var b = ue(a);\n  if (Wa(b))\n    return a;\n}\nfunction ve(a, b) {\n  if (a === \"change\")\n    return b;\n}\nvar we = false;\nif (fa) {\n  var xe;\n  if (fa) {\n    var ye = \"oninput\" in document;\n    if (!ye) {\n      var ze = document.createElement(\"div\");\n      ze.setAttribute(\"oninput\", \"return;\");\n      ye = typeof ze.oninput === \"function\";\n    }\n    xe = ye;\n  } else\n    xe = false;\n  we = xe && (!document.documentMode || 9 < document.documentMode);\n}\nfunction Ae() {\n  pe && (pe.detachEvent(\"onpropertychange\", Be), qe = pe = null);\n}\nfunction Be(a) {\n  if (a.propertyName === \"value\" && te(qe)) {\n    var b = [];\n    ne$1(b, qe, a, xb(a));\n    a = re$1;\n    if (Kb)\n      a(b);\n    else {\n      Kb = true;\n      try {\n        Gb(a, b);\n      } finally {\n        Kb = false, Mb();\n      }\n    }\n  }\n}\nfunction Ce(a, b, c) {\n  a === \"focusin\" ? (Ae(), pe = b, qe = c, pe.attachEvent(\"onpropertychange\", Be)) : a === \"focusout\" && Ae();\n}\nfunction De(a) {\n  if (a === \"selectionchange\" || a === \"keyup\" || a === \"keydown\")\n    return te(qe);\n}\nfunction Ee(a, b) {\n  if (a === \"click\")\n    return te(b);\n}\nfunction Fe(a, b) {\n  if (a === \"input\" || a === \"change\")\n    return te(b);\n}\nfunction Ge(a, b) {\n  return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;\n}\nvar He = typeof Object.is === \"function\" ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;\nfunction Je(a, b) {\n  if (He(a, b))\n    return true;\n  if (typeof a !== \"object\" || a === null || typeof b !== \"object\" || b === null)\n    return false;\n  var c = Object.keys(a), d = Object.keys(b);\n  if (c.length !== d.length)\n    return false;\n  for (d = 0; d < c.length; d++)\n    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))\n      return false;\n  return true;\n}\nfunction Ke(a) {\n  for (; a && a.firstChild; )\n    a = a.firstChild;\n  return a;\n}\nfunction Le(a, b) {\n  var c = Ke(a);\n  a = 0;\n  for (var d; c; ) {\n    if (c.nodeType === 3) {\n      d = a + c.textContent.length;\n      if (a <= b && d >= b)\n        return { node: c, offset: b - a };\n      a = d;\n    }\n    a: {\n      for (; c; ) {\n        if (c.nextSibling) {\n          c = c.nextSibling;\n          break a;\n        }\n        c = c.parentNode;\n      }\n      c = void 0;\n    }\n    c = Ke(c);\n  }\n}\nfunction Me(a, b) {\n  return a && b ? a === b ? true : a && a.nodeType === 3 ? false : b && b.nodeType === 3 ? Me(a, b.parentNode) : \"contains\" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;\n}\nfunction Ne() {\n  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {\n    try {\n      var c = typeof b.contentWindow.location.href === \"string\";\n    } catch (d) {\n      c = false;\n    }\n    if (c)\n      a = b.contentWindow;\n    else\n      break;\n    b = Xa(a.document);\n  }\n  return b;\n}\nfunction Oe(a) {\n  var b = a && a.nodeName && a.nodeName.toLowerCase();\n  return b && (b === \"input\" && (a.type === \"text\" || a.type === \"search\" || a.type === \"tel\" || a.type === \"url\" || a.type === \"password\") || b === \"textarea\" || a.contentEditable === \"true\");\n}\nvar Pe = fa && \"documentMode\" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se = null, Te = false;\nfunction Ue(a, b, c) {\n  var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;\n  Te || Qe == null || Qe !== Xa(d) || (d = Qe, \"selectionStart\" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re$1, \"onSelect\"), 0 < d.length && (b = new td(\"onSelect\", \"select\", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));\n}\nPc(\"cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange\".split(\" \"), 0);\nPc(\"drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel\".split(\" \"), 1);\nPc(Oc, 2);\nfor (var Ve = \"change selectionchange textInput compositionstart compositionend compositionupdate\".split(\" \"), We = 0; We < Ve.length; We++)\n  Nc.set(Ve[We], 0);\nea(\"onMouseEnter\", [\"mouseout\", \"mouseover\"]);\nea(\"onMouseLeave\", [\"mouseout\", \"mouseover\"]);\nea(\"onPointerEnter\", [\"pointerout\", \"pointerover\"]);\nea(\"onPointerLeave\", [\"pointerout\", \"pointerover\"]);\nda(\"onChange\", \"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));\nda(\"onSelect\", \"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));\nda(\"onBeforeInput\", [\"compositionend\", \"keypress\", \"textInput\", \"paste\"]);\nda(\"onCompositionEnd\", \"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));\nda(\"onCompositionStart\", \"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));\nda(\"onCompositionUpdate\", \"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));\nvar Xe = \"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"), Ye = new Set(\"cancel close invalid load scroll toggle\".split(\" \").concat(Xe));\nfunction Ze(a, b, c) {\n  var d = a.type || \"unknown-event\";\n  a.currentTarget = c;\n  Yb(d, b, void 0, a);\n  a.currentTarget = null;\n}\nfunction se(a, b) {\n  b = (b & 4) !== 0;\n  for (var c = 0; c < a.length; c++) {\n    var d = a[c], e = d.event;\n    d = d.listeners;\n    a: {\n      var f = void 0;\n      if (b)\n        for (var g = d.length - 1; 0 <= g; g--) {\n          var h = d[g], k = h.instance, l2 = h.currentTarget;\n          h = h.listener;\n          if (k !== f && e.isPropagationStopped())\n            break a;\n          Ze(e, h, l2);\n          f = k;\n        }\n      else\n        for (g = 0; g < d.length; g++) {\n          h = d[g];\n          k = h.instance;\n          l2 = h.currentTarget;\n          h = h.listener;\n          if (k !== f && e.isPropagationStopped())\n            break a;\n          Ze(e, h, l2);\n          f = k;\n        }\n    }\n  }\n  if (Ub)\n    throw a = Vb, Ub = false, Vb = null, a;\n}\nfunction G(a, b) {\n  var c = $e(b), d = a + \"__bubble\";\n  c.has(d) || (af$1(b, a, 2, false), c.add(d));\n}\nvar bf = \"_reactListening\" + Math.random().toString(36).slice(2);\nfunction cf(a) {\n  a[bf] || (a[bf] = true, ba.forEach(function(b) {\n    Ye.has(b) || df(b, false, a, null);\n    df(b, true, a, null);\n  }));\n}\nfunction df(a, b, c, d) {\n  var e = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f = c;\n  a === \"selectionchange\" && c.nodeType !== 9 && (f = c.ownerDocument);\n  if (d !== null && !b && Ye.has(a)) {\n    if (a !== \"scroll\")\n      return;\n    e |= 2;\n    f = d;\n  }\n  var g = $e(f), h = a + \"__\" + (b ? \"capture\" : \"bubble\");\n  g.has(h) || (b && (e |= 4), af$1(f, a, e, b), g.add(h));\n}\nfunction af$1(a, b, c, d) {\n  var e = Nc.get(b);\n  switch (e === void 0 ? 2 : e) {\n    case 0:\n      e = gd;\n      break;\n    case 1:\n      e = id;\n      break;\n    default:\n      e = hd;\n  }\n  c = e.bind(null, b, c, a);\n  e = void 0;\n  !Pb || b !== \"touchstart\" && b !== \"touchmove\" && b !== \"wheel\" || (e = true);\n  d ? e !== void 0 ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : e !== void 0 ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);\n}\nfunction jd(a, b, c, d, e) {\n  var f = d;\n  if ((b & 1) === 0 && (b & 2) === 0 && d !== null)\n    a:\n      for (; ; ) {\n        if (d === null)\n          return;\n        var g = d.tag;\n        if (g === 3 || g === 4) {\n          var h = d.stateNode.containerInfo;\n          if (h === e || h.nodeType === 8 && h.parentNode === e)\n            break;\n          if (g === 4)\n            for (g = d.return; g !== null; ) {\n              var k = g.tag;\n              if (k === 3 || k === 4) {\n                if (k = g.stateNode.containerInfo, k === e || k.nodeType === 8 && k.parentNode === e)\n                  return;\n              }\n              g = g.return;\n            }\n          for (; h !== null; ) {\n            g = wc(h);\n            if (g === null)\n              return;\n            k = g.tag;\n            if (k === 5 || k === 6) {\n              d = f = g;\n              continue a;\n            }\n            h = h.parentNode;\n          }\n        }\n        d = d.return;\n      }\n  Nb(function() {\n    var d2 = f, e2 = xb(c), g2 = [];\n    a: {\n      var h2 = Mc.get(a);\n      if (h2 !== void 0) {\n        var k2 = td, x2 = a;\n        switch (a) {\n          case \"keypress\":\n            if (od(c) === 0)\n              break a;\n          case \"keydown\":\n          case \"keyup\":\n            k2 = Rd;\n            break;\n          case \"focusin\":\n            x2 = \"focus\";\n            k2 = Fd;\n            break;\n          case \"focusout\":\n            x2 = \"blur\";\n            k2 = Fd;\n            break;\n          case \"beforeblur\":\n          case \"afterblur\":\n            k2 = Fd;\n            break;\n          case \"click\":\n            if (c.button === 2)\n              break a;\n          case \"auxclick\":\n          case \"dblclick\":\n          case \"mousedown\":\n          case \"mousemove\":\n          case \"mouseup\":\n          case \"mouseout\":\n          case \"mouseover\":\n          case \"contextmenu\":\n            k2 = Bd;\n            break;\n          case \"drag\":\n          case \"dragend\":\n          case \"dragenter\":\n          case \"dragexit\":\n          case \"dragleave\":\n          case \"dragover\":\n          case \"dragstart\":\n          case \"drop\":\n            k2 = Dd;\n            break;\n          case \"touchcancel\":\n          case \"touchend\":\n          case \"touchmove\":\n          case \"touchstart\":\n            k2 = Vd;\n            break;\n          case Ic:\n          case Jc:\n          case Kc:\n            k2 = Hd;\n            break;\n          case Lc:\n            k2 = Xd;\n            break;\n          case \"scroll\":\n            k2 = vd;\n            break;\n          case \"wheel\":\n            k2 = Zd;\n            break;\n          case \"copy\":\n          case \"cut\":\n          case \"paste\":\n            k2 = Jd;\n            break;\n          case \"gotpointercapture\":\n          case \"lostpointercapture\":\n          case \"pointercancel\":\n          case \"pointerdown\":\n          case \"pointermove\":\n          case \"pointerout\":\n          case \"pointerover\":\n          case \"pointerup\":\n            k2 = Td;\n        }\n        var w = (b & 4) !== 0, z2 = !w && a === \"scroll\", u2 = w ? h2 !== null ? h2 + \"Capture\" : null : h2;\n        w = [];\n        for (var t2 = d2, q2; t2 !== null; ) {\n          q2 = t2;\n          var v2 = q2.stateNode;\n          q2.tag === 5 && v2 !== null && (q2 = v2, u2 !== null && (v2 = Ob(t2, u2), v2 != null && w.push(ef(t2, v2, q2))));\n          if (z2)\n            break;\n          t2 = t2.return;\n        }\n        0 < w.length && (h2 = new k2(h2, x2, null, c, e2), g2.push({ event: h2, listeners: w }));\n      }\n    }\n    if ((b & 7) === 0) {\n      a: {\n        h2 = a === \"mouseover\" || a === \"pointerover\";\n        k2 = a === \"mouseout\" || a === \"pointerout\";\n        if (h2 && (b & 16) === 0 && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))\n          break a;\n        if (k2 || h2) {\n          h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;\n          if (k2) {\n            if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, x2 !== null && (z2 = Zb(x2), x2 !== z2 || x2.tag !== 5 && x2.tag !== 6))\n              x2 = null;\n          } else\n            k2 = null, x2 = d2;\n          if (k2 !== x2) {\n            w = Bd;\n            v2 = \"onMouseLeave\";\n            u2 = \"onMouseEnter\";\n            t2 = \"mouse\";\n            if (a === \"pointerout\" || a === \"pointerover\")\n              w = Td, v2 = \"onPointerLeave\", u2 = \"onPointerEnter\", t2 = \"pointer\";\n            z2 = k2 == null ? h2 : ue(k2);\n            q2 = x2 == null ? h2 : ue(x2);\n            h2 = new w(v2, t2 + \"leave\", k2, c, e2);\n            h2.target = z2;\n            h2.relatedTarget = q2;\n            v2 = null;\n            wc(e2) === d2 && (w = new w(u2, t2 + \"enter\", x2, c, e2), w.target = q2, w.relatedTarget = z2, v2 = w);\n            z2 = v2;\n            if (k2 && x2)\n              b: {\n                w = k2;\n                u2 = x2;\n                t2 = 0;\n                for (q2 = w; q2; q2 = gf(q2))\n                  t2++;\n                q2 = 0;\n                for (v2 = u2; v2; v2 = gf(v2))\n                  q2++;\n                for (; 0 < t2 - q2; )\n                  w = gf(w), t2--;\n                for (; 0 < q2 - t2; )\n                  u2 = gf(u2), q2--;\n                for (; t2--; ) {\n                  if (w === u2 || u2 !== null && w === u2.alternate)\n                    break b;\n                  w = gf(w);\n                  u2 = gf(u2);\n                }\n                w = null;\n              }\n            else\n              w = null;\n            k2 !== null && hf(g2, h2, k2, w, false);\n            x2 !== null && z2 !== null && hf(g2, z2, x2, w, true);\n          }\n        }\n      }\n      a: {\n        h2 = d2 ? ue(d2) : window;\n        k2 = h2.nodeName && h2.nodeName.toLowerCase();\n        if (k2 === \"select\" || k2 === \"input\" && h2.type === \"file\")\n          var J2 = ve;\n        else if (me(h2))\n          if (we)\n            J2 = Fe;\n          else {\n            J2 = De;\n            var K2 = Ce;\n          }\n        else\n          (k2 = h2.nodeName) && k2.toLowerCase() === \"input\" && (h2.type === \"checkbox\" || h2.type === \"radio\") && (J2 = Ee);\n        if (J2 && (J2 = J2(a, d2))) {\n          ne$1(g2, J2, c, e2);\n          break a;\n        }\n        K2 && K2(a, h2, d2);\n        a === \"focusout\" && (K2 = h2._wrapperState) && K2.controlled && h2.type === \"number\" && bb(h2, \"number\", h2.value);\n      }\n      K2 = d2 ? ue(d2) : window;\n      switch (a) {\n        case \"focusin\":\n          if (me(K2) || K2.contentEditable === \"true\")\n            Qe = K2, Re$1 = d2, Se = null;\n          break;\n        case \"focusout\":\n          Se = Re$1 = Qe = null;\n          break;\n        case \"mousedown\":\n          Te = true;\n          break;\n        case \"contextmenu\":\n        case \"mouseup\":\n        case \"dragend\":\n          Te = false;\n          Ue(g2, c, e2);\n          break;\n        case \"selectionchange\":\n          if (Pe)\n            break;\n        case \"keydown\":\n        case \"keyup\":\n          Ue(g2, c, e2);\n      }\n      var Q2;\n      if (ae)\n        b: {\n          switch (a) {\n            case \"compositionstart\":\n              var L2 = \"onCompositionStart\";\n              break b;\n            case \"compositionend\":\n              L2 = \"onCompositionEnd\";\n              break b;\n            case \"compositionupdate\":\n              L2 = \"onCompositionUpdate\";\n              break b;\n          }\n          L2 = void 0;\n        }\n      else\n        ie ? ge$1(a, c) && (L2 = \"onCompositionEnd\") : a === \"keydown\" && c.keyCode === 229 && (L2 = \"onCompositionStart\");\n      L2 && (de && c.locale !== \"ko\" && (ie || L2 !== \"onCompositionStart\" ? L2 === \"onCompositionEnd\" && ie && (Q2 = nd()) : (kd = e2, ld = \"value\" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c, e2), g2.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), Q2 !== null && (L2.data = Q2))));\n      if (Q2 = ce ? je(a, c) : ke(a, c))\n        d2 = oe(d2, \"onBeforeInput\"), 0 < d2.length && (e2 = new Ld(\"onBeforeInput\", \"beforeinput\", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = Q2);\n    }\n    se(g2, b);\n  });\n}\nfunction ef(a, b, c) {\n  return { instance: a, listener: b, currentTarget: c };\n}\nfunction oe(a, b) {\n  for (var c = b + \"Capture\", d = []; a !== null; ) {\n    var e = a, f = e.stateNode;\n    e.tag === 5 && f !== null && (e = f, f = Ob(a, c), f != null && d.unshift(ef(a, f, e)), f = Ob(a, b), f != null && d.push(ef(a, f, e)));\n    a = a.return;\n  }\n  return d;\n}\nfunction gf(a) {\n  if (a === null)\n    return null;\n  do\n    a = a.return;\n  while (a && a.tag !== 5);\n  return a ? a : null;\n}\nfunction hf(a, b, c, d, e) {\n  for (var f = b._reactName, g = []; c !== null && c !== d; ) {\n    var h = c, k = h.alternate, l2 = h.stateNode;\n    if (k !== null && k === d)\n      break;\n    h.tag === 5 && l2 !== null && (h = l2, e ? (k = Ob(c, f), k != null && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), k != null && g.push(ef(c, k, h))));\n    c = c.return;\n  }\n  g.length !== 0 && a.push({ event: b, listeners: g });\n}\nfunction jf() {\n}\nvar kf = null, lf = null;\nfunction mf(a, b) {\n  switch (a) {\n    case \"button\":\n    case \"input\":\n    case \"select\":\n    case \"textarea\":\n      return !!b.autoFocus;\n  }\n  return false;\n}\nfunction nf(a, b) {\n  return a === \"textarea\" || a === \"option\" || a === \"noscript\" || typeof b.children === \"string\" || typeof b.children === \"number\" || typeof b.dangerouslySetInnerHTML === \"object\" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;\n}\nvar of = typeof setTimeout === \"function\" ? setTimeout : void 0, pf = typeof clearTimeout === \"function\" ? clearTimeout : void 0;\nfunction qf(a) {\n  a.nodeType === 1 ? a.textContent = \"\" : a.nodeType === 9 && (a = a.body, a != null && (a.textContent = \"\"));\n}\nfunction rf(a) {\n  for (; a != null; a = a.nextSibling) {\n    var b = a.nodeType;\n    if (b === 1 || b === 3)\n      break;\n  }\n  return a;\n}\nfunction sf(a) {\n  a = a.previousSibling;\n  for (var b = 0; a; ) {\n    if (a.nodeType === 8) {\n      var c = a.data;\n      if (c === \"$\" || c === \"$!\" || c === \"$?\") {\n        if (b === 0)\n          return a;\n        b--;\n      } else\n        c === \"/$\" && b++;\n    }\n    a = a.previousSibling;\n  }\n  return null;\n}\nvar tf = 0;\nfunction uf(a) {\n  return { $$typeof: Ga, toString: a, valueOf: a };\n}\nvar vf = Math.random().toString(36).slice(2), wf = \"__reactFiber$\" + vf, xf = \"__reactProps$\" + vf, ff = \"__reactContainer$\" + vf, yf = \"__reactEvents$\" + vf;\nfunction wc(a) {\n  var b = a[wf];\n  if (b)\n    return b;\n  for (var c = a.parentNode; c; ) {\n    if (b = c[ff] || c[wf]) {\n      c = b.alternate;\n      if (b.child !== null || c !== null && c.child !== null)\n        for (a = sf(a); a !== null; ) {\n          if (c = a[wf])\n            return c;\n          a = sf(a);\n        }\n      return b;\n    }\n    a = c;\n    c = a.parentNode;\n  }\n  return null;\n}\nfunction Cb(a) {\n  a = a[wf] || a[ff];\n  return !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;\n}\nfunction ue(a) {\n  if (a.tag === 5 || a.tag === 6)\n    return a.stateNode;\n  throw Error(y(33));\n}\nfunction Db(a) {\n  return a[xf] || null;\n}\nfunction $e(a) {\n  var b = a[yf];\n  b === void 0 && (b = a[yf] = /* @__PURE__ */ new Set());\n  return b;\n}\nvar zf = [], Af = -1;\nfunction Bf(a) {\n  return { current: a };\n}\nfunction H(a) {\n  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);\n}\nfunction I(a, b) {\n  Af++;\n  zf[Af] = a.current;\n  a.current = b;\n}\nvar Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;\nfunction Ef(a, b) {\n  var c = a.type.contextTypes;\n  if (!c)\n    return Cf;\n  var d = a.stateNode;\n  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)\n    return d.__reactInternalMemoizedMaskedChildContext;\n  var e = {}, f;\n  for (f in c)\n    e[f] = b[f];\n  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);\n  return e;\n}\nfunction Ff(a) {\n  a = a.childContextTypes;\n  return a !== null && a !== void 0;\n}\nfunction Gf() {\n  H(N);\n  H(M);\n}\nfunction Hf(a, b, c) {\n  if (M.current !== Cf)\n    throw Error(y(168));\n  I(M, b);\n  I(N, c);\n}\nfunction If(a, b, c) {\n  var d = a.stateNode;\n  a = b.childContextTypes;\n  if (typeof d.getChildContext !== \"function\")\n    return c;\n  d = d.getChildContext();\n  for (var e in d)\n    if (!(e in a))\n      throw Error(y(108, Ra(b) || \"Unknown\", e));\n  return m({}, c, d);\n}\nfunction Jf(a) {\n  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;\n  Df = M.current;\n  I(M, a);\n  I(N, N.current);\n  return true;\n}\nfunction Kf(a, b, c) {\n  var d = a.stateNode;\n  if (!d)\n    throw Error(y(169));\n  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);\n  I(N, c);\n}\nvar Lf = null, Mf = null, Nf = r.unstable_runWithPriority, Of = r.unstable_scheduleCallback, Pf = r.unstable_cancelCallback, Qf = r.unstable_shouldYield, Rf = r.unstable_requestPaint, Sf = r.unstable_now, Tf = r.unstable_getCurrentPriorityLevel, Uf = r.unstable_ImmediatePriority, Vf = r.unstable_UserBlockingPriority, Wf = r.unstable_NormalPriority, Xf = r.unstable_LowPriority, Yf = r.unstable_IdlePriority, Zf = {}, $f = Rf !== void 0 ? Rf : function() {\n}, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {\n  return Sf() - dg;\n};\nfunction eg$1() {\n  switch (Tf()) {\n    case Uf:\n      return 99;\n    case Vf:\n      return 98;\n    case Wf:\n      return 97;\n    case Xf:\n      return 96;\n    case Yf:\n      return 95;\n    default:\n      throw Error(y(332));\n  }\n}\nfunction fg(a) {\n  switch (a) {\n    case 99:\n      return Uf;\n    case 98:\n      return Vf;\n    case 97:\n      return Wf;\n    case 96:\n      return Xf;\n    case 95:\n      return Yf;\n    default:\n      throw Error(y(332));\n  }\n}\nfunction gg$1(a, b) {\n  a = fg(a);\n  return Nf(a, b);\n}\nfunction hg(a, b, c) {\n  a = fg(a);\n  return Of(a, b, c);\n}\nfunction ig() {\n  if (bg !== null) {\n    var a = bg;\n    bg = null;\n    Pf(a);\n  }\n  jg();\n}\nfunction jg() {\n  if (!cg && ag !== null) {\n    cg = true;\n    var a = 0;\n    try {\n      var b = ag;\n      gg$1(99, function() {\n        for (; a < b.length; a++) {\n          var c = b[a];\n          do\n            c = c(true);\n          while (c !== null);\n        }\n      });\n      ag = null;\n    } catch (c) {\n      throw ag !== null && (ag = ag.slice(a + 1)), Of(Uf, ig), c;\n    } finally {\n      cg = false;\n    }\n  }\n}\nvar kg = ra.ReactCurrentBatchConfig;\nfunction lg$1(a, b) {\n  if (a && a.defaultProps) {\n    b = m({}, b);\n    a = a.defaultProps;\n    for (var c in a)\n      b[c] === void 0 && (b[c] = a[c]);\n    return b;\n  }\n  return b;\n}\nvar mg = Bf(null), ng = null, og = null, pg = null;\nfunction qg() {\n  pg = og = ng = null;\n}\nfunction rg(a) {\n  var b = mg.current;\n  H(mg);\n  a.type._context._currentValue = b;\n}\nfunction sg(a, b) {\n  for (; a !== null; ) {\n    var c = a.alternate;\n    if ((a.childLanes & b) === b)\n      if (c === null || (c.childLanes & b) === b)\n        break;\n      else\n        c.childLanes |= b;\n    else\n      a.childLanes |= b, c !== null && (c.childLanes |= b);\n    a = a.return;\n  }\n}\nfunction tg(a, b) {\n  ng = a;\n  pg = og = null;\n  a = a.dependencies;\n  a !== null && a.firstContext !== null && ((a.lanes & b) !== 0 && (ug = true), a.firstContext = null);\n}\nfunction vg(a, b) {\n  if (pg !== a && b !== false && b !== 0) {\n    if (typeof b !== \"number\" || b === 1073741823)\n      pg = a, b = 1073741823;\n    b = { context: a, observedBits: b, next: null };\n    if (og === null) {\n      if (ng === null)\n        throw Error(y(308));\n      og = b;\n      ng.dependencies = { lanes: 0, firstContext: b, responders: null };\n    } else\n      og = og.next = b;\n  }\n  return a._currentValue;\n}\nvar wg = false;\nfunction xg(a) {\n  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };\n}\nfunction yg(a, b) {\n  a = a.updateQueue;\n  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });\n}\nfunction zg(a, b) {\n  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };\n}\nfunction Ag(a, b) {\n  a = a.updateQueue;\n  if (a !== null) {\n    a = a.shared;\n    var c = a.pending;\n    c === null ? b.next = b : (b.next = c.next, c.next = b);\n    a.pending = b;\n  }\n}\nfunction Bg(a, b) {\n  var c = a.updateQueue, d = a.alternate;\n  if (d !== null && (d = d.updateQueue, c === d)) {\n    var e = null, f = null;\n    c = c.firstBaseUpdate;\n    if (c !== null) {\n      do {\n        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };\n        f === null ? e = f = g : f = f.next = g;\n        c = c.next;\n      } while (c !== null);\n      f === null ? e = f = b : f = f.next = b;\n    } else\n      e = f = b;\n    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };\n    a.updateQueue = c;\n    return;\n  }\n  a = c.lastBaseUpdate;\n  a === null ? c.firstBaseUpdate = b : a.next = b;\n  c.lastBaseUpdate = b;\n}\nfunction Cg(a, b, c, d) {\n  var e = a.updateQueue;\n  wg = false;\n  var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;\n  if (h !== null) {\n    e.shared.pending = null;\n    var k = h, l2 = k.next;\n    k.next = null;\n    g === null ? f = l2 : g.next = l2;\n    g = k;\n    var n2 = a.alternate;\n    if (n2 !== null) {\n      n2 = n2.updateQueue;\n      var A2 = n2.lastBaseUpdate;\n      A2 !== g && (A2 === null ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);\n    }\n  }\n  if (f !== null) {\n    A2 = e.baseState;\n    g = 0;\n    n2 = l2 = k = null;\n    do {\n      h = f.lane;\n      var p2 = f.eventTime;\n      if ((d & h) === h) {\n        n2 !== null && (n2 = n2.next = {\n          eventTime: p2,\n          lane: 0,\n          tag: f.tag,\n          payload: f.payload,\n          callback: f.callback,\n          next: null\n        });\n        a: {\n          var C2 = a, x2 = f;\n          h = b;\n          p2 = c;\n          switch (x2.tag) {\n            case 1:\n              C2 = x2.payload;\n              if (typeof C2 === \"function\") {\n                A2 = C2.call(p2, A2, h);\n                break a;\n              }\n              A2 = C2;\n              break a;\n            case 3:\n              C2.flags = C2.flags & -4097 | 64;\n            case 0:\n              C2 = x2.payload;\n              h = typeof C2 === \"function\" ? C2.call(p2, A2, h) : C2;\n              if (h === null || h === void 0)\n                break a;\n              A2 = m({}, A2, h);\n              break a;\n            case 2:\n              wg = true;\n          }\n        }\n        f.callback !== null && (a.flags |= 32, h = e.effects, h === null ? e.effects = [f] : h.push(f));\n      } else\n        p2 = { eventTime: p2, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, n2 === null ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g |= h;\n      f = f.next;\n      if (f === null)\n        if (h = e.shared.pending, h === null)\n          break;\n        else\n          f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;\n    } while (1);\n    n2 === null && (k = A2);\n    e.baseState = k;\n    e.firstBaseUpdate = l2;\n    e.lastBaseUpdate = n2;\n    Dg |= g;\n    a.lanes = g;\n    a.memoizedState = A2;\n  }\n}\nfunction Eg(a, b, c) {\n  a = b.effects;\n  b.effects = null;\n  if (a !== null)\n    for (b = 0; b < a.length; b++) {\n      var d = a[b], e = d.callback;\n      if (e !== null) {\n        d.callback = null;\n        d = c;\n        if (typeof e !== \"function\")\n          throw Error(y(191, e));\n        e.call(d);\n      }\n    }\n}\nvar Fg = new aa.Component().refs;\nfunction Gg$1(a, b, c, d) {\n  b = a.memoizedState;\n  c = c(d, b);\n  c = c === null || c === void 0 ? b : m({}, b, c);\n  a.memoizedState = c;\n  a.lanes === 0 && (a.updateQueue.baseState = c);\n}\nvar Kg = { isMounted: function(a) {\n  return (a = a._reactInternals) ? Zb(a) === a : false;\n}, enqueueSetState: function(a, b, c) {\n  a = a._reactInternals;\n  var d = Hg(), e = Ig(a), f = zg(d, e);\n  f.payload = b;\n  c !== void 0 && c !== null && (f.callback = c);\n  Ag(a, f);\n  Jg(a, e, d);\n}, enqueueReplaceState: function(a, b, c) {\n  a = a._reactInternals;\n  var d = Hg(), e = Ig(a), f = zg(d, e);\n  f.tag = 1;\n  f.payload = b;\n  c !== void 0 && c !== null && (f.callback = c);\n  Ag(a, f);\n  Jg(a, e, d);\n}, enqueueForceUpdate: function(a, b) {\n  a = a._reactInternals;\n  var c = Hg(), d = Ig(a), e = zg(c, d);\n  e.tag = 2;\n  b !== void 0 && b !== null && (e.callback = b);\n  Ag(a, e);\n  Jg(a, d, c);\n} };\nfunction Lg(a, b, c, d, e, f, g) {\n  a = a.stateNode;\n  return typeof a.shouldComponentUpdate === \"function\" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;\n}\nfunction Mg(a, b, c) {\n  var d = false, e = Cf;\n  var f = b.contextType;\n  typeof f === \"object\" && f !== null ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = d !== null && d !== void 0) ? Ef(a, e) : Cf);\n  b = new b(c, f);\n  a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null;\n  b.updater = Kg;\n  a.stateNode = b;\n  b._reactInternals = a;\n  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);\n  return b;\n}\nfunction Ng(a, b, c, d) {\n  a = b.state;\n  typeof b.componentWillReceiveProps === \"function\" && b.componentWillReceiveProps(c, d);\n  typeof b.UNSAFE_componentWillReceiveProps === \"function\" && b.UNSAFE_componentWillReceiveProps(c, d);\n  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);\n}\nfunction Og(a, b, c, d) {\n  var e = a.stateNode;\n  e.props = c;\n  e.state = a.memoizedState;\n  e.refs = Fg;\n  xg(a);\n  var f = b.contextType;\n  typeof f === \"object\" && f !== null ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));\n  Cg(a, c, e, d);\n  e.state = a.memoizedState;\n  f = b.getDerivedStateFromProps;\n  typeof f === \"function\" && (Gg$1(a, b, f, c), e.state = a.memoizedState);\n  typeof b.getDerivedStateFromProps === \"function\" || typeof e.getSnapshotBeforeUpdate === \"function\" || typeof e.UNSAFE_componentWillMount !== \"function\" && typeof e.componentWillMount !== \"function\" || (b = e.state, typeof e.componentWillMount === \"function\" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount === \"function\" && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);\n  typeof e.componentDidMount === \"function\" && (a.flags |= 4);\n}\nvar Pg = Array.isArray;\nfunction Qg(a, b, c) {\n  a = c.ref;\n  if (a !== null && typeof a !== \"function\" && typeof a !== \"object\") {\n    if (c._owner) {\n      c = c._owner;\n      if (c) {\n        if (c.tag !== 1)\n          throw Error(y(309));\n        var d = c.stateNode;\n      }\n      if (!d)\n        throw Error(y(147, a));\n      var e = \"\" + a;\n      if (b !== null && b.ref !== null && typeof b.ref === \"function\" && b.ref._stringRef === e)\n        return b.ref;\n      b = function(a2) {\n        var b2 = d.refs;\n        b2 === Fg && (b2 = d.refs = {});\n        a2 === null ? delete b2[e] : b2[e] = a2;\n      };\n      b._stringRef = e;\n      return b;\n    }\n    if (typeof a !== \"string\")\n      throw Error(y(284));\n    if (!c._owner)\n      throw Error(y(290, a));\n  }\n  return a;\n}\nfunction Rg(a, b) {\n  if (a.type !== \"textarea\")\n    throw Error(y(31, Object.prototype.toString.call(b) === \"[object Object]\" ? \"object with keys {\" + Object.keys(b).join(\", \") + \"}\" : b));\n}\nfunction Sg(a) {\n  function b(b2, c2) {\n    if (a) {\n      var d2 = b2.lastEffect;\n      d2 !== null ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;\n      c2.nextEffect = null;\n      c2.flags = 8;\n    }\n  }\n  function c(c2, d2) {\n    if (!a)\n      return null;\n    for (; d2 !== null; )\n      b(c2, d2), d2 = d2.sibling;\n    return null;\n  }\n  function d(a2, b2) {\n    for (a2 = /* @__PURE__ */ new Map(); b2 !== null; )\n      b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;\n    return a2;\n  }\n  function e(a2, b2) {\n    a2 = Tg(a2, b2);\n    a2.index = 0;\n    a2.sibling = null;\n    return a2;\n  }\n  function f(b2, c2, d2) {\n    b2.index = d2;\n    if (!a)\n      return c2;\n    d2 = b2.alternate;\n    if (d2 !== null)\n      return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;\n    b2.flags = 2;\n    return c2;\n  }\n  function g(b2) {\n    a && b2.alternate === null && (b2.flags = 2);\n    return b2;\n  }\n  function h(a2, b2, c2, d2) {\n    if (b2 === null || b2.tag !== 6)\n      return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;\n    b2 = e(b2, c2);\n    b2.return = a2;\n    return b2;\n  }\n  function k(a2, b2, c2, d2) {\n    if (b2 !== null && b2.elementType === c2.type)\n      return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;\n    d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);\n    d2.ref = Qg(a2, b2, c2);\n    d2.return = a2;\n    return d2;\n  }\n  function l2(a2, b2, c2, d2) {\n    if (b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)\n      return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;\n    b2 = e(b2, c2.children || []);\n    b2.return = a2;\n    return b2;\n  }\n  function n2(a2, b2, c2, d2, f2) {\n    if (b2 === null || b2.tag !== 7)\n      return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;\n    b2 = e(b2, c2);\n    b2.return = a2;\n    return b2;\n  }\n  function A2(a2, b2, c2) {\n    if (typeof b2 === \"string\" || typeof b2 === \"number\")\n      return b2 = Ug(\"\" + b2, a2.mode, c2), b2.return = a2, b2;\n    if (typeof b2 === \"object\" && b2 !== null) {\n      switch (b2.$$typeof) {\n        case sa:\n          return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;\n        case ta:\n          return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;\n      }\n      if (Pg(b2) || La(b2))\n        return b2 = Xg(b2, a2.mode, c2, null), b2.return = a2, b2;\n      Rg(a2, b2);\n    }\n    return null;\n  }\n  function p2(a2, b2, c2, d2) {\n    var e2 = b2 !== null ? b2.key : null;\n    if (typeof c2 === \"string\" || typeof c2 === \"number\")\n      return e2 !== null ? null : h(a2, b2, \"\" + c2, d2);\n    if (typeof c2 === \"object\" && c2 !== null) {\n      switch (c2.$$typeof) {\n        case sa:\n          return c2.key === e2 ? c2.type === ua ? n2(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;\n        case ta:\n          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;\n      }\n      if (Pg(c2) || La(c2))\n        return e2 !== null ? null : n2(a2, b2, c2, d2, null);\n      Rg(a2, c2);\n    }\n    return null;\n  }\n  function C2(a2, b2, c2, d2, e2) {\n    if (typeof d2 === \"string\" || typeof d2 === \"number\")\n      return a2 = a2.get(c2) || null, h(b2, a2, \"\" + d2, e2);\n    if (typeof d2 === \"object\" && d2 !== null) {\n      switch (d2.$$typeof) {\n        case sa:\n          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);\n        case ta:\n          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l2(b2, a2, d2, e2);\n      }\n      if (Pg(d2) || La(d2))\n        return a2 = a2.get(c2) || null, n2(b2, a2, d2, e2, null);\n      Rg(b2, d2);\n    }\n    return null;\n  }\n  function x2(e2, g2, h2, k2) {\n    for (var l3 = null, t2 = null, u2 = g2, z2 = g2 = 0, q2 = null; u2 !== null && z2 < h2.length; z2++) {\n      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;\n      var n3 = p2(e2, u2, h2[z2], k2);\n      if (n3 === null) {\n        u2 === null && (u2 = q2);\n        break;\n      }\n      a && u2 && n3.alternate === null && b(e2, u2);\n      g2 = f(n3, g2, z2);\n      t2 === null ? l3 = n3 : t2.sibling = n3;\n      t2 = n3;\n      u2 = q2;\n    }\n    if (z2 === h2.length)\n      return c(e2, u2), l3;\n    if (u2 === null) {\n      for (; z2 < h2.length; z2++)\n        u2 = A2(e2, h2[z2], k2), u2 !== null && (g2 = f(u2, g2, z2), t2 === null ? l3 = u2 : t2.sibling = u2, t2 = u2);\n      return l3;\n    }\n    for (u2 = d(e2, u2); z2 < h2.length; z2++)\n      q2 = C2(u2, e2, z2, h2[z2], k2), q2 !== null && (a && q2.alternate !== null && u2.delete(q2.key === null ? z2 : q2.key), g2 = f(q2, g2, z2), t2 === null ? l3 = q2 : t2.sibling = q2, t2 = q2);\n    a && u2.forEach(function(a2) {\n      return b(e2, a2);\n    });\n    return l3;\n  }\n  function w(e2, g2, h2, k2) {\n    var l3 = La(h2);\n    if (typeof l3 !== \"function\")\n      throw Error(y(150));\n    h2 = l3.call(h2);\n    if (h2 == null)\n      throw Error(y(151));\n    for (var t2 = l3 = null, u2 = g2, z2 = g2 = 0, q2 = null, n3 = h2.next(); u2 !== null && !n3.done; z2++, n3 = h2.next()) {\n      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;\n      var w2 = p2(e2, u2, n3.value, k2);\n      if (w2 === null) {\n        u2 === null && (u2 = q2);\n        break;\n      }\n      a && u2 && w2.alternate === null && b(e2, u2);\n      g2 = f(w2, g2, z2);\n      t2 === null ? l3 = w2 : t2.sibling = w2;\n      t2 = w2;\n      u2 = q2;\n    }\n    if (n3.done)\n      return c(e2, u2), l3;\n    if (u2 === null) {\n      for (; !n3.done; z2++, n3 = h2.next())\n        n3 = A2(e2, n3.value, k2), n3 !== null && (g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);\n      return l3;\n    }\n    for (u2 = d(e2, u2); !n3.done; z2++, n3 = h2.next())\n      n3 = C2(u2, e2, z2, n3.value, k2), n3 !== null && (a && n3.alternate !== null && u2.delete(n3.key === null ? z2 : n3.key), g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);\n    a && u2.forEach(function(a2) {\n      return b(e2, a2);\n    });\n    return l3;\n  }\n  return function(a2, d2, f2, h2) {\n    var k2 = typeof f2 === \"object\" && f2 !== null && f2.type === ua && f2.key === null;\n    k2 && (f2 = f2.props.children);\n    var l3 = typeof f2 === \"object\" && f2 !== null;\n    if (l3)\n      switch (f2.$$typeof) {\n        case sa:\n          a: {\n            l3 = f2.key;\n            for (k2 = d2; k2 !== null; ) {\n              if (k2.key === l3) {\n                switch (k2.tag) {\n                  case 7:\n                    if (f2.type === ua) {\n                      c(a2, k2.sibling);\n                      d2 = e(k2, f2.props.children);\n                      d2.return = a2;\n                      a2 = d2;\n                      break a;\n                    }\n                    break;\n                  default:\n                    if (k2.elementType === f2.type) {\n                      c(a2, k2.sibling);\n                      d2 = e(k2, f2.props);\n                      d2.ref = Qg(a2, k2, f2);\n                      d2.return = a2;\n                      a2 = d2;\n                      break a;\n                    }\n                }\n                c(a2, k2);\n                break;\n              } else\n                b(a2, k2);\n              k2 = k2.sibling;\n            }\n            f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);\n          }\n          return g(a2);\n        case ta:\n          a: {\n            for (k2 = f2.key; d2 !== null; ) {\n              if (d2.key === k2)\n                if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {\n                  c(a2, d2.sibling);\n                  d2 = e(d2, f2.children || []);\n                  d2.return = a2;\n                  a2 = d2;\n                  break a;\n                } else {\n                  c(a2, d2);\n                  break;\n                }\n              else\n                b(a2, d2);\n              d2 = d2.sibling;\n            }\n            d2 = Wg(f2, a2.mode, h2);\n            d2.return = a2;\n            a2 = d2;\n          }\n          return g(a2);\n      }\n    if (typeof f2 === \"string\" || typeof f2 === \"number\")\n      return f2 = \"\" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);\n    if (Pg(f2))\n      return x2(a2, d2, f2, h2);\n    if (La(f2))\n      return w(a2, d2, f2, h2);\n    l3 && Rg(a2, f2);\n    if (typeof f2 === \"undefined\" && !k2)\n      switch (a2.tag) {\n        case 1:\n        case 22:\n        case 0:\n        case 11:\n        case 15:\n          throw Error(y(152, Ra(a2.type) || \"Component\"));\n      }\n    return c(a2, d2);\n  };\n}\nvar Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch$1 = Bf($g);\nfunction dh(a) {\n  if (a === $g)\n    throw Error(y(174));\n  return a;\n}\nfunction eh(a, b) {\n  I(ch$1, b);\n  I(bh, a);\n  I(ah, $g);\n  a = b.nodeType;\n  switch (a) {\n    case 9:\n    case 11:\n      b = (b = b.documentElement) ? b.namespaceURI : mb(null, \"\");\n      break;\n    default:\n      a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);\n  }\n  H(ah);\n  I(ah, b);\n}\nfunction fh() {\n  H(ah);\n  H(bh);\n  H(ch$1);\n}\nfunction gh(a) {\n  dh(ch$1.current);\n  var b = dh(ah.current);\n  var c = mb(b, a.type);\n  b !== c && (I(bh, a), I(ah, c));\n}\nfunction hh(a) {\n  bh.current === a && (H(ah), H(bh));\n}\nvar P = Bf(0);\nfunction ih(a) {\n  for (var b = a; b !== null; ) {\n    if (b.tag === 13) {\n      var c = b.memoizedState;\n      if (c !== null && (c = c.dehydrated, c === null || c.data === \"$?\" || c.data === \"$!\"))\n        return b;\n    } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {\n      if ((b.flags & 64) !== 0)\n        return b;\n    } else if (b.child !== null) {\n      b.child.return = b;\n      b = b.child;\n      continue;\n    }\n    if (b === a)\n      break;\n    for (; b.sibling === null; ) {\n      if (b.return === null || b.return === a)\n        return null;\n      b = b.return;\n    }\n    b.sibling.return = b.return;\n    b = b.sibling;\n  }\n  return null;\n}\nvar jh = null, kh = null, lh = false;\nfunction mh(a, b) {\n  var c = nh(5, null, null, 0);\n  c.elementType = \"DELETED\";\n  c.type = \"DELETED\";\n  c.stateNode = b;\n  c.return = a;\n  c.flags = 8;\n  a.lastEffect !== null ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;\n}\nfunction oh(a, b) {\n  switch (a.tag) {\n    case 5:\n      var c = a.type;\n      b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;\n      return b !== null ? (a.stateNode = b, true) : false;\n    case 6:\n      return b = a.pendingProps === \"\" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, true) : false;\n    case 13:\n      return false;\n    default:\n      return false;\n  }\n}\nfunction ph(a) {\n  if (lh) {\n    var b = kh;\n    if (b) {\n      var c = b;\n      if (!oh(a, b)) {\n        b = rf(c.nextSibling);\n        if (!b || !oh(a, b)) {\n          a.flags = a.flags & -1025 | 2;\n          lh = false;\n          jh = a;\n          return;\n        }\n        mh(jh, c);\n      }\n      jh = a;\n      kh = rf(b.firstChild);\n    } else\n      a.flags = a.flags & -1025 | 2, lh = false, jh = a;\n  }\n}\nfunction qh(a) {\n  for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )\n    a = a.return;\n  jh = a;\n}\nfunction rh(a) {\n  if (a !== jh)\n    return false;\n  if (!lh)\n    return qh(a), lh = true, false;\n  var b = a.type;\n  if (a.tag !== 5 || b !== \"head\" && b !== \"body\" && !nf(b, a.memoizedProps))\n    for (b = kh; b; )\n      mh(a, b), b = rf(b.nextSibling);\n  qh(a);\n  if (a.tag === 13) {\n    a = a.memoizedState;\n    a = a !== null ? a.dehydrated : null;\n    if (!a)\n      throw Error(y(317));\n    a: {\n      a = a.nextSibling;\n      for (b = 0; a; ) {\n        if (a.nodeType === 8) {\n          var c = a.data;\n          if (c === \"/$\") {\n            if (b === 0) {\n              kh = rf(a.nextSibling);\n              break a;\n            }\n            b--;\n          } else\n            c !== \"$\" && c !== \"$!\" && c !== \"$?\" || b++;\n        }\n        a = a.nextSibling;\n      }\n      kh = null;\n    }\n  } else\n    kh = jh ? rf(a.stateNode.nextSibling) : null;\n  return true;\n}\nfunction sh() {\n  kh = jh = null;\n  lh = false;\n}\nvar th = [];\nfunction uh() {\n  for (var a = 0; a < th.length; a++)\n    th[a]._workInProgressVersionPrimary = null;\n  th.length = 0;\n}\nvar vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;\nfunction Ah() {\n  throw Error(y(321));\n}\nfunction Bh(a, b) {\n  if (b === null)\n    return false;\n  for (var c = 0; c < b.length && c < a.length; c++)\n    if (!He(a[c], b[c]))\n      return false;\n  return true;\n}\nfunction Ch(a, b, c, d, e, f) {\n  xh = f;\n  R = b;\n  b.memoizedState = null;\n  b.updateQueue = null;\n  b.lanes = 0;\n  vh.current = a === null || a.memoizedState === null ? Dh : Eh;\n  a = c(d, e);\n  if (zh) {\n    f = 0;\n    do {\n      zh = false;\n      if (!(25 > f))\n        throw Error(y(301));\n      f += 1;\n      T = S = null;\n      b.updateQueue = null;\n      vh.current = Fh;\n      a = c(d, e);\n    } while (zh);\n  }\n  vh.current = Gh;\n  b = S !== null && S.next !== null;\n  xh = 0;\n  T = S = R = null;\n  yh = false;\n  if (b)\n    throw Error(y(300));\n  return a;\n}\nfunction Hh() {\n  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };\n  T === null ? R.memoizedState = T = a : T = T.next = a;\n  return T;\n}\nfunction Ih() {\n  if (S === null) {\n    var a = R.alternate;\n    a = a !== null ? a.memoizedState : null;\n  } else\n    a = S.next;\n  var b = T === null ? R.memoizedState : T.next;\n  if (b !== null)\n    T = b, S = a;\n  else {\n    if (a === null)\n      throw Error(y(310));\n    S = a;\n    a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };\n    T === null ? R.memoizedState = T = a : T = T.next = a;\n  }\n  return T;\n}\nfunction Jh(a, b) {\n  return typeof b === \"function\" ? b(a) : b;\n}\nfunction Kh(a) {\n  var b = Ih(), c = b.queue;\n  if (c === null)\n    throw Error(y(311));\n  c.lastRenderedReducer = a;\n  var d = S, e = d.baseQueue, f = c.pending;\n  if (f !== null) {\n    if (e !== null) {\n      var g = e.next;\n      e.next = f.next;\n      f.next = g;\n    }\n    d.baseQueue = e = f;\n    c.pending = null;\n  }\n  if (e !== null) {\n    e = e.next;\n    d = d.baseState;\n    var h = g = f = null, k = e;\n    do {\n      var l2 = k.lane;\n      if ((xh & l2) === l2)\n        h !== null && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);\n      else {\n        var n2 = {\n          lane: l2,\n          action: k.action,\n          eagerReducer: k.eagerReducer,\n          eagerState: k.eagerState,\n          next: null\n        };\n        h === null ? (g = h = n2, f = d) : h = h.next = n2;\n        R.lanes |= l2;\n        Dg |= l2;\n      }\n      k = k.next;\n    } while (k !== null && k !== e);\n    h === null ? f = d : h.next = g;\n    He(d, b.memoizedState) || (ug = true);\n    b.memoizedState = d;\n    b.baseState = f;\n    b.baseQueue = h;\n    c.lastRenderedState = d;\n  }\n  return [b.memoizedState, c.dispatch];\n}\nfunction Lh(a) {\n  var b = Ih(), c = b.queue;\n  if (c === null)\n    throw Error(y(311));\n  c.lastRenderedReducer = a;\n  var d = c.dispatch, e = c.pending, f = b.memoizedState;\n  if (e !== null) {\n    c.pending = null;\n    var g = e = e.next;\n    do\n      f = a(f, g.action), g = g.next;\n    while (g !== e);\n    He(f, b.memoizedState) || (ug = true);\n    b.memoizedState = f;\n    b.baseQueue === null && (b.baseState = f);\n    c.lastRenderedState = f;\n  }\n  return [f, d];\n}\nfunction Mh(a, b, c) {\n  var d = b._getVersion;\n  d = d(b._source);\n  var e = b._workInProgressVersionPrimary;\n  if (e !== null)\n    a = e === d;\n  else if (a = a.mutableReadLanes, a = (xh & a) === a)\n    b._workInProgressVersionPrimary = d, th.push(b);\n  if (a)\n    return c(b._source);\n  th.push(b);\n  throw Error(y(350));\n}\nfunction Nh(a, b, c, d) {\n  var e = U;\n  if (e === null)\n    throw Error(y(349));\n  var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {\n    return Mh(e, b, c);\n  }), l2 = k[1], n2 = k[0];\n  k = T;\n  var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;\n  A2 = A2.subscribe;\n  var w = R;\n  a.memoizedState = { refs: p2, source: b, subscribe: d };\n  h.useEffect(function() {\n    p2.getSnapshot = c;\n    p2.setSnapshot = l2;\n    var a2 = f(b._source);\n    if (!He(g, a2)) {\n      a2 = c(b._source);\n      He(n2, a2) || (l2(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);\n      a2 = e.mutableReadLanes;\n      e.entangledLanes |= a2;\n      for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {\n        var k2 = 31 - Vc(h2), v2 = 1 << k2;\n        d2[k2] |= a2;\n        h2 &= ~v2;\n      }\n    }\n  }, [c, b, d]);\n  h.useEffect(function() {\n    return d(b._source, function() {\n      var a2 = p2.getSnapshot, c2 = p2.setSnapshot;\n      try {\n        c2(a2(b._source));\n        var d2 = Ig(w);\n        e.mutableReadLanes |= d2 & e.pendingLanes;\n      } catch (q2) {\n        c2(function() {\n          throw q2;\n        });\n      }\n    });\n  }, [b, d]);\n  He(C2, c) && He(x2, b) && He(A2, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n2 = Mh(e, b, c), k.memoizedState = k.baseState = n2);\n  return n2;\n}\nfunction Ph(a, b, c) {\n  var d = Ih();\n  return Nh(d, a, b, c);\n}\nfunction Qh(a) {\n  var b = Hh();\n  typeof a === \"function\" && (a = a());\n  b.memoizedState = b.baseState = a;\n  a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };\n  a = a.dispatch = Oh.bind(null, R, a);\n  return [b.memoizedState, a];\n}\nfunction Rh(a, b, c, d) {\n  a = { tag: a, create: b, destroy: c, deps: d, next: null };\n  b = R.updateQueue;\n  b === null ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));\n  return a;\n}\nfunction Sh(a) {\n  var b = Hh();\n  a = { current: a };\n  return b.memoizedState = a;\n}\nfunction Th() {\n  return Ih().memoizedState;\n}\nfunction Uh(a, b, c, d) {\n  var e = Hh();\n  R.flags |= a;\n  e.memoizedState = Rh(1 | b, c, void 0, d === void 0 ? null : d);\n}\nfunction Vh(a, b, c, d) {\n  var e = Ih();\n  d = d === void 0 ? null : d;\n  var f = void 0;\n  if (S !== null) {\n    var g = S.memoizedState;\n    f = g.destroy;\n    if (d !== null && Bh(d, g.deps)) {\n      Rh(b, c, f, d);\n      return;\n    }\n  }\n  R.flags |= a;\n  e.memoizedState = Rh(1 | b, c, f, d);\n}\nfunction Wh(a, b) {\n  return Uh(516, 4, a, b);\n}\nfunction Xh(a, b) {\n  return Vh(516, 4, a, b);\n}\nfunction Yh(a, b) {\n  return Vh(4, 2, a, b);\n}\nfunction Zh(a, b) {\n  if (typeof b === \"function\")\n    return a = a(), b(a), function() {\n      b(null);\n    };\n  if (b !== null && b !== void 0)\n    return a = a(), b.current = a, function() {\n      b.current = null;\n    };\n}\nfunction $h(a, b, c) {\n  c = c !== null && c !== void 0 ? c.concat([a]) : null;\n  return Vh(4, 2, Zh.bind(null, b, a), c);\n}\nfunction ai() {\n}\nfunction bi(a, b) {\n  var c = Ih();\n  b = b === void 0 ? null : b;\n  var d = c.memoizedState;\n  if (d !== null && b !== null && Bh(b, d[1]))\n    return d[0];\n  c.memoizedState = [a, b];\n  return a;\n}\nfunction ci(a, b) {\n  var c = Ih();\n  b = b === void 0 ? null : b;\n  var d = c.memoizedState;\n  if (d !== null && b !== null && Bh(b, d[1]))\n    return d[0];\n  a = a();\n  c.memoizedState = [a, b];\n  return a;\n}\nfunction di(a, b) {\n  var c = eg$1();\n  gg$1(98 > c ? 98 : c, function() {\n    a(true);\n  });\n  gg$1(97 < c ? 97 : c, function() {\n    var c2 = wh.transition;\n    wh.transition = 1;\n    try {\n      a(false), b();\n    } finally {\n      wh.transition = c2;\n    }\n  });\n}\nfunction Oh(a, b, c) {\n  var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;\n  g === null ? f.next = f : (f.next = g.next, g.next = f);\n  b.pending = f;\n  g = a.alternate;\n  if (a === R || g !== null && g === R)\n    zh = yh = true;\n  else {\n    if (a.lanes === 0 && (g === null || g.lanes === 0) && (g = b.lastRenderedReducer, g !== null))\n      try {\n        var h = b.lastRenderedState, k = g(h, c);\n        f.eagerReducer = g;\n        f.eagerState = k;\n        if (He(k, h))\n          return;\n      } catch (l2) {\n      } finally {\n      }\n    Jg(a, e, d);\n  }\n}\nvar Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {\n  Hh().memoizedState = [a, b === void 0 ? null : b];\n  return a;\n}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {\n  c = c !== null && c !== void 0 ? c.concat([a]) : null;\n  return Uh(4, 2, Zh.bind(null, b, a), c);\n}, useLayoutEffect: function(a, b) {\n  return Uh(4, 2, a, b);\n}, useMemo: function(a, b) {\n  var c = Hh();\n  b = b === void 0 ? null : b;\n  a = a();\n  c.memoizedState = [a, b];\n  return a;\n}, useReducer: function(a, b, c) {\n  var d = Hh();\n  b = c !== void 0 ? c(b) : b;\n  d.memoizedState = d.baseState = b;\n  a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };\n  a = a.dispatch = Oh.bind(null, R, a);\n  return [d.memoizedState, a];\n}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {\n  var b = Qh(a), c = b[0], d = b[1];\n  Wh(function() {\n    var b2 = wh.transition;\n    wh.transition = 1;\n    try {\n      d(a);\n    } finally {\n      wh.transition = b2;\n    }\n  }, [a]);\n  return c;\n}, useTransition: function() {\n  var a = Qh(false), b = a[0];\n  a = di.bind(null, a[1]);\n  Sh(a);\n  return [a, b];\n}, useMutableSource: function(a, b, c) {\n  var d = Hh();\n  d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };\n  return Nh(d, a, b, c);\n}, useOpaqueIdentifier: function() {\n  if (lh) {\n    var a = false, b = uf(function() {\n      a || (a = true, c(\"r:\" + (tf++).toString(36)));\n      throw Error(y(355));\n    }), c = Qh(b)[1];\n    (R.mode & 2) === 0 && (R.flags |= 516, Rh(5, function() {\n      c(\"r:\" + (tf++).toString(36));\n    }, void 0, null));\n    return b;\n  }\n  b = \"r:\" + (tf++).toString(36);\n  Qh(b);\n  return b;\n}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {\n  return Kh(Jh);\n}, useDebugValue: ai, useDeferredValue: function(a) {\n  var b = Kh(Jh), c = b[0], d = b[1];\n  Xh(function() {\n    var b2 = wh.transition;\n    wh.transition = 1;\n    try {\n      d(a);\n    } finally {\n      wh.transition = b2;\n    }\n  }, [a]);\n  return c;\n}, useTransition: function() {\n  var a = Kh(Jh)[0];\n  return [\n    Th().current,\n    a\n  ];\n}, useMutableSource: Ph, useOpaqueIdentifier: function() {\n  return Kh(Jh)[0];\n}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {\n  return Lh(Jh);\n}, useDebugValue: ai, useDeferredValue: function(a) {\n  var b = Lh(Jh), c = b[0], d = b[1];\n  Xh(function() {\n    var b2 = wh.transition;\n    wh.transition = 1;\n    try {\n      d(a);\n    } finally {\n      wh.transition = b2;\n    }\n  }, [a]);\n  return c;\n}, useTransition: function() {\n  var a = Lh(Jh)[0];\n  return [\n    Th().current,\n    a\n  ];\n}, useMutableSource: Ph, useOpaqueIdentifier: function() {\n  return Lh(Jh)[0];\n}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;\nfunction fi(a, b, c, d) {\n  b.child = a === null ? Zg(b, null, c, d) : Yg(b, a.child, c, d);\n}\nfunction gi(a, b, c, d, e) {\n  c = c.render;\n  var f = b.ref;\n  tg(b, e);\n  d = Ch(a, b, c, d, f, e);\n  if (a !== null && !ug)\n    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);\n  b.flags |= 1;\n  fi(a, b, d, e);\n  return b.child;\n}\nfunction ii$1(a, b, c, d, e, f) {\n  if (a === null) {\n    var g = c.type;\n    if (typeof g === \"function\" && !ji(g) && g.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0)\n      return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);\n    a = Vg(c.type, null, d, b, b.mode, f);\n    a.ref = b.ref;\n    a.return = b;\n    return b.child = a;\n  }\n  g = a.child;\n  if ((e & f) === 0 && (e = g.memoizedProps, c = c.compare, c = c !== null ? c : Je, c(e, d) && a.ref === b.ref))\n    return hi(a, b, f);\n  b.flags |= 1;\n  a = Tg(g, d);\n  a.ref = b.ref;\n  a.return = b;\n  return b.child = a;\n}\nfunction ki(a, b, c, d, e, f) {\n  if (a !== null && Je(a.memoizedProps, d) && a.ref === b.ref)\n    if (ug = false, (f & e) !== 0)\n      (a.flags & 16384) !== 0 && (ug = true);\n    else\n      return b.lanes = a.lanes, hi(a, b, f);\n  return li(a, b, c, d, f);\n}\nfunction mi(a, b, c) {\n  var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;\n  if (d.mode === \"hidden\" || d.mode === \"unstable-defer-without-hiding\")\n    if ((b.mode & 4) === 0)\n      b.memoizedState = { baseLanes: 0 }, ni$1(b, c);\n    else if ((c & 1073741824) !== 0)\n      b.memoizedState = { baseLanes: 0 }, ni$1(b, f !== null ? f.baseLanes : c);\n    else\n      return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni$1(b, a), null;\n  else\n    f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni$1(b, d);\n  fi(a, b, e, c);\n  return b.child;\n}\nfunction oi(a, b) {\n  var c = b.ref;\n  if (a === null && c !== null || a !== null && a.ref !== c)\n    b.flags |= 128;\n}\nfunction li(a, b, c, d, e) {\n  var f = Ff(c) ? Df : M.current;\n  f = Ef(b, f);\n  tg(b, e);\n  c = Ch(a, b, c, d, f, e);\n  if (a !== null && !ug)\n    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);\n  b.flags |= 1;\n  fi(a, b, c, e);\n  return b.child;\n}\nfunction pi$1(a, b, c, d, e) {\n  if (Ff(c)) {\n    var f = true;\n    Jf(b);\n  } else\n    f = false;\n  tg(b, e);\n  if (b.stateNode === null)\n    a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;\n  else if (a === null) {\n    var g = b.stateNode, h = b.memoizedProps;\n    g.props = h;\n    var k = g.context, l2 = c.contextType;\n    typeof l2 === \"object\" && l2 !== null ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));\n    var n2 = c.getDerivedStateFromProps, A2 = typeof n2 === \"function\" || typeof g.getSnapshotBeforeUpdate === \"function\";\n    A2 || typeof g.UNSAFE_componentWillReceiveProps !== \"function\" && typeof g.componentWillReceiveProps !== \"function\" || (h !== d || k !== l2) && Ng(b, g, d, l2);\n    wg = false;\n    var p2 = b.memoizedState;\n    g.state = p2;\n    Cg(b, d, g, e);\n    k = b.memoizedState;\n    h !== d || p2 !== k || N.current || wg ? (typeof n2 === \"function\" && (Gg$1(b, c, n2, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p2, k, l2)) ? (A2 || typeof g.UNSAFE_componentWillMount !== \"function\" && typeof g.componentWillMount !== \"function\" || (typeof g.componentWillMount === \"function\" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount === \"function\" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount === \"function\" && (b.flags |= 4)) : (typeof g.componentDidMount === \"function\" && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l2, d = h) : (typeof g.componentDidMount === \"function\" && (b.flags |= 4), d = false);\n  } else {\n    g = b.stateNode;\n    yg(a, b);\n    h = b.memoizedProps;\n    l2 = b.type === b.elementType ? h : lg$1(b.type, h);\n    g.props = l2;\n    A2 = b.pendingProps;\n    p2 = g.context;\n    k = c.contextType;\n    typeof k === \"object\" && k !== null ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));\n    var C2 = c.getDerivedStateFromProps;\n    (n2 = typeof C2 === \"function\" || typeof g.getSnapshotBeforeUpdate === \"function\") || typeof g.UNSAFE_componentWillReceiveProps !== \"function\" && typeof g.componentWillReceiveProps !== \"function\" || (h !== A2 || p2 !== k) && Ng(b, g, d, k);\n    wg = false;\n    p2 = b.memoizedState;\n    g.state = p2;\n    Cg(b, d, g, e);\n    var x2 = b.memoizedState;\n    h !== A2 || p2 !== x2 || N.current || wg ? (typeof C2 === \"function\" && (Gg$1(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || typeof g.UNSAFE_componentWillUpdate !== \"function\" && typeof g.componentWillUpdate !== \"function\" || (typeof g.componentWillUpdate === \"function\" && g.componentWillUpdate(d, x2, k), typeof g.UNSAFE_componentWillUpdate === \"function\" && g.UNSAFE_componentWillUpdate(d, x2, k)), typeof g.componentDidUpdate === \"function\" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate === \"function\" && (b.flags |= 256)) : (typeof g.componentDidUpdate !== \"function\" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== \"function\" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g.props = d, g.state = x2, g.context = k, d = l2) : (typeof g.componentDidUpdate !== \"function\" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== \"function\" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), d = false);\n  }\n  return qi(a, b, c, d, f, e);\n}\nfunction qi(a, b, c, d, e, f) {\n  oi(a, b);\n  var g = (b.flags & 64) !== 0;\n  if (!d && !g)\n    return e && Kf(b, c, false), hi(a, b, f);\n  d = b.stateNode;\n  ei.current = b;\n  var h = g && typeof c.getDerivedStateFromError !== \"function\" ? null : d.render();\n  b.flags |= 1;\n  a !== null && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);\n  b.memoizedState = d.state;\n  e && Kf(b, c, true);\n  return b.child;\n}\nfunction ri(a) {\n  var b = a.stateNode;\n  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);\n  eh(a, b.containerInfo);\n}\nvar si = { dehydrated: null, retryLane: 0 };\nfunction ti(a, b, c) {\n  var d = b.pendingProps, e = P.current, f = false, g;\n  (g = (b.flags & 64) !== 0) || (g = a !== null && a.memoizedState === null ? false : (e & 2) !== 0);\n  g ? (f = true, b.flags &= -65) : a !== null && a.memoizedState === null || d.fallback === void 0 || d.unstable_avoidThisFallback === true || (e |= 1);\n  I(P, e & 1);\n  if (a === null) {\n    d.fallback !== void 0 && ph(b);\n    a = d.children;\n    e = d.fallback;\n    if (f)\n      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;\n    if (typeof d.unstable_expectedLoadTime === \"number\")\n      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;\n    c = vi({ mode: \"visible\", children: a }, b.mode, c, null);\n    c.return = b;\n    return b.child = c;\n  }\n  if (a.memoizedState !== null) {\n    if (f)\n      return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;\n    c = xi$1(a, b, d.children, c);\n    b.memoizedState = null;\n    return c;\n  }\n  if (f)\n    return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;\n  c = xi$1(a, b, d.children, c);\n  b.memoizedState = null;\n  return c;\n}\nfunction ui(a, b, c, d) {\n  var e = a.mode, f = a.child;\n  b = { mode: \"hidden\", children: b };\n  (e & 2) === 0 && f !== null ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);\n  c = Xg(c, e, d, null);\n  f.return = a;\n  c.return = a;\n  f.sibling = c;\n  a.child = f;\n  return c;\n}\nfunction xi$1(a, b, c, d) {\n  var e = a.child;\n  a = e.sibling;\n  c = Tg(e, { mode: \"visible\", children: c });\n  (b.mode & 2) === 0 && (c.lanes = d);\n  c.return = b;\n  c.sibling = null;\n  a !== null && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);\n  return b.child = c;\n}\nfunction wi(a, b, c, d, e) {\n  var f = b.mode, g = a.child;\n  a = g.sibling;\n  var h = { mode: \"hidden\", children: c };\n  (f & 2) === 0 && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, g !== null ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);\n  a !== null ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);\n  d.return = b;\n  c.return = b;\n  c.sibling = d;\n  b.child = c;\n  return d;\n}\nfunction yi(a, b) {\n  a.lanes |= b;\n  var c = a.alternate;\n  c !== null && (c.lanes |= b);\n  sg(a.return, b);\n}\nfunction zi(a, b, c, d, e, f) {\n  var g = a.memoizedState;\n  g === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);\n}\nfunction Ai(a, b, c) {\n  var d = b.pendingProps, e = d.revealOrder, f = d.tail;\n  fi(a, b, d.children, c);\n  d = P.current;\n  if ((d & 2) !== 0)\n    d = d & 1 | 2, b.flags |= 64;\n  else {\n    if (a !== null && (a.flags & 64) !== 0)\n      a:\n        for (a = b.child; a !== null; ) {\n          if (a.tag === 13)\n            a.memoizedState !== null && yi(a, c);\n          else if (a.tag === 19)\n            yi(a, c);\n          else if (a.child !== null) {\n            a.child.return = a;\n            a = a.child;\n            continue;\n          }\n          if (a === b)\n            break a;\n          for (; a.sibling === null; ) {\n            if (a.return === null || a.return === b)\n              break a;\n            a = a.return;\n          }\n          a.sibling.return = a.return;\n          a = a.sibling;\n        }\n    d &= 1;\n  }\n  I(P, d);\n  if ((b.mode & 2) === 0)\n    b.memoizedState = null;\n  else\n    switch (e) {\n      case \"forwards\":\n        c = b.child;\n        for (e = null; c !== null; )\n          a = c.alternate, a !== null && ih(a) === null && (e = c), c = c.sibling;\n        c = e;\n        c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);\n        zi(b, false, e, c, f, b.lastEffect);\n        break;\n      case \"backwards\":\n        c = null;\n        e = b.child;\n        for (b.child = null; e !== null; ) {\n          a = e.alternate;\n          if (a !== null && ih(a) === null) {\n            b.child = e;\n            break;\n          }\n          a = e.sibling;\n          e.sibling = c;\n          c = e;\n          e = a;\n        }\n        zi(b, true, c, null, f, b.lastEffect);\n        break;\n      case \"together\":\n        zi(b, false, null, null, void 0, b.lastEffect);\n        break;\n      default:\n        b.memoizedState = null;\n    }\n  return b.child;\n}\nfunction hi(a, b, c) {\n  a !== null && (b.dependencies = a.dependencies);\n  Dg |= b.lanes;\n  if ((c & b.childLanes) !== 0) {\n    if (a !== null && b.child !== a.child)\n      throw Error(y(153));\n    if (b.child !== null) {\n      a = b.child;\n      c = Tg(a, a.pendingProps);\n      b.child = c;\n      for (c.return = b; a.sibling !== null; )\n        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;\n      c.sibling = null;\n    }\n    return b.child;\n  }\n  return null;\n}\nvar Bi, Ci, Di, Ei;\nBi = function(a, b) {\n  for (var c = b.child; c !== null; ) {\n    if (c.tag === 5 || c.tag === 6)\n      a.appendChild(c.stateNode);\n    else if (c.tag !== 4 && c.child !== null) {\n      c.child.return = c;\n      c = c.child;\n      continue;\n    }\n    if (c === b)\n      break;\n    for (; c.sibling === null; ) {\n      if (c.return === null || c.return === b)\n        return;\n      c = c.return;\n    }\n    c.sibling.return = c.return;\n    c = c.sibling;\n  }\n};\nCi = function() {\n};\nDi = function(a, b, c, d) {\n  var e = a.memoizedProps;\n  if (e !== d) {\n    a = b.stateNode;\n    dh(ah.current);\n    var f = null;\n    switch (c) {\n      case \"input\":\n        e = Ya(a, e);\n        d = Ya(a, d);\n        f = [];\n        break;\n      case \"option\":\n        e = eb(a, e);\n        d = eb(a, d);\n        f = [];\n        break;\n      case \"select\":\n        e = m({}, e, { value: void 0 });\n        d = m({}, d, { value: void 0 });\n        f = [];\n        break;\n      case \"textarea\":\n        e = gb(a, e);\n        d = gb(a, d);\n        f = [];\n        break;\n      default:\n        typeof e.onClick !== \"function\" && typeof d.onClick === \"function\" && (a.onclick = jf);\n    }\n    vb(c, d);\n    var g;\n    c = null;\n    for (l2 in e)\n      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && e[l2] != null)\n        if (l2 === \"style\") {\n          var h = e[l2];\n          for (g in h)\n            h.hasOwnProperty(g) && (c || (c = {}), c[g] = \"\");\n        } else\n          l2 !== \"dangerouslySetInnerHTML\" && l2 !== \"children\" && l2 !== \"suppressContentEditableWarning\" && l2 !== \"suppressHydrationWarning\" && l2 !== \"autoFocus\" && (ca.hasOwnProperty(l2) ? f || (f = []) : (f = f || []).push(l2, null));\n    for (l2 in d) {\n      var k = d[l2];\n      h = e != null ? e[l2] : void 0;\n      if (d.hasOwnProperty(l2) && k !== h && (k != null || h != null))\n        if (l2 === \"style\")\n          if (h) {\n            for (g in h)\n              !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = \"\");\n            for (g in k)\n              k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);\n          } else\n            c || (f || (f = []), f.push(l2, c)), c = k;\n        else\n          l2 === \"dangerouslySetInnerHTML\" ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, k != null && h !== k && (f = f || []).push(l2, k)) : l2 === \"children\" ? typeof k !== \"string\" && typeof k !== \"number\" || (f = f || []).push(l2, \"\" + k) : l2 !== \"suppressContentEditableWarning\" && l2 !== \"suppressHydrationWarning\" && (ca.hasOwnProperty(l2) ? (k != null && l2 === \"onScroll\" && G(\"scroll\", a), f || h === k || (f = [])) : typeof k === \"object\" && k !== null && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l2, k));\n    }\n    c && (f = f || []).push(\"style\", c);\n    var l2 = f;\n    if (b.updateQueue = l2)\n      b.flags |= 4;\n  }\n};\nEi = function(a, b, c, d) {\n  c !== d && (b.flags |= 4);\n};\nfunction Fi(a, b) {\n  if (!lh)\n    switch (a.tailMode) {\n      case \"hidden\":\n        b = a.tail;\n        for (var c = null; b !== null; )\n          b.alternate !== null && (c = b), b = b.sibling;\n        c === null ? a.tail = null : c.sibling = null;\n        break;\n      case \"collapsed\":\n        c = a.tail;\n        for (var d = null; c !== null; )\n          c.alternate !== null && (d = c), c = c.sibling;\n        d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;\n    }\n}\nfunction Gi(a, b, c) {\n  var d = b.pendingProps;\n  switch (b.tag) {\n    case 2:\n    case 16:\n    case 15:\n    case 0:\n    case 11:\n    case 7:\n    case 8:\n    case 12:\n    case 9:\n    case 14:\n      return null;\n    case 1:\n      return Ff(b.type) && Gf(), null;\n    case 3:\n      fh();\n      H(N);\n      H(M);\n      uh();\n      d = b.stateNode;\n      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);\n      if (a === null || a.child === null)\n        rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);\n      Ci(b);\n      return null;\n    case 5:\n      hh(b);\n      var e = dh(ch$1.current);\n      c = b.type;\n      if (a !== null && b.stateNode != null)\n        Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);\n      else {\n        if (!d) {\n          if (b.stateNode === null)\n            throw Error(y(166));\n          return null;\n        }\n        a = dh(ah.current);\n        if (rh(b)) {\n          d = b.stateNode;\n          c = b.type;\n          var f = b.memoizedProps;\n          d[wf] = b;\n          d[xf] = f;\n          switch (c) {\n            case \"dialog\":\n              G(\"cancel\", d);\n              G(\"close\", d);\n              break;\n            case \"iframe\":\n            case \"object\":\n            case \"embed\":\n              G(\"load\", d);\n              break;\n            case \"video\":\n            case \"audio\":\n              for (a = 0; a < Xe.length; a++)\n                G(Xe[a], d);\n              break;\n            case \"source\":\n              G(\"error\", d);\n              break;\n            case \"img\":\n            case \"image\":\n            case \"link\":\n              G(\"error\", d);\n              G(\"load\", d);\n              break;\n            case \"details\":\n              G(\"toggle\", d);\n              break;\n            case \"input\":\n              Za(d, f);\n              G(\"invalid\", d);\n              break;\n            case \"select\":\n              d._wrapperState = { wasMultiple: !!f.multiple };\n              G(\"invalid\", d);\n              break;\n            case \"textarea\":\n              hb(d, f), G(\"invalid\", d);\n          }\n          vb(c, f);\n          a = null;\n          for (var g in f)\n            f.hasOwnProperty(g) && (e = f[g], g === \"children\" ? typeof e === \"string\" ? d.textContent !== e && (a = [\"children\", e]) : typeof e === \"number\" && d.textContent !== \"\" + e && (a = [\"children\", \"\" + e]) : ca.hasOwnProperty(g) && e != null && g === \"onScroll\" && G(\"scroll\", d));\n          switch (c) {\n            case \"input\":\n              Va(d);\n              cb(d, f, true);\n              break;\n            case \"textarea\":\n              Va(d);\n              jb(d);\n              break;\n            case \"select\":\n            case \"option\":\n              break;\n            default:\n              typeof f.onClick === \"function\" && (d.onclick = jf);\n          }\n          d = a;\n          b.updateQueue = d;\n          d !== null && (b.flags |= 4);\n        } else {\n          g = e.nodeType === 9 ? e : e.ownerDocument;\n          a === kb.html && (a = lb(c));\n          a === kb.html ? c === \"script\" ? (a = g.createElement(\"div\"), a.innerHTML = \"<script><\\/script>\", a = a.removeChild(a.firstChild)) : typeof d.is === \"string\" ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), c === \"select\" && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);\n          a[wf] = b;\n          a[xf] = d;\n          Bi(a, b, false, false);\n          b.stateNode = a;\n          g = wb(c, d);\n          switch (c) {\n            case \"dialog\":\n              G(\"cancel\", a);\n              G(\"close\", a);\n              e = d;\n              break;\n            case \"iframe\":\n            case \"object\":\n            case \"embed\":\n              G(\"load\", a);\n              e = d;\n              break;\n            case \"video\":\n            case \"audio\":\n              for (e = 0; e < Xe.length; e++)\n                G(Xe[e], a);\n              e = d;\n              break;\n            case \"source\":\n              G(\"error\", a);\n              e = d;\n              break;\n            case \"img\":\n            case \"image\":\n            case \"link\":\n              G(\"error\", a);\n              G(\"load\", a);\n              e = d;\n              break;\n            case \"details\":\n              G(\"toggle\", a);\n              e = d;\n              break;\n            case \"input\":\n              Za(a, d);\n              e = Ya(a, d);\n              G(\"invalid\", a);\n              break;\n            case \"option\":\n              e = eb(a, d);\n              break;\n            case \"select\":\n              a._wrapperState = { wasMultiple: !!d.multiple };\n              e = m({}, d, { value: void 0 });\n              G(\"invalid\", a);\n              break;\n            case \"textarea\":\n              hb(a, d);\n              e = gb(a, d);\n              G(\"invalid\", a);\n              break;\n            default:\n              e = d;\n          }\n          vb(c, e);\n          var h = e;\n          for (f in h)\n            if (h.hasOwnProperty(f)) {\n              var k = h[f];\n              f === \"style\" ? tb(a, k) : f === \"dangerouslySetInnerHTML\" ? (k = k ? k.__html : void 0, k != null && ob(a, k)) : f === \"children\" ? typeof k === \"string\" ? (c !== \"textarea\" || k !== \"\") && pb(a, k) : typeof k === \"number\" && pb(a, \"\" + k) : f !== \"suppressContentEditableWarning\" && f !== \"suppressHydrationWarning\" && f !== \"autoFocus\" && (ca.hasOwnProperty(f) ? k != null && f === \"onScroll\" && G(\"scroll\", a) : k != null && qa(a, f, k, g));\n            }\n          switch (c) {\n            case \"input\":\n              Va(a);\n              cb(a, d, false);\n              break;\n            case \"textarea\":\n              Va(a);\n              jb(a);\n              break;\n            case \"option\":\n              d.value != null && a.setAttribute(\"value\", \"\" + Sa(d.value));\n              break;\n            case \"select\":\n              a.multiple = !!d.multiple;\n              f = d.value;\n              f != null ? fb(a, !!d.multiple, f, false) : d.defaultValue != null && fb(a, !!d.multiple, d.defaultValue, true);\n              break;\n            default:\n              typeof e.onClick === \"function\" && (a.onclick = jf);\n          }\n          mf(c, d) && (b.flags |= 4);\n        }\n        b.ref !== null && (b.flags |= 128);\n      }\n      return null;\n    case 6:\n      if (a && b.stateNode != null)\n        Ei(a, b, a.memoizedProps, d);\n      else {\n        if (typeof d !== \"string\" && b.stateNode === null)\n          throw Error(y(166));\n        c = dh(ch$1.current);\n        dh(ah.current);\n        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);\n      }\n      return null;\n    case 13:\n      H(P);\n      d = b.memoizedState;\n      if ((b.flags & 64) !== 0)\n        return b.lanes = c, b;\n      d = d !== null;\n      c = false;\n      a === null ? b.memoizedProps.fallback !== void 0 && rh(b) : c = a.memoizedState !== null;\n      if (d && !c && (b.mode & 2) !== 0)\n        if (a === null && b.memoizedProps.unstable_avoidThisFallback !== true || (P.current & 1) !== 0)\n          V === 0 && (V = 3);\n        else {\n          if (V === 0 || V === 3)\n            V = 4;\n          U === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U, W);\n        }\n      if (d || c)\n        b.flags |= 4;\n      return null;\n    case 4:\n      return fh(), Ci(b), a === null && cf(b.stateNode.containerInfo), null;\n    case 10:\n      return rg(b), null;\n    case 17:\n      return Ff(b.type) && Gf(), null;\n    case 19:\n      H(P);\n      d = b.memoizedState;\n      if (d === null)\n        return null;\n      f = (b.flags & 64) !== 0;\n      g = d.rendering;\n      if (g === null)\n        if (f)\n          Fi(d, false);\n        else {\n          if (V !== 0 || a !== null && (a.flags & 64) !== 0)\n            for (a = b.child; a !== null; ) {\n              g = ih(a);\n              if (g !== null) {\n                b.flags |= 64;\n                Fi(d, false);\n                f = g.updateQueue;\n                f !== null && (b.updateQueue = f, b.flags |= 4);\n                d.lastEffect === null && (b.firstEffect = null);\n                b.lastEffect = d.lastEffect;\n                d = c;\n                for (c = b.child; c !== null; )\n                  f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, g === null ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;\n                I(P, P.current & 1 | 2);\n                return b.child;\n              }\n              a = a.sibling;\n            }\n          d.tail !== null && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);\n        }\n      else {\n        if (!f)\n          if (a = ih(g), a !== null) {\n            if (b.flags |= 64, f = true, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Fi(d, true), d.tail === null && d.tailMode === \"hidden\" && !g.alternate && !lh)\n              return b = b.lastEffect = d.lastEffect, b !== null && (b.nextEffect = null), null;\n          } else\n            2 * O() - d.renderingStartTime > Ji && c !== 1073741824 && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);\n        d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, c !== null ? c.sibling = g : b.child = g, d.last = g);\n      }\n      return d.tail !== null ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;\n    case 23:\n    case 24:\n      return Ki(), a !== null && a.memoizedState !== null !== (b.memoizedState !== null) && d.mode !== \"unstable-defer-without-hiding\" && (b.flags |= 4), null;\n  }\n  throw Error(y(156, b.tag));\n}\nfunction Li(a) {\n  switch (a.tag) {\n    case 1:\n      Ff(a.type) && Gf();\n      var b = a.flags;\n      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;\n    case 3:\n      fh();\n      H(N);\n      H(M);\n      uh();\n      b = a.flags;\n      if ((b & 64) !== 0)\n        throw Error(y(285));\n      a.flags = b & -4097 | 64;\n      return a;\n    case 5:\n      return hh(a), null;\n    case 13:\n      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;\n    case 19:\n      return H(P), null;\n    case 4:\n      return fh(), null;\n    case 10:\n      return rg(a), null;\n    case 23:\n    case 24:\n      return Ki(), null;\n    default:\n      return null;\n  }\n}\nfunction Mi(a, b) {\n  try {\n    var c = \"\", d = b;\n    do\n      c += Qa(d), d = d.return;\n    while (d);\n    var e = c;\n  } catch (f) {\n    e = \"\\nError generating stack: \" + f.message + \"\\n\" + f.stack;\n  }\n  return { value: a, source: b, stack: e };\n}\nfunction Ni(a, b) {\n  try {\n    console.error(b.value);\n  } catch (c) {\n    setTimeout(function() {\n      throw c;\n    });\n  }\n}\nvar Oi = typeof WeakMap === \"function\" ? WeakMap : Map;\nfunction Pi$1(a, b, c) {\n  c = zg(-1, c);\n  c.tag = 3;\n  c.payload = { element: null };\n  var d = b.value;\n  c.callback = function() {\n    Qi || (Qi = true, Ri = d);\n    Ni(a, b);\n  };\n  return c;\n}\nfunction Si(a, b, c) {\n  c = zg(-1, c);\n  c.tag = 3;\n  var d = a.type.getDerivedStateFromError;\n  if (typeof d === \"function\") {\n    var e = b.value;\n    c.payload = function() {\n      Ni(a, b);\n      return d(e);\n    };\n  }\n  var f = a.stateNode;\n  f !== null && typeof f.componentDidCatch === \"function\" && (c.callback = function() {\n    typeof d !== \"function\" && (Ti === null ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));\n    var c2 = b.stack;\n    this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : \"\" });\n  });\n  return c;\n}\nvar Ui = typeof WeakSet === \"function\" ? WeakSet : Set;\nfunction Vi(a) {\n  var b = a.ref;\n  if (b !== null)\n    if (typeof b === \"function\")\n      try {\n        b(null);\n      } catch (c) {\n        Wi(a, c);\n      }\n    else\n      b.current = null;\n}\nfunction Xi$1(a, b) {\n  switch (b.tag) {\n    case 0:\n    case 11:\n    case 15:\n    case 22:\n      return;\n    case 1:\n      if (b.flags & 256 && a !== null) {\n        var c = a.memoizedProps, d = a.memoizedState;\n        a = b.stateNode;\n        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg$1(b.type, c), d);\n        a.__reactInternalSnapshotBeforeUpdate = b;\n      }\n      return;\n    case 3:\n      b.flags & 256 && qf(b.stateNode.containerInfo);\n      return;\n    case 5:\n    case 6:\n    case 4:\n    case 17:\n      return;\n  }\n  throw Error(y(163));\n}\nfunction Yi(a, b, c) {\n  switch (c.tag) {\n    case 0:\n    case 11:\n    case 15:\n    case 22:\n      b = c.updateQueue;\n      b = b !== null ? b.lastEffect : null;\n      if (b !== null) {\n        a = b = b.next;\n        do {\n          if ((a.tag & 3) === 3) {\n            var d = a.create;\n            a.destroy = d();\n          }\n          a = a.next;\n        } while (a !== b);\n      }\n      b = c.updateQueue;\n      b = b !== null ? b.lastEffect : null;\n      if (b !== null) {\n        a = b = b.next;\n        do {\n          var e = a;\n          d = e.next;\n          e = e.tag;\n          (e & 4) !== 0 && (e & 1) !== 0 && (Zi(c, a), $i(c, a));\n          a = d;\n        } while (a !== b);\n      }\n      return;\n    case 1:\n      a = c.stateNode;\n      c.flags & 4 && (b === null ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg$1(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));\n      b = c.updateQueue;\n      b !== null && Eg(c, b, a);\n      return;\n    case 3:\n      b = c.updateQueue;\n      if (b !== null) {\n        a = null;\n        if (c.child !== null)\n          switch (c.child.tag) {\n            case 5:\n              a = c.child.stateNode;\n              break;\n            case 1:\n              a = c.child.stateNode;\n          }\n        Eg(c, b, a);\n      }\n      return;\n    case 5:\n      a = c.stateNode;\n      b === null && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();\n      return;\n    case 6:\n      return;\n    case 4:\n      return;\n    case 12:\n      return;\n    case 13:\n      c.memoizedState === null && (c = c.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null && Cc(c))));\n      return;\n    case 19:\n    case 17:\n    case 20:\n    case 21:\n    case 23:\n    case 24:\n      return;\n  }\n  throw Error(y(163));\n}\nfunction aj(a, b) {\n  for (var c = a; ; ) {\n    if (c.tag === 5) {\n      var d = c.stateNode;\n      if (b)\n        d = d.style, typeof d.setProperty === \"function\" ? d.setProperty(\"display\", \"none\", \"important\") : d.display = \"none\";\n      else {\n        d = c.stateNode;\n        var e = c.memoizedProps.style;\n        e = e !== void 0 && e !== null && e.hasOwnProperty(\"display\") ? e.display : null;\n        d.style.display = sb(\"display\", e);\n      }\n    } else if (c.tag === 6)\n      c.stateNode.nodeValue = b ? \"\" : c.memoizedProps;\n    else if ((c.tag !== 23 && c.tag !== 24 || c.memoizedState === null || c === a) && c.child !== null) {\n      c.child.return = c;\n      c = c.child;\n      continue;\n    }\n    if (c === a)\n      break;\n    for (; c.sibling === null; ) {\n      if (c.return === null || c.return === a)\n        return;\n      c = c.return;\n    }\n    c.sibling.return = c.return;\n    c = c.sibling;\n  }\n}\nfunction bj(a, b) {\n  if (Mf && typeof Mf.onCommitFiberUnmount === \"function\")\n    try {\n      Mf.onCommitFiberUnmount(Lf, b);\n    } catch (f) {\n    }\n  switch (b.tag) {\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n    case 22:\n      a = b.updateQueue;\n      if (a !== null && (a = a.lastEffect, a !== null)) {\n        var c = a = a.next;\n        do {\n          var d = c, e = d.destroy;\n          d = d.tag;\n          if (e !== void 0)\n            if ((d & 4) !== 0)\n              Zi(b, c);\n            else {\n              d = b;\n              try {\n                e();\n              } catch (f) {\n                Wi(d, f);\n              }\n            }\n          c = c.next;\n        } while (c !== a);\n      }\n      break;\n    case 1:\n      Vi(b);\n      a = b.stateNode;\n      if (typeof a.componentWillUnmount === \"function\")\n        try {\n          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();\n        } catch (f) {\n          Wi(b, f);\n        }\n      break;\n    case 5:\n      Vi(b);\n      break;\n    case 4:\n      cj(a, b);\n  }\n}\nfunction dj(a) {\n  a.alternate = null;\n  a.child = null;\n  a.dependencies = null;\n  a.firstEffect = null;\n  a.lastEffect = null;\n  a.memoizedProps = null;\n  a.memoizedState = null;\n  a.pendingProps = null;\n  a.return = null;\n  a.updateQueue = null;\n}\nfunction ej(a) {\n  return a.tag === 5 || a.tag === 3 || a.tag === 4;\n}\nfunction fj(a) {\n  a: {\n    for (var b = a.return; b !== null; ) {\n      if (ej(b))\n        break a;\n      b = b.return;\n    }\n    throw Error(y(160));\n  }\n  var c = b;\n  b = c.stateNode;\n  switch (c.tag) {\n    case 5:\n      var d = false;\n      break;\n    case 3:\n      b = b.containerInfo;\n      d = true;\n      break;\n    case 4:\n      b = b.containerInfo;\n      d = true;\n      break;\n    default:\n      throw Error(y(161));\n  }\n  c.flags & 16 && (pb(b, \"\"), c.flags &= -17);\n  a:\n    b:\n      for (c = a; ; ) {\n        for (; c.sibling === null; ) {\n          if (c.return === null || ej(c.return)) {\n            c = null;\n            break a;\n          }\n          c = c.return;\n        }\n        c.sibling.return = c.return;\n        for (c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {\n          if (c.flags & 2)\n            continue b;\n          if (c.child === null || c.tag === 4)\n            continue b;\n          else\n            c.child.return = c, c = c.child;\n        }\n        if (!(c.flags & 2)) {\n          c = c.stateNode;\n          break a;\n        }\n      }\n  d ? gj(a, c, b) : hj(a, c, b);\n}\nfunction gj(a, b, c) {\n  var d = a.tag, e = d === 5 || d === 6;\n  if (e)\n    a = e ? a.stateNode : a.stateNode.instance, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c !== null && c !== void 0 || b.onclick !== null || (b.onclick = jf));\n  else if (d !== 4 && (a = a.child, a !== null))\n    for (gj(a, b, c), a = a.sibling; a !== null; )\n      gj(a, b, c), a = a.sibling;\n}\nfunction hj(a, b, c) {\n  var d = a.tag, e = d === 5 || d === 6;\n  if (e)\n    a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);\n  else if (d !== 4 && (a = a.child, a !== null))\n    for (hj(a, b, c), a = a.sibling; a !== null; )\n      hj(a, b, c), a = a.sibling;\n}\nfunction cj(a, b) {\n  for (var c = b, d = false, e, f; ; ) {\n    if (!d) {\n      d = c.return;\n      a:\n        for (; ; ) {\n          if (d === null)\n            throw Error(y(160));\n          e = d.stateNode;\n          switch (d.tag) {\n            case 5:\n              f = false;\n              break a;\n            case 3:\n              e = e.containerInfo;\n              f = true;\n              break a;\n            case 4:\n              e = e.containerInfo;\n              f = true;\n              break a;\n          }\n          d = d.return;\n        }\n      d = true;\n    }\n    if (c.tag === 5 || c.tag === 6) {\n      a:\n        for (var g = a, h = c, k = h; ; )\n          if (bj(g, k), k.child !== null && k.tag !== 4)\n            k.child.return = k, k = k.child;\n          else {\n            if (k === h)\n              break a;\n            for (; k.sibling === null; ) {\n              if (k.return === null || k.return === h)\n                break a;\n              k = k.return;\n            }\n            k.sibling.return = k.return;\n            k = k.sibling;\n          }\n      f ? (g = e, h = c.stateNode, g.nodeType === 8 ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);\n    } else if (c.tag === 4) {\n      if (c.child !== null) {\n        e = c.stateNode.containerInfo;\n        f = true;\n        c.child.return = c;\n        c = c.child;\n        continue;\n      }\n    } else if (bj(a, c), c.child !== null) {\n      c.child.return = c;\n      c = c.child;\n      continue;\n    }\n    if (c === b)\n      break;\n    for (; c.sibling === null; ) {\n      if (c.return === null || c.return === b)\n        return;\n      c = c.return;\n      c.tag === 4 && (d = false);\n    }\n    c.sibling.return = c.return;\n    c = c.sibling;\n  }\n}\nfunction ij(a, b) {\n  switch (b.tag) {\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n    case 22:\n      var c = b.updateQueue;\n      c = c !== null ? c.lastEffect : null;\n      if (c !== null) {\n        var d = c = c.next;\n        do\n          (d.tag & 3) === 3 && (a = d.destroy, d.destroy = void 0, a !== void 0 && a()), d = d.next;\n        while (d !== c);\n      }\n      return;\n    case 1:\n      return;\n    case 5:\n      c = b.stateNode;\n      if (c != null) {\n        d = b.memoizedProps;\n        var e = a !== null ? a.memoizedProps : d;\n        a = b.type;\n        var f = b.updateQueue;\n        b.updateQueue = null;\n        if (f !== null) {\n          c[xf] = d;\n          a === \"input\" && d.type === \"radio\" && d.name != null && $a(c, d);\n          wb(a, e);\n          b = wb(a, d);\n          for (e = 0; e < f.length; e += 2) {\n            var g = f[e], h = f[e + 1];\n            g === \"style\" ? tb(c, h) : g === \"dangerouslySetInnerHTML\" ? ob(c, h) : g === \"children\" ? pb(c, h) : qa(c, g, h, b);\n          }\n          switch (a) {\n            case \"input\":\n              ab(c, d);\n              break;\n            case \"textarea\":\n              ib(c, d);\n              break;\n            case \"select\":\n              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, f != null ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (d.defaultValue != null ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : \"\", false));\n          }\n        }\n      }\n      return;\n    case 6:\n      if (b.stateNode === null)\n        throw Error(y(162));\n      b.stateNode.nodeValue = b.memoizedProps;\n      return;\n    case 3:\n      c = b.stateNode;\n      c.hydrate && (c.hydrate = false, Cc(c.containerInfo));\n      return;\n    case 12:\n      return;\n    case 13:\n      b.memoizedState !== null && (jj = O(), aj(b.child, true));\n      kj(b);\n      return;\n    case 19:\n      kj(b);\n      return;\n    case 17:\n      return;\n    case 23:\n    case 24:\n      aj(b, b.memoizedState !== null);\n      return;\n  }\n  throw Error(y(163));\n}\nfunction kj(a) {\n  var b = a.updateQueue;\n  if (b !== null) {\n    a.updateQueue = null;\n    var c = a.stateNode;\n    c === null && (c = a.stateNode = new Ui());\n    b.forEach(function(b2) {\n      var d = lj.bind(null, a, b2);\n      c.has(b2) || (c.add(b2), b2.then(d, d));\n    });\n  }\n}\nfunction mj(a, b) {\n  return a !== null && (a = a.memoizedState, a === null || a.dehydrated !== null) ? (b = b.memoizedState, b !== null && b.dehydrated === null) : false;\n}\nvar nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;\nfunction wj() {\n  Ji = O() + 500;\n}\nvar Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;\nfunction Hg() {\n  return (X & 48) !== 0 ? O() : Fj !== -1 ? Fj : Fj = O();\n}\nfunction Ig(a) {\n  a = a.mode;\n  if ((a & 2) === 0)\n    return 1;\n  if ((a & 4) === 0)\n    return eg$1() === 99 ? 1 : 2;\n  Gj === 0 && (Gj = tj);\n  if (kg.transition !== 0) {\n    Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);\n    a = Gj;\n    var b = 4186112 & ~Hj;\n    b &= -b;\n    b === 0 && (a = 4186112 & ~a, b = a & -a, b === 0 && (b = 8192));\n    return b;\n  }\n  a = eg$1();\n  (X & 4) !== 0 && a === 98 ? a = Xc(12, Gj) : (a = Sc$1(a), a = Xc(a, Gj));\n  return a;\n}\nfunction Jg(a, b, c) {\n  if (50 < Dj)\n    throw Dj = 0, Ej = null, Error(y(185));\n  a = Kj(a, b);\n  if (a === null)\n    return null;\n  $c(a, b, c);\n  a === U && (Hi |= b, V === 4 && Ii(a, W));\n  var d = eg$1();\n  b === 1 ? (X & 8) !== 0 && (X & 48) === 0 ? Lj(a) : (Mj(a, c), X === 0 && (wj(), ig())) : ((X & 4) === 0 || d !== 98 && d !== 99 || (Cj === null ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));\n  vj = a;\n}\nfunction Kj(a, b) {\n  a.lanes |= b;\n  var c = a.alternate;\n  c !== null && (c.lanes |= b);\n  c = a;\n  for (a = a.return; a !== null; )\n    a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;\n  return c.tag === 3 ? c.stateNode : null;\n}\nfunction Mj(a, b) {\n  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {\n    var h = 31 - Vc(g), k = 1 << h, l2 = f[h];\n    if (l2 === -1) {\n      if ((k & d) === 0 || (k & e) !== 0) {\n        l2 = b;\n        Rc(k);\n        var n2 = F;\n        f[h] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;\n      }\n    } else\n      l2 <= b && (a.expiredLanes |= k);\n    g &= ~k;\n  }\n  d = Uc(a, a === U ? W : 0);\n  b = F;\n  if (d === 0)\n    c !== null && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);\n  else {\n    if (c !== null) {\n      if (a.callbackPriority === b)\n        return;\n      c !== Zf && Pf(c);\n    }\n    b === 15 ? (c = Lj.bind(null, a), ag === null ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : b === 14 ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));\n    a.callbackPriority = b;\n    a.callbackNode = c;\n  }\n}\nfunction Nj(a) {\n  Fj = -1;\n  Hj = Gj = 0;\n  if ((X & 48) !== 0)\n    throw Error(y(327));\n  var b = a.callbackNode;\n  if (Oj() && a.callbackNode !== b)\n    return null;\n  var c = Uc(a, a === U ? W : 0);\n  if (c === 0)\n    return null;\n  var d = c;\n  var e = X;\n  X |= 16;\n  var f = Pj();\n  if (U !== a || W !== d)\n    wj(), Qj(a, d);\n  do\n    try {\n      Rj();\n      break;\n    } catch (h) {\n      Sj(a, h);\n    }\n  while (1);\n  qg();\n  oj.current = f;\n  X = e;\n  Y !== null ? d = 0 : (U = null, W = 0, d = V);\n  if ((tj & Hi) !== 0)\n    Qj(a, 0);\n  else if (d !== 0) {\n    d === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), c !== 0 && (d = Tj(a, c)));\n    if (d === 1)\n      throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;\n    a.finishedWork = a.current.alternate;\n    a.finishedLanes = c;\n    switch (d) {\n      case 0:\n      case 1:\n        throw Error(y(345));\n      case 2:\n        Uj(a);\n        break;\n      case 3:\n        Ii(a, c);\n        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {\n          if (Uc(a, 0) !== 0)\n            break;\n          e = a.suspendedLanes;\n          if ((e & c) !== c) {\n            Hg();\n            a.pingedLanes |= a.suspendedLanes & e;\n            break;\n          }\n          a.timeoutHandle = of(Uj.bind(null, a), d);\n          break;\n        }\n        Uj(a);\n        break;\n      case 4:\n        Ii(a, c);\n        if ((c & 4186112) === c)\n          break;\n        d = a.eventTimes;\n        for (e = -1; 0 < c; ) {\n          var g = 31 - Vc(c);\n          f = 1 << g;\n          g = d[g];\n          g > e && (e = g);\n          c &= ~f;\n        }\n        c = e;\n        c = O() - c;\n        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;\n        if (10 < c) {\n          a.timeoutHandle = of(Uj.bind(null, a), c);\n          break;\n        }\n        Uj(a);\n        break;\n      case 5:\n        Uj(a);\n        break;\n      default:\n        throw Error(y(329));\n    }\n  }\n  Mj(a, O());\n  return a.callbackNode === b ? Nj.bind(null, a) : null;\n}\nfunction Ii(a, b) {\n  b &= ~uj;\n  b &= ~Hi;\n  a.suspendedLanes |= b;\n  a.pingedLanes &= ~b;\n  for (a = a.expirationTimes; 0 < b; ) {\n    var c = 31 - Vc(b), d = 1 << c;\n    a[c] = -1;\n    b &= ~d;\n  }\n}\nfunction Lj(a) {\n  if ((X & 48) !== 0)\n    throw Error(y(327));\n  Oj();\n  if (a === U && (a.expiredLanes & W) !== 0) {\n    var b = W;\n    var c = Tj(a, b);\n    (tj & Hi) !== 0 && (b = Uc(a, b), c = Tj(a, b));\n  } else\n    b = Uc(a, 0), c = Tj(a, b);\n  a.tag !== 0 && c === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), b !== 0 && (c = Tj(a, b)));\n  if (c === 1)\n    throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;\n  a.finishedWork = a.current.alternate;\n  a.finishedLanes = b;\n  Uj(a);\n  Mj(a, O());\n  return null;\n}\nfunction Vj() {\n  if (Cj !== null) {\n    var a = Cj;\n    Cj = null;\n    a.forEach(function(a2) {\n      a2.expiredLanes |= 24 & a2.pendingLanes;\n      Mj(a2, O());\n    });\n  }\n  ig();\n}\nfunction Wj(a, b) {\n  var c = X;\n  X |= 1;\n  try {\n    return a(b);\n  } finally {\n    X = c, X === 0 && (wj(), ig());\n  }\n}\nfunction Xj(a, b) {\n  var c = X;\n  X &= -2;\n  X |= 8;\n  try {\n    return a(b);\n  } finally {\n    X = c, X === 0 && (wj(), ig());\n  }\n}\nfunction ni$1(a, b) {\n  I(rj, qj);\n  qj |= b;\n  tj |= b;\n}\nfunction Ki() {\n  qj = rj.current;\n  H(rj);\n}\nfunction Qj(a, b) {\n  a.finishedWork = null;\n  a.finishedLanes = 0;\n  var c = a.timeoutHandle;\n  c !== -1 && (a.timeoutHandle = -1, pf(c));\n  if (Y !== null)\n    for (c = Y.return; c !== null; ) {\n      var d = c;\n      switch (d.tag) {\n        case 1:\n          d = d.type.childContextTypes;\n          d !== null && d !== void 0 && Gf();\n          break;\n        case 3:\n          fh();\n          H(N);\n          H(M);\n          uh();\n          break;\n        case 5:\n          hh(d);\n          break;\n        case 4:\n          fh();\n          break;\n        case 13:\n          H(P);\n          break;\n        case 19:\n          H(P);\n          break;\n        case 10:\n          rg(d);\n          break;\n        case 23:\n        case 24:\n          Ki();\n      }\n      c = c.return;\n    }\n  U = a;\n  Y = Tg(a.current, null);\n  W = qj = tj = b;\n  V = 0;\n  sj = null;\n  uj = Hi = Dg = 0;\n}\nfunction Sj(a, b) {\n  do {\n    var c = Y;\n    try {\n      qg();\n      vh.current = Gh;\n      if (yh) {\n        for (var d = R.memoizedState; d !== null; ) {\n          var e = d.queue;\n          e !== null && (e.pending = null);\n          d = d.next;\n        }\n        yh = false;\n      }\n      xh = 0;\n      T = S = R = null;\n      zh = false;\n      pj.current = null;\n      if (c === null || c.return === null) {\n        V = 1;\n        sj = b;\n        Y = null;\n        break;\n      }\n      a: {\n        var f = a, g = c.return, h = c, k = b;\n        b = W;\n        h.flags |= 2048;\n        h.firstEffect = h.lastEffect = null;\n        if (k !== null && typeof k === \"object\" && typeof k.then === \"function\") {\n          var l2 = k;\n          if ((h.mode & 2) === 0) {\n            var n2 = h.alternate;\n            n2 ? (h.updateQueue = n2.updateQueue, h.memoizedState = n2.memoizedState, h.lanes = n2.lanes) : (h.updateQueue = null, h.memoizedState = null);\n          }\n          var A2 = (P.current & 1) !== 0, p2 = g;\n          do {\n            var C2;\n            if (C2 = p2.tag === 13) {\n              var x2 = p2.memoizedState;\n              if (x2 !== null)\n                C2 = x2.dehydrated !== null ? true : false;\n              else {\n                var w = p2.memoizedProps;\n                C2 = w.fallback === void 0 ? false : w.unstable_avoidThisFallback !== true ? true : A2 ? false : true;\n              }\n            }\n            if (C2) {\n              var z2 = p2.updateQueue;\n              if (z2 === null) {\n                var u2 = /* @__PURE__ */ new Set();\n                u2.add(l2);\n                p2.updateQueue = u2;\n              } else\n                z2.add(l2);\n              if ((p2.mode & 2) === 0) {\n                p2.flags |= 64;\n                h.flags |= 16384;\n                h.flags &= -2981;\n                if (h.tag === 1)\n                  if (h.alternate === null)\n                    h.tag = 17;\n                  else {\n                    var t2 = zg(-1, 1);\n                    t2.tag = 2;\n                    Ag(h, t2);\n                  }\n                h.lanes |= 1;\n                break a;\n              }\n              k = void 0;\n              h = b;\n              var q2 = f.pingCache;\n              q2 === null ? (q2 = f.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q2.set(l2, k)) : (k = q2.get(l2), k === void 0 && (k = /* @__PURE__ */ new Set(), q2.set(l2, k)));\n              if (!k.has(h)) {\n                k.add(h);\n                var v2 = Yj.bind(null, f, l2, h);\n                l2.then(v2, v2);\n              }\n              p2.flags |= 4096;\n              p2.lanes = b;\n              break a;\n            }\n            p2 = p2.return;\n          } while (p2 !== null);\n          k = Error((Ra(h.type) || \"A React component\") + \" suspended while rendering, but no fallback UI was specified.\\n\\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.\");\n        }\n        V !== 5 && (V = 2);\n        k = Mi(k, h);\n        p2 = g;\n        do {\n          switch (p2.tag) {\n            case 3:\n              f = k;\n              p2.flags |= 4096;\n              b &= -b;\n              p2.lanes |= b;\n              var J2 = Pi$1(p2, f, b);\n              Bg(p2, J2);\n              break a;\n            case 1:\n              f = k;\n              var K2 = p2.type, Q2 = p2.stateNode;\n              if ((p2.flags & 64) === 0 && (typeof K2.getDerivedStateFromError === \"function\" || Q2 !== null && typeof Q2.componentDidCatch === \"function\" && (Ti === null || !Ti.has(Q2)))) {\n                p2.flags |= 4096;\n                b &= -b;\n                p2.lanes |= b;\n                var L2 = Si(p2, f, b);\n                Bg(p2, L2);\n                break a;\n              }\n          }\n          p2 = p2.return;\n        } while (p2 !== null);\n      }\n      Zj(c);\n    } catch (va) {\n      b = va;\n      Y === c && c !== null && (Y = c = c.return);\n      continue;\n    }\n    break;\n  } while (1);\n}\nfunction Pj() {\n  var a = oj.current;\n  oj.current = Gh;\n  return a === null ? Gh : a;\n}\nfunction Tj(a, b) {\n  var c = X;\n  X |= 16;\n  var d = Pj();\n  U === a && W === b || Qj(a, b);\n  do\n    try {\n      ak();\n      break;\n    } catch (e) {\n      Sj(a, e);\n    }\n  while (1);\n  qg();\n  X = c;\n  oj.current = d;\n  if (Y !== null)\n    throw Error(y(261));\n  U = null;\n  W = 0;\n  return V;\n}\nfunction ak() {\n  for (; Y !== null; )\n    bk(Y);\n}\nfunction Rj() {\n  for (; Y !== null && !Qf(); )\n    bk(Y);\n}\nfunction bk(a) {\n  var b = ck(a.alternate, a, qj);\n  a.memoizedProps = a.pendingProps;\n  b === null ? Zj(a) : Y = b;\n  pj.current = null;\n}\nfunction Zj(a) {\n  var b = a;\n  do {\n    var c = b.alternate;\n    a = b.return;\n    if ((b.flags & 2048) === 0) {\n      c = Gi(c, b, qj);\n      if (c !== null) {\n        Y = c;\n        return;\n      }\n      c = b;\n      if (c.tag !== 24 && c.tag !== 23 || c.memoizedState === null || (qj & 1073741824) !== 0 || (c.mode & 4) === 0) {\n        for (var d = 0, e = c.child; e !== null; )\n          d |= e.lanes | e.childLanes, e = e.sibling;\n        c.childLanes = d;\n      }\n      a !== null && (a.flags & 2048) === 0 && (a.firstEffect === null && (a.firstEffect = b.firstEffect), b.lastEffect !== null && (a.lastEffect !== null && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (a.lastEffect !== null ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));\n    } else {\n      c = Li(b);\n      if (c !== null) {\n        c.flags &= 2047;\n        Y = c;\n        return;\n      }\n      a !== null && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);\n    }\n    b = b.sibling;\n    if (b !== null) {\n      Y = b;\n      return;\n    }\n    Y = b = a;\n  } while (b !== null);\n  V === 0 && (V = 5);\n}\nfunction Uj(a) {\n  var b = eg$1();\n  gg$1(99, dk.bind(null, a, b));\n  return null;\n}\nfunction dk(a, b) {\n  do\n    Oj();\n  while (yj !== null);\n  if ((X & 48) !== 0)\n    throw Error(y(327));\n  var c = a.finishedWork;\n  if (c === null)\n    return null;\n  a.finishedWork = null;\n  a.finishedLanes = 0;\n  if (c === a.current)\n    throw Error(y(177));\n  a.callbackNode = null;\n  var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;\n  a.pendingLanes = e;\n  a.suspendedLanes = 0;\n  a.pingedLanes = 0;\n  a.expiredLanes &= e;\n  a.mutableReadLanes &= e;\n  a.entangledLanes &= e;\n  e = a.entanglements;\n  for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {\n    var k = 31 - Vc(f), l2 = 1 << k;\n    e[k] = 0;\n    g[k] = -1;\n    h[k] = -1;\n    f &= ~l2;\n  }\n  Cj !== null && (d & 24) === 0 && Cj.has(a) && Cj.delete(a);\n  a === U && (Y = U = null, W = 0);\n  1 < c.flags ? c.lastEffect !== null ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;\n  if (d !== null) {\n    e = X;\n    X |= 32;\n    pj.current = null;\n    kf = fd;\n    g = Ne();\n    if (Oe(g)) {\n      if (\"selectionStart\" in g)\n        h = { start: g.selectionStart, end: g.selectionEnd };\n      else\n        a:\n          if (h = (h = g.ownerDocument) && h.defaultView || window, (l2 = h.getSelection && h.getSelection()) && l2.rangeCount !== 0) {\n            h = l2.anchorNode;\n            f = l2.anchorOffset;\n            k = l2.focusNode;\n            l2 = l2.focusOffset;\n            try {\n              h.nodeType, k.nodeType;\n            } catch (va) {\n              h = null;\n              break a;\n            }\n            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w = g, z2 = null;\n            b:\n              for (; ; ) {\n                for (var u2; ; ) {\n                  w !== h || f !== 0 && w.nodeType !== 3 || (A2 = n2 + f);\n                  w !== k || l2 !== 0 && w.nodeType !== 3 || (p2 = n2 + l2);\n                  w.nodeType === 3 && (n2 += w.nodeValue.length);\n                  if ((u2 = w.firstChild) === null)\n                    break;\n                  z2 = w;\n                  w = u2;\n                }\n                for (; ; ) {\n                  if (w === g)\n                    break b;\n                  z2 === h && ++C2 === f && (A2 = n2);\n                  z2 === k && ++x2 === l2 && (p2 = n2);\n                  if ((u2 = w.nextSibling) !== null)\n                    break;\n                  w = z2;\n                  z2 = w.parentNode;\n                }\n                w = u2;\n              }\n            h = A2 === -1 || p2 === -1 ? null : { start: A2, end: p2 };\n          } else\n            h = null;\n      h = h || { start: 0, end: 0 };\n    } else\n      h = null;\n    lf = { focusedElem: g, selectionRange: h };\n    fd = false;\n    Ij = null;\n    Jj = false;\n    Z = d;\n    do\n      try {\n        ek();\n      } catch (va) {\n        if (Z === null)\n          throw Error(y(330));\n        Wi(Z, va);\n        Z = Z.nextEffect;\n      }\n    while (Z !== null);\n    Ij = null;\n    Z = d;\n    do\n      try {\n        for (g = a; Z !== null; ) {\n          var t2 = Z.flags;\n          t2 & 16 && pb(Z.stateNode, \"\");\n          if (t2 & 128) {\n            var q2 = Z.alternate;\n            if (q2 !== null) {\n              var v2 = q2.ref;\n              v2 !== null && (typeof v2 === \"function\" ? v2(null) : v2.current = null);\n            }\n          }\n          switch (t2 & 1038) {\n            case 2:\n              fj(Z);\n              Z.flags &= -3;\n              break;\n            case 6:\n              fj(Z);\n              Z.flags &= -3;\n              ij(Z.alternate, Z);\n              break;\n            case 1024:\n              Z.flags &= -1025;\n              break;\n            case 1028:\n              Z.flags &= -1025;\n              ij(Z.alternate, Z);\n              break;\n            case 4:\n              ij(Z.alternate, Z);\n              break;\n            case 8:\n              h = Z;\n              cj(g, h);\n              var J2 = h.alternate;\n              dj(h);\n              J2 !== null && dj(J2);\n          }\n          Z = Z.nextEffect;\n        }\n      } catch (va) {\n        if (Z === null)\n          throw Error(y(330));\n        Wi(Z, va);\n        Z = Z.nextEffect;\n      }\n    while (Z !== null);\n    v2 = lf;\n    q2 = Ne();\n    t2 = v2.focusedElem;\n    g = v2.selectionRange;\n    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {\n      g !== null && Oe(t2) && (q2 = g.start, v2 = g.end, v2 === void 0 && (v2 = q2), \"selectionStart\" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h = t2.textContent.length, J2 = Math.min(g.start, h), g = g.end === void 0 ? J2 : Math.min(g.end, h), !v2.extend && J2 > g && (h = g, g = J2, J2 = h), h = Le(t2, J2), f = Le(t2, g), h && f && (v2.rangeCount !== 1 || v2.anchorNode !== h.node || v2.anchorOffset !== h.offset || v2.focusNode !== f.node || v2.focusOffset !== f.offset) && (q2 = q2.createRange(), q2.setStart(h.node, h.offset), v2.removeAllRanges(), J2 > g ? (v2.addRange(q2), v2.extend(f.node, f.offset)) : (q2.setEnd(f.node, f.offset), v2.addRange(q2))))));\n      q2 = [];\n      for (v2 = t2; v2 = v2.parentNode; )\n        v2.nodeType === 1 && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });\n      typeof t2.focus === \"function\" && t2.focus();\n      for (t2 = 0; t2 < q2.length; t2++)\n        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;\n    }\n    fd = !!kf;\n    lf = kf = null;\n    a.current = c;\n    Z = d;\n    do\n      try {\n        for (t2 = a; Z !== null; ) {\n          var K2 = Z.flags;\n          K2 & 36 && Yi(t2, Z.alternate, Z);\n          if (K2 & 128) {\n            q2 = void 0;\n            var Q2 = Z.ref;\n            if (Q2 !== null) {\n              var L2 = Z.stateNode;\n              switch (Z.tag) {\n                case 5:\n                  q2 = L2;\n                  break;\n                default:\n                  q2 = L2;\n              }\n              typeof Q2 === \"function\" ? Q2(q2) : Q2.current = q2;\n            }\n          }\n          Z = Z.nextEffect;\n        }\n      } catch (va) {\n        if (Z === null)\n          throw Error(y(330));\n        Wi(Z, va);\n        Z = Z.nextEffect;\n      }\n    while (Z !== null);\n    Z = null;\n    $f();\n    X = e;\n  } else\n    a.current = c;\n  if (xj)\n    xj = false, yj = a, zj = b;\n  else\n    for (Z = d; Z !== null; )\n      b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;\n  d = a.pendingLanes;\n  d === 0 && (Ti = null);\n  d === 1 ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;\n  c = c.stateNode;\n  if (Mf && typeof Mf.onCommitFiberRoot === \"function\")\n    try {\n      Mf.onCommitFiberRoot(Lf, c, void 0, (c.current.flags & 64) === 64);\n    } catch (va) {\n    }\n  Mj(a, O());\n  if (Qi)\n    throw Qi = false, a = Ri, Ri = null, a;\n  if ((X & 8) !== 0)\n    return null;\n  ig();\n  return null;\n}\nfunction ek() {\n  for (; Z !== null; ) {\n    var a = Z.alternate;\n    Jj || Ij === null || ((Z.flags & 8) !== 0 ? dc(Z, Ij) && (Jj = true) : Z.tag === 13 && mj(a, Z) && dc(Z, Ij) && (Jj = true));\n    var b = Z.flags;\n    (b & 256) !== 0 && Xi$1(a, Z);\n    (b & 512) === 0 || xj || (xj = true, hg(97, function() {\n      Oj();\n      return null;\n    }));\n    Z = Z.nextEffect;\n  }\n}\nfunction Oj() {\n  if (zj !== 90) {\n    var a = 97 < zj ? 97 : zj;\n    zj = 90;\n    return gg$1(a, fk);\n  }\n  return false;\n}\nfunction $i(a, b) {\n  Aj.push(b, a);\n  xj || (xj = true, hg(97, function() {\n    Oj();\n    return null;\n  }));\n}\nfunction Zi(a, b) {\n  Bj.push(b, a);\n  xj || (xj = true, hg(97, function() {\n    Oj();\n    return null;\n  }));\n}\nfunction fk() {\n  if (yj === null)\n    return false;\n  var a = yj;\n  yj = null;\n  if ((X & 48) !== 0)\n    throw Error(y(331));\n  var b = X;\n  X |= 32;\n  var c = Bj;\n  Bj = [];\n  for (var d = 0; d < c.length; d += 2) {\n    var e = c[d], f = c[d + 1], g = e.destroy;\n    e.destroy = void 0;\n    if (typeof g === \"function\")\n      try {\n        g();\n      } catch (k) {\n        if (f === null)\n          throw Error(y(330));\n        Wi(f, k);\n      }\n  }\n  c = Aj;\n  Aj = [];\n  for (d = 0; d < c.length; d += 2) {\n    e = c[d];\n    f = c[d + 1];\n    try {\n      var h = e.create;\n      e.destroy = h();\n    } catch (k) {\n      if (f === null)\n        throw Error(y(330));\n      Wi(f, k);\n    }\n  }\n  for (h = a.current.firstEffect; h !== null; )\n    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;\n  X = b;\n  ig();\n  return true;\n}\nfunction gk(a, b, c) {\n  b = Mi(c, b);\n  b = Pi$1(a, b, 1);\n  Ag(a, b);\n  b = Hg();\n  a = Kj(a, 1);\n  a !== null && ($c(a, 1, b), Mj(a, b));\n}\nfunction Wi(a, b) {\n  if (a.tag === 3)\n    gk(a, a, b);\n  else\n    for (var c = a.return; c !== null; ) {\n      if (c.tag === 3) {\n        gk(c, a, b);\n        break;\n      } else if (c.tag === 1) {\n        var d = c.stateNode;\n        if (typeof c.type.getDerivedStateFromError === \"function\" || typeof d.componentDidCatch === \"function\" && (Ti === null || !Ti.has(d))) {\n          a = Mi(b, a);\n          var e = Si(c, a, 1);\n          Ag(c, e);\n          e = Hg();\n          c = Kj(c, 1);\n          if (c !== null)\n            $c(c, 1, e), Mj(c, e);\n          else if (typeof d.componentDidCatch === \"function\" && (Ti === null || !Ti.has(d)))\n            try {\n              d.componentDidCatch(b, a);\n            } catch (f) {\n            }\n          break;\n        }\n      }\n      c = c.return;\n    }\n}\nfunction Yj(a, b, c) {\n  var d = a.pingCache;\n  d !== null && d.delete(b);\n  b = Hg();\n  a.pingedLanes |= a.suspendedLanes & c;\n  U === a && (W & c) === c && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);\n  Mj(a, b);\n}\nfunction lj(a, b) {\n  var c = a.stateNode;\n  c !== null && c.delete(b);\n  b = 0;\n  b === 0 && (b = a.mode, (b & 2) === 0 ? b = 1 : (b & 4) === 0 ? b = eg$1() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b = Yc(62914560 & ~Gj), b === 0 && (b = 4194304)));\n  c = Hg();\n  a = Kj(a, b);\n  a !== null && ($c(a, b, c), Mj(a, c));\n}\nvar ck;\nck = function(a, b, c) {\n  var d = b.lanes;\n  if (a !== null)\n    if (a.memoizedProps !== b.pendingProps || N.current)\n      ug = true;\n    else if ((c & d) !== 0)\n      ug = (a.flags & 16384) !== 0 ? true : false;\n    else {\n      ug = false;\n      switch (b.tag) {\n        case 3:\n          ri(b);\n          sh();\n          break;\n        case 5:\n          gh(b);\n          break;\n        case 1:\n          Ff(b.type) && Jf(b);\n          break;\n        case 4:\n          eh(b, b.stateNode.containerInfo);\n          break;\n        case 10:\n          d = b.memoizedProps.value;\n          var e = b.type._context;\n          I(mg, e._currentValue);\n          e._currentValue = d;\n          break;\n        case 13:\n          if (b.memoizedState !== null) {\n            if ((c & b.child.childLanes) !== 0)\n              return ti(a, b, c);\n            I(P, P.current & 1);\n            b = hi(a, b, c);\n            return b !== null ? b.sibling : null;\n          }\n          I(P, P.current & 1);\n          break;\n        case 19:\n          d = (c & b.childLanes) !== 0;\n          if ((a.flags & 64) !== 0) {\n            if (d)\n              return Ai(a, b, c);\n            b.flags |= 64;\n          }\n          e = b.memoizedState;\n          e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null);\n          I(P, P.current);\n          if (d)\n            break;\n          else\n            return null;\n        case 23:\n        case 24:\n          return b.lanes = 0, mi(a, b, c);\n      }\n      return hi(a, b, c);\n    }\n  else\n    ug = false;\n  b.lanes = 0;\n  switch (b.tag) {\n    case 2:\n      d = b.type;\n      a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);\n      a = b.pendingProps;\n      e = Ef(b, M.current);\n      tg(b, c);\n      e = Ch(null, b, d, a, e, c);\n      b.flags |= 1;\n      if (typeof e === \"object\" && e !== null && typeof e.render === \"function\" && e.$$typeof === void 0) {\n        b.tag = 1;\n        b.memoizedState = null;\n        b.updateQueue = null;\n        if (Ff(d)) {\n          var f = true;\n          Jf(b);\n        } else\n          f = false;\n        b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null;\n        xg(b);\n        var g = d.getDerivedStateFromProps;\n        typeof g === \"function\" && Gg$1(b, d, g, a);\n        e.updater = Kg;\n        b.stateNode = e;\n        e._reactInternals = b;\n        Og(b, d, a, c);\n        b = qi(null, b, d, true, f, c);\n      } else\n        b.tag = 0, fi(null, b, e, c), b = b.child;\n      return b;\n    case 16:\n      e = b.elementType;\n      a: {\n        a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);\n        a = b.pendingProps;\n        f = e._init;\n        e = f(e._payload);\n        b.type = e;\n        f = b.tag = hk(e);\n        a = lg$1(e, a);\n        switch (f) {\n          case 0:\n            b = li(null, b, e, a, c);\n            break a;\n          case 1:\n            b = pi$1(null, b, e, a, c);\n            break a;\n          case 11:\n            b = gi(null, b, e, a, c);\n            break a;\n          case 14:\n            b = ii$1(null, b, e, lg$1(e.type, a), d, c);\n            break a;\n        }\n        throw Error(y(306, e, \"\"));\n      }\n      return b;\n    case 0:\n      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), li(a, b, d, e, c);\n    case 1:\n      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), pi$1(a, b, d, e, c);\n    case 3:\n      ri(b);\n      d = b.updateQueue;\n      if (a === null || d === null)\n        throw Error(y(282));\n      d = b.pendingProps;\n      e = b.memoizedState;\n      e = e !== null ? e.element : null;\n      yg(a, b);\n      Cg(b, d, null, c);\n      d = b.memoizedState.element;\n      if (d === e)\n        sh(), b = hi(a, b, c);\n      else {\n        e = b.stateNode;\n        if (f = e.hydrate)\n          kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;\n        if (f) {\n          a = e.mutableSourceEagerHydrationData;\n          if (a != null)\n            for (e = 0; e < a.length; e += 2)\n              f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);\n          c = Zg(b, null, d, c);\n          for (b.child = c; c; )\n            c.flags = c.flags & -3 | 1024, c = c.sibling;\n        } else\n          fi(a, b, d, c), sh();\n        b = b.child;\n      }\n      return b;\n    case 5:\n      return gh(b), a === null && ph(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : f !== null && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;\n    case 6:\n      return a === null && ph(b), null;\n    case 13:\n      return ti(a, b, c);\n    case 4:\n      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;\n    case 11:\n      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), gi(a, b, d, e, c);\n    case 7:\n      return fi(a, b, b.pendingProps, c), b.child;\n    case 8:\n      return fi(a, b, b.pendingProps.children, c), b.child;\n    case 12:\n      return fi(a, b, b.pendingProps.children, c), b.child;\n    case 10:\n      a: {\n        d = b.type._context;\n        e = b.pendingProps;\n        g = b.memoizedProps;\n        f = e.value;\n        var h = b.type._context;\n        I(mg, h._currentValue);\n        h._currentValue = f;\n        if (g !== null)\n          if (h = g.value, f = He(h, f) ? 0 : (typeof d._calculateChangedBits === \"function\" ? d._calculateChangedBits(h, f) : 1073741823) | 0, f === 0) {\n            if (g.children === e.children && !N.current) {\n              b = hi(a, b, c);\n              break a;\n            }\n          } else\n            for (h = b.child, h !== null && (h.return = b); h !== null; ) {\n              var k = h.dependencies;\n              if (k !== null) {\n                g = h.child;\n                for (var l2 = k.firstContext; l2 !== null; ) {\n                  if (l2.context === d && (l2.observedBits & f) !== 0) {\n                    h.tag === 1 && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h, l2));\n                    h.lanes |= c;\n                    l2 = h.alternate;\n                    l2 !== null && (l2.lanes |= c);\n                    sg(h.return, c);\n                    k.lanes |= c;\n                    break;\n                  }\n                  l2 = l2.next;\n                }\n              } else\n                g = h.tag === 10 ? h.type === b.type ? null : h.child : h.child;\n              if (g !== null)\n                g.return = h;\n              else\n                for (g = h; g !== null; ) {\n                  if (g === b) {\n                    g = null;\n                    break;\n                  }\n                  h = g.sibling;\n                  if (h !== null) {\n                    h.return = g.return;\n                    g = h;\n                    break;\n                  }\n                  g = g.return;\n                }\n              h = g;\n            }\n        fi(a, b, e.children, c);\n        b = b.child;\n      }\n      return b;\n    case 9:\n      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;\n    case 14:\n      return e = b.type, f = lg$1(e, b.pendingProps), f = lg$1(e.type, f), ii$1(a, b, e, f, d, c);\n    case 15:\n      return ki(a, b, b.type, b.pendingProps, d, c);\n    case 17:\n      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);\n    case 19:\n      return Ai(a, b, c);\n    case 23:\n      return mi(a, b, c);\n    case 24:\n      return mi(a, b, c);\n  }\n  throw Error(y(156, b.tag));\n};\nfunction ik(a, b, c, d) {\n  this.tag = a;\n  this.key = c;\n  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n  this.index = 0;\n  this.ref = null;\n  this.pendingProps = b;\n  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n  this.mode = d;\n  this.flags = 0;\n  this.lastEffect = this.firstEffect = this.nextEffect = null;\n  this.childLanes = this.lanes = 0;\n  this.alternate = null;\n}\nfunction nh(a, b, c, d) {\n  return new ik(a, b, c, d);\n}\nfunction ji(a) {\n  a = a.prototype;\n  return !(!a || !a.isReactComponent);\n}\nfunction hk(a) {\n  if (typeof a === \"function\")\n    return ji(a) ? 1 : 0;\n  if (a !== void 0 && a !== null) {\n    a = a.$$typeof;\n    if (a === Aa)\n      return 11;\n    if (a === Da)\n      return 14;\n  }\n  return 2;\n}\nfunction Tg(a, b) {\n  var c = a.alternate;\n  c === null ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);\n  c.childLanes = a.childLanes;\n  c.lanes = a.lanes;\n  c.child = a.child;\n  c.memoizedProps = a.memoizedProps;\n  c.memoizedState = a.memoizedState;\n  c.updateQueue = a.updateQueue;\n  b = a.dependencies;\n  c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext };\n  c.sibling = a.sibling;\n  c.index = a.index;\n  c.ref = a.ref;\n  return c;\n}\nfunction Vg(a, b, c, d, e, f) {\n  var g = 2;\n  d = a;\n  if (typeof a === \"function\")\n    ji(a) && (g = 1);\n  else if (typeof a === \"string\")\n    g = 5;\n  else\n    a:\n      switch (a) {\n        case ua:\n          return Xg(c.children, e, f, b);\n        case Ha:\n          g = 8;\n          e |= 16;\n          break;\n        case wa:\n          g = 8;\n          e |= 1;\n          break;\n        case xa:\n          return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;\n        case Ba:\n          return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;\n        case Ca:\n          return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;\n        case Ia:\n          return vi(c, e, f, b);\n        case Ja:\n          return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;\n        default:\n          if (typeof a === \"object\" && a !== null)\n            switch (a.$$typeof) {\n              case ya:\n                g = 10;\n                break a;\n              case za:\n                g = 9;\n                break a;\n              case Aa:\n                g = 11;\n                break a;\n              case Da:\n                g = 14;\n                break a;\n              case Ea:\n                g = 16;\n                d = null;\n                break a;\n              case Fa:\n                g = 22;\n                break a;\n            }\n          throw Error(y(130, a == null ? a : typeof a, \"\"));\n      }\n  b = nh(g, c, b, e);\n  b.elementType = a;\n  b.type = d;\n  b.lanes = f;\n  return b;\n}\nfunction Xg(a, b, c, d) {\n  a = nh(7, a, d, b);\n  a.lanes = c;\n  return a;\n}\nfunction vi(a, b, c, d) {\n  a = nh(23, a, d, b);\n  a.elementType = Ia;\n  a.lanes = c;\n  return a;\n}\nfunction Ug(a, b, c) {\n  a = nh(6, a, null, b);\n  a.lanes = c;\n  return a;\n}\nfunction Wg(a, b, c) {\n  b = nh(4, a.children !== null ? a.children : [], a.key, b);\n  b.lanes = c;\n  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };\n  return b;\n}\nfunction jk(a, b, c) {\n  this.tag = b;\n  this.containerInfo = a;\n  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;\n  this.timeoutHandle = -1;\n  this.pendingContext = this.context = null;\n  this.hydrate = c;\n  this.callbackNode = null;\n  this.callbackPriority = 0;\n  this.eventTimes = Zc(0);\n  this.expirationTimes = Zc(-1);\n  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n  this.entanglements = Zc(0);\n  this.mutableSourceEagerHydrationData = null;\n}\nfunction kk(a, b, c) {\n  var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;\n  return { $$typeof: ta, key: d == null ? null : \"\" + d, children: a, containerInfo: b, implementation: c };\n}\nfunction lk(a, b, c, d) {\n  var e = b.current, f = Hg(), g = Ig(e);\n  a:\n    if (c) {\n      c = c._reactInternals;\n      b: {\n        if (Zb(c) !== c || c.tag !== 1)\n          throw Error(y(170));\n        var h = c;\n        do {\n          switch (h.tag) {\n            case 3:\n              h = h.stateNode.context;\n              break b;\n            case 1:\n              if (Ff(h.type)) {\n                h = h.stateNode.__reactInternalMemoizedMergedChildContext;\n                break b;\n              }\n          }\n          h = h.return;\n        } while (h !== null);\n        throw Error(y(171));\n      }\n      if (c.tag === 1) {\n        var k = c.type;\n        if (Ff(k)) {\n          c = If(c, k, h);\n          break a;\n        }\n      }\n      c = h;\n    } else\n      c = Cf;\n  b.context === null ? b.context = c : b.pendingContext = c;\n  b = zg(f, g);\n  b.payload = { element: a };\n  d = d === void 0 ? null : d;\n  d !== null && (b.callback = d);\n  Ag(e, b);\n  Jg(e, g, f);\n  return g;\n}\nfunction mk(a) {\n  a = a.current;\n  if (!a.child)\n    return null;\n  switch (a.child.tag) {\n    case 5:\n      return a.child.stateNode;\n    default:\n      return a.child.stateNode;\n  }\n}\nfunction nk(a, b) {\n  a = a.memoizedState;\n  if (a !== null && a.dehydrated !== null) {\n    var c = a.retryLane;\n    a.retryLane = c !== 0 && c < b ? c : b;\n  }\n}\nfunction ok(a, b) {\n  nk(a, b);\n  (a = a.alternate) && nk(a, b);\n}\nfunction pk() {\n  return null;\n}\nfunction qk(a, b, c) {\n  var d = c != null && c.hydrationOptions != null && c.hydrationOptions.mutableSources || null;\n  c = new jk(a, b, c != null && c.hydrate === true);\n  b = nh(3, null, null, b === 2 ? 7 : b === 1 ? 3 : 0);\n  c.current = b;\n  b.stateNode = c;\n  xg(b);\n  a[ff] = c.current;\n  cf(a.nodeType === 8 ? a.parentNode : a);\n  if (d)\n    for (a = 0; a < d.length; a++) {\n      b = d[a];\n      var e = b._getVersion;\n      e = e(b._source);\n      c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);\n    }\n  this._internalRoot = c;\n}\nqk.prototype.render = function(a) {\n  lk(a, this._internalRoot, null, null);\n};\nqk.prototype.unmount = function() {\n  var a = this._internalRoot, b = a.containerInfo;\n  lk(null, a, null, function() {\n    b[ff] = null;\n  });\n};\nfunction rk(a) {\n  return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== \" react-mount-point-unstable \"));\n}\nfunction sk(a, b) {\n  b || (b = a ? a.nodeType === 9 ? a.documentElement : a.firstChild : null, b = !(!b || b.nodeType !== 1 || !b.hasAttribute(\"data-reactroot\")));\n  if (!b)\n    for (var c; c = a.lastChild; )\n      a.removeChild(c);\n  return new qk(a, 0, b ? { hydrate: true } : void 0);\n}\nfunction tk(a, b, c, d, e) {\n  var f = c._reactRootContainer;\n  if (f) {\n    var g = f._internalRoot;\n    if (typeof e === \"function\") {\n      var h = e;\n      e = function() {\n        var a2 = mk(g);\n        h.call(a2);\n      };\n    }\n    lk(b, g, a, e);\n  } else {\n    f = c._reactRootContainer = sk(c, d);\n    g = f._internalRoot;\n    if (typeof e === \"function\") {\n      var k = e;\n      e = function() {\n        var a2 = mk(g);\n        k.call(a2);\n      };\n    }\n    Xj(function() {\n      lk(b, g, a, e);\n    });\n  }\n  return mk(g);\n}\nec = function(a) {\n  if (a.tag === 13) {\n    var b = Hg();\n    Jg(a, 4, b);\n    ok(a, 4);\n  }\n};\nfc = function(a) {\n  if (a.tag === 13) {\n    var b = Hg();\n    Jg(a, 67108864, b);\n    ok(a, 67108864);\n  }\n};\ngc = function(a) {\n  if (a.tag === 13) {\n    var b = Hg(), c = Ig(a);\n    Jg(a, c, b);\n    ok(a, c);\n  }\n};\nhc = function(a, b) {\n  return b();\n};\nyb = function(a, b, c) {\n  switch (b) {\n    case \"input\":\n      ab(a, c);\n      b = c.name;\n      if (c.type === \"radio\" && b != null) {\n        for (c = a; c.parentNode; )\n          c = c.parentNode;\n        c = c.querySelectorAll(\"input[name=\" + JSON.stringify(\"\" + b) + '][type=\"radio\"]');\n        for (b = 0; b < c.length; b++) {\n          var d = c[b];\n          if (d !== a && d.form === a.form) {\n            var e = Db(d);\n            if (!e)\n              throw Error(y(90));\n            Wa(d);\n            ab(d, e);\n          }\n        }\n      }\n      break;\n    case \"textarea\":\n      ib(a, c);\n      break;\n    case \"select\":\n      b = c.value, b != null && fb(a, !!c.multiple, b, false);\n  }\n};\nGb = Wj;\nHb = function(a, b, c, d, e) {\n  var f = X;\n  X |= 4;\n  try {\n    return gg$1(98, a.bind(null, b, c, d, e));\n  } finally {\n    X = f, X === 0 && (wj(), ig());\n  }\n};\nIb = function() {\n  (X & 49) === 0 && (Vj(), Oj());\n};\nJb = function(a, b) {\n  var c = X;\n  X |= 2;\n  try {\n    return a(b);\n  } finally {\n    X = c, X === 0 && (wj(), ig());\n  }\n};\nfunction uk(a, b) {\n  var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;\n  if (!rk(b))\n    throw Error(y(200));\n  return kk(a, b, null, c);\n}\nvar vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: \"17.0.2\", rendererPackageName: \"react-dom\" };\nvar xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {\n  a = cc(a);\n  return a === null ? null : a.stateNode;\n}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };\nif (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\") {\n  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (!yk.isDisabled && yk.supportsFiber)\n    try {\n      Lf = yk.inject(xk), Mf = yk;\n    } catch (a) {\n    }\n}\nreactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;\nreactDom_production_min.createPortal = uk;\nreactDom_production_min.findDOMNode = function(a) {\n  if (a == null)\n    return null;\n  if (a.nodeType === 1)\n    return a;\n  var b = a._reactInternals;\n  if (b === void 0) {\n    if (typeof a.render === \"function\")\n      throw Error(y(188));\n    throw Error(y(268, Object.keys(a)));\n  }\n  a = cc(b);\n  a = a === null ? null : a.stateNode;\n  return a;\n};\nreactDom_production_min.flushSync = function(a, b) {\n  var c = X;\n  if ((c & 48) !== 0)\n    return a(b);\n  X |= 1;\n  try {\n    if (a)\n      return gg$1(99, a.bind(null, b));\n  } finally {\n    X = c, ig();\n  }\n};\nreactDom_production_min.hydrate = function(a, b, c) {\n  if (!rk(b))\n    throw Error(y(200));\n  return tk(null, a, b, true, c);\n};\nreactDom_production_min.render = function(a, b, c) {\n  if (!rk(b))\n    throw Error(y(200));\n  return tk(null, a, b, false, c);\n};\nreactDom_production_min.unmountComponentAtNode = function(a) {\n  if (!rk(a))\n    throw Error(y(40));\n  return a._reactRootContainer ? (Xj(function() {\n    tk(null, null, a, false, function() {\n      a._reactRootContainer = null;\n      a[ff] = null;\n    });\n  }), true) : false;\n};\nreactDom_production_min.unstable_batchedUpdates = Wj;\nreactDom_production_min.unstable_createPortal = function(a, b) {\n  return uk(a, b, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);\n};\nreactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {\n  if (!rk(c))\n    throw Error(y(200));\n  if (a == null || a._reactInternals === void 0)\n    throw Error(y(38));\n  return tk(a, b, c, false, d);\n};\nreactDom_production_min.version = \"17.0.2\";\nfunction checkDCE() {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== \"function\") {\n    return;\n  }\n  try {\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    console.error(err);\n  }\n}\n{\n  checkDCE();\n  reactDom.exports = reactDom_production_min;\n}\nvar ReactDOM = reactDom.exports;\nvar toggleSelection = function() {\n  var selection = document.getSelection();\n  if (!selection.rangeCount) {\n    return function() {\n    };\n  }\n  var active = document.activeElement;\n  var ranges = [];\n  for (var i = 0; i < selection.rangeCount; i++) {\n    ranges.push(selection.getRangeAt(i));\n  }\n  switch (active.tagName.toUpperCase()) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      active.blur();\n      break;\n    default:\n      active = null;\n      break;\n  }\n  selection.removeAllRanges();\n  return function() {\n    selection.type === \"Caret\" && selection.removeAllRanges();\n    if (!selection.rangeCount) {\n      ranges.forEach(function(range2) {\n        selection.addRange(range2);\n      });\n    }\n    active && active.focus();\n  };\n};\nvar deselectCurrent = toggleSelection;\nvar clipboardToIE11Formatting = {\n  \"text/plain\": \"Text\",\n  \"text/html\": \"Url\",\n  \"default\": \"Text\"\n};\nvar defaultMessage = \"Copy to clipboard: #{key}, Enter\";\nfunction format$1(message) {\n  var copyKey = (/mac os x/i.test(navigator.userAgent) ? \"\\u2318\" : \"Ctrl\") + \"+C\";\n  return message.replace(/#{\\s*key\\s*}/g, copyKey);\n}\nfunction copy$1(text3, options) {\n  var debug, message, reselectPrevious, range2, selection, mark, success = false;\n  if (!options) {\n    options = {};\n  }\n  debug = options.debug || false;\n  try {\n    reselectPrevious = deselectCurrent();\n    range2 = document.createRange();\n    selection = document.getSelection();\n    mark = document.createElement(\"span\");\n    mark.textContent = text3;\n    mark.style.all = \"unset\";\n    mark.style.position = \"fixed\";\n    mark.style.top = 0;\n    mark.style.clip = \"rect(0, 0, 0, 0)\";\n    mark.style.whiteSpace = \"pre\";\n    mark.style.webkitUserSelect = \"text\";\n    mark.style.MozUserSelect = \"text\";\n    mark.style.msUserSelect = \"text\";\n    mark.style.userSelect = \"text\";\n    mark.addEventListener(\"copy\", function(e) {\n      e.stopPropagation();\n      if (options.format) {\n        e.preventDefault();\n        if (typeof e.clipboardData === \"undefined\") {\n          debug && console.warn(\"unable to use e.clipboardData\");\n          debug && console.warn(\"trying IE specific stuff\");\n          window.clipboardData.clearData();\n          var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting[\"default\"];\n          window.clipboardData.setData(format3, text3);\n        } else {\n          e.clipboardData.clearData();\n          e.clipboardData.setData(options.format, text3);\n        }\n      }\n      if (options.onCopy) {\n        e.preventDefault();\n        options.onCopy(e.clipboardData);\n      }\n    });\n    document.body.appendChild(mark);\n    range2.selectNodeContents(mark);\n    selection.addRange(range2);\n    var successful = document.execCommand(\"copy\");\n    if (!successful) {\n      throw new Error(\"copy command was unsuccessful\");\n    }\n    success = true;\n  } catch (err) {\n    debug && console.error(\"unable to copy using execCommand: \", err);\n    debug && console.warn(\"trying IE specific stuff\");\n    try {\n      window.clipboardData.setData(options.format || \"text\", text3);\n      options.onCopy && options.onCopy(window.clipboardData);\n      success = true;\n    } catch (err2) {\n      debug && console.error(\"unable to copy using clipboardData: \", err2);\n      debug && console.error(\"falling back to prompt\");\n      message = format$1(\"message\" in options ? options.message : defaultMessage);\n      window.prompt(message, text3);\n    }\n  } finally {\n    if (selection) {\n      if (typeof selection.removeRange == \"function\") {\n        selection.removeRange(range2);\n      } else {\n        selection.removeAllRanges();\n      }\n    }\n    if (mark) {\n      document.body.removeChild(mark);\n    }\n    reselectPrevious();\n  }\n  return success;\n}\nvar copyToClipboard = copy$1;\nconst version = \"16.3.0\";\nconst versionInfo = Object.freeze({\n  major: 16,\n  minor: 3,\n  patch: 0,\n  preReleaseTag: null\n});\nfunction devAssert$1(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\nfunction isPromise$2(value) {\n  return typeof (value === null || value === void 0 ? void 0 : value.then) === \"function\";\n}\nfunction isObjectLike$1(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction invariant$2(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(message != null ? message : \"Unexpected invariant triggered.\");\n  }\n}\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\nfunction getLocation$1(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n  for (const match2 of source.body.matchAll(LineRegExp)) {\n    typeof match2.index === \"number\" || invariant$2(false);\n    if (match2.index >= position) {\n      break;\n    }\n    lastLineStart = match2.index + match2[0].length;\n    line += 1;\n  }\n  return {\n    line,\n    column: position + 1 - lastLineStart\n  };\n}\nfunction printLocation(location) {\n  return printSourceLocation(location.source, getLocation$1(location.source, location.start));\n}\nfunction printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = \"\".padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex];\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n    return locationStr + printPrefixedLines([\n      [`${lineNum} |`, subLines[0]],\n      ...subLines.slice(1, subLineIndex + 1).map((subLine) => [\"|\", subLine]),\n      [\"|\", \"^\".padStart(subLineColumnNum)],\n      [\"|\", subLines[subLineIndex + 1]]\n    ]);\n  }\n  return locationStr + printPrefixedLines([\n    [`${lineNum - 1} |`, lines[lineIndex - 1]],\n    [`${lineNum} |`, locationLine],\n    [\"|\", \"^\".padStart(columnNum)],\n    [`${lineNum + 1} |`, lines[lineIndex + 1]]\n  ]);\n}\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== void 0);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? \" \" + line : \"\")).join(\"\\n\");\n}\nfunction toNormalizedArgs(args) {\n  const firstArg = args[0];\n  if (firstArg == null || \"kind\" in firstArg || \"length\" in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5]\n    };\n  }\n  return firstArg;\n}\nclass GraphQLError extends Error {\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n    const { nodes, source, positions, path, originalError, extensions } = toNormalizedArgs(rawArgs);\n    super(message);\n    this.name = \"GraphQLError\";\n    this.path = path !== null && path !== void 0 ? path : void 0;\n    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;\n    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);\n    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));\n    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;\n    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);\n    this.locations = positions && source ? positions.map((pos) => getLocation$1(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation$1(loc.source, loc.start));\n    const originalExtensions = isObjectLike$1(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;\n    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true\n      },\n      name: {\n        enumerable: false\n      },\n      nodes: {\n        enumerable: false\n      },\n      source: {\n        enumerable: false\n      },\n      positions: {\n        enumerable: false\n      },\n      originalError: {\n        enumerable: false\n      }\n    });\n    if (originalError !== null && originalError !== void 0 && originalError.stack) {\n      Object.defineProperty(this, \"stack\", {\n        value: originalError.stack,\n        writable: true,\n        configurable: true\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, \"stack\", {\n        value: Error().stack,\n        writable: true,\n        configurable: true\n      });\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLError\";\n  }\n  toString() {\n    let output = this.message;\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += \"\\n\\n\" + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += \"\\n\\n\" + printSourceLocation(this.source, location);\n      }\n    }\n    return output;\n  }\n  toJSON() {\n    const formattedError = {\n      message: this.message\n    };\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n    return formattedError;\n  }\n}\nfunction undefinedIfEmpty(array) {\n  return array === void 0 || array.length === 0 ? void 0 : array;\n}\nfunction printError(error2) {\n  return error2.toString();\n}\nfunction formatError$1(error2) {\n  return error2.toJSON();\n}\nfunction syntaxError$1(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, void 0, source, [\n    position\n  ]);\n}\nclass Location$1 {\n  constructor(startToken, endToken, source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Location\";\n  }\n  toJSON() {\n    return {\n      start: this.start,\n      end: this.end\n    };\n  }\n}\nclass Token$4 {\n  constructor(kind2, start2, end2, line, column, value) {\n    this.kind = kind2;\n    this.start = start2;\n    this.end = end2;\n    this.line = line;\n    this.column = column;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Token\";\n  }\n  toJSON() {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column\n    };\n  }\n}\nconst QueryDocumentKeys = {\n  Name: [],\n  Document: [\"definitions\"],\n  OperationDefinition: [\n    \"name\",\n    \"variableDefinitions\",\n    \"directives\",\n    \"selectionSet\"\n  ],\n  VariableDefinition: [\"variable\", \"type\", \"defaultValue\", \"directives\"],\n  Variable: [\"name\"],\n  SelectionSet: [\"selections\"],\n  Field: [\"alias\", \"name\", \"arguments\", \"directives\", \"selectionSet\"],\n  Argument: [\"name\", \"value\"],\n  FragmentSpread: [\"name\", \"directives\"],\n  InlineFragment: [\"typeCondition\", \"directives\", \"selectionSet\"],\n  FragmentDefinition: [\n    \"name\",\n    \"variableDefinitions\",\n    \"typeCondition\",\n    \"directives\",\n    \"selectionSet\"\n  ],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: [\"values\"],\n  ObjectValue: [\"fields\"],\n  ObjectField: [\"name\", \"value\"],\n  Directive: [\"name\", \"arguments\"],\n  NamedType: [\"name\"],\n  ListType: [\"type\"],\n  NonNullType: [\"type\"],\n  SchemaDefinition: [\"description\", \"directives\", \"operationTypes\"],\n  OperationTypeDefinition: [\"type\"],\n  ScalarTypeDefinition: [\"description\", \"name\", \"directives\"],\n  ObjectTypeDefinition: [\n    \"description\",\n    \"name\",\n    \"interfaces\",\n    \"directives\",\n    \"fields\"\n  ],\n  FieldDefinition: [\"description\", \"name\", \"arguments\", \"type\", \"directives\"],\n  InputValueDefinition: [\n    \"description\",\n    \"name\",\n    \"type\",\n    \"defaultValue\",\n    \"directives\"\n  ],\n  InterfaceTypeDefinition: [\n    \"description\",\n    \"name\",\n    \"interfaces\",\n    \"directives\",\n    \"fields\"\n  ],\n  UnionTypeDefinition: [\"description\", \"name\", \"directives\", \"types\"],\n  EnumTypeDefinition: [\"description\", \"name\", \"directives\", \"values\"],\n  EnumValueDefinition: [\"description\", \"name\", \"directives\"],\n  InputObjectTypeDefinition: [\"description\", \"name\", \"directives\", \"fields\"],\n  DirectiveDefinition: [\"description\", \"name\", \"arguments\", \"locations\"],\n  SchemaExtension: [\"directives\", \"operationTypes\"],\n  ScalarTypeExtension: [\"name\", \"directives\"],\n  ObjectTypeExtension: [\"name\", \"interfaces\", \"directives\", \"fields\"],\n  InterfaceTypeExtension: [\"name\", \"interfaces\", \"directives\", \"fields\"],\n  UnionTypeExtension: [\"name\", \"directives\", \"types\"],\n  EnumTypeExtension: [\"name\", \"directives\", \"values\"],\n  InputObjectTypeExtension: [\"name\", \"directives\", \"fields\"]\n};\nconst kindValues = new Set(Object.keys(QueryDocumentKeys));\nfunction isNode(maybeNode) {\n  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;\n  return typeof maybeKind === \"string\" && kindValues.has(maybeKind);\n}\nlet OperationTypeNode;\n(function(OperationTypeNode2) {\n  OperationTypeNode2[\"QUERY\"] = \"query\";\n  OperationTypeNode2[\"MUTATION\"] = \"mutation\";\n  OperationTypeNode2[\"SUBSCRIPTION\"] = \"subscription\";\n})(OperationTypeNode || (OperationTypeNode = {}));\nlet DirectiveLocation;\n(function(DirectiveLocation2) {\n  DirectiveLocation2[\"QUERY\"] = \"QUERY\";\n  DirectiveLocation2[\"MUTATION\"] = \"MUTATION\";\n  DirectiveLocation2[\"SUBSCRIPTION\"] = \"SUBSCRIPTION\";\n  DirectiveLocation2[\"FIELD\"] = \"FIELD\";\n  DirectiveLocation2[\"FRAGMENT_DEFINITION\"] = \"FRAGMENT_DEFINITION\";\n  DirectiveLocation2[\"FRAGMENT_SPREAD\"] = \"FRAGMENT_SPREAD\";\n  DirectiveLocation2[\"INLINE_FRAGMENT\"] = \"INLINE_FRAGMENT\";\n  DirectiveLocation2[\"VARIABLE_DEFINITION\"] = \"VARIABLE_DEFINITION\";\n  DirectiveLocation2[\"SCHEMA\"] = \"SCHEMA\";\n  DirectiveLocation2[\"SCALAR\"] = \"SCALAR\";\n  DirectiveLocation2[\"OBJECT\"] = \"OBJECT\";\n  DirectiveLocation2[\"FIELD_DEFINITION\"] = \"FIELD_DEFINITION\";\n  DirectiveLocation2[\"ARGUMENT_DEFINITION\"] = \"ARGUMENT_DEFINITION\";\n  DirectiveLocation2[\"INTERFACE\"] = \"INTERFACE\";\n  DirectiveLocation2[\"UNION\"] = \"UNION\";\n  DirectiveLocation2[\"ENUM\"] = \"ENUM\";\n  DirectiveLocation2[\"ENUM_VALUE\"] = \"ENUM_VALUE\";\n  DirectiveLocation2[\"INPUT_OBJECT\"] = \"INPUT_OBJECT\";\n  DirectiveLocation2[\"INPUT_FIELD_DEFINITION\"] = \"INPUT_FIELD_DEFINITION\";\n})(DirectiveLocation || (DirectiveLocation = {}));\nlet Kind;\n(function(Kind2) {\n  Kind2[\"NAME\"] = \"Name\";\n  Kind2[\"DOCUMENT\"] = \"Document\";\n  Kind2[\"OPERATION_DEFINITION\"] = \"OperationDefinition\";\n  Kind2[\"VARIABLE_DEFINITION\"] = \"VariableDefinition\";\n  Kind2[\"SELECTION_SET\"] = \"SelectionSet\";\n  Kind2[\"FIELD\"] = \"Field\";\n  Kind2[\"ARGUMENT\"] = \"Argument\";\n  Kind2[\"FRAGMENT_SPREAD\"] = \"FragmentSpread\";\n  Kind2[\"INLINE_FRAGMENT\"] = \"InlineFragment\";\n  Kind2[\"FRAGMENT_DEFINITION\"] = \"FragmentDefinition\";\n  Kind2[\"VARIABLE\"] = \"Variable\";\n  Kind2[\"INT\"] = \"IntValue\";\n  Kind2[\"FLOAT\"] = \"FloatValue\";\n  Kind2[\"STRING\"] = \"StringValue\";\n  Kind2[\"BOOLEAN\"] = \"BooleanValue\";\n  Kind2[\"NULL\"] = \"NullValue\";\n  Kind2[\"ENUM\"] = \"EnumValue\";\n  Kind2[\"LIST\"] = \"ListValue\";\n  Kind2[\"OBJECT\"] = \"ObjectValue\";\n  Kind2[\"OBJECT_FIELD\"] = \"ObjectField\";\n  Kind2[\"DIRECTIVE\"] = \"Directive\";\n  Kind2[\"NAMED_TYPE\"] = \"NamedType\";\n  Kind2[\"LIST_TYPE\"] = \"ListType\";\n  Kind2[\"NON_NULL_TYPE\"] = \"NonNullType\";\n  Kind2[\"SCHEMA_DEFINITION\"] = \"SchemaDefinition\";\n  Kind2[\"OPERATION_TYPE_DEFINITION\"] = \"OperationTypeDefinition\";\n  Kind2[\"SCALAR_TYPE_DEFINITION\"] = \"ScalarTypeDefinition\";\n  Kind2[\"OBJECT_TYPE_DEFINITION\"] = \"ObjectTypeDefinition\";\n  Kind2[\"FIELD_DEFINITION\"] = \"FieldDefinition\";\n  Kind2[\"INPUT_VALUE_DEFINITION\"] = \"InputValueDefinition\";\n  Kind2[\"INTERFACE_TYPE_DEFINITION\"] = \"InterfaceTypeDefinition\";\n  Kind2[\"UNION_TYPE_DEFINITION\"] = \"UnionTypeDefinition\";\n  Kind2[\"ENUM_TYPE_DEFINITION\"] = \"EnumTypeDefinition\";\n  Kind2[\"ENUM_VALUE_DEFINITION\"] = \"EnumValueDefinition\";\n  Kind2[\"INPUT_OBJECT_TYPE_DEFINITION\"] = \"InputObjectTypeDefinition\";\n  Kind2[\"DIRECTIVE_DEFINITION\"] = \"DirectiveDefinition\";\n  Kind2[\"SCHEMA_EXTENSION\"] = \"SchemaExtension\";\n  Kind2[\"SCALAR_TYPE_EXTENSION\"] = \"ScalarTypeExtension\";\n  Kind2[\"OBJECT_TYPE_EXTENSION\"] = \"ObjectTypeExtension\";\n  Kind2[\"INTERFACE_TYPE_EXTENSION\"] = \"InterfaceTypeExtension\";\n  Kind2[\"UNION_TYPE_EXTENSION\"] = \"UnionTypeExtension\";\n  Kind2[\"ENUM_TYPE_EXTENSION\"] = \"EnumTypeExtension\";\n  Kind2[\"INPUT_OBJECT_TYPE_EXTENSION\"] = \"InputObjectTypeExtension\";\n})(Kind || (Kind = {}));\nfunction isWhiteSpace$2(code3) {\n  return code3 === 9 || code3 === 32;\n}\nfunction isDigit$2(code3) {\n  return code3 >= 48 && code3 <= 57;\n}\nfunction isLetter$1(code3) {\n  return code3 >= 97 && code3 <= 122 || code3 >= 65 && code3 <= 90;\n}\nfunction isNameStart(code3) {\n  return isLetter$1(code3) || code3 === 95;\n}\nfunction isNameContinue(code3) {\n  return isLetter$1(code3) || isDigit$2(code3) || code3 === 95;\n}\nfunction dedentBlockStringLines(lines) {\n  var _firstNonEmptyLine2;\n  let commonIndent = Number.MAX_SAFE_INTEGER;\n  let firstNonEmptyLine = null;\n  let lastNonEmptyLine = -1;\n  for (let i = 0; i < lines.length; ++i) {\n    var _firstNonEmptyLine;\n    const line = lines[i];\n    const indent2 = leadingWhitespace$1(line);\n    if (indent2 === line.length) {\n      continue;\n    }\n    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;\n    lastNonEmptyLine = i;\n    if (i !== 0 && indent2 < commonIndent) {\n      commonIndent = indent2;\n    }\n  }\n  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);\n}\nfunction leadingWhitespace$1(str) {\n  let i = 0;\n  while (i < str.length && isWhiteSpace$2(str.charCodeAt(i))) {\n    ++i;\n  }\n  return i;\n}\nfunction isPrintableAsBlockString(value) {\n  if (value === \"\") {\n    return true;\n  }\n  let isEmptyLine = true;\n  let hasIndent = false;\n  let hasCommonIndent = true;\n  let seenNonEmptyLine = false;\n  for (let i = 0; i < value.length; ++i) {\n    switch (value.codePointAt(i)) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 11:\n      case 12:\n      case 14:\n      case 15:\n        return false;\n      case 13:\n        return false;\n      case 10:\n        if (isEmptyLine && !seenNonEmptyLine) {\n          return false;\n        }\n        seenNonEmptyLine = true;\n        isEmptyLine = true;\n        hasIndent = false;\n        break;\n      case 9:\n      case 32:\n        hasIndent || (hasIndent = isEmptyLine);\n        break;\n      default:\n        hasCommonIndent && (hasCommonIndent = hasIndent);\n        isEmptyLine = false;\n    }\n  }\n  if (isEmptyLine) {\n    return false;\n  }\n  if (hasCommonIndent && seenNonEmptyLine) {\n    return false;\n  }\n  return true;\n}\nfunction printBlockString$1(value, options) {\n  const escapedValue = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  const lines = escapedValue.split(/\\r\\n|[\\n\\r]/g);\n  const isSingleLine = lines.length === 1;\n  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace$2(line.charCodeAt(0)));\n  const hasTrailingTripleQuotes = escapedValue.endsWith('\\\\\"\"\"');\n  const hasTrailingQuote = value.endsWith('\"') && !hasTrailingTripleQuotes;\n  const hasTrailingSlash = value.endsWith(\"\\\\\");\n  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;\n  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);\n  let result2 = \"\";\n  const skipLeadingNewLine = isSingleLine && isWhiteSpace$2(value.charCodeAt(0));\n  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {\n    result2 += \"\\n\";\n  }\n  result2 += escapedValue;\n  if (printAsMultipleLines || forceTrailingNewline) {\n    result2 += \"\\n\";\n  }\n  return '\"\"\"' + result2 + '\"\"\"';\n}\nlet TokenKind;\n(function(TokenKind2) {\n  TokenKind2[\"SOF\"] = \"<SOF>\";\n  TokenKind2[\"EOF\"] = \"<EOF>\";\n  TokenKind2[\"BANG\"] = \"!\";\n  TokenKind2[\"DOLLAR\"] = \"$\";\n  TokenKind2[\"AMP\"] = \"&\";\n  TokenKind2[\"PAREN_L\"] = \"(\";\n  TokenKind2[\"PAREN_R\"] = \")\";\n  TokenKind2[\"SPREAD\"] = \"...\";\n  TokenKind2[\"COLON\"] = \":\";\n  TokenKind2[\"EQUALS\"] = \"=\";\n  TokenKind2[\"AT\"] = \"@\";\n  TokenKind2[\"BRACKET_L\"] = \"[\";\n  TokenKind2[\"BRACKET_R\"] = \"]\";\n  TokenKind2[\"BRACE_L\"] = \"{\";\n  TokenKind2[\"PIPE\"] = \"|\";\n  TokenKind2[\"BRACE_R\"] = \"}\";\n  TokenKind2[\"NAME\"] = \"Name\";\n  TokenKind2[\"INT\"] = \"Int\";\n  TokenKind2[\"FLOAT\"] = \"Float\";\n  TokenKind2[\"STRING\"] = \"String\";\n  TokenKind2[\"BLOCK_STRING\"] = \"BlockString\";\n  TokenKind2[\"COMMENT\"] = \"Comment\";\n})(TokenKind || (TokenKind = {}));\nclass Lexer {\n  constructor(source) {\n    const startOfFileToken = new Token$4(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n  get [Symbol.toStringTag]() {\n    return \"Lexer\";\n  }\n  advance() {\n    this.lastToken = this.token;\n    const token2 = this.token = this.lookahead();\n    return token2;\n  }\n  lookahead() {\n    let token2 = this.token;\n    if (token2.kind !== TokenKind.EOF) {\n      do {\n        if (token2.next) {\n          token2 = token2.next;\n        } else {\n          const nextToken = readNextToken(this, token2.end);\n          token2.next = nextToken;\n          nextToken.prev = token2;\n          token2 = nextToken;\n        }\n      } while (token2.kind === TokenKind.COMMENT);\n    }\n    return token2;\n  }\n}\nfunction isPunctuatorTokenKind(kind2) {\n  return kind2 === TokenKind.BANG || kind2 === TokenKind.DOLLAR || kind2 === TokenKind.AMP || kind2 === TokenKind.PAREN_L || kind2 === TokenKind.PAREN_R || kind2 === TokenKind.SPREAD || kind2 === TokenKind.COLON || kind2 === TokenKind.EQUALS || kind2 === TokenKind.AT || kind2 === TokenKind.BRACKET_L || kind2 === TokenKind.BRACKET_R || kind2 === TokenKind.BRACE_L || kind2 === TokenKind.PIPE || kind2 === TokenKind.BRACE_R;\n}\nfunction isUnicodeScalarValue(code3) {\n  return code3 >= 0 && code3 <= 55295 || code3 >= 57344 && code3 <= 1114111;\n}\nfunction isSupplementaryCodePoint(body, location) {\n  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));\n}\nfunction isLeadingSurrogate(code3) {\n  return code3 >= 55296 && code3 <= 56319;\n}\nfunction isTrailingSurrogate(code3) {\n  return code3 >= 56320 && code3 <= 57343;\n}\nfunction printCodePointAt(lexer, location) {\n  const code3 = lexer.source.body.codePointAt(location);\n  if (code3 === void 0) {\n    return TokenKind.EOF;\n  } else if (code3 >= 32 && code3 <= 126) {\n    const char = String.fromCodePoint(code3);\n    return char === '\"' ? `'\"'` : `\"${char}\"`;\n  }\n  return \"U+\" + code3.toString(16).toUpperCase().padStart(4, \"0\");\n}\nfunction createToken(lexer, kind2, start2, end2, value) {\n  const line = lexer.line;\n  const col = 1 + start2 - lexer.lineStart;\n  return new Token$4(kind2, start2, end2, line, col, value);\n}\nfunction readNextToken(lexer, start2) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start2;\n  while (position < bodyLength) {\n    const code3 = body.charCodeAt(position);\n    switch (code3) {\n      case 65279:\n      case 9:\n      case 32:\n      case 44:\n        ++position;\n        continue;\n      case 10:\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      case 13:\n        if (body.charCodeAt(position + 1) === 10) {\n          position += 2;\n        } else {\n          ++position;\n        }\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      case 35:\n        return readComment(lexer, position);\n      case 33:\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n      case 36:\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n      case 38:\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n      case 40:\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n      case 41:\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n      case 46:\n        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n        break;\n      case 58:\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n      case 61:\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n      case 64:\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n      case 91:\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n      case 93:\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n      case 123:\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n      case 124:\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n      case 125:\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      case 34:\n        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n          return readBlockString(lexer, position);\n        }\n        return readString$1(lexer, position);\n    }\n    if (isDigit$2(code3) || code3 === 45) {\n      return readNumber$1(lexer, position, code3);\n    }\n    if (isNameStart(code3)) {\n      return readName(lexer, position);\n    }\n    throw syntaxError$1(lexer.source, position, code3 === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (\")?` : isUnicodeScalarValue(code3) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);\n  }\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\nfunction readComment(lexer, start2) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start2 + 1;\n  while (position < bodyLength) {\n    const code3 = body.charCodeAt(position);\n    if (code3 === 10 || code3 === 13) {\n      break;\n    }\n    if (isUnicodeScalarValue(code3)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n  return createToken(lexer, TokenKind.COMMENT, start2, position, body.slice(start2 + 1, position));\n}\nfunction readNumber$1(lexer, start2, firstCode) {\n  const body = lexer.source.body;\n  let position = start2;\n  let code3 = firstCode;\n  let isFloat = false;\n  if (code3 === 45) {\n    code3 = body.charCodeAt(++position);\n  }\n  if (code3 === 48) {\n    code3 = body.charCodeAt(++position);\n    if (isDigit$2(code3)) {\n      throw syntaxError$1(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);\n    }\n  } else {\n    position = readDigits$1(lexer, position, code3);\n    code3 = body.charCodeAt(position);\n  }\n  if (code3 === 46) {\n    isFloat = true;\n    code3 = body.charCodeAt(++position);\n    position = readDigits$1(lexer, position, code3);\n    code3 = body.charCodeAt(position);\n  }\n  if (code3 === 69 || code3 === 101) {\n    isFloat = true;\n    code3 = body.charCodeAt(++position);\n    if (code3 === 43 || code3 === 45) {\n      code3 = body.charCodeAt(++position);\n    }\n    position = readDigits$1(lexer, position, code3);\n    code3 = body.charCodeAt(position);\n  }\n  if (code3 === 46 || isNameStart(code3)) {\n    throw syntaxError$1(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);\n  }\n  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start2, position, body.slice(start2, position));\n}\nfunction readDigits$1(lexer, start2, firstCode) {\n  if (!isDigit$2(firstCode)) {\n    throw syntaxError$1(lexer.source, start2, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start2)}.`);\n  }\n  const body = lexer.source.body;\n  let position = start2 + 1;\n  while (isDigit$2(body.charCodeAt(position))) {\n    ++position;\n  }\n  return position;\n}\nfunction readString$1(lexer, start2) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start2 + 1;\n  let chunkStart = position;\n  let value = \"\";\n  while (position < bodyLength) {\n    const code3 = body.charCodeAt(position);\n    if (code3 === 34) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start2, position + 1, value);\n    }\n    if (code3 === 92) {\n      value += body.slice(chunkStart, position);\n      const escape3 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);\n      value += escape3.value;\n      position += escape3.size;\n      chunkStart = position;\n      continue;\n    }\n    if (code3 === 10 || code3 === 13) {\n      break;\n    }\n    if (isUnicodeScalarValue(code3)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError$1(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);\n    }\n  }\n  throw syntaxError$1(lexer.source, position, \"Unterminated string.\");\n}\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3;\n  while (size < 12) {\n    const code3 = body.charCodeAt(position + size++);\n    if (code3 === 125) {\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n      return {\n        value: String.fromCodePoint(point),\n        size\n      };\n    }\n    point = point << 4 | readHexDigit(code3);\n    if (point < 0) {\n      break;\n    }\n  }\n  throw syntaxError$1(lexer.source, position, `Invalid Unicode escape sequence: \"${body.slice(position, position + size)}\".`);\n}\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code3 = read16BitHexCode(body, position + 2);\n  if (isUnicodeScalarValue(code3)) {\n    return {\n      value: String.fromCodePoint(code3),\n      size: 6\n    };\n  }\n  if (isLeadingSurrogate(code3)) {\n    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n      if (isTrailingSurrogate(trailingCode)) {\n        return {\n          value: String.fromCodePoint(code3, trailingCode),\n          size: 12\n        };\n      }\n    }\n  }\n  throw syntaxError$1(lexer.source, position, `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`);\n}\nfunction read16BitHexCode(body, position) {\n  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));\n}\nfunction readHexDigit(code3) {\n  return code3 >= 48 && code3 <= 57 ? code3 - 48 : code3 >= 65 && code3 <= 70 ? code3 - 55 : code3 >= 97 && code3 <= 102 ? code3 - 87 : -1;\n}\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code3 = body.charCodeAt(position + 1);\n  switch (code3) {\n    case 34:\n      return {\n        value: '\"',\n        size: 2\n      };\n    case 92:\n      return {\n        value: \"\\\\\",\n        size: 2\n      };\n    case 47:\n      return {\n        value: \"/\",\n        size: 2\n      };\n    case 98:\n      return {\n        value: \"\\b\",\n        size: 2\n      };\n    case 102:\n      return {\n        value: \"\\f\",\n        size: 2\n      };\n    case 110:\n      return {\n        value: \"\\n\",\n        size: 2\n      };\n    case 114:\n      return {\n        value: \"\\r\",\n        size: 2\n      };\n    case 116:\n      return {\n        value: \"\t\",\n        size: 2\n      };\n  }\n  throw syntaxError$1(lexer.source, position, `Invalid character escape sequence: \"${body.slice(position, position + 2)}\".`);\n}\nfunction readBlockString(lexer, start2) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start2 + 3;\n  let chunkStart = position;\n  let currentLine = \"\";\n  const blockLines = [];\n  while (position < bodyLength) {\n    const code3 = body.charCodeAt(position);\n    if (code3 === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token2 = createToken(lexer, TokenKind.BLOCK_STRING, start2, position + 3, dedentBlockStringLines(blockLines).join(\"\\n\"));\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token2;\n    }\n    if (code3 === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1;\n      position += 4;\n      continue;\n    }\n    if (code3 === 10 || code3 === 13) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      if (code3 === 13 && body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n      currentLine = \"\";\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    }\n    if (isUnicodeScalarValue(code3)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError$1(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);\n    }\n  }\n  throw syntaxError$1(lexer.source, position, \"Unterminated string.\");\n}\nfunction readName(lexer, start2) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start2 + 1;\n  while (position < bodyLength) {\n    const code3 = body.charCodeAt(position);\n    if (isNameContinue(code3)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n  return createToken(lexer, TokenKind.NAME, start2, position, body.slice(start2, position));\n}\nconst MAX_ARRAY_LENGTH$1 = 10;\nconst MAX_RECURSIVE_DEPTH$2 = 2;\nfunction inspect$2(value) {\n  return formatValue$2(value, []);\n}\nfunction formatValue$2(value, seenValues) {\n  switch (typeof value) {\n    case \"string\":\n      return JSON.stringify(value);\n    case \"function\":\n      return value.name ? `[function ${value.name}]` : \"[function]\";\n    case \"object\":\n      return formatObjectValue$2(value, seenValues);\n    default:\n      return String(value);\n  }\n}\nfunction formatObjectValue$2(value, previouslySeenValues) {\n  if (value === null) {\n    return \"null\";\n  }\n  if (previouslySeenValues.includes(value)) {\n    return \"[Circular]\";\n  }\n  const seenValues = [...previouslySeenValues, value];\n  if (isJSONable$2(value)) {\n    const jsonValue = value.toJSON();\n    if (jsonValue !== value) {\n      return typeof jsonValue === \"string\" ? jsonValue : formatValue$2(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray$2(value, seenValues);\n  }\n  return formatObject$2(value, seenValues);\n}\nfunction isJSONable$2(value) {\n  return typeof value.toJSON === \"function\";\n}\nfunction formatObject$2(object, seenValues) {\n  const entries = Object.entries(object);\n  if (entries.length === 0) {\n    return \"{}\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH$2) {\n    return \"[\" + getObjectTag$2(object) + \"]\";\n  }\n  const properties = entries.map(([key, value]) => key + \": \" + formatValue$2(value, seenValues));\n  return \"{ \" + properties.join(\", \") + \" }\";\n}\nfunction formatArray$2(array, seenValues) {\n  if (array.length === 0) {\n    return \"[]\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH$2) {\n    return \"[Array]\";\n  }\n  const len = Math.min(MAX_ARRAY_LENGTH$1, array.length);\n  const remaining = array.length - len;\n  const items = [];\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue$2(array[i], seenValues));\n  }\n  if (remaining === 1) {\n    items.push(\"... 1 more item\");\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n  return \"[\" + items.join(\", \") + \"]\";\n}\nfunction getObjectTag$2(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, \"\").replace(/]$/, \"\");\n  if (tag === \"Object\" && typeof object.constructor === \"function\") {\n    const name2 = object.constructor.name;\n    if (typeof name2 === \"string\" && name2 !== \"\") {\n      return name2;\n    }\n  }\n  return tag;\n}\nconst instanceOf = function instanceOf2(value, constructor) {\n  return value instanceof constructor;\n};\nclass Source {\n  constructor(body, name2 = \"GraphQL request\", locationOffset = {\n    line: 1,\n    column: 1\n  }) {\n    typeof body === \"string\" || devAssert$1(false, `Body must be a string. Received: ${inspect$2(body)}.`);\n    this.body = body;\n    this.name = name2;\n    this.locationOffset = locationOffset;\n    this.locationOffset.line > 0 || devAssert$1(false, \"line in locationOffset is 1-indexed and must be positive.\");\n    this.locationOffset.column > 0 || devAssert$1(false, \"column in locationOffset is 1-indexed and must be positive.\");\n  }\n  get [Symbol.toStringTag]() {\n    return \"Source\";\n  }\n}\nfunction isSource(source) {\n  return instanceOf(source, Source);\n}\nfunction parse$1(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\nfunction parseValue$1(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\nfunction parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\nfunction parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type2 = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type2;\n}\nclass Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  parseName() {\n    const token2 = this.expectToken(TokenKind.NAME);\n    return this.node(token2, {\n      kind: Kind.NAME,\n      value: token2.value\n    });\n  }\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)\n    });\n  }\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    }\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case \"schema\":\n          return this.parseSchemaDefinition();\n        case \"scalar\":\n          return this.parseScalarTypeDefinition();\n        case \"type\":\n          return this.parseObjectTypeDefinition();\n        case \"interface\":\n          return this.parseInterfaceTypeDefinition();\n        case \"union\":\n          return this.parseUnionTypeDefinition();\n        case \"enum\":\n          return this.parseEnumTypeDefinition();\n        case \"input\":\n          return this.parseInputObjectTypeDefinition();\n        case \"directive\":\n          return this.parseDirectiveDefinition();\n      }\n      if (hasDescription) {\n        throw syntaxError$1(this._lexer.source, this._lexer.token.start, \"Unexpected description, descriptions are supported only on type definitions.\");\n      }\n      switch (keywordToken.value) {\n        case \"query\":\n        case \"mutation\":\n        case \"subscription\":\n          return this.parseOperationDefinition();\n        case \"fragment\":\n          return this.parseFragmentDefinition();\n        case \"extend\":\n          return this.parseTypeSystemExtension();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  }\n  parseOperationDefinition() {\n    const start2 = this._lexer.token;\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start2, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: void 0,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    const operation = this.parseOperationType();\n    let name2;\n    if (this.peek(TokenKind.NAME)) {\n      name2 = this.parseName();\n    }\n    return this.node(start2, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name: name2,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n    switch (operationToken.value) {\n      case \"query\":\n        return OperationTypeNode.QUERY;\n      case \"mutation\":\n        return OperationTypeNode.MUTATION;\n      case \"subscription\":\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n    throw this.unexpected(operationToken);\n  }\n  parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,\n      directives: this.parseConstDirectives()\n    });\n  }\n  parseVariable() {\n    const start2 = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start2, {\n      kind: Kind.VARIABLE,\n      name: this.parseName()\n    });\n  }\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)\n    });\n  }\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  parseField() {\n    const start2 = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name2;\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name2 = this.parseName();\n    } else {\n      name2 = nameOrAlias;\n    }\n    return this.node(start2, {\n      kind: Kind.FIELD,\n      alias,\n      name: name2,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0\n    });\n  }\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  parseArgument(isConst = false) {\n    const start2 = this._lexer.token;\n    const name2 = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start2, {\n      kind: Kind.ARGUMENT,\n      name: name2,\n      value: this.parseValueLiteral(isConst)\n    });\n  }\n  parseConstArgument() {\n    return this.parseArgument(true);\n  }\n  parseFragment() {\n    const start2 = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword(\"on\");\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start2, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false)\n      });\n    }\n    return this.node(start2, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  parseFragmentDefinition() {\n    var _this$_options;\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"fragment\");\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {\n      return this.node(start2, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword(\"on\"), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    return this.node(start2, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword(\"on\"), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  parseFragmentName() {\n    if (this._lexer.token.value === \"on\") {\n      throw this.unexpected();\n    }\n    return this.parseName();\n  }\n  parseValueLiteral(isConst) {\n    const token2 = this._lexer.token;\n    switch (token2.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n      case TokenKind.INT:\n        this._lexer.advance();\n        return this.node(token2, {\n          kind: Kind.INT,\n          value: token2.value\n        });\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n        return this.node(token2, {\n          kind: Kind.FLOAT,\n          value: token2.value\n        });\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n      case TokenKind.NAME:\n        this._lexer.advance();\n        switch (token2.value) {\n          case \"true\":\n            return this.node(token2, {\n              kind: Kind.BOOLEAN,\n              value: true\n            });\n          case \"false\":\n            return this.node(token2, {\n              kind: Kind.BOOLEAN,\n              value: false\n            });\n          case \"null\":\n            return this.node(token2, {\n              kind: Kind.NULL\n            });\n          default:\n            return this.node(token2, {\n              kind: Kind.ENUM,\n              value: token2.value\n            });\n        }\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError$1(this._lexer.source, token2.start, `Unexpected variable \"$${varName}\" in constant value.`);\n          } else {\n            throw this.unexpected(token2);\n          }\n        }\n        return this.parseVariable();\n      default:\n        throw this.unexpected();\n    }\n  }\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n  parseStringLiteral() {\n    const token2 = this._lexer.token;\n    this._lexer.advance();\n    return this.node(token2, {\n      kind: Kind.STRING,\n      value: token2.value,\n      block: token2.kind === TokenKind.BLOCK_STRING\n    });\n  }\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)\n    });\n  }\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)\n    });\n  }\n  parseObjectField(isConst) {\n    const start2 = this._lexer.token;\n    const name2 = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start2, {\n      kind: Kind.OBJECT_FIELD,\n      name: name2,\n      value: this.parseValueLiteral(isConst)\n    });\n  }\n  parseDirectives(isConst) {\n    const directives = [];\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n    return directives;\n  }\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  parseDirective(isConst) {\n    const start2 = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start2, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst)\n    });\n  }\n  parseTypeReference() {\n    const start2 = this._lexer.token;\n    let type2;\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type2 = this.node(start2, {\n        kind: Kind.LIST_TYPE,\n        type: innerType\n      });\n    } else {\n      type2 = this.parseNamedType();\n    }\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start2, {\n        kind: Kind.NON_NULL_TYPE,\n        type: type2\n      });\n    }\n    return type2;\n  }\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName()\n    });\n  }\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  parseSchemaDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"schema\");\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return this.node(start2, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes\n    });\n  }\n  parseOperationTypeDefinition() {\n    const start2 = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type2 = this.parseNamedType();\n    return this.node(start2, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type: type2\n    });\n  }\n  parseScalarTypeDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"scalar\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start2, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name: name2,\n      directives\n    });\n  }\n  parseObjectTypeDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"type\");\n    const name2 = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start2, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name: name2,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword(\"implements\") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];\n  }\n  parseFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  parseFieldDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    const name2 = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type2 = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start2, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name: name2,\n      arguments: args,\n      type: type2,\n      directives\n    });\n  }\n  parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  parseInputValueDef() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    const name2 = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type2 = this.parseTypeReference();\n    let defaultValue2;\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue2 = this.parseConstValueLiteral();\n    }\n    const directives = this.parseConstDirectives();\n    return this.node(start2, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name: name2,\n      type: type2,\n      defaultValue: defaultValue2,\n      directives\n    });\n  }\n  parseInterfaceTypeDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"interface\");\n    const name2 = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start2, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name: name2,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  parseUnionTypeDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"union\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start2, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name: name2,\n      directives,\n      types\n    });\n  }\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  parseEnumTypeDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"enum\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start2, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name: name2,\n      directives,\n      values\n    });\n  }\n  parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  parseEnumValueDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    const name2 = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start2, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name: name2,\n      directives\n    });\n  }\n  parseEnumValueName() {\n    if (this._lexer.token.value === \"true\" || this._lexer.token.value === \"false\" || this._lexer.token.value === \"null\") {\n      throw syntaxError$1(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);\n    }\n    return this.parseName();\n  }\n  parseInputObjectTypeDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"input\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start2, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name: name2,\n      directives,\n      fields\n    });\n  }\n  parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case \"schema\":\n          return this.parseSchemaExtension();\n        case \"scalar\":\n          return this.parseScalarTypeExtension();\n        case \"type\":\n          return this.parseObjectTypeExtension();\n        case \"interface\":\n          return this.parseInterfaceTypeExtension();\n        case \"union\":\n          return this.parseUnionTypeExtension();\n        case \"enum\":\n          return this.parseEnumTypeExtension();\n        case \"input\":\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  }\n  parseSchemaExtension() {\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"schema\");\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start2, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes\n    });\n  }\n  parseScalarTypeExtension() {\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"scalar\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start2, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name2,\n      directives\n    });\n  }\n  parseObjectTypeExtension() {\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"type\");\n    const name2 = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start2, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name2,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  parseInterfaceTypeExtension() {\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"interface\");\n    const name2 = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start2, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name2,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  parseUnionTypeExtension() {\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"union\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start2, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name2,\n      directives,\n      types\n    });\n  }\n  parseEnumTypeExtension() {\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"enum\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start2, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name2,\n      directives,\n      values\n    });\n  }\n  parseInputObjectTypeExtension() {\n    const start2 = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"input\");\n    const name2 = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start2, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name2,\n      directives,\n      fields\n    });\n  }\n  parseDirectiveDefinition() {\n    const start2 = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword(\"directive\");\n    this.expectToken(TokenKind.AT);\n    const name2 = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword(\"repeatable\");\n    this.expectKeyword(\"on\");\n    const locations = this.parseDirectiveLocations();\n    return this.node(start2, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name: name2,\n      arguments: args,\n      repeatable,\n      locations\n    });\n  }\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  parseDirectiveLocation() {\n    const start2 = this._lexer.token;\n    const name2 = this.parseName();\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name2.value)) {\n      return name2;\n    }\n    throw this.unexpected(start2);\n  }\n  node(startToken, node) {\n    var _this$_options2;\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {\n      node.loc = new Location$1(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n    return node;\n  }\n  peek(kind2) {\n    return this._lexer.token.kind === kind2;\n  }\n  expectToken(kind2) {\n    const token2 = this._lexer.token;\n    if (token2.kind === kind2) {\n      this._lexer.advance();\n      return token2;\n    }\n    throw syntaxError$1(this._lexer.source, token2.start, `Expected ${getTokenKindDesc(kind2)}, found ${getTokenDesc(token2)}.`);\n  }\n  expectOptionalToken(kind2) {\n    const token2 = this._lexer.token;\n    if (token2.kind === kind2) {\n      this._lexer.advance();\n      return true;\n    }\n    return false;\n  }\n  expectKeyword(value) {\n    const token2 = this._lexer.token;\n    if (token2.kind === TokenKind.NAME && token2.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError$1(this._lexer.source, token2.start, `Expected \"${value}\", found ${getTokenDesc(token2)}.`);\n    }\n  }\n  expectOptionalKeyword(value) {\n    const token2 = this._lexer.token;\n    if (token2.kind === TokenKind.NAME && token2.value === value) {\n      this._lexer.advance();\n      return true;\n    }\n    return false;\n  }\n  unexpected(atToken) {\n    const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError$1(this._lexer.source, token2.start, `Unexpected ${getTokenDesc(token2)}.`);\n  }\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n    return nodes;\n  }\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n      return nodes;\n    }\n    return [];\n  }\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n    return nodes;\n  }\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n    return nodes;\n  }\n}\nfunction getTokenDesc(token2) {\n  const value = token2.value;\n  return getTokenKindDesc(token2.kind) + (value != null ? ` \"${value}\"` : \"\");\n}\nfunction getTokenKindDesc(kind2) {\n  return isPunctuatorTokenKind(kind2) ? `\"${kind2}\"` : kind2;\n}\nconst MAX_SUGGESTIONS$1 = 5;\nfunction didYouMean$1(firstArg, secondArg) {\n  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];\n  let message = \" Did you mean \";\n  if (subMessage) {\n    message += subMessage + \" \";\n  }\n  const suggestions = suggestionsArg.map((x2) => `\"${x2}\"`);\n  switch (suggestions.length) {\n    case 0:\n      return \"\";\n    case 1:\n      return message + suggestions[0] + \"?\";\n    case 2:\n      return message + suggestions[0] + \" or \" + suggestions[1] + \"?\";\n  }\n  const selected = suggestions.slice(0, MAX_SUGGESTIONS$1);\n  const lastItem = selected.pop();\n  return message + selected.join(\", \") + \", or \" + lastItem + \"?\";\n}\nfunction identityFunc(x2) {\n  return x2;\n}\nfunction keyMap$1(list3, keyFn) {\n  const result2 = /* @__PURE__ */ Object.create(null);\n  for (const item of list3) {\n    result2[keyFn(item)] = item;\n  }\n  return result2;\n}\nfunction keyValMap(list3, keyFn, valFn) {\n  const result2 = /* @__PURE__ */ Object.create(null);\n  for (const item of list3) {\n    result2[keyFn(item)] = valFn(item);\n  }\n  return result2;\n}\nfunction mapValue(map2, fn) {\n  const result2 = /* @__PURE__ */ Object.create(null);\n  for (const key of Object.keys(map2)) {\n    result2[key] = fn(map2[key], key);\n  }\n  return result2;\n}\nfunction naturalCompare$1(aStr, bStr) {\n  let aIndex = 0;\n  let bIndex = 0;\n  while (aIndex < aStr.length && bIndex < bStr.length) {\n    let aChar = aStr.charCodeAt(aIndex);\n    let bChar = bStr.charCodeAt(bIndex);\n    if (isDigit$1(aChar) && isDigit$1(bChar)) {\n      let aNum = 0;\n      do {\n        ++aIndex;\n        aNum = aNum * 10 + aChar - DIGIT_0$1;\n        aChar = aStr.charCodeAt(aIndex);\n      } while (isDigit$1(aChar) && aNum > 0);\n      let bNum = 0;\n      do {\n        ++bIndex;\n        bNum = bNum * 10 + bChar - DIGIT_0$1;\n        bChar = bStr.charCodeAt(bIndex);\n      } while (isDigit$1(bChar) && bNum > 0);\n      if (aNum < bNum) {\n        return -1;\n      }\n      if (aNum > bNum) {\n        return 1;\n      }\n    } else {\n      if (aChar < bChar) {\n        return -1;\n      }\n      if (aChar > bChar) {\n        return 1;\n      }\n      ++aIndex;\n      ++bIndex;\n    }\n  }\n  return aStr.length - bStr.length;\n}\nconst DIGIT_0$1 = 48;\nconst DIGIT_9$1 = 57;\nfunction isDigit$1(code3) {\n  return !isNaN(code3) && DIGIT_0$1 <= code3 && code3 <= DIGIT_9$1;\n}\nfunction suggestionList$1(input, options) {\n  const optionsByDistance = /* @__PURE__ */ Object.create(null);\n  const lexicalDistance2 = new LexicalDistance$1(input);\n  const threshold = Math.floor(input.length * 0.4) + 1;\n  for (const option of options) {\n    const distance = lexicalDistance2.measure(option, threshold);\n    if (distance !== void 0) {\n      optionsByDistance[option] = distance;\n    }\n  }\n  return Object.keys(optionsByDistance).sort((a, b) => {\n    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare$1(a, b);\n  });\n}\nclass LexicalDistance$1 {\n  constructor(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray$1(this._inputLowerCase);\n    this._rows = [\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0)\n    ];\n  }\n  measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n    const optionLowerCase = option.toLowerCase();\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n    let a = stringToArray$1(optionLowerCase);\n    let b = this._inputArray;\n    if (a.length < b.length) {\n      const tmp = a;\n      a = b;\n      b = tmp;\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength - bLength > threshold) {\n      return void 0;\n    }\n    const rows = this._rows;\n    for (let j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n    for (let i = 1; i <= aLength; i++) {\n      const upRow = rows[(i - 1) % 3];\n      const currentRow = rows[i % 3];\n      let smallestCell = currentRow[0] = i;\n      for (let j = 1; j <= bLength; j++) {\n        const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);\n        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n        currentRow[j] = currentCell;\n      }\n      if (smallestCell > threshold) {\n        return void 0;\n      }\n    }\n    const distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : void 0;\n  }\n}\nfunction stringToArray$1(str) {\n  const strLength = str.length;\n  const array = new Array(strLength);\n  for (let i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n}\nfunction toObjMap(obj) {\n  if (obj == null) {\n    return /* @__PURE__ */ Object.create(null);\n  }\n  if (Object.getPrototypeOf(obj) === null) {\n    return obj;\n  }\n  const map2 = /* @__PURE__ */ Object.create(null);\n  for (const [key, value] of Object.entries(obj)) {\n    map2[key] = value;\n  }\n  return map2;\n}\nfunction printString(str) {\n  return `\"${str.replace(escapedRegExp, escapedReplacer)}\"`;\n}\nconst escapedRegExp = /[\\x00-\\x1f\\x22\\x5c\\x7f-\\x9f]/g;\nfunction escapedReplacer(str) {\n  return escapeSequences[str.charCodeAt(0)];\n}\nconst escapeSequences = [\n  \"\\\\u0000\",\n  \"\\\\u0001\",\n  \"\\\\u0002\",\n  \"\\\\u0003\",\n  \"\\\\u0004\",\n  \"\\\\u0005\",\n  \"\\\\u0006\",\n  \"\\\\u0007\",\n  \"\\\\b\",\n  \"\\\\t\",\n  \"\\\\n\",\n  \"\\\\u000B\",\n  \"\\\\f\",\n  \"\\\\r\",\n  \"\\\\u000E\",\n  \"\\\\u000F\",\n  \"\\\\u0010\",\n  \"\\\\u0011\",\n  \"\\\\u0012\",\n  \"\\\\u0013\",\n  \"\\\\u0014\",\n  \"\\\\u0015\",\n  \"\\\\u0016\",\n  \"\\\\u0017\",\n  \"\\\\u0018\",\n  \"\\\\u0019\",\n  \"\\\\u001A\",\n  \"\\\\u001B\",\n  \"\\\\u001C\",\n  \"\\\\u001D\",\n  \"\\\\u001E\",\n  \"\\\\u001F\",\n  \"\",\n  \"\",\n  '\\\\\"',\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\\\\\\\\\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\",\n  \"\\\\u007F\",\n  \"\\\\u0080\",\n  \"\\\\u0081\",\n  \"\\\\u0082\",\n  \"\\\\u0083\",\n  \"\\\\u0084\",\n  \"\\\\u0085\",\n  \"\\\\u0086\",\n  \"\\\\u0087\",\n  \"\\\\u0088\",\n  \"\\\\u0089\",\n  \"\\\\u008A\",\n  \"\\\\u008B\",\n  \"\\\\u008C\",\n  \"\\\\u008D\",\n  \"\\\\u008E\",\n  \"\\\\u008F\",\n  \"\\\\u0090\",\n  \"\\\\u0091\",\n  \"\\\\u0092\",\n  \"\\\\u0093\",\n  \"\\\\u0094\",\n  \"\\\\u0095\",\n  \"\\\\u0096\",\n  \"\\\\u0097\",\n  \"\\\\u0098\",\n  \"\\\\u0099\",\n  \"\\\\u009A\",\n  \"\\\\u009B\",\n  \"\\\\u009C\",\n  \"\\\\u009D\",\n  \"\\\\u009E\",\n  \"\\\\u009F\"\n];\nconst BREAK = Object.freeze({});\nfunction visit(root2, visitor, visitorKeys = QueryDocumentKeys) {\n  const enterLeaveMap = /* @__PURE__ */ new Map();\n  for (const kind2 of Object.values(Kind)) {\n    enterLeaveMap.set(kind2, getEnterLeaveForKind(visitor, kind2));\n  }\n  let stack = void 0;\n  let inArray = Array.isArray(root2);\n  let keys = [root2];\n  let index = -1;\n  let edits = [];\n  let node = root2;\n  let key = void 0;\n  let parent = void 0;\n  const path = [];\n  const ancestors = [];\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? void 0 : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === null || node === void 0) {\n        continue;\n      }\n      path.push(key);\n    }\n    let result2;\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n      isNode(node) || devAssert$1(false, `Invalid AST Node: ${inspect$2(node)}.`);\n      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;\n      result2 = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);\n      if (result2 === BREAK) {\n        break;\n      }\n      if (result2 === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result2 !== void 0) {\n        edits.push([key, result2]);\n        if (!isLeaving) {\n          if (isNode(result2)) {\n            node = result2;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n    if (result2 === void 0 && isEdited) {\n      edits.push([key, node]);\n    }\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== void 0);\n  if (edits.length !== 0) {\n    return edits[edits.length - 1][1];\n  }\n  return root2;\n}\nfunction visitInParallel(visitors) {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = /* @__PURE__ */ Object.create(null);\n  for (const kind2 of Object.values(Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(void 0);\n    const leaveList = new Array(visitors.length).fill(void 0);\n    for (let i = 0; i < visitors.length; ++i) {\n      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind2);\n      hasVisitor || (hasVisitor = enter != null || leave != null);\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n    if (!hasVisitor) {\n      continue;\n    }\n    const mergedEnterLeave = {\n      enter(...args) {\n        const node = args[0];\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _enterList$i;\n            const result2 = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);\n            if (result2 === false) {\n              skipping[i] = node;\n            } else if (result2 === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result2 !== void 0) {\n              return result2;\n            }\n          }\n        }\n      },\n      leave(...args) {\n        const node = args[0];\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _leaveList$i;\n            const result2 = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);\n            if (result2 === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result2 !== void 0 && result2 !== false) {\n              return result2;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      }\n    };\n    mergedVisitor[kind2] = mergedEnterLeave;\n  }\n  return mergedVisitor;\n}\nfunction getEnterLeaveForKind(visitor, kind2) {\n  const kindVisitor = visitor[kind2];\n  if (typeof kindVisitor === \"object\") {\n    return kindVisitor;\n  } else if (typeof kindVisitor === \"function\") {\n    return {\n      enter: kindVisitor,\n      leave: void 0\n    };\n  }\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave\n  };\n}\nfunction getVisitFn(visitor, kind2, isLeaving) {\n  const { enter, leave } = getEnterLeaveForKind(visitor, kind2);\n  return isLeaving ? leave : enter;\n}\nfunction print(ast2) {\n  return visit(ast2, printDocASTReducer$1);\n}\nconst MAX_LINE_LENGTH$1 = 80;\nconst printDocASTReducer$1 = {\n  Name: {\n    leave: (node) => node.value\n  },\n  Variable: {\n    leave: (node) => \"$\" + node.name\n  },\n  Document: {\n    leave: (node) => join$1(node.definitions, \"\\n\\n\")\n  },\n  OperationDefinition: {\n    leave(node) {\n      const varDefs = wrap$1(\"(\", join$1(node.variableDefinitions, \", \"), \")\");\n      const prefix = join$1([\n        node.operation,\n        join$1([node.name, varDefs]),\n        join$1(node.directives, \" \")\n      ], \" \");\n      return (prefix === \"query\" ? \"\" : prefix + \" \") + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: ({ variable, type: type2, defaultValue: defaultValue2, directives }) => variable + \": \" + type2 + wrap$1(\" = \", defaultValue2) + wrap$1(\" \", join$1(directives, \" \"))\n  },\n  SelectionSet: {\n    leave: ({ selections }) => block$3(selections)\n  },\n  Field: {\n    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {\n      const prefix = wrap$1(\"\", alias, \": \") + name2;\n      let argsLine = prefix + wrap$1(\"(\", join$1(args, \", \"), \")\");\n      if (argsLine.length > MAX_LINE_LENGTH$1) {\n        argsLine = prefix + wrap$1(\"(\\n\", indent$4(join$1(args, \"\\n\")), \"\\n)\");\n      }\n      return join$1([argsLine, join$1(directives, \" \"), selectionSet], \" \");\n    }\n  },\n  Argument: {\n    leave: ({ name: name2, value }) => name2 + \": \" + value\n  },\n  FragmentSpread: {\n    leave: ({ name: name2, directives }) => \"...\" + name2 + wrap$1(\" \", join$1(directives, \" \"))\n  },\n  InlineFragment: {\n    leave: ({ typeCondition, directives, selectionSet }) => join$1([\n      \"...\",\n      wrap$1(\"on \", typeCondition),\n      join$1(directives, \" \"),\n      selectionSet\n    ], \" \")\n  },\n  FragmentDefinition: {\n    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name2}${wrap$1(\"(\", join$1(variableDefinitions, \", \"), \")\")} on ${typeCondition} ${wrap$1(\"\", join$1(directives, \" \"), \" \")}` + selectionSet\n  },\n  IntValue: {\n    leave: ({ value }) => value\n  },\n  FloatValue: {\n    leave: ({ value }) => value\n  },\n  StringValue: {\n    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString$1(value) : printString(value)\n  },\n  BooleanValue: {\n    leave: ({ value }) => value ? \"true\" : \"false\"\n  },\n  NullValue: {\n    leave: () => \"null\"\n  },\n  EnumValue: {\n    leave: ({ value }) => value\n  },\n  ListValue: {\n    leave: ({ values }) => \"[\" + join$1(values, \", \") + \"]\"\n  },\n  ObjectValue: {\n    leave: ({ fields }) => \"{\" + join$1(fields, \", \") + \"}\"\n  },\n  ObjectField: {\n    leave: ({ name: name2, value }) => name2 + \": \" + value\n  },\n  Directive: {\n    leave: ({ name: name2, arguments: args }) => \"@\" + name2 + wrap$1(\"(\", join$1(args, \", \"), \")\")\n  },\n  NamedType: {\n    leave: ({ name: name2 }) => name2\n  },\n  ListType: {\n    leave: ({ type: type2 }) => \"[\" + type2 + \"]\"\n  },\n  NonNullType: {\n    leave: ({ type: type2 }) => type2 + \"!\"\n  },\n  SchemaDefinition: {\n    leave: ({ description, directives, operationTypes }) => wrap$1(\"\", description, \"\\n\") + join$1([\"schema\", join$1(directives, \" \"), block$3(operationTypes)], \" \")\n  },\n  OperationTypeDefinition: {\n    leave: ({ operation, type: type2 }) => operation + \": \" + type2\n  },\n  ScalarTypeDefinition: {\n    leave: ({ description, name: name2, directives }) => wrap$1(\"\", description, \"\\n\") + join$1([\"scalar\", name2, join$1(directives, \" \")], \" \")\n  },\n  ObjectTypeDefinition: {\n    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap$1(\"\", description, \"\\n\") + join$1([\n      \"type\",\n      name2,\n      wrap$1(\"implements \", join$1(interfaces, \" & \")),\n      join$1(directives, \" \"),\n      block$3(fields)\n    ], \" \")\n  },\n  FieldDefinition: {\n    leave: ({ description, name: name2, arguments: args, type: type2, directives }) => wrap$1(\"\", description, \"\\n\") + name2 + (hasMultilineItems$1(args) ? wrap$1(\"(\\n\", indent$4(join$1(args, \"\\n\")), \"\\n)\") : wrap$1(\"(\", join$1(args, \", \"), \")\")) + \": \" + type2 + wrap$1(\" \", join$1(directives, \" \"))\n  },\n  InputValueDefinition: {\n    leave: ({ description, name: name2, type: type2, defaultValue: defaultValue2, directives }) => wrap$1(\"\", description, \"\\n\") + join$1([name2 + \": \" + type2, wrap$1(\"= \", defaultValue2), join$1(directives, \" \")], \" \")\n  },\n  InterfaceTypeDefinition: {\n    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap$1(\"\", description, \"\\n\") + join$1([\n      \"interface\",\n      name2,\n      wrap$1(\"implements \", join$1(interfaces, \" & \")),\n      join$1(directives, \" \"),\n      block$3(fields)\n    ], \" \")\n  },\n  UnionTypeDefinition: {\n    leave: ({ description, name: name2, directives, types }) => wrap$1(\"\", description, \"\\n\") + join$1([\"union\", name2, join$1(directives, \" \"), wrap$1(\"= \", join$1(types, \" | \"))], \" \")\n  },\n  EnumTypeDefinition: {\n    leave: ({ description, name: name2, directives, values }) => wrap$1(\"\", description, \"\\n\") + join$1([\"enum\", name2, join$1(directives, \" \"), block$3(values)], \" \")\n  },\n  EnumValueDefinition: {\n    leave: ({ description, name: name2, directives }) => wrap$1(\"\", description, \"\\n\") + join$1([name2, join$1(directives, \" \")], \" \")\n  },\n  InputObjectTypeDefinition: {\n    leave: ({ description, name: name2, directives, fields }) => wrap$1(\"\", description, \"\\n\") + join$1([\"input\", name2, join$1(directives, \" \"), block$3(fields)], \" \")\n  },\n  DirectiveDefinition: {\n    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap$1(\"\", description, \"\\n\") + \"directive @\" + name2 + (hasMultilineItems$1(args) ? wrap$1(\"(\\n\", indent$4(join$1(args, \"\\n\")), \"\\n)\") : wrap$1(\"(\", join$1(args, \", \"), \")\")) + (repeatable ? \" repeatable\" : \"\") + \" on \" + join$1(locations, \" | \")\n  },\n  SchemaExtension: {\n    leave: ({ directives, operationTypes }) => join$1([\"extend schema\", join$1(directives, \" \"), block$3(operationTypes)], \" \")\n  },\n  ScalarTypeExtension: {\n    leave: ({ name: name2, directives }) => join$1([\"extend scalar\", name2, join$1(directives, \" \")], \" \")\n  },\n  ObjectTypeExtension: {\n    leave: ({ name: name2, interfaces, directives, fields }) => join$1([\n      \"extend type\",\n      name2,\n      wrap$1(\"implements \", join$1(interfaces, \" & \")),\n      join$1(directives, \" \"),\n      block$3(fields)\n    ], \" \")\n  },\n  InterfaceTypeExtension: {\n    leave: ({ name: name2, interfaces, directives, fields }) => join$1([\n      \"extend interface\",\n      name2,\n      wrap$1(\"implements \", join$1(interfaces, \" & \")),\n      join$1(directives, \" \"),\n      block$3(fields)\n    ], \" \")\n  },\n  UnionTypeExtension: {\n    leave: ({ name: name2, directives, types }) => join$1([\n      \"extend union\",\n      name2,\n      join$1(directives, \" \"),\n      wrap$1(\"= \", join$1(types, \" | \"))\n    ], \" \")\n  },\n  EnumTypeExtension: {\n    leave: ({ name: name2, directives, values }) => join$1([\"extend enum\", name2, join$1(directives, \" \"), block$3(values)], \" \")\n  },\n  InputObjectTypeExtension: {\n    leave: ({ name: name2, directives, fields }) => join$1([\"extend input\", name2, join$1(directives, \" \"), block$3(fields)], \" \")\n  }\n};\nfunction join$1(maybeArray, separator2 = \"\") {\n  var _maybeArray$filter$jo;\n  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator2)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : \"\";\n}\nfunction block$3(array) {\n  return wrap$1(\"{\\n\", indent$4(join$1(array, \"\\n\")), \"\\n}\");\n}\nfunction wrap$1(start2, maybeString, end2 = \"\") {\n  return maybeString != null && maybeString !== \"\" ? start2 + maybeString + end2 : \"\";\n}\nfunction indent$4(str) {\n  return wrap$1(\"  \", str.replace(/\\n/g, \"\\n  \"));\n}\nfunction hasMultilineItems$1(maybeArray) {\n  var _maybeArray$some;\n  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes(\"\\n\"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;\n}\nvar printer = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  print\n});\nfunction valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n    case Kind.LIST:\n      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));\n    case Kind.OBJECT:\n      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));\n    case Kind.VARIABLE:\n      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];\n  }\n}\nfunction assertName(name2) {\n  name2 != null || devAssert$1(false, \"Must provide name.\");\n  typeof name2 === \"string\" || devAssert$1(false, \"Expected name to be a string.\");\n  if (name2.length === 0) {\n    throw new GraphQLError(\"Expected name to be a non-empty string.\");\n  }\n  for (let i = 1; i < name2.length; ++i) {\n    if (!isNameContinue(name2.charCodeAt(i))) {\n      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but \"${name2}\" does not.`);\n    }\n  }\n  if (!isNameStart(name2.charCodeAt(0))) {\n    throw new GraphQLError(`Names must start with [_a-zA-Z] but \"${name2}\" does not.`);\n  }\n  return name2;\n}\nfunction assertEnumValueName(name2) {\n  if (name2 === \"true\" || name2 === \"false\" || name2 === \"null\") {\n    throw new GraphQLError(`Enum values cannot be named: ${name2}`);\n  }\n  return assertName(name2);\n}\nfunction isType(type2) {\n  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);\n}\nfunction assertType(type2) {\n  if (!isType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL type.`);\n  }\n  return type2;\n}\nfunction isScalarType(type2) {\n  return instanceOf(type2, GraphQLScalarType);\n}\nfunction assertScalarType(type2) {\n  if (!isScalarType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL Scalar type.`);\n  }\n  return type2;\n}\nfunction isObjectType(type2) {\n  return instanceOf(type2, GraphQLObjectType);\n}\nfunction assertObjectType(type2) {\n  if (!isObjectType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL Object type.`);\n  }\n  return type2;\n}\nfunction isInterfaceType(type2) {\n  return instanceOf(type2, GraphQLInterfaceType);\n}\nfunction assertInterfaceType(type2) {\n  if (!isInterfaceType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL Interface type.`);\n  }\n  return type2;\n}\nfunction isUnionType(type2) {\n  return instanceOf(type2, GraphQLUnionType);\n}\nfunction assertUnionType(type2) {\n  if (!isUnionType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL Union type.`);\n  }\n  return type2;\n}\nfunction isEnumType(type2) {\n  return instanceOf(type2, GraphQLEnumType);\n}\nfunction assertEnumType(type2) {\n  if (!isEnumType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL Enum type.`);\n  }\n  return type2;\n}\nfunction isInputObjectType(type2) {\n  return instanceOf(type2, GraphQLInputObjectType);\n}\nfunction assertInputObjectType(type2) {\n  if (!isInputObjectType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL Input Object type.`);\n  }\n  return type2;\n}\nfunction isListType(type2) {\n  return instanceOf(type2, GraphQLList);\n}\nfunction assertListType(type2) {\n  if (!isListType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL List type.`);\n  }\n  return type2;\n}\nfunction isNonNullType(type2) {\n  return instanceOf(type2, GraphQLNonNull);\n}\nfunction assertNonNullType(type2) {\n  if (!isNonNullType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL Non-Null type.`);\n  }\n  return type2;\n}\nfunction isInputType(type2) {\n  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);\n}\nfunction assertInputType(type2) {\n  if (!isInputType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL input type.`);\n  }\n  return type2;\n}\nfunction isOutputType(type2) {\n  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);\n}\nfunction assertOutputType(type2) {\n  if (!isOutputType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL output type.`);\n  }\n  return type2;\n}\nfunction isLeafType(type2) {\n  return isScalarType(type2) || isEnumType(type2);\n}\nfunction assertLeafType(type2) {\n  if (!isLeafType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL leaf type.`);\n  }\n  return type2;\n}\nfunction isCompositeType(type2) {\n  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);\n}\nfunction assertCompositeType(type2) {\n  if (!isCompositeType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL composite type.`);\n  }\n  return type2;\n}\nfunction isAbstractType(type2) {\n  return isInterfaceType(type2) || isUnionType(type2);\n}\nfunction assertAbstractType(type2) {\n  if (!isAbstractType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL abstract type.`);\n  }\n  return type2;\n}\nclass GraphQLList {\n  constructor(ofType) {\n    isType(ofType) || devAssert$1(false, `Expected ${inspect$2(ofType)} to be a GraphQL type.`);\n    this.ofType = ofType;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLList\";\n  }\n  toString() {\n    return \"[\" + String(this.ofType) + \"]\";\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nclass GraphQLNonNull {\n  constructor(ofType) {\n    isNullableType(ofType) || devAssert$1(false, `Expected ${inspect$2(ofType)} to be a GraphQL nullable type.`);\n    this.ofType = ofType;\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLNonNull\";\n  }\n  toString() {\n    return String(this.ofType) + \"!\";\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction isWrappingType(type2) {\n  return isListType(type2) || isNonNullType(type2);\n}\nfunction assertWrappingType(type2) {\n  if (!isWrappingType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL wrapping type.`);\n  }\n  return type2;\n}\nfunction isNullableType(type2) {\n  return isType(type2) && !isNonNullType(type2);\n}\nfunction assertNullableType(type2) {\n  if (!isNullableType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL nullable type.`);\n  }\n  return type2;\n}\nfunction getNullableType(type2) {\n  if (type2) {\n    return isNonNullType(type2) ? type2.ofType : type2;\n  }\n}\nfunction isNamedType(type2) {\n  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);\n}\nfunction assertNamedType(type2) {\n  if (!isNamedType(type2)) {\n    throw new Error(`Expected ${inspect$2(type2)} to be a GraphQL named type.`);\n  }\n  return type2;\n}\nfunction getNamedType(type2) {\n  if (type2) {\n    let unwrappedType = type2;\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n    return unwrappedType;\n  }\n}\nfunction resolveReadonlyArrayThunk(thunk) {\n  return typeof thunk === \"function\" ? thunk() : thunk;\n}\nfunction resolveObjMapThunk(thunk) {\n  return typeof thunk === \"function\" ? thunk() : thunk;\n}\nclass GraphQLScalarType {\n  constructor(config2) {\n    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;\n    const parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;\n    this.name = assertName(config2.name);\n    this.description = config2.description;\n    this.specifiedByURL = config2.specifiedByURL;\n    this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;\n    this.parseValue = parseValue2;\n    this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    config2.specifiedByURL == null || typeof config2.specifiedByURL === \"string\" || devAssert$1(false, `${this.name} must provide \"specifiedByURL\" as a string, but got: ${inspect$2(config2.specifiedByURL)}.`);\n    config2.serialize == null || typeof config2.serialize === \"function\" || devAssert$1(false, `${this.name} must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided.`);\n    if (config2.parseLiteral) {\n      typeof config2.parseValue === \"function\" && typeof config2.parseLiteral === \"function\" || devAssert$1(false, `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`);\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLScalarType\";\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nclass GraphQLObjectType {\n  constructor(config2) {\n    var _config$extensionASTN2;\n    this.name = assertName(config2.name);\n    this.description = config2.description;\n    this.isTypeOf = config2.isTypeOf;\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];\n    this._fields = () => defineFieldMap(config2);\n    this._interfaces = () => defineInterfaces(config2);\n    config2.isTypeOf == null || typeof config2.isTypeOf === \"function\" || devAssert$1(false, `${this.name} must provide \"isTypeOf\" as a function, but got: ${inspect$2(config2.isTypeOf)}.`);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLObjectType\";\n  }\n  getFields() {\n    if (typeof this._fields === \"function\") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  getInterfaces() {\n    if (typeof this._interfaces === \"function\") {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction defineInterfaces(config2) {\n  var _config$interfaces;\n  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);\n  Array.isArray(interfaces) || devAssert$1(false, `${config2.name} interfaces must be an Array or a function which returns an Array.`);\n  return interfaces;\n}\nfunction defineFieldMap(config2) {\n  const fieldMap = resolveObjMapThunk(config2.fields);\n  isPlainObj(fieldMap) || devAssert$1(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    var _fieldConfig$args;\n    isPlainObj(fieldConfig) || devAssert$1(false, `${config2.name}.${fieldName} field config must be an object.`);\n    fieldConfig.resolve == null || typeof fieldConfig.resolve === \"function\" || devAssert$1(false, `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect$2(fieldConfig.resolve)}.`);\n    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};\n    isPlainObj(argsConfig) || devAssert$1(false, `${config2.name}.${fieldName} args must be an object with argument names as keys.`);\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\nfunction defineArguments(config2) {\n  return Object.entries(config2).map(([argName, argConfig]) => ({\n    name: assertName(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: argConfig.defaultValue,\n    deprecationReason: argConfig.deprecationReason,\n    extensions: toObjMap(argConfig.extensions),\n    astNode: argConfig.astNode\n  }));\n}\nfunction isPlainObj(obj) {\n  return isObjectLike$1(obj) && !Array.isArray(obj);\n}\nfunction fieldsToFieldsConfig(fields) {\n  return mapValue(fields, (field) => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode\n  }));\n}\nfunction argsToArgsConfig(args) {\n  return keyValMap(args, (arg) => arg.name, (arg) => ({\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    deprecationReason: arg.deprecationReason,\n    extensions: arg.extensions,\n    astNode: arg.astNode\n  }));\n}\nfunction isRequiredArgument$1(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === void 0;\n}\nclass GraphQLInterfaceType {\n  constructor(config2) {\n    var _config$extensionASTN3;\n    this.name = assertName(config2.name);\n    this.description = config2.description;\n    this.resolveType = config2.resolveType;\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];\n    this._fields = defineFieldMap.bind(void 0, config2);\n    this._interfaces = defineInterfaces.bind(void 0, config2);\n    config2.resolveType == null || typeof config2.resolveType === \"function\" || devAssert$1(false, `${this.name} must provide \"resolveType\" as a function, but got: ${inspect$2(config2.resolveType)}.`);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLInterfaceType\";\n  }\n  getFields() {\n    if (typeof this._fields === \"function\") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  getInterfaces() {\n    if (typeof this._interfaces === \"function\") {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nclass GraphQLUnionType {\n  constructor(config2) {\n    var _config$extensionASTN4;\n    this.name = assertName(config2.name);\n    this.description = config2.description;\n    this.resolveType = config2.resolveType;\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];\n    this._types = defineTypes.bind(void 0, config2);\n    config2.resolveType == null || typeof config2.resolveType === \"function\" || devAssert$1(false, `${this.name} must provide \"resolveType\" as a function, but got: ${inspect$2(config2.resolveType)}.`);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLUnionType\";\n  }\n  getTypes() {\n    if (typeof this._types === \"function\") {\n      this._types = this._types();\n    }\n    return this._types;\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction defineTypes(config2) {\n  const types = resolveReadonlyArrayThunk(config2.types);\n  Array.isArray(types) || devAssert$1(false, `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`);\n  return types;\n}\nclass GraphQLEnumType {\n  constructor(config2) {\n    var _config$extensionASTN5;\n    this.name = assertName(config2.name);\n    this.description = config2.description;\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];\n    this._values = defineEnumValues(this.name, config2.values);\n    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));\n    this._nameLookup = keyMap$1(this._values, (value) => value.name);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLEnumType\";\n  }\n  getValues() {\n    return this._values;\n  }\n  getValue(name2) {\n    return this._nameLookup[name2];\n  }\n  serialize(outputValue) {\n    const enumValue = this._valueLookup.get(outputValue);\n    if (enumValue === void 0) {\n      throw new GraphQLError(`Enum \"${this.name}\" cannot represent value: ${inspect$2(outputValue)}`);\n    }\n    return enumValue.name;\n  }\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"string\") {\n      const valueStr = inspect$2(inputValue);\n      throw new GraphQLError(`Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));\n    }\n    const enumValue = this.getValue(inputValue);\n    if (enumValue == null) {\n      throw new GraphQLError(`Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, inputValue));\n    }\n    return enumValue.value;\n  }\n  parseLiteral(valueNode, _variables) {\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(`Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), valueNode);\n    }\n    const enumValue = this.getValue(valueNode.value);\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(`Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` + didYouMeanEnumValue(this, valueStr), valueNode);\n    }\n    return enumValue.value;\n  }\n  toConfig() {\n    const values = keyValMap(this.getValues(), (value) => value.name, (value) => ({\n      description: value.description,\n      value: value.value,\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions,\n      astNode: value.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction didYouMeanEnumValue(enumType, unknownValueStr) {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = suggestionList$1(unknownValueStr, allNames);\n  return didYouMean$1(\"the enum value\", suggestedValues);\n}\nfunction defineEnumValues(typeName, valueMap) {\n  isPlainObj(valueMap) || devAssert$1(false, `${typeName} values must be an object with value names as keys.`);\n  return Object.entries(valueMap).map(([valueName, valueConfig]) => {\n    isPlainObj(valueConfig) || devAssert$1(false, `${typeName}.${valueName} must refer to an object with a \"value\" key representing an internal value but got: ${inspect$2(valueConfig)}.`);\n    return {\n      name: assertEnumValueName(valueName),\n      description: valueConfig.description,\n      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,\n      deprecationReason: valueConfig.deprecationReason,\n      extensions: toObjMap(valueConfig.extensions),\n      astNode: valueConfig.astNode\n    };\n  });\n}\nclass GraphQLInputObjectType {\n  constructor(config2) {\n    var _config$extensionASTN6;\n    this.name = assertName(config2.name);\n    this.description = config2.description;\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];\n    this._fields = defineInputFieldMap.bind(void 0, config2);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLInputObjectType\";\n  }\n  getFields() {\n    if (typeof this._fields === \"function\") {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n  toConfig() {\n    const fields = mapValue(this.getFields(), (field) => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode\n    }));\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes\n    };\n  }\n  toString() {\n    return this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nfunction defineInputFieldMap(config2) {\n  const fieldMap = resolveObjMapThunk(config2.fields);\n  isPlainObj(fieldMap) || devAssert$1(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    !(\"resolve\" in fieldConfig) || devAssert$1(false, `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      defaultValue: fieldConfig.defaultValue,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMap(fieldConfig.extensions),\n      astNode: fieldConfig.astNode\n    };\n  });\n}\nfunction isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === void 0;\n}\nfunction isEqualType(typeA, typeB) {\n  if (typeA === typeB) {\n    return true;\n  }\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n  return false;\n}\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  if (maybeSubType === superType) {\n    return true;\n  }\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if (isNonNullType(maybeSubType)) {\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  }\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if (isListType(maybeSubType)) {\n    return false;\n  }\n  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n}\nfunction doTypesOverlap(schema, typeA, typeB) {\n  if (typeA === typeB) {\n    return true;\n  }\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(typeB)) {\n      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));\n    }\n    return schema.isSubType(typeA, typeB);\n  }\n  if (isAbstractType(typeB)) {\n    return schema.isSubType(typeB, typeA);\n  }\n  return false;\n}\nconst GRAPHQL_MAX_INT = 2147483647;\nconst GRAPHQL_MIN_INT = -2147483648;\nconst GraphQLInt = new GraphQLScalarType({\n  name: \"Int\",\n  description: \"The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue ? 1 : 0;\n    }\n    let num2 = coercedValue;\n    if (typeof coercedValue === \"string\" && coercedValue !== \"\") {\n      num2 = Number(coercedValue);\n    }\n    if (typeof num2 !== \"number\" || !Number.isInteger(num2)) {\n      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect$2(coercedValue)}`);\n    }\n    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(\"Int cannot represent non 32-bit signed integer value: \" + inspect$2(coercedValue));\n    }\n    return num2;\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"number\" || !Number.isInteger(inputValue)) {\n      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect$2(inputValue)}`);\n    }\n    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, valueNode);\n    }\n    const num2 = parseInt(valueNode.value, 10);\n    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {\n      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, valueNode);\n    }\n    return num2;\n  }\n});\nconst GraphQLFloat = new GraphQLScalarType({\n  name: \"Float\",\n  description: \"The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue ? 1 : 0;\n    }\n    let num2 = coercedValue;\n    if (typeof coercedValue === \"string\" && coercedValue !== \"\") {\n      num2 = Number(coercedValue);\n    }\n    if (typeof num2 !== \"number\" || !Number.isFinite(num2)) {\n      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect$2(coercedValue)}`);\n    }\n    return num2;\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"number\" || !Number.isFinite(inputValue)) {\n      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect$2(inputValue)}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);\n    }\n    return parseFloat(valueNode.value);\n  }\n});\nconst GraphQLString = new GraphQLScalarType({\n  name: \"String\",\n  description: \"The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"string\") {\n      return coercedValue;\n    }\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue ? \"true\" : \"false\";\n    }\n    if (typeof coercedValue === \"number\" && Number.isFinite(coercedValue)) {\n      return coercedValue.toString();\n    }\n    throw new GraphQLError(`String cannot represent value: ${inspect$2(outputValue)}`);\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"string\") {\n      throw new GraphQLError(`String cannot represent a non string value: ${inspect$2(inputValue)}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.STRING) {\n      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, valueNode);\n    }\n    return valueNode.value;\n  }\n});\nconst GraphQLBoolean = new GraphQLScalarType({\n  name: \"Boolean\",\n  description: \"The `Boolean` scalar type represents `true` or `false`.\",\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"boolean\") {\n      return coercedValue;\n    }\n    if (Number.isFinite(coercedValue)) {\n      return coercedValue !== 0;\n    }\n    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect$2(coercedValue)}`);\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue !== \"boolean\") {\n      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect$2(inputValue)}`);\n    }\n    return inputValue;\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.BOOLEAN) {\n      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, valueNode);\n    }\n    return valueNode.value;\n  }\n});\nconst GraphQLID = new GraphQLScalarType({\n  name: \"ID\",\n  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.',\n  serialize(outputValue) {\n    const coercedValue = serializeObject(outputValue);\n    if (typeof coercedValue === \"string\") {\n      return coercedValue;\n    }\n    if (Number.isInteger(coercedValue)) {\n      return String(coercedValue);\n    }\n    throw new GraphQLError(`ID cannot represent value: ${inspect$2(outputValue)}`);\n  },\n  parseValue(inputValue) {\n    if (typeof inputValue === \"string\") {\n      return inputValue;\n    }\n    if (typeof inputValue === \"number\" && Number.isInteger(inputValue)) {\n      return inputValue.toString();\n    }\n    throw new GraphQLError(`ID cannot represent value: ${inspect$2(inputValue)}`);\n  },\n  parseLiteral(valueNode) {\n    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {\n      throw new GraphQLError(\"ID cannot represent a non-string and non-integer value: \" + print(valueNode), valueNode);\n    }\n    return valueNode.value;\n  }\n});\nconst specifiedScalarTypes = Object.freeze([\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID\n]);\nfunction isSpecifiedScalarType(type2) {\n  return specifiedScalarTypes.some(({ name: name2 }) => type2.name === name2);\n}\nfunction serializeObject(outputValue) {\n  if (isObjectLike$1(outputValue)) {\n    if (typeof outputValue.valueOf === \"function\") {\n      const valueOfResult = outputValue.valueOf();\n      if (!isObjectLike$1(valueOfResult)) {\n        return valueOfResult;\n      }\n    }\n    if (typeof outputValue.toJSON === \"function\") {\n      return outputValue.toJSON();\n    }\n  }\n  return outputValue;\n}\nfunction isDirective(directive) {\n  return instanceOf(directive, GraphQLDirective);\n}\nfunction assertDirective(directive) {\n  if (!isDirective(directive)) {\n    throw new Error(`Expected ${inspect$2(directive)} to be a GraphQL directive.`);\n  }\n  return directive;\n}\nclass GraphQLDirective {\n  constructor(config2) {\n    var _config$isRepeatable, _config$args;\n    this.name = assertName(config2.name);\n    this.description = config2.description;\n    this.locations = config2.locations;\n    this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    Array.isArray(config2.locations) || devAssert$1(false, `@${config2.name} locations must be an Array.`);\n    const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};\n    isObjectLike$1(args) && !Array.isArray(args) || devAssert$1(false, `@${config2.name} args must be an object with argument names as keys.`);\n    this.args = defineArguments(args);\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLDirective\";\n  }\n  toConfig() {\n    return {\n      name: this.name,\n      description: this.description,\n      locations: this.locations,\n      args: argsToArgsConfig(this.args),\n      isRepeatable: this.isRepeatable,\n      extensions: this.extensions,\n      astNode: this.astNode\n    };\n  }\n  toString() {\n    return \"@\" + this.name;\n  }\n  toJSON() {\n    return this.toString();\n  }\n}\nconst GraphQLIncludeDirective = new GraphQLDirective({\n  name: \"include\",\n  description: \"Directs the executor to include this field or fragment only when the `if` argument is true.\",\n  locations: [\n    DirectiveLocation.FIELD,\n    DirectiveLocation.FRAGMENT_SPREAD,\n    DirectiveLocation.INLINE_FRAGMENT\n  ],\n  args: {\n    if: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      description: \"Included when true.\"\n    }\n  }\n});\nconst GraphQLSkipDirective = new GraphQLDirective({\n  name: \"skip\",\n  description: \"Directs the executor to skip this field or fragment when the `if` argument is true.\",\n  locations: [\n    DirectiveLocation.FIELD,\n    DirectiveLocation.FRAGMENT_SPREAD,\n    DirectiveLocation.INLINE_FRAGMENT\n  ],\n  args: {\n    if: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      description: \"Skipped when true.\"\n    }\n  }\n});\nconst DEFAULT_DEPRECATION_REASON = \"No longer supported\";\nconst GraphQLDeprecatedDirective = new GraphQLDirective({\n  name: \"deprecated\",\n  description: \"Marks an element of a GraphQL schema as no longer supported.\",\n  locations: [\n    DirectiveLocation.FIELD_DEFINITION,\n    DirectiveLocation.ARGUMENT_DEFINITION,\n    DirectiveLocation.INPUT_FIELD_DEFINITION,\n    DirectiveLocation.ENUM_VALUE\n  ],\n  args: {\n    reason: {\n      type: GraphQLString,\n      description: \"Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).\",\n      defaultValue: DEFAULT_DEPRECATION_REASON\n    }\n  }\n});\nconst GraphQLSpecifiedByDirective = new GraphQLDirective({\n  name: \"specifiedBy\",\n  description: \"Exposes a URL that specifies the behavior of this scalar.\",\n  locations: [DirectiveLocation.SCALAR],\n  args: {\n    url: {\n      type: new GraphQLNonNull(GraphQLString),\n      description: \"The URL that specifies the behavior of this scalar.\"\n    }\n  }\n});\nconst specifiedDirectives = Object.freeze([\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n  GraphQLDeprecatedDirective,\n  GraphQLSpecifiedByDirective\n]);\nfunction isSpecifiedDirective(directive) {\n  return specifiedDirectives.some(({ name: name2 }) => name2 === directive.name);\n}\nfunction isIterableObject$1(maybeIterable) {\n  return typeof maybeIterable === \"object\" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === \"function\";\n}\nfunction astFromValue(value, type2) {\n  if (isNonNullType(type2)) {\n    const astValue = astFromValue(value, type2.ofType);\n    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {\n      return null;\n    }\n    return astValue;\n  }\n  if (value === null) {\n    return {\n      kind: Kind.NULL\n    };\n  }\n  if (value === void 0) {\n    return null;\n  }\n  if (isListType(type2)) {\n    const itemType = type2.ofType;\n    if (isIterableObject$1(value)) {\n      const valuesNodes = [];\n      for (const item of value) {\n        const itemNode = astFromValue(item, itemType);\n        if (itemNode != null) {\n          valuesNodes.push(itemNode);\n        }\n      }\n      return {\n        kind: Kind.LIST,\n        values: valuesNodes\n      };\n    }\n    return astFromValue(value, itemType);\n  }\n  if (isInputObjectType(type2)) {\n    if (!isObjectLike$1(value)) {\n      return null;\n    }\n    const fieldNodes = [];\n    for (const field of Object.values(type2.getFields())) {\n      const fieldValue = astFromValue(value[field.name], field.type);\n      if (fieldValue) {\n        fieldNodes.push({\n          kind: Kind.OBJECT_FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: field.name\n          },\n          value: fieldValue\n        });\n      }\n    }\n    return {\n      kind: Kind.OBJECT,\n      fields: fieldNodes\n    };\n  }\n  if (isLeafType(type2)) {\n    const serialized = type2.serialize(value);\n    if (serialized == null) {\n      return null;\n    }\n    if (typeof serialized === \"boolean\") {\n      return {\n        kind: Kind.BOOLEAN,\n        value: serialized\n      };\n    }\n    if (typeof serialized === \"number\" && Number.isFinite(serialized)) {\n      const stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: Kind.INT,\n        value: stringNum\n      } : {\n        kind: Kind.FLOAT,\n        value: stringNum\n      };\n    }\n    if (typeof serialized === \"string\") {\n      if (isEnumType(type2)) {\n        return {\n          kind: Kind.ENUM,\n          value: serialized\n        };\n      }\n      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: Kind.INT,\n          value: serialized\n        };\n      }\n      return {\n        kind: Kind.STRING,\n        value: serialized\n      };\n    }\n    throw new TypeError(`Cannot convert value to AST: ${inspect$2(serialized)}.`);\n  }\n  invariant$2(false, \"Unexpected input type: \" + inspect$2(type2));\n}\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\nconst __Schema = new GraphQLObjectType({\n  name: \"__Schema\",\n  description: \"A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.\",\n  fields: () => ({\n    description: {\n      type: GraphQLString,\n      resolve: (schema) => schema.description\n    },\n    types: {\n      description: \"A list of all types supported by this server.\",\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),\n      resolve(schema) {\n        return Object.values(schema.getTypeMap());\n      }\n    },\n    queryType: {\n      description: \"The type that query operations will be rooted at.\",\n      type: new GraphQLNonNull(__Type),\n      resolve: (schema) => schema.getQueryType()\n    },\n    mutationType: {\n      description: \"If this server supports mutation, the type that mutation operations will be rooted at.\",\n      type: __Type,\n      resolve: (schema) => schema.getMutationType()\n    },\n    subscriptionType: {\n      description: \"If this server support subscription, the type that subscription operations will be rooted at.\",\n      type: __Type,\n      resolve: (schema) => schema.getSubscriptionType()\n    },\n    directives: {\n      description: \"A list of all directives supported by this server.\",\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),\n      resolve: (schema) => schema.getDirectives()\n    }\n  })\n});\nconst __Directive = new GraphQLObjectType({\n  name: \"__Directive\",\n  description: \"A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\\n\\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.\",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (directive) => directive.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (directive) => directive.description\n    },\n    isRepeatable: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (directive) => directive.isRepeatable\n    },\n    locations: {\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),\n      resolve: (directive) => directive.locations\n    },\n    args: {\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(field, { includeDeprecated }) {\n        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);\n      }\n    }\n  })\n});\nconst __DirectiveLocation = new GraphQLEnumType({\n  name: \"__DirectiveLocation\",\n  description: \"A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.\",\n  values: {\n    QUERY: {\n      value: DirectiveLocation.QUERY,\n      description: \"Location adjacent to a query operation.\"\n    },\n    MUTATION: {\n      value: DirectiveLocation.MUTATION,\n      description: \"Location adjacent to a mutation operation.\"\n    },\n    SUBSCRIPTION: {\n      value: DirectiveLocation.SUBSCRIPTION,\n      description: \"Location adjacent to a subscription operation.\"\n    },\n    FIELD: {\n      value: DirectiveLocation.FIELD,\n      description: \"Location adjacent to a field.\"\n    },\n    FRAGMENT_DEFINITION: {\n      value: DirectiveLocation.FRAGMENT_DEFINITION,\n      description: \"Location adjacent to a fragment definition.\"\n    },\n    FRAGMENT_SPREAD: {\n      value: DirectiveLocation.FRAGMENT_SPREAD,\n      description: \"Location adjacent to a fragment spread.\"\n    },\n    INLINE_FRAGMENT: {\n      value: DirectiveLocation.INLINE_FRAGMENT,\n      description: \"Location adjacent to an inline fragment.\"\n    },\n    VARIABLE_DEFINITION: {\n      value: DirectiveLocation.VARIABLE_DEFINITION,\n      description: \"Location adjacent to a variable definition.\"\n    },\n    SCHEMA: {\n      value: DirectiveLocation.SCHEMA,\n      description: \"Location adjacent to a schema definition.\"\n    },\n    SCALAR: {\n      value: DirectiveLocation.SCALAR,\n      description: \"Location adjacent to a scalar definition.\"\n    },\n    OBJECT: {\n      value: DirectiveLocation.OBJECT,\n      description: \"Location adjacent to an object type definition.\"\n    },\n    FIELD_DEFINITION: {\n      value: DirectiveLocation.FIELD_DEFINITION,\n      description: \"Location adjacent to a field definition.\"\n    },\n    ARGUMENT_DEFINITION: {\n      value: DirectiveLocation.ARGUMENT_DEFINITION,\n      description: \"Location adjacent to an argument definition.\"\n    },\n    INTERFACE: {\n      value: DirectiveLocation.INTERFACE,\n      description: \"Location adjacent to an interface definition.\"\n    },\n    UNION: {\n      value: DirectiveLocation.UNION,\n      description: \"Location adjacent to a union definition.\"\n    },\n    ENUM: {\n      value: DirectiveLocation.ENUM,\n      description: \"Location adjacent to an enum definition.\"\n    },\n    ENUM_VALUE: {\n      value: DirectiveLocation.ENUM_VALUE,\n      description: \"Location adjacent to an enum value definition.\"\n    },\n    INPUT_OBJECT: {\n      value: DirectiveLocation.INPUT_OBJECT,\n      description: \"Location adjacent to an input object type definition.\"\n    },\n    INPUT_FIELD_DEFINITION: {\n      value: DirectiveLocation.INPUT_FIELD_DEFINITION,\n      description: \"Location adjacent to an input object field definition.\"\n    }\n  }\n});\nconst __Type = new GraphQLObjectType({\n  name: \"__Type\",\n  description: \"The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\\n\\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.\",\n  fields: () => ({\n    kind: {\n      type: new GraphQLNonNull(__TypeKind),\n      resolve(type2) {\n        if (isScalarType(type2)) {\n          return TypeKind.SCALAR;\n        }\n        if (isObjectType(type2)) {\n          return TypeKind.OBJECT;\n        }\n        if (isInterfaceType(type2)) {\n          return TypeKind.INTERFACE;\n        }\n        if (isUnionType(type2)) {\n          return TypeKind.UNION;\n        }\n        if (isEnumType(type2)) {\n          return TypeKind.ENUM;\n        }\n        if (isInputObjectType(type2)) {\n          return TypeKind.INPUT_OBJECT;\n        }\n        if (isListType(type2)) {\n          return TypeKind.LIST;\n        }\n        if (isNonNullType(type2)) {\n          return TypeKind.NON_NULL;\n        }\n        invariant$2(false, `Unexpected type: \"${inspect$2(type2)}\".`);\n      }\n    },\n    name: {\n      type: GraphQLString,\n      resolve: (type2) => \"name\" in type2 ? type2.name : void 0\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (type2) => \"description\" in type2 ? type2.description : void 0\n    },\n    specifiedByURL: {\n      type: GraphQLString,\n      resolve: (obj) => \"specifiedByURL\" in obj ? obj.specifiedByURL : void 0\n    },\n    fields: {\n      type: new GraphQLList(new GraphQLNonNull(__Field)),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(type2, { includeDeprecated }) {\n        if (isObjectType(type2) || isInterfaceType(type2)) {\n          const fields = Object.values(type2.getFields());\n          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);\n        }\n      }\n    },\n    interfaces: {\n      type: new GraphQLList(new GraphQLNonNull(__Type)),\n      resolve(type2) {\n        if (isObjectType(type2) || isInterfaceType(type2)) {\n          return type2.getInterfaces();\n        }\n      }\n    },\n    possibleTypes: {\n      type: new GraphQLList(new GraphQLNonNull(__Type)),\n      resolve(type2, _args, _context, { schema }) {\n        if (isAbstractType(type2)) {\n          return schema.getPossibleTypes(type2);\n        }\n      }\n    },\n    enumValues: {\n      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(type2, { includeDeprecated }) {\n        if (isEnumType(type2)) {\n          const values = type2.getValues();\n          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);\n        }\n      }\n    },\n    inputFields: {\n      type: new GraphQLList(new GraphQLNonNull(__InputValue)),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(type2, { includeDeprecated }) {\n        if (isInputObjectType(type2)) {\n          const values = Object.values(type2.getFields());\n          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);\n        }\n      }\n    },\n    ofType: {\n      type: __Type,\n      resolve: (type2) => \"ofType\" in type2 ? type2.ofType : void 0\n    }\n  })\n});\nconst __Field = new GraphQLObjectType({\n  name: \"__Field\",\n  description: \"Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.\",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (field) => field.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (field) => field.description\n    },\n    args: {\n      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),\n      args: {\n        includeDeprecated: {\n          type: GraphQLBoolean,\n          defaultValue: false\n        }\n      },\n      resolve(field, { includeDeprecated }) {\n        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);\n      }\n    },\n    type: {\n      type: new GraphQLNonNull(__Type),\n      resolve: (field) => field.type\n    },\n    isDeprecated: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (field) => field.deprecationReason != null\n    },\n    deprecationReason: {\n      type: GraphQLString,\n      resolve: (field) => field.deprecationReason\n    }\n  })\n});\nconst __InputValue = new GraphQLObjectType({\n  name: \"__InputValue\",\n  description: \"Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.\",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (inputValue) => inputValue.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (inputValue) => inputValue.description\n    },\n    type: {\n      type: new GraphQLNonNull(__Type),\n      resolve: (inputValue) => inputValue.type\n    },\n    defaultValue: {\n      type: GraphQLString,\n      description: \"A GraphQL-formatted string representing the default value for this input value.\",\n      resolve(inputValue) {\n        const { type: type2, defaultValue: defaultValue2 } = inputValue;\n        const valueAST = astFromValue(defaultValue2, type2);\n        return valueAST ? print(valueAST) : null;\n      }\n    },\n    isDeprecated: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (field) => field.deprecationReason != null\n    },\n    deprecationReason: {\n      type: GraphQLString,\n      resolve: (obj) => obj.deprecationReason\n    }\n  })\n});\nconst __EnumValue = new GraphQLObjectType({\n  name: \"__EnumValue\",\n  description: \"One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.\",\n  fields: () => ({\n    name: {\n      type: new GraphQLNonNull(GraphQLString),\n      resolve: (enumValue) => enumValue.name\n    },\n    description: {\n      type: GraphQLString,\n      resolve: (enumValue) => enumValue.description\n    },\n    isDeprecated: {\n      type: new GraphQLNonNull(GraphQLBoolean),\n      resolve: (enumValue) => enumValue.deprecationReason != null\n    },\n    deprecationReason: {\n      type: GraphQLString,\n      resolve: (enumValue) => enumValue.deprecationReason\n    }\n  })\n});\nlet TypeKind;\n(function(TypeKind2) {\n  TypeKind2[\"SCALAR\"] = \"SCALAR\";\n  TypeKind2[\"OBJECT\"] = \"OBJECT\";\n  TypeKind2[\"INTERFACE\"] = \"INTERFACE\";\n  TypeKind2[\"UNION\"] = \"UNION\";\n  TypeKind2[\"ENUM\"] = \"ENUM\";\n  TypeKind2[\"INPUT_OBJECT\"] = \"INPUT_OBJECT\";\n  TypeKind2[\"LIST\"] = \"LIST\";\n  TypeKind2[\"NON_NULL\"] = \"NON_NULL\";\n})(TypeKind || (TypeKind = {}));\nconst __TypeKind = new GraphQLEnumType({\n  name: \"__TypeKind\",\n  description: \"An enum describing what kind of type a given `__Type` is.\",\n  values: {\n    SCALAR: {\n      value: TypeKind.SCALAR,\n      description: \"Indicates this type is a scalar.\"\n    },\n    OBJECT: {\n      value: TypeKind.OBJECT,\n      description: \"Indicates this type is an object. `fields` and `interfaces` are valid fields.\"\n    },\n    INTERFACE: {\n      value: TypeKind.INTERFACE,\n      description: \"Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.\"\n    },\n    UNION: {\n      value: TypeKind.UNION,\n      description: \"Indicates this type is a union. `possibleTypes` is a valid field.\"\n    },\n    ENUM: {\n      value: TypeKind.ENUM,\n      description: \"Indicates this type is an enum. `enumValues` is a valid field.\"\n    },\n    INPUT_OBJECT: {\n      value: TypeKind.INPUT_OBJECT,\n      description: \"Indicates this type is an input object. `inputFields` is a valid field.\"\n    },\n    LIST: {\n      value: TypeKind.LIST,\n      description: \"Indicates this type is a list. `ofType` is a valid field.\"\n    },\n    NON_NULL: {\n      value: TypeKind.NON_NULL,\n      description: \"Indicates this type is a non-null. `ofType` is a valid field.\"\n    }\n  }\n});\nconst SchemaMetaFieldDef = {\n  name: \"__schema\",\n  type: new GraphQLNonNull(__Schema),\n  description: \"Access the current type schema of this server.\",\n  args: [],\n  resolve: (_source, _args, _context, { schema }) => schema,\n  deprecationReason: void 0,\n  extensions: /* @__PURE__ */ Object.create(null),\n  astNode: void 0\n};\nconst TypeMetaFieldDef = {\n  name: \"__type\",\n  type: __Type,\n  description: \"Request the type information of a single type.\",\n  args: [\n    {\n      name: \"name\",\n      description: void 0,\n      type: new GraphQLNonNull(GraphQLString),\n      defaultValue: void 0,\n      deprecationReason: void 0,\n      extensions: /* @__PURE__ */ Object.create(null),\n      astNode: void 0\n    }\n  ],\n  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),\n  deprecationReason: void 0,\n  extensions: /* @__PURE__ */ Object.create(null),\n  astNode: void 0\n};\nconst TypeNameMetaFieldDef = {\n  name: \"__typename\",\n  type: new GraphQLNonNull(GraphQLString),\n  description: \"The name of the current Object type at runtime.\",\n  args: [],\n  resolve: (_source, _args, _context, { parentType }) => parentType.name,\n  deprecationReason: void 0,\n  extensions: /* @__PURE__ */ Object.create(null),\n  astNode: void 0\n};\nconst introspectionTypes = Object.freeze([\n  __Schema,\n  __Directive,\n  __DirectiveLocation,\n  __Type,\n  __Field,\n  __InputValue,\n  __EnumValue,\n  __TypeKind\n]);\nfunction isIntrospectionType(type2) {\n  return introspectionTypes.some(({ name: name2 }) => type2.name === name2);\n}\nvar introspection = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  __Schema,\n  __Directive,\n  __DirectiveLocation,\n  __Type,\n  __Field,\n  __InputValue,\n  __EnumValue,\n  get TypeKind() {\n    return TypeKind;\n  },\n  __TypeKind,\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n  introspectionTypes,\n  isIntrospectionType\n});\nfunction isSchema(schema) {\n  return instanceOf(schema, GraphQLSchema);\n}\nfunction assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect$2(schema)} to be a GraphQL schema.`);\n  }\n  return schema;\n}\nclass GraphQLSchema {\n  constructor(config2) {\n    var _config$extensionASTN, _config$directives;\n    this.__validationErrors = config2.assumeValid === true ? [] : void 0;\n    isObjectLike$1(config2) || devAssert$1(false, \"Must provide configuration object.\");\n    !config2.types || Array.isArray(config2.types) || devAssert$1(false, `\"types\" must be Array if provided but got: ${inspect$2(config2.types)}.`);\n    !config2.directives || Array.isArray(config2.directives) || devAssert$1(false, `\"directives\" must be Array if provided but got: ${inspect$2(config2.directives)}.`);\n    this.description = config2.description;\n    this.extensions = toObjMap(config2.extensions);\n    this.astNode = config2.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config2.query;\n    this._mutationType = config2.mutation;\n    this._subscriptionType = config2.subscription;\n    this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;\n    const allReferencedTypes = new Set(config2.types);\n    if (config2.types != null) {\n      for (const type2 of config2.types) {\n        allReferencedTypes.delete(type2);\n        collectReferencedTypes(type2, allReferencedTypes);\n      }\n    }\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n    for (const directive of this._directives) {\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n    collectReferencedTypes(__Schema, allReferencedTypes);\n    this._typeMap = /* @__PURE__ */ Object.create(null);\n    this._subTypeMap = /* @__PURE__ */ Object.create(null);\n    this._implementationsMap = /* @__PURE__ */ Object.create(null);\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n      const typeName = namedType.name;\n      typeName || devAssert$1(false, \"One of the provided types for building the Schema is missing a name.\");\n      if (this._typeMap[typeName] !== void 0) {\n        throw new Error(`Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`);\n      }\n      this._typeMap[typeName] = namedType;\n      if (isInterfaceType(namedType)) {\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === void 0) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === void 0) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"GraphQLSchema\";\n  }\n  getQueryType() {\n    return this._queryType;\n  }\n  getMutationType() {\n    return this._mutationType;\n  }\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n  getRootType(operation) {\n    switch (operation) {\n      case OperationTypeNode.QUERY:\n        return this.getQueryType();\n      case OperationTypeNode.MUTATION:\n        return this.getMutationType();\n      case OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n  getTypeMap() {\n    return this._typeMap;\n  }\n  getType(name2) {\n    return this.getTypeMap()[name2];\n  }\n  getPossibleTypes(abstractType) {\n    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  }\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  }\n  isSubType(abstractType, maybeSubType) {\n    let map2 = this._subTypeMap[abstractType.name];\n    if (map2 === void 0) {\n      map2 = /* @__PURE__ */ Object.create(null);\n      if (isUnionType(abstractType)) {\n        for (const type2 of abstractType.getTypes()) {\n          map2[type2.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n        for (const type2 of implementations.objects) {\n          map2[type2.name] = true;\n        }\n        for (const type2 of implementations.interfaces) {\n          map2[type2.name] = true;\n        }\n      }\n      this._subTypeMap[abstractType.name] = map2;\n    }\n    return map2[maybeSubType.name] !== void 0;\n  }\n  getDirectives() {\n    return this._directives;\n  }\n  getDirective(name2) {\n    return this.getDirectives().find((directive) => directive.name === name2);\n  }\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== void 0\n    };\n  }\n}\nfunction collectReferencedTypes(type2, typeSet) {\n  const namedType = getNamedType(type2);\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n  return typeSet;\n}\nfunction validateSchema(schema) {\n  assertSchema(schema);\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  }\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes$1(context);\n  const errors2 = context.getErrors();\n  schema.__validationErrors = errors2;\n  return errors2;\n}\nfunction assertValidSchema(schema) {\n  const errors2 = validateSchema(schema);\n  if (errors2.length !== 0) {\n    throw new Error(errors2.map((error2) => error2.message).join(\"\\n\\n\"));\n  }\n}\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n    this._errors.push(new GraphQLError(message, _nodes));\n  }\n  getErrors() {\n    return this._errors;\n  }\n}\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n    context.reportError(`Query root type must be Object type, it cannot be ${inspect$2(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n  const mutationType = schema.getMutationType();\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n    context.reportError(`Mutation root type must be Object type if provided, it cannot be ${inspect$2(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n    context.reportError(`Subscription root type must be Object type if provided, it cannot be ${inspect$2(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap((schemaNode) => {\n    var _schemaNode$operation;\n    return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];\n  }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    if (!isDirective(directive)) {\n      context.reportError(`Expected directive but got: ${inspect$2(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    }\n    validateName(context, directive);\n    for (const arg of directive.args) {\n      validateName(context, arg);\n      if (!isInputType(arg.type)) {\n        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect$2(arg.type)}.`, arg.astNode);\n      }\n      if (isRequiredArgument$1(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [\n          getDeprecatedDirectiveNode(arg.astNode),\n          (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type\n        ]);\n      }\n    }\n  }\n}\nfunction validateName(context, node) {\n  if (node.name.startsWith(\"__\")) {\n    context.reportError(`Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, node.astNode);\n  }\n}\nfunction validateTypes$1(context) {\n  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n  for (const type2 of Object.values(typeMap)) {\n    if (!isNamedType(type2)) {\n      context.reportError(`Expected GraphQL named type but got: ${inspect$2(type2)}.`, type2.astNode);\n      continue;\n    }\n    if (!isIntrospectionType(type2)) {\n      validateName(context, type2);\n    }\n    if (isObjectType(type2)) {\n      validateFields(context, type2);\n      validateInterfaces(context, type2);\n    } else if (isInterfaceType(type2)) {\n      validateFields(context, type2);\n      validateInterfaces(context, type2);\n    } else if (isUnionType(type2)) {\n      validateUnionMembers(context, type2);\n    } else if (isEnumType(type2)) {\n      validateEnumValues(context, type2);\n    } else if (isInputObjectType(type2)) {\n      validateInputFields(context, type2);\n      validateInputObjectCircularRefs(type2);\n    }\n  }\n}\nfunction validateFields(context, type2) {\n  const fields = Object.values(type2.getFields());\n  if (fields.length === 0) {\n    context.reportError(`Type ${type2.name} must define one or more fields.`, [\n      type2.astNode,\n      ...type2.extensionASTNodes\n    ]);\n  }\n  for (const field of fields) {\n    validateName(context, field);\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n      context.reportError(`The type of ${type2.name}.${field.name} must be Output Type but got: ${inspect$2(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    }\n    for (const arg of field.args) {\n      const argName = arg.name;\n      validateName(context, arg);\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n        context.reportError(`The type of ${type2.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect$2(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n      if (isRequiredArgument$1(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n        context.reportError(`Required argument ${type2.name}.${field.name}(${argName}:) cannot be deprecated.`, [\n          getDeprecatedDirectiveNode(arg.astNode),\n          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type\n        ]);\n      }\n    }\n  }\n}\nfunction validateInterfaces(context, type2) {\n  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);\n  for (const iface of type2.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(`Type ${inspect$2(type2)} must only implement Interface types, it cannot implement ${inspect$2(iface)}.`, getAllImplementsInterfaceNodes(type2, iface));\n      continue;\n    }\n    if (type2 === iface) {\n      context.reportError(`Type ${type2.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type2, iface));\n      continue;\n    }\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(`Type ${type2.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type2, iface));\n      continue;\n    }\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type2, iface);\n    validateTypeImplementsInterface(context, type2, iface);\n  }\n}\nfunction validateTypeImplementsInterface(context, type2, iface) {\n  const typeFieldMap = type2.getFields();\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName];\n    if (!typeField) {\n      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type2.name} does not provide it.`, [ifaceField.astNode, type2.astNode, ...type2.extensionASTNodes]);\n      continue;\n    }\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ${inspect$2(ifaceField.type)} but ${type2.name}.${fieldName} is type ${inspect$2(typeField.type)}.`, [\n        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,\n        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type\n      ]);\n    }\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName);\n      if (!typeArg) {\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type2.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);\n        continue;\n      }\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect$2(ifaceArg.type)} but ${type2.name}.${fieldName}(${argName}:) is type ${inspect$2(typeArg.type)}.`, [\n          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,\n          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type\n        ]);\n      }\n    }\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n      if (!ifaceArg && isRequiredArgument$1(typeArg)) {\n        context.reportError(`Object field ${type2.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);\n      }\n    }\n  }\n}\nfunction validateTypeImplementsAncestors(context, type2, iface) {\n  const ifaceInterfaces = type2.getInterfaces();\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(transitive === type2 ? `Type ${type2.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type2.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [\n        ...getAllImplementsInterfaceNodes(iface, transitive),\n        ...getAllImplementsInterfaceNodes(type2, iface)\n      ]);\n    }\n  }\n}\nfunction validateUnionMembers(context, union2) {\n  const memberTypes = union2.getTypes();\n  if (memberTypes.length === 0) {\n    context.reportError(`Union type ${union2.name} must define one or more member types.`, [union2.astNode, ...union2.extensionASTNodes]);\n  }\n  const includedTypeNames = /* @__PURE__ */ Object.create(null);\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(`Union type ${union2.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union2, memberType.name));\n      continue;\n    }\n    includedTypeNames[memberType.name] = true;\n    if (!isObjectType(memberType)) {\n      context.reportError(`Union type ${union2.name} can only include Object types, it cannot include ${inspect$2(memberType)}.`, getUnionMemberTypeNodes(union2, String(memberType)));\n    }\n  }\n}\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n  if (enumValues.length === 0) {\n    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);\n  }\n  for (const enumValue of enumValues) {\n    validateName(context, enumValue);\n  }\n}\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n  if (fields.length === 0) {\n    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);\n  }\n  for (const field of fields) {\n    validateName(context, field);\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect$2(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [\n        getDeprecatedDirectiveNode(field.astNode),\n        (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type\n      ]);\n    }\n  }\n}\nfunction createInputObjectCircularRefsValidator(context) {\n  const visitedTypes = /* @__PURE__ */ Object.create(null);\n  const fieldPath = [];\n  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);\n  return detectCycleRecursive;\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n        if (cycleIndex === void 0) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(\".\");\n          context.reportError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, cyclePath.map((fieldObj) => fieldObj.astNode));\n        }\n        fieldPath.pop();\n      }\n    }\n    fieldPathIndexByTypeName[inputObj.name] = void 0;\n  }\n}\nfunction getAllImplementsInterfaceNodes(type2, iface) {\n  const { astNode, extensionASTNodes } = type2;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;\n  return nodes.flatMap((typeNode) => {\n    var _typeNode$interfaces;\n    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];\n  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\nfunction getUnionMemberTypeNodes(union2, typeName) {\n  const { astNode, extensionASTNodes } = union2;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;\n  return nodes.flatMap((unionNode) => {\n    var _unionNode$types;\n    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];\n  }).filter((typeNode) => typeNode.name.value === typeName);\n}\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find((node) => node.name.value === GraphQLDeprecatedDirective.name);\n}\nfunction typeFromAST(schema, typeNode) {\n  switch (typeNode.kind) {\n    case Kind.LIST_TYPE: {\n      const innerType = typeFromAST(schema, typeNode.type);\n      return innerType && new GraphQLList(innerType);\n    }\n    case Kind.NON_NULL_TYPE: {\n      const innerType = typeFromAST(schema, typeNode.type);\n      return innerType && new GraphQLNonNull(innerType);\n    }\n    case Kind.NAMED_TYPE:\n      return schema.getType(typeNode.name.value);\n  }\n}\nclass TypeInfo {\n  constructor(schema, initialType, getFieldDefFn) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef$3;\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return \"TypeInfo\";\n  }\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n  getDirective() {\n    return this._directive;\n  }\n  getArgument() {\n    return this._argument;\n  }\n  getEnumValue() {\n    return this._enumValue;\n  }\n  enter(node) {\n    const schema = this._schema;\n    switch (node.kind) {\n      case Kind.SELECTION_SET: {\n        const namedType = getNamedType(this.getType());\n        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : void 0);\n        break;\n      }\n      case Kind.FIELD: {\n        const parentType = this.getParentType();\n        let fieldDef;\n        let fieldType;\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n        this._fieldDefStack.push(fieldDef);\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);\n        break;\n      }\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n      case Kind.OPERATION_DEFINITION: {\n        const rootType = schema.getRootType(node.operation);\n        this._typeStack.push(isObjectType(rootType) ? rootType : void 0);\n        break;\n      }\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION: {\n        const typeConditionAST = node.typeCondition;\n        const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);\n        break;\n      }\n      case Kind.VARIABLE_DEFINITION: {\n        const inputType = typeFromAST(schema, node.type);\n        this._inputTypeStack.push(isInputType(inputType) ? inputType : void 0);\n        break;\n      }\n      case Kind.ARGUMENT: {\n        var _this$getDirective;\n        let argDef;\n        let argType;\n        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n        if (fieldOrDirective) {\n          argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n        this._argument = argDef;\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);\n        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);\n        break;\n      }\n      case Kind.LIST: {\n        const listType = getNullableType(this.getInputType());\n        const itemType = isListType(listType) ? listType.ofType : listType;\n        this._defaultValueStack.push(void 0);\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);\n        break;\n      }\n      case Kind.OBJECT_FIELD: {\n        const objectType = getNamedType(this.getInputType());\n        let inputFieldType;\n        let inputField;\n        if (isInputObjectType(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n        this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);\n        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : void 0);\n        break;\n      }\n      case Kind.ENUM: {\n        const enumType = getNamedType(this.getInputType());\n        let enumValue;\n        if (isEnumType(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n        this._enumValue = enumValue;\n        break;\n      }\n    }\n  }\n  leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n        break;\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n        this._typeStack.pop();\n        break;\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n        break;\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ARGUMENT:\n        this._argument = null;\n        this._defaultValueStack.pop();\n        this._inputTypeStack.pop();\n        break;\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n        this._inputTypeStack.pop();\n        break;\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  }\n}\nfunction getFieldDef$3(schema, parentType, fieldNode) {\n  const name2 = fieldNode.name.value;\n  if (name2 === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n  if (name2 === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n  if (name2 === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name2];\n  }\n}\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(...args) {\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = getEnterLeaveForKind(visitor, node.kind).enter;\n      if (fn) {\n        const result2 = fn.apply(visitor, args);\n        if (result2 !== void 0) {\n          typeInfo.leave(node);\n          if (isNode(result2)) {\n            typeInfo.enter(result2);\n          }\n        }\n        return result2;\n      }\n    },\n    leave(...args) {\n      const node = args[0];\n      const fn = getEnterLeaveForKind(visitor, node.kind).leave;\n      let result2;\n      if (fn) {\n        result2 = fn.apply(visitor, args);\n      }\n      typeInfo.leave(node);\n      return result2;\n    }\n  };\n}\nfunction isDefinitionNode(node) {\n  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);\n}\nfunction isExecutableDefinitionNode(node) {\n  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;\n}\nfunction isSelectionNode(node) {\n  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;\n}\nfunction isValueNode(node) {\n  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;\n}\nfunction isConstValueNode(node) {\n  return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);\n}\nfunction isTypeNode(node) {\n  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;\n}\nfunction isTypeSystemDefinitionNode(node) {\n  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;\n}\nfunction isTypeDefinitionNode(node) {\n  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;\n}\nfunction isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nfunction isTypeExtensionNode(node) {\n  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;\n}\nfunction ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? \"schema\" : '\"' + definition.name.value + '\"';\n          context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, definition));\n        }\n      }\n      return false;\n    }\n  };\n}\nfunction FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type2 = context.getParentType();\n      if (type2) {\n        const fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          const schema = context.getSchema();\n          const fieldName = node.name.value;\n          let suggestion = didYouMean$1(\"to use an inline fragment on\", getSuggestedTypeNames(schema, type2, fieldName));\n          if (suggestion === \"\") {\n            suggestion = didYouMean$1(getSuggestedFieldNames(type2, fieldName));\n          }\n          context.reportError(new GraphQLError(`Cannot query field \"${fieldName}\" on type \"${type2.name}\".` + suggestion, node));\n        }\n      }\n    }\n  };\n}\nfunction getSuggestedTypeNames(schema, type2, fieldName) {\n  if (!isAbstractType(type2)) {\n    return [];\n  }\n  const suggestedTypes = /* @__PURE__ */ new Set();\n  const usageCount = /* @__PURE__ */ Object.create(null);\n  for (const possibleType of schema.getPossibleTypes(type2)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    }\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      }\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n  return [...suggestedTypes].sort((typeA, typeB) => {\n    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    }\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n    return naturalCompare$1(typeA.name, typeB.name);\n  }).map((x2) => x2.name);\n}\nfunction getSuggestedFieldNames(type2, fieldName) {\n  if (isObjectType(type2) || isInterfaceType(type2)) {\n    const possibleFieldNames = Object.keys(type2.getFields());\n    return suggestionList$1(fieldName, possibleFieldNames);\n  }\n  return [];\n}\nfunction FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n      if (typeCondition) {\n        const type2 = typeFromAST(context.getSchema(), typeCondition);\n        if (type2 && !isCompositeType(type2)) {\n          const typeStr = print(typeCondition);\n          context.reportError(new GraphQLError(`Fragment cannot condition on non composite type \"${typeStr}\".`, typeCondition));\n        }\n      }\n    },\n    FragmentDefinition(node) {\n      const type2 = typeFromAST(context.getSchema(), node.typeCondition);\n      if (type2 && !isCompositeType(type2)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(new GraphQLError(`Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`, node.typeCondition));\n      }\n    }\n  };\n}\nfunction KnownArgumentNamesRule(context) {\n  return __spreadProps(__spreadValues({}, KnownArgumentNamesOnDirectivesRule(context)), {\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList$1(argName, knownArgsNames);\n        context.reportError(new GraphQLError(`Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` + didYouMean$1(suggestions), argNode));\n      }\n    }\n  });\n}\nfunction KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = /* @__PURE__ */ Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n  const astDefinitions = context.getDocument().definitions;\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList$1(argName, knownArgs);\n            context.reportError(new GraphQLError(`Unknown argument \"${argName}\" on directive \"@${directiveName}\".` + didYouMean$1(suggestions), argNode));\n          }\n        }\n      }\n      return false;\n    }\n  };\n}\nfunction KnownDirectivesRule(context) {\n  const locationsMap = /* @__PURE__ */ Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n  const astDefinitions = context.getDocument().definitions;\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);\n    }\n  }\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name2 = node.name.value;\n      const locations = locationsMap[name2];\n      if (!locations) {\n        context.reportError(new GraphQLError(`Unknown directive \"@${name2}\".`, node));\n        return;\n      }\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(new GraphQLError(`Directive \"@${name2}\" may not be used on ${candidateLocation}.`, node));\n      }\n    }\n  };\n}\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  \"kind\" in appliedTo || invariant$2(false);\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      \"kind\" in parentNode || invariant$2(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    default:\n      invariant$2(false, \"Unexpected kind: \" + inspect$2(appliedTo.kind));\n  }\n}\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\nfunction KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n      if (!fragment) {\n        context.reportError(new GraphQLError(`Unknown fragment \"${fragmentName}\".`, node.name));\n      }\n    }\n  };\n}\nfunction KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);\n  const definedTypes = /* @__PURE__ */ Object.create(null);\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes)\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n        const suggestedTypes = suggestionList$1(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(`Unknown type \"${typeName}\".` + didYouMean$1(suggestedTypes), node));\n      }\n    }\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map((type2) => type2.name);\nfunction isSDLNode(value) {\n  return \"kind\" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}\nfunction LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter((definition) => definition.kind === Kind.OPERATION_DEFINITION).length;\n    },\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new GraphQLError(\"This anonymous operation must be the only defined operation.\", node));\n      }\n    }\n  };\n}\nfunction LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n  const oldSchema = context.getSchema();\n  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(new GraphQLError(\"Cannot define a new schema within a schema extension.\", node));\n        return;\n      }\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(new GraphQLError(\"Must provide only one schema definition.\", node));\n      }\n      ++schemaDefinitionsCount;\n    }\n  };\n}\nfunction NoFragmentCyclesRule(context) {\n  const visitedFrags = /* @__PURE__ */ Object.create(null);\n  const spreadPath = [];\n  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);\n  return {\n    OperationDefinition: () => false,\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  };\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n    if (spreadNodes.length === 0) {\n      return;\n    }\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n      if (cycleIndex === void 0) {\n        const spreadFragment = context.getFragment(spreadName);\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath.slice(0, -1).map((s) => '\"' + s.name.value + '\"').join(\", \");\n        context.reportError(new GraphQLError(`Cannot spread fragment \"${spreadName}\" within itself` + (viaPath !== \"\" ? ` via ${viaPath}.` : \".\"), cyclePath));\n      }\n      spreadPath.pop();\n    }\n    spreadPathIndexByName[fragmentName] = void 0;\n  }\n}\nfunction NoUndefinedVariablesRule(context) {\n  let variableNameDefined = /* @__PURE__ */ Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = /* @__PURE__ */ Object.create(null);\n      },\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n        for (const { node } of usages) {\n          const varName = node.name.value;\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".` : `Variable \"$${varName}\" is not defined.`, [node, operation]));\n          }\n        }\n      }\n    },\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    }\n  };\n}\nfunction NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave() {\n        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(operation)) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new GraphQLError(`Fragment \"${fragName}\" is never used.`, fragmentDef));\n          }\n        }\n      }\n    }\n  };\n}\nfunction NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n      leave(operation) {\n        const variableNameUsed = /* @__PURE__ */ Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new GraphQLError(operation.name ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".` : `Variable \"$${variableName}\" is never used.`, variableDef));\n          }\n        }\n      }\n    },\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\nfunction sortValueNode(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.OBJECT:\n      return __spreadProps(__spreadValues({}, valueNode), { fields: sortFields(valueNode.fields) });\n    case Kind.LIST:\n      return __spreadProps(__spreadValues({}, valueNode), { values: valueNode.values.map(sortValueNode) });\n    case Kind.INT:\n    case Kind.FLOAT:\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n    case Kind.NULL:\n    case Kind.ENUM:\n    case Kind.VARIABLE:\n      return valueNode;\n  }\n}\nfunction sortFields(fields) {\n  return fields.map((fieldNode) => __spreadProps(__spreadValues({}, fieldNode), {\n    value: sortValueNode(fieldNode.value)\n  })).sort((fieldA, fieldB) => naturalCompare$1(fieldA.name.value, fieldB.name.value));\n}\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(([responseName, subReason]) => `subfields \"${responseName}\" conflict because ` + reasonMessage(subReason)).join(\" and \");\n  }\n  return reason;\n}\nfunction OverlappingFieldsCanBeMergedRule(context) {\n  const comparedFragmentPairs = new PairSet();\n  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(`Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, fields1.concat(fields2)));\n      }\n    }\n  };\n}\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n  if (fragmentNames.length !== 0) {\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n  return conflicts;\n}\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  const fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);\n  if (fieldMap === fieldMap2) {\n    return;\n  }\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);\n  for (const referencedFragmentName of referencedFragmentNames) {\n    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {\n      continue;\n    }\n    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);\n  }\n}\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  if (fragmentName1 === fragmentName2) {\n    return;\n  }\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);\n  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);\n  }\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);\n  }\n}\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);\n  }\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);\n  }\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);\n    }\n  }\n  return conflicts;\n}\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n}\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n}\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2;\n  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n  if (!areMutuallyExclusive) {\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2]\n      ];\n    }\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [\n        [responseName, \"they have differing arguments\"],\n        [node1],\n        [node2]\n      ];\n    }\n  }\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect$2(type1)}\" and \"${inspect$2(type2)}\"`\n      ],\n      [node1],\n      [node2]\n    ];\n  }\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n  const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n  const inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map((argNode) => ({\n      kind: Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value\n    }))\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n}\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isListType(type2)) {\n    return true;\n  }\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n  if (isNonNullType(type2)) {\n    return true;\n  }\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n}\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (cached) {\n    return cached;\n  }\n  const nodeAndDefs = /* @__PURE__ */ Object.create(null);\n  const fragmentNames = /* @__PURE__ */ Object.create(null);\n  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n  const result2 = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result2);\n  return result2;\n}\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        const responseName = selection.alias ? selection.alias.value : fieldName;\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n        break;\n      }\n    }\n  }\n}\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]\n    ];\n  }\n}\nclass PairSet {\n  constructor() {\n    this._data = /* @__PURE__ */ new Map();\n  }\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result2 = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);\n    if (result2 === void 0) {\n      return false;\n    }\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result2;\n  }\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const map2 = this._data.get(key1);\n    if (map2 === void 0) {\n      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map2.set(key2, areMutuallyExclusive);\n    }\n  }\n}\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        const parentTypeStr = inspect$2(parentType);\n        const fragTypeStr = inspect$2(fragType);\n        context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`, node));\n      }\n    },\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        const parentTypeStr = inspect$2(parentType);\n        const fragTypeStr = inspect$2(fragType);\n        context.reportError(new GraphQLError(`Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`, node));\n      }\n    }\n  };\n}\nfunction getFragmentType(context, name2) {\n  const frag = context.getFragment(name2);\n  if (frag) {\n    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);\n    if (isCompositeType(type2)) {\n      return type2;\n    }\n  }\n}\nfunction PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = /* @__PURE__ */ Object.create(null);\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, defNode ? [defNode, node] : node));\n      }\n    } else {\n      const allTypeNames = Object.keys(__spreadValues(__spreadValues({}, definedTypes), schema === null || schema === void 0 ? void 0 : schema.getTypeMap()));\n      const suggestedTypes = suggestionList$1(typeName, allTypeNames);\n      context.reportError(new GraphQLError(`Cannot extend type \"${typeName}\" because it is not defined.` + didYouMean$1(suggestedTypes), node.name));\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION\n};\nfunction typeToExtKind(type2) {\n  if (isScalarType(type2)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n  if (isObjectType(type2)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n  if (isInterfaceType(type2)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n  if (isUnionType(type2)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n  if (isEnumType(type2)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n  if (isInputObjectType(type2)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  invariant$2(false, \"Unexpected type: \" + inspect$2(type2));\n}\nfunction extensionKindToTypeName(kind2) {\n  switch (kind2) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return \"scalar\";\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return \"object\";\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return \"interface\";\n    case Kind.UNION_TYPE_EXTENSION:\n      return \"union\";\n    case Kind.ENUM_TYPE_EXTENSION:\n      return \"enum\";\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return \"input object\";\n    default:\n      invariant$2(false, \"Unexpected kind: \" + inspect$2(kind2));\n  }\n}\nfunction ProvidedRequiredArgumentsRule(context) {\n  return __spreadProps(__spreadValues({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {\n    Field: {\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n        const fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          return false;\n        }\n        const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value));\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument$1(argDef)) {\n            const argTypeStr = inspect$2(argDef.type);\n            context.reportError(new GraphQLError(`Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`, fieldNode));\n          }\n        }\n      }\n    }\n  });\n}\nfunction ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n  const requiredArgsMap = /* @__PURE__ */ Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap$1(directive.args.filter(isRequiredArgument$1), (arg) => arg.name);\n  }\n  const astDefinitions = context.getDocument().definitions;\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];\n      requiredArgsMap[def.name.value] = keyMap$1(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);\n    }\n  }\n  return {\n    Directive: {\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n        if (requiredArgs) {\n          var _directiveNode$argume;\n          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type) ? inspect$2(argDef.type) : print(argDef.type);\n              context.reportError(new GraphQLError(`Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`, directiveNode));\n            }\n          }\n        }\n      }\n    }\n  };\n}\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\nfunction ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type2 = context.getType();\n      const selectionSet = node.selectionSet;\n      if (type2) {\n        if (isLeafType(getNamedType(type2))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect$2(type2);\n            context.reportError(new GraphQLError(`Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`, selectionSet));\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect$2(type2);\n          context.reportError(new GraphQLError(`Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`, node));\n        }\n      }\n    }\n  };\n}\nfunction printPathArray$1(path) {\n  return path.map((key) => typeof key === \"number\" ? \"[\" + key.toString() + \"]\" : \".\" + key).join(\"\");\n}\nfunction addPath$1(prev, key, typename) {\n  return {\n    prev,\n    key,\n    typename\n  };\n}\nfunction pathToArray$1(path) {\n  const flattened = [];\n  let curr = path;\n  while (curr) {\n    flattened.push(curr.key);\n    curr = curr.prev;\n  }\n  return flattened.reverse();\n}\nfunction coerceInputValue$1(inputValue, type2, onError = defaultOnError$1) {\n  return coerceInputValueImpl$1(inputValue, type2, onError, void 0);\n}\nfunction defaultOnError$1(path, invalidValue, error2) {\n  let errorPrefix = \"Invalid value \" + inspect$2(invalidValue);\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${printPathArray$1(path)}\"`;\n  }\n  error2.message = errorPrefix + \": \" + error2.message;\n  throw error2;\n}\nfunction coerceInputValueImpl$1(inputValue, type2, onError, path) {\n  if (isNonNullType(type2)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl$1(inputValue, type2.ofType, onError, path);\n    }\n    onError(pathToArray$1(path), inputValue, new GraphQLError(`Expected non-nullable type \"${inspect$2(type2)}\" not to be null.`));\n    return;\n  }\n  if (inputValue == null) {\n    return null;\n  }\n  if (isListType(type2)) {\n    const itemType = type2.ofType;\n    if (isIterableObject$1(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = addPath$1(path, index, void 0);\n        return coerceInputValueImpl$1(itemValue, itemType, onError, itemPath);\n      });\n    }\n    return [coerceInputValueImpl$1(inputValue, itemType, onError, path)];\n  }\n  if (isInputObjectType(type2)) {\n    if (!isObjectLike$1(inputValue)) {\n      onError(pathToArray$1(path), inputValue, new GraphQLError(`Expected type \"${type2.name}\" to be an object.`));\n      return;\n    }\n    const coercedValue = {};\n    const fieldDefs = type2.getFields();\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n      if (fieldValue === void 0) {\n        if (field.defaultValue !== void 0) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          const typeStr = inspect$2(field.type);\n          onError(pathToArray$1(path), inputValue, new GraphQLError(`Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`));\n        }\n        continue;\n      }\n      coercedValue[field.name] = coerceInputValueImpl$1(fieldValue, field.type, onError, addPath$1(path, field.name, type2.name));\n    }\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = suggestionList$1(fieldName, Object.keys(type2.getFields()));\n        onError(pathToArray$1(path), inputValue, new GraphQLError(`Field \"${fieldName}\" is not defined by type \"${type2.name}\".` + didYouMean$1(suggestions)));\n      }\n    }\n    return coercedValue;\n  }\n  if (isLeafType(type2)) {\n    let parseResult;\n    try {\n      parseResult = type2.parseValue(inputValue);\n    } catch (error2) {\n      if (error2 instanceof GraphQLError) {\n        onError(pathToArray$1(path), inputValue, error2);\n      } else {\n        onError(pathToArray$1(path), inputValue, new GraphQLError(`Expected type \"${type2.name}\". ` + error2.message, void 0, void 0, void 0, void 0, error2));\n      }\n      return;\n    }\n    if (parseResult === void 0) {\n      onError(pathToArray$1(path), inputValue, new GraphQLError(`Expected type \"${type2.name}\".`));\n    }\n    return parseResult;\n  }\n  invariant$2(false, \"Unexpected input type: \" + inspect$2(type2));\n}\nfunction valueFromAST$1(valueNode, type2, variables) {\n  if (!valueNode) {\n    return;\n  }\n  if (valueNode.kind === Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n    if (variables == null || variables[variableName] === void 0) {\n      return;\n    }\n    const variableValue = variables[variableName];\n    if (variableValue === null && isNonNullType(type2)) {\n      return;\n    }\n    return variableValue;\n  }\n  if (isNonNullType(type2)) {\n    if (valueNode.kind === Kind.NULL) {\n      return;\n    }\n    return valueFromAST$1(valueNode, type2.ofType, variables);\n  }\n  if (valueNode.kind === Kind.NULL) {\n    return null;\n  }\n  if (isListType(type2)) {\n    const itemType = type2.ofType;\n    if (valueNode.kind === Kind.LIST) {\n      const coercedValues = [];\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable$1(itemNode, variables)) {\n          if (isNonNullType(itemType)) {\n            return;\n          }\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST$1(itemNode, itemType, variables);\n          if (itemValue === void 0) {\n            return;\n          }\n          coercedValues.push(itemValue);\n        }\n      }\n      return coercedValues;\n    }\n    const coercedValue = valueFromAST$1(valueNode, itemType, variables);\n    if (coercedValue === void 0) {\n      return;\n    }\n    return [coercedValue];\n  }\n  if (isInputObjectType(type2)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return;\n    }\n    const coercedObj = /* @__PURE__ */ Object.create(null);\n    const fieldNodes = keyMap$1(valueNode.fields, (field) => field.name.value);\n    for (const field of Object.values(type2.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n      if (!fieldNode || isMissingVariable$1(fieldNode.value, variables)) {\n        if (field.defaultValue !== void 0) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return;\n        }\n        continue;\n      }\n      const fieldValue = valueFromAST$1(fieldNode.value, field.type, variables);\n      if (fieldValue === void 0) {\n        return;\n      }\n      coercedObj[field.name] = fieldValue;\n    }\n    return coercedObj;\n  }\n  if (isLeafType(type2)) {\n    let result2;\n    try {\n      result2 = type2.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return;\n    }\n    if (result2 === void 0) {\n      return;\n    }\n    return result2;\n  }\n  invariant$2(false, \"Unexpected input type: \" + inspect$2(type2));\n}\nfunction isMissingVariable$1(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);\n}\nfunction getVariableValues$1(schema, varDefNodes, inputs, options) {\n  const errors2 = [];\n  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;\n  try {\n    const coerced = coerceVariableValues$1(schema, varDefNodes, inputs, (error2) => {\n      if (maxErrors != null && errors2.length >= maxErrors) {\n        throw new GraphQLError(\"Too many errors processing variables, error limit reached. Execution aborted.\");\n      }\n      errors2.push(error2);\n    });\n    if (errors2.length === 0) {\n      return {\n        coerced\n      };\n    }\n  } catch (error2) {\n    errors2.push(error2);\n  }\n  return {\n    errors: errors2\n  };\n}\nfunction coerceVariableValues$1(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type);\n    if (!isInputType(varType)) {\n      const varTypeStr = print(varDefNode.type);\n      onError(new GraphQLError(`Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`, varDefNode.type));\n      continue;\n    }\n    if (!hasOwnProperty$2(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST$1(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect$2(varType);\n        onError(new GraphQLError(`Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`, varDefNode));\n      }\n      continue;\n    }\n    const value = inputs[varName];\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect$2(varType);\n      onError(new GraphQLError(`Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`, varDefNode));\n      continue;\n    }\n    coercedValues[varName] = coerceInputValue$1(value, varType, (path, invalidValue, error2) => {\n      let prefix = `Variable \"$${varName}\" got invalid value ` + inspect$2(invalidValue);\n      if (path.length > 0) {\n        prefix += ` at \"${varName}${printPathArray$1(path)}\"`;\n      }\n      onError(new GraphQLError(prefix + \"; \" + error2.message, varDefNode, void 0, void 0, void 0, error2.originalError));\n    });\n  }\n  return coercedValues;\n}\nfunction getArgumentValues$1(def, node, variableValues) {\n  var _node$arguments;\n  const coercedValues = {};\n  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];\n  const argNodeMap = keyMap$1(argumentNodes, (arg) => arg.name.value);\n  for (const argDef of def.args) {\n    const name2 = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name2];\n    if (!argumentNode) {\n      if (argDef.defaultValue !== void 0) {\n        coercedValues[name2] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(`Argument \"${name2}\" of required type \"${inspect$2(argType)}\" was not provided.`, node);\n      }\n      continue;\n    }\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n      if (variableValues == null || !hasOwnProperty$2(variableValues, variableName)) {\n        if (argDef.defaultValue !== void 0) {\n          coercedValues[name2] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(`Argument \"${name2}\" of required type \"${inspect$2(argType)}\" was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n        }\n        continue;\n      }\n      isNull = variableValues[variableName] == null;\n    }\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(`Argument \"${name2}\" of non-null type \"${inspect$2(argType)}\" must not be null.`, valueNode);\n    }\n    const coercedValue = valueFromAST$1(valueNode, argType, variableValues);\n    if (coercedValue === void 0) {\n      throw new GraphQLError(`Argument \"${name2}\" has invalid value ${print(valueNode)}.`, valueNode);\n    }\n    coercedValues[name2] = coercedValue;\n  }\n  return coercedValues;\n}\nfunction getDirectiveValues$1(directiveDef, node, variableValues) {\n  var _node$directives;\n  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive) => directive.name.value === directiveDef.name);\n  if (directiveNode) {\n    return getArgumentValues$1(directiveDef, directiveNode, variableValues);\n  }\n}\nfunction hasOwnProperty$2(obj, prop2) {\n  return Object.prototype.hasOwnProperty.call(obj, prop2);\n}\nfunction collectFields$1(schema, fragments, variableValues, runtimeType, selectionSet) {\n  const fields = /* @__PURE__ */ new Map();\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, /* @__PURE__ */ new Set());\n  return fields;\n}\nfunction collectSubfields$1(schema, fragments, variableValues, returnType, fieldNodes) {\n  const subFieldNodes = /* @__PURE__ */ new Map();\n  const visitedFragmentNames = /* @__PURE__ */ new Set();\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n  return subFieldNodes;\n}\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode$1(variableValues, selection)) {\n          continue;\n        }\n        const name2 = getFieldEntryKey$1(selection);\n        const fieldList = fields.get(name2);\n        if (fieldList !== void 0) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name2, [selection]);\n        }\n        break;\n      }\n      case Kind.INLINE_FRAGMENT: {\n        if (!shouldIncludeNode$1(variableValues, selection) || !doesFragmentConditionMatch$1(schema, selection, runtimeType)) {\n          continue;\n        }\n        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n        break;\n      }\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode$1(variableValues, selection)) {\n          continue;\n        }\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n        if (!fragment || !doesFragmentConditionMatch$1(schema, fragment, runtimeType)) {\n          continue;\n        }\n        collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n        break;\n      }\n    }\n  }\n}\nfunction shouldIncludeNode$1(variableValues, node) {\n  const skip2 = getDirectiveValues$1(GraphQLSkipDirective, node, variableValues);\n  if ((skip2 === null || skip2 === void 0 ? void 0 : skip2.if) === true) {\n    return false;\n  }\n  const include = getDirectiveValues$1(GraphQLIncludeDirective, node, variableValues);\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n  return true;\n}\nfunction doesFragmentConditionMatch$1(schema, fragment, type2) {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n  if (conditionalType === type2) {\n    return true;\n  }\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type2);\n  }\n  return false;\n}\nfunction getFieldEntryKey$1(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\nfunction SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === \"subscription\") {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = /* @__PURE__ */ Object.create(null);\n          const document2 = context.getDocument();\n          const fragments = /* @__PURE__ */ Object.create(null);\n          for (const definition of document2.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n          const fields = collectFields$1(schema, fragments, variableValues, subscriptionType, node.selectionSet);\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(new GraphQLError(operationName != null ? `Subscription \"${operationName}\" must select only one top level field.` : \"Anonymous Subscription must select only one top level field.\", extraFieldSelections));\n          }\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n            if (fieldName.startsWith(\"__\")) {\n              context.reportError(new GraphQLError(operationName != null ? `Subscription \"${operationName}\" must not select an introspection top level field.` : \"Anonymous Subscription must not select an introspection top level field.\", fieldNodes));\n            }\n          }\n        }\n      }\n    }\n  };\n}\nfunction groupBy(list3, keyFn) {\n  const result2 = /* @__PURE__ */ new Map();\n  for (const item of list3) {\n    const key = keyFn(item);\n    const group = result2.get(key);\n    if (group === void 0) {\n      result2.set(key, [item]);\n    } else {\n      group.push(item);\n    }\n  }\n  return result2;\n}\nfunction UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField\n  };\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n    const typeName = typeNode.name.value;\n    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n      const fieldName = fieldDef.name.value;\n      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n    return false;\n  }\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(new GraphQLError(`Argument \"${parentName}(${argName}:)\" can only be defined once.`, argNodes.map((node) => node.name)));\n      }\n    }\n    return false;\n  }\n}\nfunction UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness\n  };\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(new GraphQLError(`There can be only one argument named \"${argName}\".`, argNodes.map((node) => node.name)));\n      }\n    }\n  }\n}\nfunction UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {\n        context.reportError(new GraphQLError(`Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`, node.name));\n        return;\n      }\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(new GraphQLError(`There can be only one directive named \"@${directiveName}\".`, [knownDirectiveNames[directiveName], node.name]));\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n      return false;\n    }\n  };\n}\nfunction UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n  const astDefinitions = context.getDocument().definitions;\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n  const schemaDirectives = /* @__PURE__ */ Object.create(null);\n  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);\n  return {\n    enter(node) {\n      if (!(\"directives\" in node) || !node.directives) {\n        return;\n      }\n      let seenDirectives;\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n        if (seenDirectives === void 0) {\n          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);\n        }\n      } else {\n        seenDirectives = /* @__PURE__ */ Object.create(null);\n      }\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(`The directive \"@${directiveName}\" can only be used once at this location.`, [seenDirectives[directiveName], directive]));\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    }\n  };\n}\nfunction UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);\n  const knownValueNames = /* @__PURE__ */ Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness\n  };\n  function checkValueUniqueness(node) {\n    var _node$values;\n    const typeName = node.name.value;\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);\n    }\n    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n    const valueNames = knownValueNames[typeName];\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(new GraphQLError(`Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`, valueDef.name));\n      } else if (valueNames[valueName]) {\n        context.reportError(new GraphQLError(`Enum value \"${typeName}.${valueName}\" can only be defined once.`, [valueNames[valueName], valueDef.name]));\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n    return false;\n  }\n}\nfunction UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);\n  const knownFieldNames = /* @__PURE__ */ Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness\n  };\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n    const typeName = node.name.value;\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);\n    }\n    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n    const fieldNames = knownFieldNames[typeName];\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(new GraphQLError(`Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`, fieldDef.name));\n      } else if (fieldNames[fieldName]) {\n        context.reportError(new GraphQLError(`Field \"${typeName}.${fieldName}\" can only be defined once.`, [fieldNames[fieldName], fieldDef.name]));\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n    return false;\n  }\n}\nfunction hasField(type2, fieldName) {\n  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {\n    return type2.getFields()[fieldName] != null;\n  }\n  return false;\n}\nfunction UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = /* @__PURE__ */ Object.create(null);\n  return {\n    OperationDefinition: () => false,\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new GraphQLError(`There can be only one fragment named \"${fragmentName}\".`, [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n      return false;\n    }\n  };\n}\nfunction UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = /* @__PURE__ */ Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = /* @__PURE__ */ Object.create(null);\n      },\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant$2(false);\n        knownNames = prevKnownNames;\n      }\n    },\n    ObjectField(node) {\n      const fieldName = node.name.value;\n      if (knownNames[fieldName]) {\n        context.reportError(new GraphQLError(`There can be only one input field named \"${fieldName}\".`, [knownNames[fieldName], node.name]));\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    }\n  };\n}\nfunction UniqueOperationNamesRule(context) {\n  const knownOperationNames = /* @__PURE__ */ Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new GraphQLError(`There can be only one operation named \"${operationName.value}\".`, [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n      return false;\n    },\n    FragmentDefinition: () => false\n  };\n}\nfunction UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = /* @__PURE__ */ Object.create(null);\n  const existingOperationTypes = schema ? {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType()\n  } : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes\n  };\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n      if (existingOperationTypes[operation]) {\n        context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, operationType));\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, [alreadyDefinedOperationType, operationType]));\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n    return false;\n  }\n}\nfunction UniqueTypeNamesRule(context) {\n  const knownTypeNames = /* @__PURE__ */ Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName\n  };\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(new GraphQLError(`Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`, node.name));\n      return;\n    }\n    if (knownTypeNames[typeName]) {\n      context.reportError(new GraphQLError(`There can be only one type named \"${typeName}\".`, [\n        knownTypeNames[typeName],\n        node.name\n      ]));\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n    return false;\n  }\n}\nfunction UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];\n      const seenVariableDefinitions = groupBy(variableDefinitions, (node) => node.variable.name.value);\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(new GraphQLError(`There can be only one variable named \"$${variableName}\".`, variableNodes.map((node) => node.variable.name)));\n        }\n      }\n    }\n  };\n}\nfunction ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      const type2 = getNullableType(context.getParentInputType());\n      if (!isListType(type2)) {\n        isValidValueNode(context, node);\n        return false;\n      }\n    },\n    ObjectValue(node) {\n      const type2 = getNamedType(context.getInputType());\n      if (!isInputObjectType(type2)) {\n        isValidValueNode(context, node);\n        return false;\n      }\n      const fieldNodeMap = keyMap$1(node.fields, (field) => field.name.value);\n      for (const fieldDef of Object.values(type2.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect$2(fieldDef.type);\n          context.reportError(new GraphQLError(`Field \"${type2.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`, node));\n        }\n      }\n    },\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList$1(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new GraphQLError(`Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` + didYouMean$1(suggestions), node));\n      }\n    },\n    NullValue(node) {\n      const type2 = context.getInputType();\n      if (isNonNullType(type2)) {\n        context.reportError(new GraphQLError(`Expected value of type \"${inspect$2(type2)}\", found ${print(node)}.`, node));\n      }\n    },\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node)\n  };\n}\nfunction isValidValueNode(context, node) {\n  const locationType = context.getInputType();\n  if (!locationType) {\n    return;\n  }\n  const type2 = getNamedType(locationType);\n  if (!isLeafType(type2)) {\n    const typeStr = inspect$2(locationType);\n    context.reportError(new GraphQLError(`Expected value of type \"${typeStr}\", found ${print(node)}.`, node));\n    return;\n  }\n  try {\n    const parseResult = type2.parseLiteral(node, void 0);\n    if (parseResult === void 0) {\n      const typeStr = inspect$2(locationType);\n      context.reportError(new GraphQLError(`Expected value of type \"${typeStr}\", found ${print(node)}.`, node));\n    }\n  } catch (error2) {\n    const typeStr = inspect$2(locationType);\n    if (error2 instanceof GraphQLError) {\n      context.reportError(error2);\n    } else {\n      context.reportError(new GraphQLError(`Expected value of type \"${typeStr}\", found ${print(node)}; ` + error2.message, node, void 0, void 0, void 0, error2));\n    }\n  }\n}\nfunction VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type2 = typeFromAST(context.getSchema(), node.type);\n      if (type2 !== void 0 && !isInputType(type2)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(new GraphQLError(`Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`, node.type));\n      }\n    }\n  };\n}\nfunction VariablesInAllowedPositionRule(context) {\n  let varDefMap = /* @__PURE__ */ Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = /* @__PURE__ */ Object.create(null);\n      },\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n        for (const { node, type: type2, defaultValue: defaultValue2 } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n          if (varDef && type2) {\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type2, defaultValue2)) {\n              const varTypeStr = inspect$2(varType);\n              const typeStr = inspect$2(type2);\n              context.reportError(new GraphQLError(`Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`, [varDef, node]));\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\nfunction allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== void 0;\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\nconst specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule\n]);\nconst specifiedSDLRules$1 = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule\n]);\nclass ASTValidationContext {\n  constructor(ast2, onError) {\n    this._ast = ast2;\n    this._fragments = void 0;\n    this._fragmentSpreads = /* @__PURE__ */ new Map();\n    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();\n    this._onError = onError;\n  }\n  get [Symbol.toStringTag]() {\n    return \"ASTValidationContext\";\n  }\n  reportError(error2) {\n    this._onError(error2);\n  }\n  getDocument() {\n    return this._ast;\n  }\n  getFragment(name2) {\n    let fragments;\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = /* @__PURE__ */ Object.create(null);\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n      this._fragments = fragments;\n    }\n    return fragments[name2];\n  }\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set2;\n      while (set2 = setsToVisit.pop()) {\n        for (const selection of set2.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n      this._fragmentSpreads.set(node, spreads);\n    }\n    return spreads;\n  }\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = /* @__PURE__ */ Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n      while (node = nodesToVisit.pop()) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n    return fragments;\n  }\n}\nclass SDLValidationContext extends ASTValidationContext {\n  constructor(ast2, schema, onError) {\n    super(ast2, onError);\n    this._schema = schema;\n  }\n  get [Symbol.toStringTag]() {\n    return \"SDLValidationContext\";\n  }\n  getSchema() {\n    return this._schema;\n  }\n}\nclass ValidationContext extends ASTValidationContext {\n  constructor(schema, ast2, typeInfo, onError) {\n    super(ast2, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = /* @__PURE__ */ new Map();\n    this._recursiveVariableUsages = /* @__PURE__ */ new Map();\n  }\n  get [Symbol.toStringTag]() {\n    return \"ValidationContext\";\n  }\n  getSchema() {\n    return this._schema;\n  }\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(node, visitWithTypeInfo(typeInfo, {\n        VariableDefinition: () => false,\n        Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n      this._variableUsages.set(node, usages);\n    }\n    return usages;\n  }\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n    return usages;\n  }\n  getType() {\n    return this._typeInfo.getType();\n  }\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\nfunction validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {\n  var _options$maxErrors;\n  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;\n  documentAST || devAssert$1(false, \"Must provide document.\");\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors2 = [];\n  const context = new ValidationContext(schema, documentAST, typeInfo, (error2) => {\n    if (errors2.length >= maxErrors) {\n      errors2.push(new GraphQLError(\"Too many validation errors, error limit reached. Validation aborted.\"));\n      throw abortObj;\n    }\n    errors2.push(error2);\n  });\n  const visitor = visitInParallel(rules.map((rule) => rule(context)));\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n  return errors2;\n}\nfunction validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules$1) {\n  const errors2 = [];\n  const context = new SDLValidationContext(documentAST, schemaToExtend, (error2) => {\n    errors2.push(error2);\n  });\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors2;\n}\nfunction assertValidSDL(documentAST) {\n  const errors2 = validateSDL(documentAST);\n  if (errors2.length !== 0) {\n    throw new Error(errors2.map((error2) => error2.message).join(\"\\n\\n\"));\n  }\n}\nfunction assertValidSDLExtension(documentAST, schema) {\n  const errors2 = validateSDL(documentAST, schema);\n  if (errors2.length !== 0) {\n    throw new Error(errors2.map((error2) => error2.message).join(\"\\n\\n\"));\n  }\n}\nfunction memoize3(fn) {\n  let cache0;\n  return function memoized(a1, a2, a3) {\n    if (cache0 === void 0) {\n      cache0 = /* @__PURE__ */ new WeakMap();\n    }\n    let cache1 = cache0.get(a1);\n    if (cache1 === void 0) {\n      cache1 = /* @__PURE__ */ new WeakMap();\n      cache0.set(a1, cache1);\n    }\n    let cache2 = cache1.get(a2);\n    if (cache2 === void 0) {\n      cache2 = /* @__PURE__ */ new WeakMap();\n      cache1.set(a2, cache2);\n    }\n    let fnResult = cache2.get(a3);\n    if (fnResult === void 0) {\n      fnResult = fn(a1, a2, a3);\n      cache2.set(a3, fnResult);\n    }\n    return fnResult;\n  };\n}\nfunction promiseForObject(object) {\n  return Promise.all(Object.values(object)).then((resolvedValues) => {\n    const resolvedObject = /* @__PURE__ */ Object.create(null);\n    for (const [i, key] of Object.keys(object).entries()) {\n      resolvedObject[key] = resolvedValues[i];\n    }\n    return resolvedObject;\n  });\n}\nfunction promiseReduce$1(values, callbackFn, initialValue) {\n  let accumulator = initialValue;\n  for (const value of values) {\n    accumulator = isPromise$2(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);\n  }\n  return accumulator;\n}\nfunction toError$1(thrownValue) {\n  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown$1(thrownValue);\n}\nclass NonErrorThrown$1 extends Error {\n  constructor(thrownValue) {\n    super(\"Unexpected error value: \" + inspect$2(thrownValue));\n    this.name = \"NonErrorThrown\";\n    this.thrownValue = thrownValue;\n  }\n}\nfunction locatedError(rawOriginalError, nodes, path) {\n  var _nodes;\n  const originalError = toError$1(rawOriginalError);\n  if (isLocatedGraphQLError(originalError)) {\n    return originalError;\n  }\n  return new GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes, originalError.source, originalError.positions, path, originalError);\n}\nfunction isLocatedGraphQLError(error2) {\n  return Array.isArray(error2.path);\n}\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) => collectSubfields$1(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));\nfunction execute$1(args) {\n  arguments.length < 2 || devAssert$1(false, \"graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.\");\n  const { schema, document: document2, variableValues, rootValue } = args;\n  assertValidExecutionArguments(schema, document2, variableValues);\n  const exeContext = buildExecutionContext(args);\n  if (!(\"schema\" in exeContext)) {\n    return {\n      errors: exeContext\n    };\n  }\n  try {\n    const { operation } = exeContext;\n    const result2 = executeOperation(exeContext, operation, rootValue);\n    if (isPromise$2(result2)) {\n      return result2.then((data) => buildResponse(data, exeContext.errors), (error2) => {\n        exeContext.errors.push(error2);\n        return buildResponse(null, exeContext.errors);\n      });\n    }\n    return buildResponse(result2, exeContext.errors);\n  } catch (error2) {\n    exeContext.errors.push(error2);\n    return buildResponse(null, exeContext.errors);\n  }\n}\nfunction executeSync(args) {\n  const result2 = execute$1(args);\n  if (isPromise$2(result2)) {\n    throw new Error(\"GraphQL execution failed to complete synchronously.\");\n  }\n  return result2;\n}\nfunction buildResponse(data, errors2) {\n  return errors2.length === 0 ? {\n    data\n  } : {\n    errors: errors2,\n    data\n  };\n}\nfunction assertValidExecutionArguments(schema, document2, rawVariableValues) {\n  document2 || devAssert$1(false, \"Must provide document.\");\n  assertValidSchema(schema);\n  rawVariableValues == null || isObjectLike$1(rawVariableValues) || devAssert$1(false, \"Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.\");\n}\nfunction buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n  const {\n    schema,\n    document: document2,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver\n  } = args;\n  let operation;\n  const fragments = /* @__PURE__ */ Object.create(null);\n  for (const definition of document2.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== void 0) {\n            return [\n              new GraphQLError(\"Must provide operation name if query contains multiple operations.\")\n            ];\n          }\n          operation = definition;\n        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n          operation = definition;\n        }\n        break;\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n    }\n  }\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n    return [new GraphQLError(\"Must provide an operation.\")];\n  }\n  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];\n  const coercedVariableValues = getVariableValues$1(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {\n    maxErrors: 50\n  });\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver$1,\n    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver$1,\n    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver$1,\n    errors: []\n  };\n}\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n  if (rootType == null) {\n    throw new GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, operation);\n  }\n  const rootFields = collectFields$1(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);\n  const path = void 0;\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n    case OperationTypeNode.SUBSCRIPTION:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return promiseReduce$1(fields.entries(), (results, [responseName, fieldNodes]) => {\n    const fieldPath = addPath$1(path, responseName, parentType.name);\n    const result2 = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n    if (result2 === void 0) {\n      return results;\n    }\n    if (isPromise$2(result2)) {\n      return result2.then((resolvedResult) => {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n    results[responseName] = result2;\n    return results;\n  }, /* @__PURE__ */ Object.create(null));\n}\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = /* @__PURE__ */ Object.create(null);\n  let containsPromise = false;\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = addPath$1(path, responseName, parentType.name);\n    const result2 = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n    if (result2 !== void 0) {\n      results[responseName] = result2;\n      if (isPromise$2(result2)) {\n        containsPromise = true;\n      }\n    }\n  }\n  if (!containsPromise) {\n    return results;\n  }\n  return promiseForObject(results);\n}\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n  const fieldDef = getFieldDef$2(exeContext.schema, parentType, fieldNodes[0]);\n  if (!fieldDef) {\n    return;\n  }\n  const returnType = fieldDef.type;\n  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;\n  const info2 = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);\n  try {\n    const args = getArgumentValues$1(fieldDef, fieldNodes[0], exeContext.variableValues);\n    const contextValue = exeContext.contextValue;\n    const result2 = resolveFn(source, args, contextValue, info2);\n    let completed;\n    if (isPromise$2(result2)) {\n      completed = result2.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info2, path, resolved));\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info2, path, result2);\n    }\n    if (isPromise$2(completed)) {\n      return completed.then(void 0, (rawError) => {\n        const error2 = locatedError(rawError, fieldNodes, pathToArray$1(path));\n        return handleFieldError(error2, returnType, exeContext);\n      });\n    }\n    return completed;\n  } catch (rawError) {\n    const error2 = locatedError(rawError, fieldNodes, pathToArray$1(path));\n    return handleFieldError(error2, returnType, exeContext);\n  }\n}\nfunction buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n}\nfunction handleFieldError(error2, returnType, exeContext) {\n  if (isNonNullType(returnType)) {\n    throw error2;\n  }\n  exeContext.errors.push(error2);\n  return null;\n}\nfunction completeValue(exeContext, returnType, fieldNodes, info2, path, result2) {\n  if (result2 instanceof Error) {\n    throw result2;\n  }\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info2, path, result2);\n    if (completed === null) {\n      throw new Error(`Cannot return null for non-nullable field ${info2.parentType.name}.${info2.fieldName}.`);\n    }\n    return completed;\n  }\n  if (result2 == null) {\n    return null;\n  }\n  if (isListType(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info2, path, result2);\n  }\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result2);\n  }\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info2, path, result2);\n  }\n  if (isObjectType(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info2, path, result2);\n  }\n  invariant$2(false, \"Cannot complete value of unexpected output type: \" + inspect$2(returnType));\n}\nfunction completeListValue(exeContext, returnType, fieldNodes, info2, path, result2) {\n  if (!isIterableObject$1(result2)) {\n    throw new GraphQLError(`Expected Iterable, but did not find one for field \"${info2.parentType.name}.${info2.fieldName}\".`);\n  }\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result2, (item, index) => {\n    const itemPath = addPath$1(path, index, void 0);\n    try {\n      let completedItem;\n      if (isPromise$2(item)) {\n        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info2, itemPath, resolved));\n      } else {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info2, itemPath, item);\n      }\n      if (isPromise$2(completedItem)) {\n        containsPromise = true;\n        return completedItem.then(void 0, (rawError) => {\n          const error2 = locatedError(rawError, fieldNodes, pathToArray$1(itemPath));\n          return handleFieldError(error2, itemType, exeContext);\n        });\n      }\n      return completedItem;\n    } catch (rawError) {\n      const error2 = locatedError(rawError, fieldNodes, pathToArray$1(itemPath));\n      return handleFieldError(error2, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\nfunction completeLeafValue(returnType, result2) {\n  const serializedResult = returnType.serialize(result2);\n  if (serializedResult == null) {\n    throw new Error(`Expected \\`${inspect$2(returnType)}.serialize(${inspect$2(result2)})\\` to return non-nullable value, returned: ${inspect$2(serializedResult)}`);\n  }\n  return serializedResult;\n}\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info2, path, result2) {\n  var _returnType$resolveTy;\n  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result2, contextValue, info2, returnType);\n  if (isPromise$2(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info2, result2), fieldNodes, info2, path, result2));\n  }\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info2, result2), fieldNodes, info2, path, result2);\n}\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info2, result2) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info2.parentType.name}.${info2.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`, fieldNodes);\n  }\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError(\"Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.\");\n  }\n  if (typeof runtimeTypeName !== \"string\") {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info2.parentType.name}.${info2.fieldName}\" with value ${inspect$2(result2)}, received \"${inspect$2(runtimeTypeName)}\".`);\n  }\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n  if (runtimeType == null) {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`, fieldNodes);\n  }\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`, fieldNodes);\n  }\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(`Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`, fieldNodes);\n  }\n  return runtimeType;\n}\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info2, path, result2) {\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result2, exeContext.contextValue, info2);\n    if (isPromise$2(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result2, fieldNodes);\n        }\n        return executeFields(exeContext, returnType, result2, path, subFieldNodes);\n      });\n    }\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result2, fieldNodes);\n    }\n  }\n  return executeFields(exeContext, returnType, result2, path, subFieldNodes);\n}\nfunction invalidReturnTypeError(returnType, result2, fieldNodes) {\n  return new GraphQLError(`Expected value of type \"${returnType.name}\" but got: ${inspect$2(result2)}.`, fieldNodes);\n}\nconst defaultTypeResolver$1 = function(value, contextValue, info2, abstractType) {\n  if (isObjectLike$1(value) && typeof value.__typename === \"string\") {\n    return value.__typename;\n  }\n  const possibleTypes = info2.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type2 = possibleTypes[i];\n    if (type2.isTypeOf) {\n      const isTypeOfResult = type2.isTypeOf(value, contextValue, info2);\n      if (isPromise$2(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type2.name;\n      }\n    }\n  }\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\nconst defaultFieldResolver$1 = function(source, args, contextValue, info2) {\n  if (isObjectLike$1(source) || typeof source === \"function\") {\n    const property = source[info2.fieldName];\n    if (typeof property === \"function\") {\n      return source[info2.fieldName](args, contextValue, info2);\n    }\n    return property;\n  }\n};\nfunction getFieldDef$2(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n  return parentType.getFields()[fieldName];\n}\nfunction graphql$1(args) {\n  return new Promise((resolve) => resolve(graphqlImpl(args)));\n}\nfunction graphqlSync(args) {\n  const result2 = graphqlImpl(args);\n  if (isPromise$2(result2)) {\n    throw new Error(\"GraphQL execution failed to complete synchronously.\");\n  }\n  return result2;\n}\nfunction graphqlImpl(args) {\n  arguments.length < 2 || devAssert$1(false, \"graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.\");\n  const {\n    schema,\n    source,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver\n  } = args;\n  const schemaValidationErrors = validateSchema(schema);\n  if (schemaValidationErrors.length > 0) {\n    return {\n      errors: schemaValidationErrors\n    };\n  }\n  let document2;\n  try {\n    document2 = parse$1(source);\n  } catch (syntaxError2) {\n    return {\n      errors: [syntaxError2]\n    };\n  }\n  const validationErrors = validate(schema, document2);\n  if (validationErrors.length > 0) {\n    return {\n      errors: validationErrors\n    };\n  }\n  return execute$1({\n    schema,\n    document: document2,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    typeResolver\n  });\n}\nfunction isAsyncIterable$3(maybeAsyncIterable) {\n  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === \"function\";\n}\nfunction mapAsyncIterator$1(iterable, callback) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  async function mapResult(result2) {\n    if (result2.done) {\n      return result2;\n    }\n    try {\n      return {\n        value: await callback(result2.value),\n        done: false\n      };\n    } catch (error2) {\n      if (typeof iterator.return === \"function\") {\n        try {\n          await iterator.return();\n        } catch (_e) {\n        }\n      }\n      throw error2;\n    }\n  }\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n    async return() {\n      return typeof iterator.return === \"function\" ? mapResult(await iterator.return()) : {\n        value: void 0,\n        done: true\n      };\n    },\n    async throw(error2) {\n      if (typeof iterator.throw === \"function\") {\n        return mapResult(await iterator.throw(error2));\n      }\n      throw error2;\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\nasync function subscribe(args) {\n  arguments.length < 2 || devAssert$1(false, \"graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.\");\n  const {\n    schema,\n    document: document2,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver,\n    subscribeFieldResolver\n  } = args;\n  const resultOrStream = await createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);\n  if (!isAsyncIterable$3(resultOrStream)) {\n    return resultOrStream;\n  }\n  const mapSourceToResponse = (payload) => execute$1({\n    schema,\n    document: document2,\n    rootValue: payload,\n    contextValue,\n    variableValues,\n    operationName,\n    fieldResolver\n  });\n  return mapAsyncIterator$1(resultOrStream, mapSourceToResponse);\n}\nasync function createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver) {\n  assertValidExecutionArguments(schema, document2, variableValues);\n  const exeContext = buildExecutionContext({\n    schema,\n    document: document2,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName,\n    subscribeFieldResolver\n  });\n  if (!(\"schema\" in exeContext)) {\n    return {\n      errors: exeContext\n    };\n  }\n  try {\n    const eventStream = await executeSubscription(exeContext);\n    if (!isAsyncIterable$3(eventStream)) {\n      throw new Error(`Subscription field must return Async Iterable. Received: ${inspect$2(eventStream)}.`);\n    }\n    return eventStream;\n  } catch (error2) {\n    if (error2 instanceof GraphQLError) {\n      return {\n        errors: [error2]\n      };\n    }\n    throw error2;\n  }\n}\nasync function executeSubscription(exeContext) {\n  const { schema, fragments, operation, variableValues, rootValue } = exeContext;\n  const rootType = schema.getSubscriptionType();\n  if (rootType == null) {\n    throw new GraphQLError(\"Schema is not configured to execute subscription operation.\", operation);\n  }\n  const rootFields = collectFields$1(schema, fragments, variableValues, rootType, operation.selectionSet);\n  const [responseName, fieldNodes] = [...rootFields.entries()][0];\n  const fieldDef = getFieldDef$2(schema, rootType, fieldNodes[0]);\n  if (!fieldDef) {\n    const fieldName = fieldNodes[0].name.value;\n    throw new GraphQLError(`The subscription field \"${fieldName}\" is not defined.`, fieldNodes);\n  }\n  const path = addPath$1(void 0, responseName, rootType.name);\n  const info2 = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);\n  try {\n    var _fieldDef$subscribe;\n    const args = getArgumentValues$1(fieldDef, fieldNodes[0], variableValues);\n    const contextValue = exeContext.contextValue;\n    const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;\n    const eventStream = await resolveFn(rootValue, args, contextValue, info2);\n    if (eventStream instanceof Error) {\n      throw eventStream;\n    }\n    return eventStream;\n  } catch (error2) {\n    throw locatedError(error2, fieldNodes, pathToArray$1(path));\n  }\n}\nfunction NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant$2(false);\n        context.reportError(new GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, node));\n      }\n    },\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n        if (directiveDef != null) {\n          context.reportError(new GraphQLError(`Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`, node));\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          parentType != null && fieldDef != null || invariant$2(false);\n          context.reportError(new GraphQLError(`Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`, node));\n        }\n      }\n    },\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;\n        if (deprecationReason != null) {\n          context.reportError(new GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, node));\n        }\n      }\n    },\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant$2(false);\n        context.reportError(new GraphQLError(`The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`, node));\n      }\n    }\n  };\n}\nfunction NoSchemaIntrospectionCustomRule(context) {\n  return {\n    Field(node) {\n      const type2 = getNamedType(context.getType());\n      if (type2 && isIntrospectionType(type2)) {\n        context.reportError(new GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field \"${node.name.value}\".`, node));\n      }\n    }\n  };\n}\nfunction getIntrospectionQuery(options) {\n  const optionsWithDefault = __spreadValues({\n    descriptions: true,\n    specifiedByUrl: false,\n    directiveIsRepeatable: false,\n    schemaDescription: false,\n    inputValueDeprecation: false\n  }, options);\n  const descriptions = optionsWithDefault.descriptions ? \"description\" : \"\";\n  const specifiedByUrl = optionsWithDefault.specifiedByUrl ? \"specifiedByURL\" : \"\";\n  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? \"isRepeatable\" : \"\";\n  const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : \"\";\n  function inputDeprecation(str) {\n    return optionsWithDefault.inputValueDeprecation ? str : \"\";\n  }\n  return `\n    query IntrospectionQuery {\n      __schema {\n        ${schemaDescription}\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ${descriptions}\n          ${directiveIsRepeatable}\n          locations\n          args${inputDeprecation(\"(includeDeprecated: true)\")} {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ${descriptions}\n      ${specifiedByUrl}\n      fields(includeDeprecated: true) {\n        name\n        ${descriptions}\n        args${inputDeprecation(\"(includeDeprecated: true)\")} {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields${inputDeprecation(\"(includeDeprecated: true)\")} {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ${descriptions}\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ${descriptions}\n      type { ...TypeRef }\n      defaultValue\n      ${inputDeprecation(\"isDeprecated\")}\n      ${inputDeprecation(\"deprecationReason\")}\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n}\nfunction getOperationAST(documentAST, operationName) {\n  let operation = null;\n  for (const definition of documentAST.definitions) {\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      var _definition$name;\n      if (operationName == null) {\n        if (operation) {\n          return null;\n        }\n        operation = definition;\n      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n        return definition;\n      }\n    }\n  }\n  return operation;\n}\nvar getOperationAST$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  getOperationAST\n});\nfunction getOperationRootType(schema, operation) {\n  if (operation.operation === \"query\") {\n    const queryType = schema.getQueryType();\n    if (!queryType) {\n      throw new GraphQLError(\"Schema does not define the required query root type.\", operation);\n    }\n    return queryType;\n  }\n  if (operation.operation === \"mutation\") {\n    const mutationType = schema.getMutationType();\n    if (!mutationType) {\n      throw new GraphQLError(\"Schema is not configured for mutations.\", operation);\n    }\n    return mutationType;\n  }\n  if (operation.operation === \"subscription\") {\n    const subscriptionType = schema.getSubscriptionType();\n    if (!subscriptionType) {\n      throw new GraphQLError(\"Schema is not configured for subscriptions.\", operation);\n    }\n    return subscriptionType;\n  }\n  throw new GraphQLError(\"Can only have query, mutation and subscription operations.\", operation);\n}\nfunction introspectionFromSchema(schema, options) {\n  const optionsWithDefaults = __spreadValues({\n    specifiedByUrl: true,\n    directiveIsRepeatable: true,\n    schemaDescription: true,\n    inputValueDeprecation: true\n  }, options);\n  const document2 = parse$1(getIntrospectionQuery(optionsWithDefaults));\n  const result2 = executeSync({\n    schema,\n    document: document2\n  });\n  !result2.errors && result2.data || invariant$2(false);\n  return result2.data;\n}\nfunction buildClientSchema(introspection2, options) {\n  isObjectLike$1(introspection2) && isObjectLike$1(introspection2.__schema) || devAssert$1(false, `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect$2(introspection2)}.`);\n  const schemaIntrospection = introspection2.__schema;\n  const typeMap = keyValMap(schemaIntrospection.types, (typeIntrospection) => typeIntrospection.name, (typeIntrospection) => buildType(typeIntrospection));\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  }\n  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;\n  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error(\"Decorated type deeper than introspection query.\");\n      }\n      return new GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error(\"Decorated type deeper than introspection query.\");\n      }\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n    return getNamedType2(typeRef);\n  }\n  function getNamedType2(typeRef) {\n    const typeName = typeRef.name;\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect$2(typeRef)}.`);\n    }\n    const type2 = typeMap[typeName];\n    if (!type2) {\n      throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);\n    }\n    return type2;\n  }\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType2(typeRef));\n  }\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType2(typeRef));\n  }\n  function buildType(type2) {\n    if (type2 != null && type2.name != null && type2.kind != null) {\n      switch (type2.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type2);\n        case TypeKind.OBJECT:\n          return buildObjectDef(type2);\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type2);\n        case TypeKind.UNION:\n          return buildUnionDef(type2);\n        case TypeKind.ENUM:\n          return buildEnumDef(type2);\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type2);\n      }\n    }\n    const typeStr = inspect$2(type2);\n    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);\n  }\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL\n    });\n  }\n  function buildImplementationsList(implementingIntrospection) {\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect$2(implementingIntrospection);\n      throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);\n    }\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection)\n    });\n  }\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection)\n    });\n  }\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect$2(unionIntrospection);\n      throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);\n    }\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect$2(enumIntrospection);\n      throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);\n    }\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, (valueIntrospection) => valueIntrospection.name, (valueIntrospection) => ({\n        description: valueIntrospection.description,\n        deprecationReason: valueIntrospection.deprecationReason\n      }))\n    });\n  }\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect$2(inputObjectIntrospection);\n      throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);\n    }\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)\n    });\n  }\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(`Introspection result missing fields: ${inspect$2(typeIntrospection)}.`);\n    }\n    return keyValMap(typeIntrospection.fields, (fieldIntrospection) => fieldIntrospection.name, buildField);\n  }\n  function buildField(fieldIntrospection) {\n    const type2 = getType(fieldIntrospection.type);\n    if (!isOutputType(type2)) {\n      const typeStr = inspect$2(type2);\n      throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);\n    }\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect$2(fieldIntrospection);\n      throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);\n    }\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type2,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, (inputValue) => inputValue.name, buildInputValue);\n  }\n  function buildInputValue(inputValueIntrospection) {\n    const type2 = getType(inputValueIntrospection.type);\n    if (!isInputType(type2)) {\n      const typeStr = inspect$2(type2);\n      throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);\n    }\n    const defaultValue2 = inputValueIntrospection.defaultValue != null ? valueFromAST$1(parseValue$1(inputValueIntrospection.defaultValue), type2) : void 0;\n    return {\n      description: inputValueIntrospection.description,\n      type: type2,\n      defaultValue: defaultValue2,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect$2(directiveIntrospection);\n      throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);\n    }\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect$2(directiveIntrospection);\n      throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);\n    }\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\nfunction extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert$1(false, \"Must provide valid Document AST.\");\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\nfunction extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n  const typeDefs = [];\n  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);\n  const directiveDefs = [];\n  let schemaDef;\n  const schemaExtensions = [];\n  for (const def of documentAST.definitions) {\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n  const typeMap = /* @__PURE__ */ Object.create(null);\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n    const name2 = typeNode.name.value;\n    typeMap[name2] = (_stdTypeMap$name = stdTypeMap[name2]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n  const operationTypes = __spreadValues(__spreadValues({\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));\n  return __spreadProps(__spreadValues({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective)\n    ],\n    extensions: /* @__PURE__ */ Object.create(null),\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  });\n  function replaceType(type2) {\n    if (isListType(type2)) {\n      return new GraphQLList(replaceType(type2.ofType));\n    }\n    if (isNonNullType(type2)) {\n      return new GraphQLNonNull(replaceType(type2.ofType));\n    }\n    return replaceNamedType(type2);\n  }\n  function replaceNamedType(type2) {\n    return typeMap[type2.name];\n  }\n  function replaceDirective(directive) {\n    const config2 = directive.toConfig();\n    return new GraphQLDirective(__spreadProps(__spreadValues({}, config2), {\n      args: mapValue(config2.args, extendArg)\n    }));\n  }\n  function extendNamedType(type2) {\n    if (isIntrospectionType(type2) || isSpecifiedScalarType(type2)) {\n      return type2;\n    }\n    if (isScalarType(type2)) {\n      return extendScalarType(type2);\n    }\n    if (isObjectType(type2)) {\n      return extendObjectType(type2);\n    }\n    if (isInterfaceType(type2)) {\n      return extendInterfaceType(type2);\n    }\n    if (isUnionType(type2)) {\n      return extendUnionType(type2);\n    }\n    if (isEnumType(type2)) {\n      return extendEnumType(type2);\n    }\n    if (isInputObjectType(type2)) {\n      return extendInputObjectType(type2);\n    }\n    invariant$2(false, \"Unexpected type: \" + inspect$2(type2));\n  }\n  function extendInputObjectType(type2) {\n    var _typeExtensionsMap$co;\n    const config2 = type2.toConfig();\n    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {\n      fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, (field) => __spreadProps(__spreadValues({}, field), {\n        type: replaceType(field.type)\n      }))), buildInputFieldMap(extensions)),\n      extensionASTNodes: config2.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendEnumType(type2) {\n    var _typeExtensionsMap$ty;\n    const config2 = type2.toConfig();\n    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {\n      values: __spreadValues(__spreadValues({}, config2.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config2.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendScalarType(type2) {\n    var _typeExtensionsMap$co2;\n    const config2 = type2.toConfig();\n    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    let specifiedByURL = config2.specifiedByURL;\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;\n    }\n    return new GraphQLScalarType(__spreadProps(__spreadValues({}, config2), {\n      specifiedByURL,\n      extensionASTNodes: config2.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendObjectType(type2) {\n    var _typeExtensionsMap$co3;\n    const config2 = type2.toConfig();\n    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {\n      interfaces: () => [\n        ...type2.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions)\n      ],\n      fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions)),\n      extensionASTNodes: config2.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendInterfaceType(type2) {\n    var _typeExtensionsMap$co4;\n    const config2 = type2.toConfig();\n    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {\n      interfaces: () => [\n        ...type2.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions)\n      ],\n      fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions)),\n      extensionASTNodes: config2.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendUnionType(type2) {\n    var _typeExtensionsMap$co5;\n    const config2 = type2.toConfig();\n    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(__spreadProps(__spreadValues({}, config2), {\n      types: () => [\n        ...type2.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions)\n      ],\n      extensionASTNodes: config2.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendField(field) {\n    return __spreadProps(__spreadValues({}, field), {\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg)\n    });\n  }\n  function extendArg(arg) {\n    return __spreadProps(__spreadValues({}, arg), { type: replaceType(arg.type) });\n  }\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n    for (const node of nodes) {\n      var _node$operationTypes;\n      const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n      for (const operationType of operationTypesNodes) {\n        opTypes[operationType.operation] = getNamedType2(operationType.type);\n      }\n    }\n    return opTypes;\n  }\n  function getNamedType2(node) {\n    var _stdTypeMap$name2;\n    const name2 = node.name.value;\n    const type2 = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];\n    if (type2 === void 0) {\n      throw new Error(`Unknown type: \"${name2}\".`);\n    }\n    return type2;\n  }\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n    return getNamedType2(node);\n  }\n  function buildDirective(node) {\n    var _node$description;\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = /* @__PURE__ */ Object.create(null);\n    for (const node of nodes) {\n      var _node$fields;\n      const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n      for (const field of nodeFields) {\n        var _field$description;\n        fieldConfigMap[field.name.value] = {\n          type: getWrappedType(field.type),\n          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n    return fieldConfigMap;\n  }\n  function buildArgumentMap(args) {\n    const argsNodes = args !== null && args !== void 0 ? args : [];\n    const argConfigMap = /* @__PURE__ */ Object.create(null);\n    for (const arg of argsNodes) {\n      var _arg$description;\n      const type2 = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type2,\n        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,\n        defaultValue: valueFromAST$1(arg.defaultValue, type2),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n    return argConfigMap;\n  }\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = /* @__PURE__ */ Object.create(null);\n    for (const node of nodes) {\n      var _node$fields2;\n      const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n      for (const field of fieldsNodes) {\n        var _field$description2;\n        const type2 = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type2,\n          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,\n          defaultValue: valueFromAST$1(field.defaultValue, type2),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n    return inputFieldMap;\n  }\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = /* @__PURE__ */ Object.create(null);\n    for (const node of nodes) {\n      var _node$values;\n      const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n      for (const value of valuesNodes) {\n        var _value$description;\n        enumValueMap[value.name.value] = {\n          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n    return enumValueMap;\n  }\n  function buildInterfaces(nodes) {\n    return nodes.flatMap((node) => {\n      var _node$interfaces$map, _node$interfaces;\n      return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];\n    });\n  }\n  function buildUnionTypes(nodes) {\n    return nodes.flatMap((node) => {\n      var _node$types$map, _node$types;\n      return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : [];\n    });\n  }\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n    const name2 = astNode.name.value;\n    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLObjectType({\n          name: name2,\n          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes\n        });\n      }\n      case Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInterfaceType({\n          name: name2,\n          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes\n        });\n      }\n      case Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLEnumType({\n          name: name2,\n          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes\n        });\n      }\n      case Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLUnionType({\n          name: name2,\n          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes\n        });\n      }\n      case Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n        return new GraphQLScalarType({\n          name: name2,\n          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes\n        });\n      }\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new GraphQLInputObjectType({\n          name: name2,\n          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes\n        });\n      }\n    }\n  }\n}\nconst stdTypeMap = keyMap$1([...specifiedScalarTypes, ...introspectionTypes], (type2) => type2.name);\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues$1(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = getDirectiveValues$1(GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\nfunction buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert$1(false, \"Must provide valid Document AST.\");\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n  const emptySchemaConfig = {\n    description: void 0,\n    types: [],\n    directives: [],\n    extensions: /* @__PURE__ */ Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  const config2 = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n  if (config2.astNode == null) {\n    for (const type2 of config2.types) {\n      switch (type2.name) {\n        case \"Query\":\n          config2.query = type2;\n          break;\n        case \"Mutation\":\n          config2.mutation = type2;\n          break;\n        case \"Subscription\":\n          config2.subscription = type2;\n          break;\n      }\n    }\n  }\n  const directives = [\n    ...config2.directives,\n    ...specifiedDirectives.filter((stdDirective) => config2.directives.every((directive) => directive.name !== stdDirective.name))\n  ];\n  return new GraphQLSchema(__spreadProps(__spreadValues({}, config2), { directives }));\n}\nfunction buildSchema(source, options) {\n  const document2 = parse$1(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables\n  });\n  return buildASTSchema(document2, {\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\nfunction lexicographicSortSchema(schema) {\n  const schemaConfig = schema.toConfig();\n  const typeMap = keyValMap(sortByName(schemaConfig.types), (type2) => type2.name, sortNamedType);\n  return new GraphQLSchema(__spreadProps(__spreadValues({}, schemaConfig), {\n    types: Object.values(typeMap),\n    directives: sortByName(schemaConfig.directives).map(sortDirective),\n    query: replaceMaybeType(schemaConfig.query),\n    mutation: replaceMaybeType(schemaConfig.mutation),\n    subscription: replaceMaybeType(schemaConfig.subscription)\n  }));\n  function replaceType(type2) {\n    if (isListType(type2)) {\n      return new GraphQLList(replaceType(type2.ofType));\n    } else if (isNonNullType(type2)) {\n      return new GraphQLNonNull(replaceType(type2.ofType));\n    }\n    return replaceNamedType(type2);\n  }\n  function replaceNamedType(type2) {\n    return typeMap[type2.name];\n  }\n  function replaceMaybeType(maybeType) {\n    return maybeType && replaceNamedType(maybeType);\n  }\n  function sortDirective(directive) {\n    const config2 = directive.toConfig();\n    return new GraphQLDirective(__spreadProps(__spreadValues({}, config2), {\n      locations: sortBy(config2.locations, (x2) => x2),\n      args: sortArgs(config2.args)\n    }));\n  }\n  function sortArgs(args) {\n    return sortObjMap(args, (arg) => __spreadProps(__spreadValues({}, arg), { type: replaceType(arg.type) }));\n  }\n  function sortFields2(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => __spreadProps(__spreadValues({}, field), {\n      type: replaceType(field.type),\n      args: field.args && sortArgs(field.args)\n    }));\n  }\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, (field) => __spreadProps(__spreadValues({}, field), {\n      type: replaceType(field.type)\n    }));\n  }\n  function sortTypes(array) {\n    return sortByName(array).map(replaceNamedType);\n  }\n  function sortNamedType(type2) {\n    if (isScalarType(type2) || isIntrospectionType(type2)) {\n      return type2;\n    }\n    if (isObjectType(type2)) {\n      const config2 = type2.toConfig();\n      return new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {\n        interfaces: () => sortTypes(config2.interfaces),\n        fields: () => sortFields2(config2.fields)\n      }));\n    }\n    if (isInterfaceType(type2)) {\n      const config2 = type2.toConfig();\n      return new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {\n        interfaces: () => sortTypes(config2.interfaces),\n        fields: () => sortFields2(config2.fields)\n      }));\n    }\n    if (isUnionType(type2)) {\n      const config2 = type2.toConfig();\n      return new GraphQLUnionType(__spreadProps(__spreadValues({}, config2), {\n        types: () => sortTypes(config2.types)\n      }));\n    }\n    if (isEnumType(type2)) {\n      const config2 = type2.toConfig();\n      return new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {\n        values: sortObjMap(config2.values, (value) => value)\n      }));\n    }\n    if (isInputObjectType(type2)) {\n      const config2 = type2.toConfig();\n      return new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {\n        fields: () => sortInputFields(config2.fields)\n      }));\n    }\n    invariant$2(false, \"Unexpected type: \" + inspect$2(type2));\n  }\n}\nfunction sortObjMap(map2, sortValueFn) {\n  const sortedMap = /* @__PURE__ */ Object.create(null);\n  for (const key of Object.keys(map2).sort(naturalCompare$1)) {\n    sortedMap[key] = sortValueFn(map2[key]);\n  }\n  return sortedMap;\n}\nfunction sortByName(array) {\n  return sortBy(array, (obj) => obj.name);\n}\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort((obj1, obj2) => {\n    const key1 = mapToKey(obj1);\n    const key2 = mapToKey(obj2);\n    return naturalCompare$1(key1, key2);\n  });\n}\nfunction printSchema(schema) {\n  return printFilteredSchema(schema, (n2) => !isSpecifiedDirective(n2), isDefinedType);\n}\nfunction printIntrospectionSchema(schema) {\n  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);\n}\nfunction isDefinedType(type2) {\n  return !isSpecifiedScalarType(type2) && !isIntrospectionType(type2);\n}\nfunction printFilteredSchema(schema, directiveFilter, typeFilter) {\n  const directives = schema.getDirectives().filter(directiveFilter);\n  const types = Object.values(schema.getTypeMap()).filter(typeFilter);\n  return [\n    printSchemaDefinition(schema),\n    ...directives.map((directive) => printDirective(directive)),\n    ...types.map((type2) => printType(type2))\n  ].filter(Boolean).join(\"\\n\\n\");\n}\nfunction printSchemaDefinition(schema) {\n  if (schema.description == null && isSchemaOfCommonNames(schema)) {\n    return;\n  }\n  const operationTypes = [];\n  const queryType = schema.getQueryType();\n  if (queryType) {\n    operationTypes.push(`  query: ${queryType.name}`);\n  }\n  const mutationType = schema.getMutationType();\n  if (mutationType) {\n    operationTypes.push(`  mutation: ${mutationType.name}`);\n  }\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType) {\n    operationTypes.push(`  subscription: ${subscriptionType.name}`);\n  }\n  return printDescription(schema) + `schema {\n${operationTypes.join(\"\\n\")}\n}`;\n}\nfunction isSchemaOfCommonNames(schema) {\n  const queryType = schema.getQueryType();\n  if (queryType && queryType.name !== \"Query\") {\n    return false;\n  }\n  const mutationType = schema.getMutationType();\n  if (mutationType && mutationType.name !== \"Mutation\") {\n    return false;\n  }\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && subscriptionType.name !== \"Subscription\") {\n    return false;\n  }\n  return true;\n}\nfunction printType(type2) {\n  if (isScalarType(type2)) {\n    return printScalar(type2);\n  }\n  if (isObjectType(type2)) {\n    return printObject(type2);\n  }\n  if (isInterfaceType(type2)) {\n    return printInterface(type2);\n  }\n  if (isUnionType(type2)) {\n    return printUnion(type2);\n  }\n  if (isEnumType(type2)) {\n    return printEnum(type2);\n  }\n  if (isInputObjectType(type2)) {\n    return printInputObject(type2);\n  }\n  invariant$2(false, \"Unexpected type: \" + inspect$2(type2));\n}\nfunction printScalar(type2) {\n  return printDescription(type2) + `scalar ${type2.name}` + printSpecifiedByURL(type2);\n}\nfunction printImplementedInterfaces(type2) {\n  const interfaces = type2.getInterfaces();\n  return interfaces.length ? \" implements \" + interfaces.map((i) => i.name).join(\" & \") : \"\";\n}\nfunction printObject(type2) {\n  return printDescription(type2) + `type ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);\n}\nfunction printInterface(type2) {\n  return printDescription(type2) + `interface ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);\n}\nfunction printUnion(type2) {\n  const types = type2.getTypes();\n  const possibleTypes = types.length ? \" = \" + types.join(\" | \") : \"\";\n  return printDescription(type2) + \"union \" + type2.name + possibleTypes;\n}\nfunction printEnum(type2) {\n  const values = type2.getValues().map((value, i) => printDescription(value, \"  \", !i) + \"  \" + value.name + printDeprecated(value.deprecationReason));\n  return printDescription(type2) + `enum ${type2.name}` + printBlock(values);\n}\nfunction printInputObject(type2) {\n  const fields = Object.values(type2.getFields()).map((f, i) => printDescription(f, \"  \", !i) + \"  \" + printInputValue(f));\n  return printDescription(type2) + `input ${type2.name}` + printBlock(fields);\n}\nfunction printFields(type2) {\n  const fields = Object.values(type2.getFields()).map((f, i) => printDescription(f, \"  \", !i) + \"  \" + f.name + printArgs(f.args, \"  \") + \": \" + String(f.type) + printDeprecated(f.deprecationReason));\n  return printBlock(fields);\n}\nfunction printBlock(items) {\n  return items.length !== 0 ? \" {\\n\" + items.join(\"\\n\") + \"\\n}\" : \"\";\n}\nfunction printArgs(args, indentation = \"\") {\n  if (args.length === 0) {\n    return \"\";\n  }\n  if (args.every((arg) => !arg.description)) {\n    return \"(\" + args.map(printInputValue).join(\", \") + \")\";\n  }\n  return \"(\\n\" + args.map((arg, i) => printDescription(arg, \"  \" + indentation, !i) + \"  \" + indentation + printInputValue(arg)).join(\"\\n\") + \"\\n\" + indentation + \")\";\n}\nfunction printInputValue(arg) {\n  const defaultAST = astFromValue(arg.defaultValue, arg.type);\n  let argDecl = arg.name + \": \" + String(arg.type);\n  if (defaultAST) {\n    argDecl += ` = ${print(defaultAST)}`;\n  }\n  return argDecl + printDeprecated(arg.deprecationReason);\n}\nfunction printDirective(directive) {\n  return printDescription(directive) + \"directive @\" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? \" repeatable\" : \"\") + \" on \" + directive.locations.join(\" | \");\n}\nfunction printDeprecated(reason) {\n  if (reason == null) {\n    return \"\";\n  }\n  if (reason !== DEFAULT_DEPRECATION_REASON) {\n    const astValue = print({\n      kind: Kind.STRING,\n      value: reason\n    });\n    return ` @deprecated(reason: ${astValue})`;\n  }\n  return \" @deprecated\";\n}\nfunction printSpecifiedByURL(scalar) {\n  if (scalar.specifiedByURL == null) {\n    return \"\";\n  }\n  const astValue = print({\n    kind: Kind.STRING,\n    value: scalar.specifiedByURL\n  });\n  return ` @specifiedBy(url: ${astValue})`;\n}\nfunction printDescription(def, indentation = \"\", firstInBlock = true) {\n  const { description } = def;\n  if (description == null) {\n    return \"\";\n  }\n  const blockString = print({\n    kind: Kind.STRING,\n    value: description,\n    block: isPrintableAsBlockString(description)\n  });\n  const prefix = indentation && !firstInBlock ? \"\\n\" + indentation : indentation;\n  return prefix + blockString.replace(/\\n/g, \"\\n\" + indentation) + \"\\n\";\n}\nfunction concatAST(documents) {\n  const definitions = [];\n  for (const doc of documents) {\n    definitions.push(...doc.definitions);\n  }\n  return {\n    kind: Kind.DOCUMENT,\n    definitions\n  };\n}\nfunction separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = /* @__PURE__ */ Object.create(null);\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  }\n  const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);\n  for (const operation of operations) {\n    const dependencies = /* @__PURE__ */ new Set();\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    }\n    const operationName = operation.name ? operation.name.value : \"\";\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter((node) => node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))\n    };\n  }\n  return separatedDocumentASTs;\n}\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n    if (immediateDeps !== void 0) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}\nfunction stripIgnoredCharacters(source) {\n  const sourceObj = isSource(source) ? source : new Source(source);\n  const body = sourceObj.body;\n  const lexer = new Lexer(sourceObj);\n  let strippedBody = \"\";\n  let wasLastAddedTokenNonPunctuator = false;\n  while (lexer.advance().kind !== TokenKind.EOF) {\n    const currentToken = lexer.token;\n    const tokenKind = currentToken.kind;\n    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);\n    if (wasLastAddedTokenNonPunctuator) {\n      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {\n        strippedBody += \" \";\n      }\n    }\n    const tokenBody = body.slice(currentToken.start, currentToken.end);\n    if (tokenKind === TokenKind.BLOCK_STRING) {\n      strippedBody += printBlockString$1(currentToken.value, {\n        minimize: true\n      });\n    } else {\n      strippedBody += tokenBody;\n    }\n    wasLastAddedTokenNonPunctuator = isNonPunctuator;\n  }\n  return strippedBody;\n}\nfunction assertValidName(name2) {\n  const error2 = isValidNameError(name2);\n  if (error2) {\n    throw error2;\n  }\n  return name2;\n}\nfunction isValidNameError(name2) {\n  typeof name2 === \"string\" || devAssert$1(false, \"Expected name to be a string.\");\n  if (name2.startsWith(\"__\")) {\n    return new GraphQLError(`Name \"${name2}\" must not begin with \"__\", which is reserved by GraphQL introspection.`);\n  }\n  try {\n    assertName(name2);\n  } catch (error2) {\n    return error2;\n  }\n}\nlet BreakingChangeType;\n(function(BreakingChangeType2) {\n  BreakingChangeType2[\"TYPE_REMOVED\"] = \"TYPE_REMOVED\";\n  BreakingChangeType2[\"TYPE_CHANGED_KIND\"] = \"TYPE_CHANGED_KIND\";\n  BreakingChangeType2[\"TYPE_REMOVED_FROM_UNION\"] = \"TYPE_REMOVED_FROM_UNION\";\n  BreakingChangeType2[\"VALUE_REMOVED_FROM_ENUM\"] = \"VALUE_REMOVED_FROM_ENUM\";\n  BreakingChangeType2[\"REQUIRED_INPUT_FIELD_ADDED\"] = \"REQUIRED_INPUT_FIELD_ADDED\";\n  BreakingChangeType2[\"IMPLEMENTED_INTERFACE_REMOVED\"] = \"IMPLEMENTED_INTERFACE_REMOVED\";\n  BreakingChangeType2[\"FIELD_REMOVED\"] = \"FIELD_REMOVED\";\n  BreakingChangeType2[\"FIELD_CHANGED_KIND\"] = \"FIELD_CHANGED_KIND\";\n  BreakingChangeType2[\"REQUIRED_ARG_ADDED\"] = \"REQUIRED_ARG_ADDED\";\n  BreakingChangeType2[\"ARG_REMOVED\"] = \"ARG_REMOVED\";\n  BreakingChangeType2[\"ARG_CHANGED_KIND\"] = \"ARG_CHANGED_KIND\";\n  BreakingChangeType2[\"DIRECTIVE_REMOVED\"] = \"DIRECTIVE_REMOVED\";\n  BreakingChangeType2[\"DIRECTIVE_ARG_REMOVED\"] = \"DIRECTIVE_ARG_REMOVED\";\n  BreakingChangeType2[\"REQUIRED_DIRECTIVE_ARG_ADDED\"] = \"REQUIRED_DIRECTIVE_ARG_ADDED\";\n  BreakingChangeType2[\"DIRECTIVE_REPEATABLE_REMOVED\"] = \"DIRECTIVE_REPEATABLE_REMOVED\";\n  BreakingChangeType2[\"DIRECTIVE_LOCATION_REMOVED\"] = \"DIRECTIVE_LOCATION_REMOVED\";\n})(BreakingChangeType || (BreakingChangeType = {}));\nlet DangerousChangeType;\n(function(DangerousChangeType2) {\n  DangerousChangeType2[\"VALUE_ADDED_TO_ENUM\"] = \"VALUE_ADDED_TO_ENUM\";\n  DangerousChangeType2[\"TYPE_ADDED_TO_UNION\"] = \"TYPE_ADDED_TO_UNION\";\n  DangerousChangeType2[\"OPTIONAL_INPUT_FIELD_ADDED\"] = \"OPTIONAL_INPUT_FIELD_ADDED\";\n  DangerousChangeType2[\"OPTIONAL_ARG_ADDED\"] = \"OPTIONAL_ARG_ADDED\";\n  DangerousChangeType2[\"IMPLEMENTED_INTERFACE_ADDED\"] = \"IMPLEMENTED_INTERFACE_ADDED\";\n  DangerousChangeType2[\"ARG_DEFAULT_VALUE_CHANGE\"] = \"ARG_DEFAULT_VALUE_CHANGE\";\n})(DangerousChangeType || (DangerousChangeType = {}));\nfunction findBreakingChanges(oldSchema, newSchema) {\n  return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in BreakingChangeType);\n}\nfunction findDangerousChanges(oldSchema, newSchema) {\n  return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in DangerousChangeType);\n}\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema)\n  ];\n}\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`\n    });\n  }\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n    for (const newArg of argsDiff.added) {\n      if (isRequiredArgument$1(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`\n        });\n      }\n    }\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`\n      });\n    }\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`\n      });\n    }\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`\n        });\n      }\n    }\n  }\n  return schemaChanges;\n}\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`\n    });\n  }\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (isEnumType(oldType) && isEnumType(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (isUnionType(oldType) && isUnionType(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (isObjectType(oldType) && isObjectType(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n  for (const newField of fieldsDiff.added) {\n    if (isRequiredInputField(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    }\n  }\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`\n    });\n  }\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`\n    });\n  }\n  return schemaChanges;\n}\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`\n    });\n  }\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`\n    });\n  }\n  return schemaChanges;\n}\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`\n    });\n  }\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`\n    });\n  }\n  return schemaChanges;\n}\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`\n    });\n  }\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`\n      });\n    } else if (oldArg.defaultValue !== void 0) {\n      if (newArg.defaultValue === void 0) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`\n        });\n      } else {\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`\n          });\n        }\n      }\n    }\n  }\n  for (const newArg of argsDiff.added) {\n    if (isRequiredArgument$1(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if (isListType(oldType)) {\n    return isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);\n  }\n  if (isNonNullType(oldType)) {\n    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n  return isNamedType(newType) && oldType.name === newType.name || isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);\n}\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if (isListType(oldType)) {\n    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n  if (isNonNullType(oldType)) {\n    return isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);\n  }\n  return isNamedType(newType) && oldType.name === newType.name;\n}\nfunction typeKindName(type2) {\n  if (isScalarType(type2)) {\n    return \"a Scalar type\";\n  }\n  if (isObjectType(type2)) {\n    return \"an Object type\";\n  }\n  if (isInterfaceType(type2)) {\n    return \"an Interface type\";\n  }\n  if (isUnionType(type2)) {\n    return \"a Union type\";\n  }\n  if (isEnumType(type2)) {\n    return \"an Enum type\";\n  }\n  if (isInputObjectType(type2)) {\n    return \"an Input type\";\n  }\n  invariant$2(false, \"Unexpected type: \" + inspect$2(type2));\n}\nfunction stringifyValue(value, type2) {\n  const ast2 = astFromValue(value, type2);\n  ast2 != null || invariant$2(false);\n  return print(sortValueNode(ast2));\n}\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = keyMap$1(oldArray, ({ name: name2 }) => name2);\n  const newMap = keyMap$1(newArray, ({ name: name2 }) => name2);\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n    if (newItem === void 0) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === void 0) {\n      added.push(newItem);\n    }\n  }\n  return {\n    added,\n    persisted,\n    removed\n  };\n}\nvar graphql = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  version,\n  versionInfo,\n  graphql: graphql$1,\n  graphqlSync,\n  resolveObjMapThunk,\n  resolveReadonlyArrayThunk,\n  GraphQLSchema,\n  GraphQLDirective,\n  GraphQLScalarType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLNonNull,\n  specifiedScalarTypes,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLString,\n  GraphQLBoolean,\n  GraphQLID,\n  GRAPHQL_MAX_INT,\n  GRAPHQL_MIN_INT,\n  specifiedDirectives,\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n  GraphQLDeprecatedDirective,\n  GraphQLSpecifiedByDirective,\n  get TypeKind() {\n    return TypeKind;\n  },\n  DEFAULT_DEPRECATION_REASON,\n  introspectionTypes,\n  __Schema,\n  __Directive,\n  __DirectiveLocation,\n  __Type,\n  __Field,\n  __InputValue,\n  __EnumValue,\n  __TypeKind,\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n  isSchema,\n  isDirective,\n  isType,\n  isScalarType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isEnumType,\n  isInputObjectType,\n  isListType,\n  isNonNullType,\n  isInputType,\n  isOutputType,\n  isLeafType,\n  isCompositeType,\n  isAbstractType,\n  isWrappingType,\n  isNullableType,\n  isNamedType,\n  isRequiredArgument: isRequiredArgument$1,\n  isRequiredInputField,\n  isSpecifiedScalarType,\n  isIntrospectionType,\n  isSpecifiedDirective,\n  assertSchema,\n  assertDirective,\n  assertType,\n  assertScalarType,\n  assertObjectType,\n  assertInterfaceType,\n  assertUnionType,\n  assertEnumType,\n  assertInputObjectType,\n  assertListType,\n  assertNonNullType,\n  assertInputType,\n  assertOutputType,\n  assertLeafType,\n  assertCompositeType,\n  assertAbstractType,\n  assertWrappingType,\n  assertNullableType,\n  assertNamedType,\n  getNullableType,\n  getNamedType,\n  validateSchema,\n  assertValidSchema,\n  assertName,\n  assertEnumValueName,\n  Token: Token$4,\n  Source,\n  Location: Location$1,\n  get OperationTypeNode() {\n    return OperationTypeNode;\n  },\n  getLocation: getLocation$1,\n  printLocation,\n  printSourceLocation,\n  Lexer,\n  get TokenKind() {\n    return TokenKind;\n  },\n  parse: parse$1,\n  parseValue: parseValue$1,\n  parseConstValue,\n  parseType,\n  print,\n  visit,\n  visitInParallel,\n  getVisitFn,\n  getEnterLeaveForKind,\n  BREAK,\n  get Kind() {\n    return Kind;\n  },\n  get DirectiveLocation() {\n    return DirectiveLocation;\n  },\n  isDefinitionNode,\n  isExecutableDefinitionNode,\n  isSelectionNode,\n  isValueNode,\n  isConstValueNode,\n  isTypeNode,\n  isTypeSystemDefinitionNode,\n  isTypeDefinitionNode,\n  isTypeSystemExtensionNode,\n  isTypeExtensionNode,\n  execute: execute$1,\n  executeSync,\n  defaultFieldResolver: defaultFieldResolver$1,\n  defaultTypeResolver: defaultTypeResolver$1,\n  responsePathAsArray: pathToArray$1,\n  getVariableValues: getVariableValues$1,\n  getDirectiveValues: getDirectiveValues$1,\n  subscribe,\n  createSourceEventStream,\n  validate,\n  ValidationContext,\n  specifiedRules,\n  ExecutableDefinitionsRule,\n  FieldsOnCorrectTypeRule,\n  FragmentsOnCompositeTypesRule,\n  KnownArgumentNamesRule,\n  KnownDirectivesRule,\n  KnownFragmentNamesRule,\n  KnownTypeNamesRule,\n  LoneAnonymousOperationRule,\n  NoFragmentCyclesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedFragmentsRule,\n  NoUnusedVariablesRule,\n  OverlappingFieldsCanBeMergedRule,\n  PossibleFragmentSpreadsRule,\n  ProvidedRequiredArgumentsRule,\n  ScalarLeafsRule,\n  SingleFieldSubscriptionsRule,\n  UniqueArgumentNamesRule,\n  UniqueDirectivesPerLocationRule,\n  UniqueFragmentNamesRule,\n  UniqueInputFieldNamesRule,\n  UniqueOperationNamesRule,\n  UniqueVariableNamesRule,\n  ValuesOfCorrectTypeRule,\n  VariablesAreInputTypesRule,\n  VariablesInAllowedPositionRule,\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  PossibleTypeExtensionsRule,\n  NoDeprecatedCustomRule,\n  NoSchemaIntrospectionCustomRule,\n  GraphQLError,\n  syntaxError: syntaxError$1,\n  locatedError,\n  printError,\n  formatError: formatError$1,\n  getIntrospectionQuery,\n  getOperationAST,\n  getOperationRootType,\n  introspectionFromSchema,\n  buildClientSchema,\n  buildASTSchema,\n  buildSchema,\n  extendSchema,\n  lexicographicSortSchema,\n  printSchema,\n  printType,\n  printIntrospectionSchema,\n  typeFromAST,\n  valueFromAST: valueFromAST$1,\n  valueFromASTUntyped,\n  astFromValue,\n  TypeInfo,\n  visitWithTypeInfo,\n  coerceInputValue: coerceInputValue$1,\n  concatAST,\n  separateOperations,\n  stripIgnoredCharacters,\n  isEqualType,\n  isTypeSubTypeOf,\n  doTypesOverlap,\n  assertValidName,\n  isValidNameError,\n  get BreakingChangeType() {\n    return BreakingChangeType;\n  },\n  get DangerousChangeType() {\n    return DangerousChangeType;\n  },\n  findBreakingChanges,\n  findDangerousChanges\n});\nfunction getDefinitionState(tokenState) {\n  let definitionState;\n  forEachState$2(tokenState, (state) => {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n      case \"Mutation\":\n      case \"Subscription\":\n      case \"FragmentDefinition\":\n        definitionState = state;\n        break;\n    }\n  });\n  return definitionState;\n}\nfunction getFieldDef$1(schema, type2, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type2) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type2) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type2)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (\"getFields\" in type2) {\n    return type2.getFields()[fieldName];\n  }\n  return null;\n}\nfunction forEachState$2(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state && state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\nfunction objectValues(object) {\n  const keys = Object.keys(object);\n  const len = keys.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\nfunction hintList$2(token2, list3) {\n  return filterAndSortList$1(list3, normalizeText$1(token2.string));\n}\nfunction filterAndSortList$1(list3, text3) {\n  if (!text3) {\n    return filterNonEmpty$1(list3, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list3.map((entry) => ({\n    proximity: getProximity$1(normalizeText$1(entry.label), text3),\n    entry\n  }));\n  return filterNonEmpty$1(filterNonEmpty$1(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);\n}\nfunction filterNonEmpty$1(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\nfunction normalizeText$1(text3) {\n  return text3.toLowerCase().replace(/\\W/g, \"\");\n}\nfunction getProximity$1(suggestion, text3) {\n  let proximity = lexicalDistance$1(text3, suggestion);\n  if (suggestion.length > text3.length) {\n    proximity -= suggestion.length - text3.length - 1;\n    proximity += suggestion.indexOf(text3) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\nfunction lexicalDistance$1(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\nvar integer;\n(function(integer2) {\n  integer2.MIN_VALUE = -2147483648;\n  integer2.MAX_VALUE = 2147483647;\n})(integer || (integer = {}));\nvar uinteger;\n(function(uinteger2) {\n  uinteger2.MIN_VALUE = 0;\n  uinteger2.MAX_VALUE = 2147483647;\n})(uinteger || (uinteger = {}));\nvar Position$1;\n(function(Position2) {\n  function create(line, character) {\n    if (line === Number.MAX_VALUE) {\n      line = uinteger.MAX_VALUE;\n    }\n    if (character === Number.MAX_VALUE) {\n      character = uinteger.MAX_VALUE;\n    }\n    return { line, character };\n  }\n  Position2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n  }\n  Position2.is = is2;\n})(Position$1 || (Position$1 = {}));\nvar Range$1;\n(function(Range2) {\n  function create(one, two, three, four) {\n    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n      return { start: Position$1.create(one, two), end: Position$1.create(three, four) };\n    } else if (Position$1.is(one) && Position$1.is(two)) {\n      return { start: one, end: two };\n    } else {\n      throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\n    }\n  }\n  Range2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) && Position$1.is(candidate.start) && Position$1.is(candidate.end);\n  }\n  Range2.is = is2;\n})(Range$1 || (Range$1 = {}));\nvar Location;\n(function(Location2) {\n  function create(uri, range2) {\n    return { uri, range: range2 };\n  }\n  Location2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range$1.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n  }\n  Location2.is = is2;\n})(Location || (Location = {}));\nvar LocationLink;\n(function(LocationLink2) {\n  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n  }\n  LocationLink2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range$1.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range$1.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range$1.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n  }\n  LocationLink2.is = is2;\n})(LocationLink || (LocationLink = {}));\nvar Color;\n(function(Color2) {\n  function create(red, green, blue, alpha2) {\n    return {\n      red,\n      green,\n      blue,\n      alpha: alpha2\n    };\n  }\n  Color2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);\n  }\n  Color2.is = is2;\n})(Color || (Color = {}));\nvar ColorInformation;\n(function(ColorInformation2) {\n  function create(range2, color) {\n    return {\n      range: range2,\n      color\n    };\n  }\n  ColorInformation2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Range$1.is(candidate.range) && Color.is(candidate.color);\n  }\n  ColorInformation2.is = is2;\n})(ColorInformation || (ColorInformation = {}));\nvar ColorPresentation;\n(function(ColorPresentation2) {\n  function create(label, textEdit, additionalTextEdits) {\n    return {\n      label,\n      textEdit,\n      additionalTextEdits\n    };\n  }\n  ColorPresentation2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n  }\n  ColorPresentation2.is = is2;\n})(ColorPresentation || (ColorPresentation = {}));\nvar FoldingRangeKind;\n(function(FoldingRangeKind2) {\n  FoldingRangeKind2[\"Comment\"] = \"comment\";\n  FoldingRangeKind2[\"Imports\"] = \"imports\";\n  FoldingRangeKind2[\"Region\"] = \"region\";\n})(FoldingRangeKind || (FoldingRangeKind = {}));\nvar FoldingRange;\n(function(FoldingRange2) {\n  function create(startLine, endLine, startCharacter, endCharacter, kind2) {\n    var result2 = {\n      startLine,\n      endLine\n    };\n    if (Is.defined(startCharacter)) {\n      result2.startCharacter = startCharacter;\n    }\n    if (Is.defined(endCharacter)) {\n      result2.endCharacter = endCharacter;\n    }\n    if (Is.defined(kind2)) {\n      result2.kind = kind2;\n    }\n    return result2;\n  }\n  FoldingRange2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n  }\n  FoldingRange2.is = is2;\n})(FoldingRange || (FoldingRange = {}));\nvar DiagnosticRelatedInformation;\n(function(DiagnosticRelatedInformation2) {\n  function create(location, message) {\n    return {\n      location,\n      message\n    };\n  }\n  DiagnosticRelatedInformation2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n  }\n  DiagnosticRelatedInformation2.is = is2;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\nvar DiagnosticSeverity;\n(function(DiagnosticSeverity2) {\n  DiagnosticSeverity2.Error = 1;\n  DiagnosticSeverity2.Warning = 2;\n  DiagnosticSeverity2.Information = 3;\n  DiagnosticSeverity2.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\nvar DiagnosticTag;\n(function(DiagnosticTag2) {\n  DiagnosticTag2.Unnecessary = 1;\n  DiagnosticTag2.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\nvar CodeDescription;\n(function(CodeDescription2) {\n  function is2(value) {\n    var candidate = value;\n    return candidate !== void 0 && candidate !== null && Is.string(candidate.href);\n  }\n  CodeDescription2.is = is2;\n})(CodeDescription || (CodeDescription = {}));\nvar Diagnostic;\n(function(Diagnostic2) {\n  function create(range2, message, severity, code3, source, relatedInformation) {\n    var result2 = { range: range2, message };\n    if (Is.defined(severity)) {\n      result2.severity = severity;\n    }\n    if (Is.defined(code3)) {\n      result2.code = code3;\n    }\n    if (Is.defined(source)) {\n      result2.source = source;\n    }\n    if (Is.defined(relatedInformation)) {\n      result2.relatedInformation = relatedInformation;\n    }\n    return result2;\n  }\n  Diagnostic2.create = create;\n  function is2(value) {\n    var _a2;\n    var candidate = value;\n    return Is.defined(candidate) && Range$1.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n  }\n  Diagnostic2.is = is2;\n})(Diagnostic || (Diagnostic = {}));\nvar Command;\n(function(Command2) {\n  function create(title, command) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n    var result2 = { title, command };\n    if (Is.defined(args) && args.length > 0) {\n      result2.arguments = args;\n    }\n    return result2;\n  }\n  Command2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n  }\n  Command2.is = is2;\n})(Command || (Command = {}));\nvar TextEdit;\n(function(TextEdit2) {\n  function replace2(range2, newText) {\n    return { range: range2, newText };\n  }\n  TextEdit2.replace = replace2;\n  function insert(position, newText) {\n    return { range: { start: position, end: position }, newText };\n  }\n  TextEdit2.insert = insert;\n  function del(range2) {\n    return { range: range2, newText: \"\" };\n  }\n  TextEdit2.del = del;\n  function is2(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range$1.is(candidate.range);\n  }\n  TextEdit2.is = is2;\n})(TextEdit || (TextEdit = {}));\nvar ChangeAnnotation;\n(function(ChangeAnnotation2) {\n  function create(label, needsConfirmation, description) {\n    var result2 = { label };\n    if (needsConfirmation !== void 0) {\n      result2.needsConfirmation = needsConfirmation;\n    }\n    if (description !== void 0) {\n      result2.description = description;\n    }\n    return result2;\n  }\n  ChangeAnnotation2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate !== void 0 && Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);\n  }\n  ChangeAnnotation2.is = is2;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function(ChangeAnnotationIdentifier2) {\n  function is2(value) {\n    var candidate = value;\n    return typeof candidate === \"string\";\n  }\n  ChangeAnnotationIdentifier2.is = is2;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function(AnnotatedTextEdit2) {\n  function replace2(range2, newText, annotation) {\n    return { range: range2, newText, annotationId: annotation };\n  }\n  AnnotatedTextEdit2.replace = replace2;\n  function insert(position, newText, annotation) {\n    return { range: { start: position, end: position }, newText, annotationId: annotation };\n  }\n  AnnotatedTextEdit2.insert = insert;\n  function del(range2, annotation) {\n    return { range: range2, newText: \"\", annotationId: annotation };\n  }\n  AnnotatedTextEdit2.del = del;\n  function is2(value) {\n    var candidate = value;\n    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  AnnotatedTextEdit2.is = is2;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\nvar TextDocumentEdit;\n(function(TextDocumentEdit2) {\n  function create(textDocument, edits) {\n    return { textDocument, edits };\n  }\n  TextDocumentEdit2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n  }\n  TextDocumentEdit2.is = is2;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function(CreateFile2) {\n  function create(uri, options, annotation) {\n    var result2 = {\n      kind: \"create\",\n      uri\n    };\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result2.options = options;\n    }\n    if (annotation !== void 0) {\n      result2.annotationId = annotation;\n    }\n    return result2;\n  }\n  CreateFile2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate && candidate.kind === \"create\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  CreateFile2.is = is2;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function(RenameFile2) {\n  function create(oldUri, newUri, options, annotation) {\n    var result2 = {\n      kind: \"rename\",\n      oldUri,\n      newUri\n    };\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result2.options = options;\n    }\n    if (annotation !== void 0) {\n      result2.annotationId = annotation;\n    }\n    return result2;\n  }\n  RenameFile2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate && candidate.kind === \"rename\" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  RenameFile2.is = is2;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function(DeleteFile2) {\n  function create(uri, options, annotation) {\n    var result2 = {\n      kind: \"delete\",\n      uri\n    };\n    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\n      result2.options = options;\n    }\n    if (annotation !== void 0) {\n      result2.annotationId = annotation;\n    }\n    return result2;\n  }\n  DeleteFile2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate && candidate.kind === \"delete\" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));\n  }\n  DeleteFile2.is = is2;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function(WorkspaceEdit2) {\n  function is2(value) {\n    var candidate = value;\n    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {\n      if (Is.string(change.kind)) {\n        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n      } else {\n        return TextDocumentEdit.is(change);\n      }\n    }));\n  }\n  WorkspaceEdit2.is = is2;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = function() {\n  function TextEditChangeImpl2(edits, changeAnnotations) {\n    this.edits = edits;\n    this.changeAnnotations = changeAnnotations;\n  }\n  TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {\n    var edit;\n    var id2;\n    if (annotation === void 0) {\n      edit = TextEdit.insert(position, newText);\n    } else if (ChangeAnnotationIdentifier.is(annotation)) {\n      id2 = annotation;\n      edit = AnnotatedTextEdit.insert(position, newText, annotation);\n    } else {\n      this.assertChangeAnnotations(this.changeAnnotations);\n      id2 = this.changeAnnotations.manage(annotation);\n      edit = AnnotatedTextEdit.insert(position, newText, id2);\n    }\n    this.edits.push(edit);\n    if (id2 !== void 0) {\n      return id2;\n    }\n  };\n  TextEditChangeImpl2.prototype.replace = function(range2, newText, annotation) {\n    var edit;\n    var id2;\n    if (annotation === void 0) {\n      edit = TextEdit.replace(range2, newText);\n    } else if (ChangeAnnotationIdentifier.is(annotation)) {\n      id2 = annotation;\n      edit = AnnotatedTextEdit.replace(range2, newText, annotation);\n    } else {\n      this.assertChangeAnnotations(this.changeAnnotations);\n      id2 = this.changeAnnotations.manage(annotation);\n      edit = AnnotatedTextEdit.replace(range2, newText, id2);\n    }\n    this.edits.push(edit);\n    if (id2 !== void 0) {\n      return id2;\n    }\n  };\n  TextEditChangeImpl2.prototype.delete = function(range2, annotation) {\n    var edit;\n    var id2;\n    if (annotation === void 0) {\n      edit = TextEdit.del(range2);\n    } else if (ChangeAnnotationIdentifier.is(annotation)) {\n      id2 = annotation;\n      edit = AnnotatedTextEdit.del(range2, annotation);\n    } else {\n      this.assertChangeAnnotations(this.changeAnnotations);\n      id2 = this.changeAnnotations.manage(annotation);\n      edit = AnnotatedTextEdit.del(range2, id2);\n    }\n    this.edits.push(edit);\n    if (id2 !== void 0) {\n      return id2;\n    }\n  };\n  TextEditChangeImpl2.prototype.add = function(edit) {\n    this.edits.push(edit);\n  };\n  TextEditChangeImpl2.prototype.all = function() {\n    return this.edits;\n  };\n  TextEditChangeImpl2.prototype.clear = function() {\n    this.edits.splice(0, this.edits.length);\n  };\n  TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {\n    if (value === void 0) {\n      throw new Error(\"Text edit change is not configured to manage change annotations.\");\n    }\n  };\n  return TextEditChangeImpl2;\n}();\nvar ChangeAnnotations = function() {\n  function ChangeAnnotations2(annotations2) {\n    this._annotations = annotations2 === void 0 ? /* @__PURE__ */ Object.create(null) : annotations2;\n    this._counter = 0;\n    this._size = 0;\n  }\n  ChangeAnnotations2.prototype.all = function() {\n    return this._annotations;\n  };\n  Object.defineProperty(ChangeAnnotations2.prototype, \"size\", {\n    get: function() {\n      return this._size;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {\n    var id2;\n    if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n      id2 = idOrAnnotation;\n    } else {\n      id2 = this.nextId();\n      annotation = idOrAnnotation;\n    }\n    if (this._annotations[id2] !== void 0) {\n      throw new Error(\"Id \" + id2 + \" is already in use.\");\n    }\n    if (annotation === void 0) {\n      throw new Error(\"No annotation provided for id \" + id2);\n    }\n    this._annotations[id2] = annotation;\n    this._size++;\n    return id2;\n  };\n  ChangeAnnotations2.prototype.nextId = function() {\n    this._counter++;\n    return this._counter.toString();\n  };\n  return ChangeAnnotations2;\n}();\n(function() {\n  function WorkspaceChange(workspaceEdit) {\n    var _this = this;\n    this._textEditChanges = /* @__PURE__ */ Object.create(null);\n    if (workspaceEdit !== void 0) {\n      this._workspaceEdit = workspaceEdit;\n      if (workspaceEdit.documentChanges) {\n        this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n        workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        workspaceEdit.documentChanges.forEach(function(change) {\n          if (TextDocumentEdit.is(change)) {\n            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n          }\n        });\n      } else if (workspaceEdit.changes) {\n        Object.keys(workspaceEdit.changes).forEach(function(key) {\n          var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n          _this._textEditChanges[key] = textEditChange;\n        });\n      }\n    } else {\n      this._workspaceEdit = {};\n    }\n  }\n  Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n    get: function() {\n      this.initDocumentChanges();\n      if (this._changeAnnotations !== void 0) {\n        if (this._changeAnnotations.size === 0) {\n          this._workspaceEdit.changeAnnotations = void 0;\n        } else {\n          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n      }\n      return this._workspaceEdit;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  WorkspaceChange.prototype.getTextEditChange = function(key) {\n    if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n      this.initDocumentChanges();\n      if (this._workspaceEdit.documentChanges === void 0) {\n        throw new Error(\"Workspace edit is not configured for document changes.\");\n      }\n      var textDocument = { uri: key.uri, version: key.version };\n      var result2 = this._textEditChanges[textDocument.uri];\n      if (!result2) {\n        var edits = [];\n        var textDocumentEdit = {\n          textDocument,\n          edits\n        };\n        this._workspaceEdit.documentChanges.push(textDocumentEdit);\n        result2 = new TextEditChangeImpl(edits, this._changeAnnotations);\n        this._textEditChanges[textDocument.uri] = result2;\n      }\n      return result2;\n    } else {\n      this.initChanges();\n      if (this._workspaceEdit.changes === void 0) {\n        throw new Error(\"Workspace edit is not configured for normal text edit changes.\");\n      }\n      var result2 = this._textEditChanges[key];\n      if (!result2) {\n        var edits = [];\n        this._workspaceEdit.changes[key] = edits;\n        result2 = new TextEditChangeImpl(edits);\n        this._textEditChanges[key] = result2;\n      }\n      return result2;\n    }\n  };\n  WorkspaceChange.prototype.initDocumentChanges = function() {\n    if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {\n      this._changeAnnotations = new ChangeAnnotations();\n      this._workspaceEdit.documentChanges = [];\n      this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n    }\n  };\n  WorkspaceChange.prototype.initChanges = function() {\n    if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {\n      this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);\n    }\n  };\n  WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {\n    this.initDocumentChanges();\n    if (this._workspaceEdit.documentChanges === void 0) {\n      throw new Error(\"Workspace edit is not configured for document changes.\");\n    }\n    var annotation;\n    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n      annotation = optionsOrAnnotation;\n    } else {\n      options = optionsOrAnnotation;\n    }\n    var operation;\n    var id2;\n    if (annotation === void 0) {\n      operation = CreateFile.create(uri, options);\n    } else {\n      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n      operation = CreateFile.create(uri, options, id2);\n    }\n    this._workspaceEdit.documentChanges.push(operation);\n    if (id2 !== void 0) {\n      return id2;\n    }\n  };\n  WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {\n    this.initDocumentChanges();\n    if (this._workspaceEdit.documentChanges === void 0) {\n      throw new Error(\"Workspace edit is not configured for document changes.\");\n    }\n    var annotation;\n    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n      annotation = optionsOrAnnotation;\n    } else {\n      options = optionsOrAnnotation;\n    }\n    var operation;\n    var id2;\n    if (annotation === void 0) {\n      operation = RenameFile.create(oldUri, newUri, options);\n    } else {\n      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n      operation = RenameFile.create(oldUri, newUri, options, id2);\n    }\n    this._workspaceEdit.documentChanges.push(operation);\n    if (id2 !== void 0) {\n      return id2;\n    }\n  };\n  WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {\n    this.initDocumentChanges();\n    if (this._workspaceEdit.documentChanges === void 0) {\n      throw new Error(\"Workspace edit is not configured for document changes.\");\n    }\n    var annotation;\n    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n      annotation = optionsOrAnnotation;\n    } else {\n      options = optionsOrAnnotation;\n    }\n    var operation;\n    var id2;\n    if (annotation === void 0) {\n      operation = DeleteFile.create(uri, options);\n    } else {\n      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n      operation = DeleteFile.create(uri, options, id2);\n    }\n    this._workspaceEdit.documentChanges.push(operation);\n    if (id2 !== void 0) {\n      return id2;\n    }\n  };\n  return WorkspaceChange;\n})();\nvar TextDocumentIdentifier;\n(function(TextDocumentIdentifier2) {\n  function create(uri) {\n    return { uri };\n  }\n  TextDocumentIdentifier2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri);\n  }\n  TextDocumentIdentifier2.is = is2;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\nvar VersionedTextDocumentIdentifier;\n(function(VersionedTextDocumentIdentifier2) {\n  function create(uri, version2) {\n    return { uri, version: version2 };\n  }\n  VersionedTextDocumentIdentifier2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n  }\n  VersionedTextDocumentIdentifier2.is = is2;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\nvar OptionalVersionedTextDocumentIdentifier;\n(function(OptionalVersionedTextDocumentIdentifier2) {\n  function create(uri, version2) {\n    return { uri, version: version2 };\n  }\n  OptionalVersionedTextDocumentIdentifier2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n  }\n  OptionalVersionedTextDocumentIdentifier2.is = is2;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\nvar TextDocumentItem;\n(function(TextDocumentItem2) {\n  function create(uri, languageId, version2, text3) {\n    return { uri, languageId, version: version2, text: text3 };\n  }\n  TextDocumentItem2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n  }\n  TextDocumentItem2.is = is2;\n})(TextDocumentItem || (TextDocumentItem = {}));\nvar MarkupKind;\n(function(MarkupKind2) {\n  MarkupKind2.PlainText = \"plaintext\";\n  MarkupKind2.Markdown = \"markdown\";\n})(MarkupKind || (MarkupKind = {}));\n(function(MarkupKind2) {\n  function is2(value) {\n    var candidate = value;\n    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;\n  }\n  MarkupKind2.is = is2;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function(MarkupContent2) {\n  function is2(value) {\n    var candidate = value;\n    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n  }\n  MarkupContent2.is = is2;\n})(MarkupContent || (MarkupContent = {}));\nvar CompletionItemKind$1;\n(function(CompletionItemKind2) {\n  CompletionItemKind2.Text = 1;\n  CompletionItemKind2.Method = 2;\n  CompletionItemKind2.Function = 3;\n  CompletionItemKind2.Constructor = 4;\n  CompletionItemKind2.Field = 5;\n  CompletionItemKind2.Variable = 6;\n  CompletionItemKind2.Class = 7;\n  CompletionItemKind2.Interface = 8;\n  CompletionItemKind2.Module = 9;\n  CompletionItemKind2.Property = 10;\n  CompletionItemKind2.Unit = 11;\n  CompletionItemKind2.Value = 12;\n  CompletionItemKind2.Enum = 13;\n  CompletionItemKind2.Keyword = 14;\n  CompletionItemKind2.Snippet = 15;\n  CompletionItemKind2.Color = 16;\n  CompletionItemKind2.File = 17;\n  CompletionItemKind2.Reference = 18;\n  CompletionItemKind2.Folder = 19;\n  CompletionItemKind2.EnumMember = 20;\n  CompletionItemKind2.Constant = 21;\n  CompletionItemKind2.Struct = 22;\n  CompletionItemKind2.Event = 23;\n  CompletionItemKind2.Operator = 24;\n  CompletionItemKind2.TypeParameter = 25;\n})(CompletionItemKind$1 || (CompletionItemKind$1 = {}));\nvar InsertTextFormat;\n(function(InsertTextFormat2) {\n  InsertTextFormat2.PlainText = 1;\n  InsertTextFormat2.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\nvar CompletionItemTag;\n(function(CompletionItemTag2) {\n  CompletionItemTag2.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\nvar InsertReplaceEdit;\n(function(InsertReplaceEdit2) {\n  function create(newText, insert, replace2) {\n    return { newText, insert, replace: replace2 };\n  }\n  InsertReplaceEdit2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate && Is.string(candidate.newText) && Range$1.is(candidate.insert) && Range$1.is(candidate.replace);\n  }\n  InsertReplaceEdit2.is = is2;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\nvar InsertTextMode;\n(function(InsertTextMode2) {\n  InsertTextMode2.asIs = 1;\n  InsertTextMode2.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nvar CompletionItem;\n(function(CompletionItem2) {\n  function create(label) {\n    return { label };\n  }\n  CompletionItem2.create = create;\n})(CompletionItem || (CompletionItem = {}));\nvar CompletionList;\n(function(CompletionList2) {\n  function create(items, isIncomplete) {\n    return { items: items ? items : [], isIncomplete: !!isIncomplete };\n  }\n  CompletionList2.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function(MarkedString2) {\n  function fromPlainText(plainText) {\n    return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\");\n  }\n  MarkedString2.fromPlainText = fromPlainText;\n  function is2(value) {\n    var candidate = value;\n    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\n  }\n  MarkedString2.is = is2;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function(Hover2) {\n  function is2(value) {\n    var candidate = value;\n    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range$1.is(value.range));\n  }\n  Hover2.is = is2;\n})(Hover || (Hover = {}));\nvar ParameterInformation;\n(function(ParameterInformation2) {\n  function create(label, documentation) {\n    return documentation ? { label, documentation } : { label };\n  }\n  ParameterInformation2.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\nvar SignatureInformation;\n(function(SignatureInformation2) {\n  function create(label, documentation) {\n    var parameters = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n      parameters[_i - 2] = arguments[_i];\n    }\n    var result2 = { label };\n    if (Is.defined(documentation)) {\n      result2.documentation = documentation;\n    }\n    if (Is.defined(parameters)) {\n      result2.parameters = parameters;\n    } else {\n      result2.parameters = [];\n    }\n    return result2;\n  }\n  SignatureInformation2.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\nvar DocumentHighlightKind;\n(function(DocumentHighlightKind2) {\n  DocumentHighlightKind2.Text = 1;\n  DocumentHighlightKind2.Read = 2;\n  DocumentHighlightKind2.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\nvar DocumentHighlight;\n(function(DocumentHighlight2) {\n  function create(range2, kind2) {\n    var result2 = { range: range2 };\n    if (Is.number(kind2)) {\n      result2.kind = kind2;\n    }\n    return result2;\n  }\n  DocumentHighlight2.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\nvar SymbolKind;\n(function(SymbolKind2) {\n  SymbolKind2.File = 1;\n  SymbolKind2.Module = 2;\n  SymbolKind2.Namespace = 3;\n  SymbolKind2.Package = 4;\n  SymbolKind2.Class = 5;\n  SymbolKind2.Method = 6;\n  SymbolKind2.Property = 7;\n  SymbolKind2.Field = 8;\n  SymbolKind2.Constructor = 9;\n  SymbolKind2.Enum = 10;\n  SymbolKind2.Interface = 11;\n  SymbolKind2.Function = 12;\n  SymbolKind2.Variable = 13;\n  SymbolKind2.Constant = 14;\n  SymbolKind2.String = 15;\n  SymbolKind2.Number = 16;\n  SymbolKind2.Boolean = 17;\n  SymbolKind2.Array = 18;\n  SymbolKind2.Object = 19;\n  SymbolKind2.Key = 20;\n  SymbolKind2.Null = 21;\n  SymbolKind2.EnumMember = 22;\n  SymbolKind2.Struct = 23;\n  SymbolKind2.Event = 24;\n  SymbolKind2.Operator = 25;\n  SymbolKind2.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\nvar SymbolTag;\n(function(SymbolTag2) {\n  SymbolTag2.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nvar SymbolInformation;\n(function(SymbolInformation2) {\n  function create(name2, kind2, range2, uri, containerName) {\n    var result2 = {\n      name: name2,\n      kind: kind2,\n      location: { uri, range: range2 }\n    };\n    if (containerName) {\n      result2.containerName = containerName;\n    }\n    return result2;\n  }\n  SymbolInformation2.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar DocumentSymbol;\n(function(DocumentSymbol2) {\n  function create(name2, detail, kind2, range2, selectionRange, children) {\n    var result2 = {\n      name: name2,\n      detail,\n      kind: kind2,\n      range: range2,\n      selectionRange\n    };\n    if (children !== void 0) {\n      result2.children = children;\n    }\n    return result2;\n  }\n  DocumentSymbol2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range$1.is(candidate.range) && Range$1.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));\n  }\n  DocumentSymbol2.is = is2;\n})(DocumentSymbol || (DocumentSymbol = {}));\nvar CodeActionKind;\n(function(CodeActionKind2) {\n  CodeActionKind2.Empty = \"\";\n  CodeActionKind2.QuickFix = \"quickfix\";\n  CodeActionKind2.Refactor = \"refactor\";\n  CodeActionKind2.RefactorExtract = \"refactor.extract\";\n  CodeActionKind2.RefactorInline = \"refactor.inline\";\n  CodeActionKind2.RefactorRewrite = \"refactor.rewrite\";\n  CodeActionKind2.Source = \"source\";\n  CodeActionKind2.SourceOrganizeImports = \"source.organizeImports\";\n  CodeActionKind2.SourceFixAll = \"source.fixAll\";\n})(CodeActionKind || (CodeActionKind = {}));\nvar CodeActionContext;\n(function(CodeActionContext2) {\n  function create(diagnostics, only) {\n    var result2 = { diagnostics };\n    if (only !== void 0 && only !== null) {\n      result2.only = only;\n    }\n    return result2;\n  }\n  CodeActionContext2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\n  }\n  CodeActionContext2.is = is2;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function(CodeAction2) {\n  function create(title, kindOrCommandOrEdit, kind2) {\n    var result2 = { title };\n    var checkKind = true;\n    if (typeof kindOrCommandOrEdit === \"string\") {\n      checkKind = false;\n      result2.kind = kindOrCommandOrEdit;\n    } else if (Command.is(kindOrCommandOrEdit)) {\n      result2.command = kindOrCommandOrEdit;\n    } else {\n      result2.edit = kindOrCommandOrEdit;\n    }\n    if (checkKind && kind2 !== void 0) {\n      result2.kind = kind2;\n    }\n    return result2;\n  }\n  CodeAction2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\n  }\n  CodeAction2.is = is2;\n})(CodeAction || (CodeAction = {}));\nvar CodeLens;\n(function(CodeLens2) {\n  function create(range2, data) {\n    var result2 = { range: range2 };\n    if (Is.defined(data)) {\n      result2.data = data;\n    }\n    return result2;\n  }\n  CodeLens2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range$1.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n  }\n  CodeLens2.is = is2;\n})(CodeLens || (CodeLens = {}));\nvar FormattingOptions;\n(function(FormattingOptions2) {\n  function create(tabSize, insertSpaces) {\n    return { tabSize, insertSpaces };\n  }\n  FormattingOptions2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n  }\n  FormattingOptions2.is = is2;\n})(FormattingOptions || (FormattingOptions = {}));\nvar DocumentLink;\n(function(DocumentLink2) {\n  function create(range2, target2, data) {\n    return { range: range2, target: target2, data };\n  }\n  DocumentLink2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range$1.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n  }\n  DocumentLink2.is = is2;\n})(DocumentLink || (DocumentLink = {}));\nvar SelectionRange;\n(function(SelectionRange2) {\n  function create(range2, parent) {\n    return { range: range2, parent };\n  }\n  SelectionRange2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return candidate !== void 0 && Range$1.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));\n  }\n  SelectionRange2.is = is2;\n})(SelectionRange || (SelectionRange = {}));\nvar TextDocument;\n(function(TextDocument2) {\n  function create(uri, languageId, version2, content) {\n    return new FullTextDocument(uri, languageId, version2, content);\n  }\n  TextDocument2.create = create;\n  function is2(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n  }\n  TextDocument2.is = is2;\n  function applyEdits(document2, edits) {\n    var text3 = document2.getText();\n    var sortedEdits = mergeSort(edits, function(a, b) {\n      var diff2 = a.range.start.line - b.range.start.line;\n      if (diff2 === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n      return diff2;\n    });\n    var lastModifiedOffset = text3.length;\n    for (var i = sortedEdits.length - 1; i >= 0; i--) {\n      var e = sortedEdits[i];\n      var startOffset = document2.offsetAt(e.range.start);\n      var endOffset = document2.offsetAt(e.range.end);\n      if (endOffset <= lastModifiedOffset) {\n        text3 = text3.substring(0, startOffset) + e.newText + text3.substring(endOffset, text3.length);\n      } else {\n        throw new Error(\"Overlapping edit\");\n      }\n      lastModifiedOffset = startOffset;\n    }\n    return text3;\n  }\n  TextDocument2.applyEdits = applyEdits;\n  function mergeSort(data, compare) {\n    if (data.length <= 1) {\n      return data;\n    }\n    var p2 = data.length / 2 | 0;\n    var left = data.slice(0, p2);\n    var right = data.slice(p2);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n      var ret = compare(left[leftIdx], right[rightIdx]);\n      if (ret <= 0) {\n        data[i++] = left[leftIdx++];\n      } else {\n        data[i++] = right[rightIdx++];\n      }\n    }\n    while (leftIdx < left.length) {\n      data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n      data[i++] = right[rightIdx++];\n    }\n    return data;\n  }\n})(TextDocument || (TextDocument = {}));\nvar FullTextDocument = function() {\n  function FullTextDocument2(uri, languageId, version2, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version2;\n    this._content = content;\n    this._lineOffsets = void 0;\n  }\n  Object.defineProperty(FullTextDocument2.prototype, \"uri\", {\n    get: function() {\n      return this._uri;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument2.prototype, \"languageId\", {\n    get: function() {\n      return this._languageId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument2.prototype, \"version\", {\n    get: function() {\n      return this._version;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  FullTextDocument2.prototype.getText = function(range2) {\n    if (range2) {\n      var start2 = this.offsetAt(range2.start);\n      var end2 = this.offsetAt(range2.end);\n      return this._content.substring(start2, end2);\n    }\n    return this._content;\n  };\n  FullTextDocument2.prototype.update = function(event, version2) {\n    this._content = event.text;\n    this._version = version2;\n    this._lineOffsets = void 0;\n  };\n  FullTextDocument2.prototype.getLineOffsets = function() {\n    if (this._lineOffsets === void 0) {\n      var lineOffsets = [];\n      var text3 = this._content;\n      var isLineStart = true;\n      for (var i = 0; i < text3.length; i++) {\n        if (isLineStart) {\n          lineOffsets.push(i);\n          isLineStart = false;\n        }\n        var ch2 = text3.charAt(i);\n        isLineStart = ch2 === \"\\r\" || ch2 === \"\\n\";\n        if (ch2 === \"\\r\" && i + 1 < text3.length && text3.charAt(i + 1) === \"\\n\") {\n          i++;\n        }\n      }\n      if (isLineStart && text3.length > 0) {\n        lineOffsets.push(text3.length);\n      }\n      this._lineOffsets = lineOffsets;\n    }\n    return this._lineOffsets;\n  };\n  FullTextDocument2.prototype.positionAt = function(offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    var lineOffsets = this.getLineOffsets();\n    var low = 0, high = lineOffsets.length;\n    if (high === 0) {\n      return Position$1.create(0, offset);\n    }\n    while (low < high) {\n      var mid2 = Math.floor((low + high) / 2);\n      if (lineOffsets[mid2] > offset) {\n        high = mid2;\n      } else {\n        low = mid2 + 1;\n      }\n    }\n    var line = low - 1;\n    return Position$1.create(line, offset - lineOffsets[line]);\n  };\n  FullTextDocument2.prototype.offsetAt = function(position) {\n    var lineOffsets = this.getLineOffsets();\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n    var lineOffset = lineOffsets[position.line];\n    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  };\n  Object.defineProperty(FullTextDocument2.prototype, \"lineCount\", {\n    get: function() {\n      return this.getLineOffsets().length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return FullTextDocument2;\n}();\nvar Is;\n(function(Is2) {\n  var toString = Object.prototype.toString;\n  function defined(value) {\n    return typeof value !== \"undefined\";\n  }\n  Is2.defined = defined;\n  function undefined$1(value) {\n    return typeof value === \"undefined\";\n  }\n  Is2.undefined = undefined$1;\n  function boolean(value) {\n    return value === true || value === false;\n  }\n  Is2.boolean = boolean;\n  function string2(value) {\n    return toString.call(value) === \"[object String]\";\n  }\n  Is2.string = string2;\n  function number(value) {\n    return toString.call(value) === \"[object Number]\";\n  }\n  Is2.number = number;\n  function numberRange(value, min, max) {\n    return toString.call(value) === \"[object Number]\" && min <= value && value <= max;\n  }\n  Is2.numberRange = numberRange;\n  function integer2(value) {\n    return toString.call(value) === \"[object Number]\" && -2147483648 <= value && value <= 2147483647;\n  }\n  Is2.integer = integer2;\n  function uinteger2(value) {\n    return toString.call(value) === \"[object Number]\" && 0 <= value && value <= 2147483647;\n  }\n  Is2.uinteger = uinteger2;\n  function func(value) {\n    return toString.call(value) === \"[object Function]\";\n  }\n  Is2.func = func;\n  function objectLiteral(value) {\n    return value !== null && typeof value === \"object\";\n  }\n  Is2.objectLiteral = objectLiteral;\n  function typedArray(value, check2) {\n    return Array.isArray(value) && value.every(check2);\n  }\n  Is2.typedArray = typedArray;\n})(Is || (Is = {}));\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match2) => {\n      let isMatched = this._testNextCharacter(match2);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match2);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token2 = null;\n      let match2 = null;\n      if (typeof pattern === \"string\") {\n        const regex2 = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match2 = regex2.test(this._sourceText.substr(this._pos, pattern.length));\n        token2 = pattern;\n      } else if (pattern instanceof RegExp) {\n        match2 = this._sourceText.slice(this._pos).match(pattern);\n        token2 = match2 && match2[0];\n      }\n      if (match2 != null) {\n        if (typeof pattern === \"string\" || match2 instanceof Array && this._sourceText.startsWith(match2[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token2 && token2.length) {\n              this._pos += token2.length;\n            }\n          }\n          return match2;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num2) => {\n      this._pos -= num2;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match2 = this._sourceText.match(/\\s*/);\n      let indent2 = 0;\n      if (match2 && match2.length !== 0) {\n        const whitespaces = match2[0];\n        let pos = 0;\n        while (whitespaces.length > pos) {\n          if (whitespaces.charCodeAt(pos) === 9) {\n            indent2 += 2;\n          } else {\n            indent2++;\n          }\n          pos++;\n        }\n      }\n      return indent2;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\nfunction opt(ofRule) {\n  return { ofRule };\n}\nfunction list$1(ofRule, separator2) {\n  return { ofRule, isList: true, separator: separator2 };\n}\nfunction butNot(rule, exclusions) {\n  const ruleMatch = rule.match;\n  rule.match = (token2) => {\n    let check2 = false;\n    if (ruleMatch) {\n      check2 = ruleMatch(token2);\n    }\n    return check2 && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token2));\n  };\n  return rule;\n}\nfunction t(kind2, style) {\n  return { style, match: (token2) => token2.kind === kind2 };\n}\nfunction p(value, style) {\n  return {\n    style: style || \"punctuation\",\n    match: (token2) => token2.kind === \"Punctuation\" && token2.value === value\n  };\n}\nconst isIgnored = (ch2) => ch2 === \" \" || ch2 === \"\t\" || ch2 === \",\" || ch2 === \"\\n\" || ch2 === \"\\r\" || ch2 === \"\\uFEFF\" || ch2 === \"\\xA0\";\nconst LexRules$2 = {\n  Name: /^[_A-Za-z][_0-9A-Za-z]*/,\n  Punctuation: /^(?:!|\\$|\\(|\\)|\\.\\.\\.|:|=|&|@|\\[|]|\\{|\\||\\})/,\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  String: /^(?:\"\"\"(?:\\\\\"\"\"|[^\"]|\"[^\"]|\"\"[^\"])*(?:\"\"\")?|\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?)/,\n  Comment: /^#.*/\n};\nconst ParseRules$2 = {\n  Document: [list$1(\"Definition\")],\n  Definition(token2) {\n    switch (token2.value) {\n      case \"{\":\n        return \"ShortQuery\";\n      case \"query\":\n        return \"Query\";\n      case \"mutation\":\n        return \"Mutation\";\n      case \"subscription\":\n        return \"Subscription\";\n      case \"fragment\":\n        return Kind.FRAGMENT_DEFINITION;\n      case \"schema\":\n        return \"SchemaDef\";\n      case \"scalar\":\n        return \"ScalarDef\";\n      case \"type\":\n        return \"ObjectTypeDef\";\n      case \"interface\":\n        return \"InterfaceDef\";\n      case \"union\":\n        return \"UnionDef\";\n      case \"enum\":\n        return \"EnumDef\";\n      case \"input\":\n        return \"InputDef\";\n      case \"extend\":\n        return \"ExtendDef\";\n      case \"directive\":\n        return \"DirectiveDef\";\n    }\n  },\n  ShortQuery: [\"SelectionSet\"],\n  Query: [\n    word(\"query\"),\n    opt(name(\"def\")),\n    opt(\"VariableDefinitions\"),\n    list$1(\"Directive\"),\n    \"SelectionSet\"\n  ],\n  Mutation: [\n    word(\"mutation\"),\n    opt(name(\"def\")),\n    opt(\"VariableDefinitions\"),\n    list$1(\"Directive\"),\n    \"SelectionSet\"\n  ],\n  Subscription: [\n    word(\"subscription\"),\n    opt(name(\"def\")),\n    opt(\"VariableDefinitions\"),\n    list$1(\"Directive\"),\n    \"SelectionSet\"\n  ],\n  VariableDefinitions: [p(\"(\"), list$1(\"VariableDefinition\"), p(\")\")],\n  VariableDefinition: [\"Variable\", p(\":\"), \"Type\", opt(\"DefaultValue\")],\n  Variable: [p(\"$\", \"variable\"), name(\"variable\")],\n  DefaultValue: [p(\"=\"), \"Value\"],\n  SelectionSet: [p(\"{\"), list$1(\"Selection\"), p(\"}\")],\n  Selection(token2, stream) {\n    return token2.value === \"...\" ? stream.match(/[\\s\\u00a0,]*(on\\b|@|{)/, false) ? \"InlineFragment\" : \"FragmentSpread\" : stream.match(/[\\s\\u00a0,]*:/, false) ? \"AliasedField\" : \"Field\";\n  },\n  AliasedField: [\n    name(\"property\"),\n    p(\":\"),\n    name(\"qualifier\"),\n    opt(\"Arguments\"),\n    list$1(\"Directive\"),\n    opt(\"SelectionSet\")\n  ],\n  Field: [\n    name(\"property\"),\n    opt(\"Arguments\"),\n    list$1(\"Directive\"),\n    opt(\"SelectionSet\")\n  ],\n  Arguments: [p(\"(\"), list$1(\"Argument\"), p(\")\")],\n  Argument: [name(\"attribute\"), p(\":\"), \"Value\"],\n  FragmentSpread: [p(\"...\"), name(\"def\"), list$1(\"Directive\")],\n  InlineFragment: [\n    p(\"...\"),\n    opt(\"TypeCondition\"),\n    list$1(\"Directive\"),\n    \"SelectionSet\"\n  ],\n  FragmentDefinition: [\n    word(\"fragment\"),\n    opt(butNot(name(\"def\"), [word(\"on\")])),\n    \"TypeCondition\",\n    list$1(\"Directive\"),\n    \"SelectionSet\"\n  ],\n  TypeCondition: [word(\"on\"), \"NamedType\"],\n  Value(token2) {\n    switch (token2.kind) {\n      case \"Number\":\n        return \"NumberValue\";\n      case \"String\":\n        return \"StringValue\";\n      case \"Punctuation\":\n        switch (token2.value) {\n          case \"[\":\n            return \"ListValue\";\n          case \"{\":\n            return \"ObjectValue\";\n          case \"$\":\n            return \"Variable\";\n          case \"&\":\n            return \"NamedType\";\n        }\n        return null;\n      case \"Name\":\n        switch (token2.value) {\n          case \"true\":\n          case \"false\":\n            return \"BooleanValue\";\n        }\n        if (token2.value === \"null\") {\n          return \"NullValue\";\n        }\n        return \"EnumValue\";\n    }\n  },\n  NumberValue: [t(\"Number\", \"number\")],\n  StringValue: [\n    {\n      style: \"string\",\n      match: (token2) => token2.kind === \"String\",\n      update(state, token2) {\n        if (token2.value.startsWith('\"\"\"')) {\n          state.inBlockstring = !token2.value.slice(3).endsWith('\"\"\"');\n        }\n      }\n    }\n  ],\n  BooleanValue: [t(\"Name\", \"builtin\")],\n  NullValue: [t(\"Name\", \"keyword\")],\n  EnumValue: [name(\"string-2\")],\n  ListValue: [p(\"[\"), list$1(\"Value\"), p(\"]\")],\n  ObjectValue: [p(\"{\"), list$1(\"ObjectField\"), p(\"}\")],\n  ObjectField: [name(\"attribute\"), p(\":\"), \"Value\"],\n  Type(token2) {\n    return token2.value === \"[\" ? \"ListType\" : \"NonNullType\";\n  },\n  ListType: [p(\"[\"), \"Type\", p(\"]\"), opt(p(\"!\"))],\n  NonNullType: [\"NamedType\", opt(p(\"!\"))],\n  NamedType: [type(\"atom\")],\n  Directive: [p(\"@\", \"meta\"), name(\"meta\"), opt(\"Arguments\")],\n  DirectiveDef: [\n    word(\"directive\"),\n    p(\"@\", \"meta\"),\n    name(\"meta\"),\n    opt(\"ArgumentsDef\"),\n    word(\"on\"),\n    list$1(\"DirectiveLocation\", p(\"|\"))\n  ],\n  InterfaceDef: [\n    word(\"interface\"),\n    name(\"atom\"),\n    opt(\"Implements\"),\n    list$1(\"Directive\"),\n    p(\"{\"),\n    list$1(\"FieldDef\"),\n    p(\"}\")\n  ],\n  Implements: [word(\"implements\"), list$1(\"NamedType\", p(\"&\"))],\n  DirectiveLocation: [name(\"string-2\")],\n  SchemaDef: [\n    word(\"schema\"),\n    list$1(\"Directive\"),\n    p(\"{\"),\n    list$1(\"OperationTypeDef\"),\n    p(\"}\")\n  ],\n  OperationTypeDef: [name(\"keyword\"), p(\":\"), name(\"atom\")],\n  ScalarDef: [word(\"scalar\"), name(\"atom\"), list$1(\"Directive\")],\n  ObjectTypeDef: [\n    word(\"type\"),\n    name(\"atom\"),\n    opt(\"Implements\"),\n    list$1(\"Directive\"),\n    p(\"{\"),\n    list$1(\"FieldDef\"),\n    p(\"}\")\n  ],\n  FieldDef: [\n    name(\"property\"),\n    opt(\"ArgumentsDef\"),\n    p(\":\"),\n    \"Type\",\n    list$1(\"Directive\")\n  ],\n  ArgumentsDef: [p(\"(\"), list$1(\"InputValueDef\"), p(\")\")],\n  InputValueDef: [\n    name(\"attribute\"),\n    p(\":\"),\n    \"Type\",\n    opt(\"DefaultValue\"),\n    list$1(\"Directive\")\n  ],\n  UnionDef: [\n    word(\"union\"),\n    name(\"atom\"),\n    list$1(\"Directive\"),\n    p(\"=\"),\n    list$1(\"UnionMember\", p(\"|\"))\n  ],\n  UnionMember: [\"NamedType\"],\n  EnumDef: [\n    word(\"enum\"),\n    name(\"atom\"),\n    list$1(\"Directive\"),\n    p(\"{\"),\n    list$1(\"EnumValueDef\"),\n    p(\"}\")\n  ],\n  EnumValueDef: [name(\"string-2\"), list$1(\"Directive\")],\n  InputDef: [\n    word(\"input\"),\n    name(\"atom\"),\n    list$1(\"Directive\"),\n    p(\"{\"),\n    list$1(\"InputValueDef\"),\n    p(\"}\")\n  ],\n  ExtendDef: [word(\"extend\"), \"ObjectTypeDef\"]\n};\nfunction word(value) {\n  return {\n    style: \"keyword\",\n    match: (token2) => token2.kind === \"Name\" && token2.value === value\n  };\n}\nfunction name(style) {\n  return {\n    style,\n    match: (token2) => token2.kind === \"Name\",\n    update(state, token2) {\n      state.name = token2.value;\n    }\n  };\n}\nfunction type(style) {\n  return {\n    style,\n    match: (token2) => token2.kind === \"Name\",\n    update(state, token2) {\n      if (state.prevState && state.prevState.prevState) {\n        state.name = token2.value;\n        state.prevState.prevState.type = token2.value;\n      }\n    }\n  };\n}\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules$2,\n  parseRules: ParseRules$2,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeperator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\nfunction getToken(stream, state, options) {\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = editorConfig && editorConfig.tabSize || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token2 = lex$1(lexRules, stream);\n  if (!token2) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token2.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign$2({}, state);\n  if (token2.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token2.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token2.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token2, stream) : null : state.rule[state.step];\n    if (state.needsSeperator) {\n      expected = expected && (expected == null ? void 0 : expected.separator);\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if (expected.match && expected.match(token2)) {\n        if (expected.update) {\n          expected.update(state, token2);\n        }\n        if (token2.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign$2(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\nfunction assign$2(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = __spreadValues({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeperator = false;\n}\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeperator = state.prevState.needsSeperator;\n  state.prevState = state.prevState.prevState;\n}\nfunction advanceRule(state, successful) {\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator2 = step.separator;\n      state.needsSeperator = !state.needsSeperator;\n      if (!state.needsSeperator && separator2.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeperator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if (state.rule && state.rule[state.step].separator) {\n          state.needsSeperator = !state.needsSeperator;\n        }\n      } else {\n        state.needsSeperator = false;\n        state.step++;\n      }\n    }\n  }\n}\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\nfunction lex$1(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match2 = stream.match(lexRules[kinds[i]]);\n    if (match2 && match2 instanceof Array) {\n      return { kind: kinds[i], value: match2[0] };\n    }\n  }\n}\nconst AdditionalRuleKinds = {\n  ALIASED_FIELD: \"AliasedField\",\n  ARGUMENTS: \"Arguments\",\n  SHORT_QUERY: \"ShortQuery\",\n  QUERY: \"Query\",\n  MUTATION: \"Mutation\",\n  SUBSCRIPTION: \"Subscription\",\n  TYPE_CONDITION: \"TypeCondition\",\n  INVALID: \"Invalid\",\n  COMMENT: \"Comment\",\n  SCHEMA_DEF: \"SchemaDef\",\n  SCALAR_DEF: \"ScalarDef\",\n  OBJECT_TYPE_DEF: \"ObjectTypeDef\",\n  OBJECT_VALUE: \"ObjectValue\",\n  LIST_VALUE: \"ListValue\",\n  INTERFACE_DEF: \"InterfaceDef\",\n  UNION_DEF: \"UnionDef\",\n  ENUM_DEF: \"EnumDef\",\n  ENUM_VALUE: \"EnumValue\",\n  FIELD_DEF: \"FieldDef\",\n  INPUT_DEF: \"InputDef\",\n  INPUT_VALUE_DEF: \"InputValueDef\",\n  ARGUMENTS_DEF: \"ArgumentsDef\",\n  EXTEND_DEF: \"ExtendDef\",\n  DIRECTIVE_DEF: \"DirectiveDef\",\n  IMPLEMENTS: \"Implements\",\n  VARIABLE_DEFINITIONS: \"VariableDefinitions\",\n  TYPE: \"Type\"\n};\nconst RuleKinds = __spreadValues(__spreadValues({}, Kind), AdditionalRuleKinds);\nconst SuggestionCommand = {\n  command: \"editor.action.triggerSuggest\",\n  title: \"Suggestions\"\n};\nconst collectFragmentDefs = (op) => {\n  const externalFragments = [];\n  if (op) {\n    visit(parse$1(op), {\n      FragmentDefinition(def) {\n        externalFragments.push(def);\n      }\n    });\n  }\n  return externalFragments;\n};\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n  var _a2;\n  const opts = __spreadProps(__spreadValues({}, options), {\n    schema\n  });\n  const token2 = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token2.state.kind === \"Invalid\" ? token2.state.prevState : token2.state;\n  if (!state) {\n    return [];\n  }\n  const kind2 = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo$3(schema, token2.state);\n  if (kind2 === RuleKinds.DOCUMENT) {\n    return hintList$2(token2, [\n      { label: \"query\", kind: CompletionItemKind$1.Function },\n      { label: \"mutation\", kind: CompletionItemKind$1.Function },\n      { label: \"subscription\", kind: CompletionItemKind$1.Function },\n      { label: \"fragment\", kind: CompletionItemKind$1.Function },\n      { label: \"{\", kind: CompletionItemKind$1.Constructor }\n    ]);\n  }\n  if (kind2 === RuleKinds.IMPLEMENTS || kind2 === RuleKinds.NAMED_TYPE && ((_a2 = state.prevState) == null ? void 0 : _a2.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token2, state, schema, queryText, typeInfo);\n  }\n  if (kind2 === RuleKinds.SELECTION_SET || kind2 === RuleKinds.FIELD || kind2 === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token2, typeInfo, opts);\n  }\n  if (kind2 === RuleKinds.ARGUMENTS || kind2 === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList$2(token2, argDefs.map((argDef) => {\n        var _a3;\n        return {\n          label: argDef.name,\n          insertText: argDef.name + \": \",\n          command: SuggestionCommand,\n          detail: String(argDef.type),\n          documentation: (_a3 = argDef.description) != null ? _a3 : void 0,\n          kind: CompletionItemKind$1.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n  if (kind2 === RuleKinds.OBJECT_VALUE || kind2 === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind2 === RuleKinds.OBJECT_VALUE ? CompletionItemKind$1.Value : CompletionItemKind$1.Field;\n      return hintList$2(token2, objectFields.map((field) => {\n        var _a3;\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a3 = field.description) != null ? _a3 : void 0,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n  if (kind2 === RuleKinds.ENUM_VALUE || kind2 === RuleKinds.LIST_VALUE && step === 1 || kind2 === RuleKinds.OBJECT_FIELD && step === 2 || kind2 === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token2, typeInfo, queryText, schema);\n  }\n  if (kind2 === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema, token2);\n    return hintList$2(token2, variableDefinitions.filter((v2) => v2.detail === (namedInputType == null ? void 0 : namedInputType.name)));\n  }\n  if (kind2 === RuleKinds.TYPE_CONDITION && step === 1 || kind2 === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token2, typeInfo, schema);\n  }\n  if (kind2 === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token2, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n  if (kind2 === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind2 === RuleKinds.LIST_TYPE && step === 1 || kind2 === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token2, schema);\n  }\n  if (kind2 === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token2, state, schema);\n  }\n  return [];\n}\nconst insertSuffix = ` {\n  $1\n}`;\nconst getInsertText = (field) => {\n  const type2 = field.type;\n  if (isCompositeType(type2)) {\n    return insertSuffix;\n  }\n  if (isListType(type2) && isCompositeType(type2.ofType)) {\n    return insertSuffix;\n  }\n  if (isNonNullType(type2)) {\n    if (isCompositeType(type2.ofType)) {\n      return insertSuffix;\n    }\n    if (isListType(type2.ofType) && isCompositeType(type2.ofType.ofType)) {\n      return insertSuffix;\n    }\n  }\n  return null;\n};\nfunction getSuggestionsForFieldNames(token2, typeInfo, options) {\n  var _a2;\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n    if (\"getFields\" in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef);\n    }\n    if (parentType === ((_a2 = options == null ? void 0 : options.schema) == null ? void 0 : _a2.getQueryType())) {\n      fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);\n    }\n    return hintList$2(token2, fields.map((field, index) => {\n      var _a3;\n      const suggestion = {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a3 = field.description) != null ? _a3 : void 0,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind$1.Field,\n        type: field.type\n      };\n      const insertText = getInsertText(field);\n      if (insertText) {\n        suggestion.insertText = field.name + insertText;\n        suggestion.insertTextFormat = InsertTextFormat.Snippet;\n        suggestion.command = SuggestionCommand;\n      }\n      return suggestion;\n    }));\n  }\n  return [];\n}\nfunction getSuggestionsForInputValues(token2, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, token2).filter((v2) => v2.detail === namedInputType.name);\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList$2(token2, values.map((value) => {\n      var _a2;\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a2 = value.description) != null ? _a2 : void 0,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind$1.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList$2(token2, queryVariables.concat([\n      {\n        label: \"true\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not false.\",\n        kind: CompletionItemKind$1.Variable,\n        type: GraphQLBoolean\n      },\n      {\n        label: \"false\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not true.\",\n        kind: CompletionItemKind$1.Variable,\n        type: GraphQLBoolean\n      }\n    ]));\n  }\n  return queryVariables;\n}\nfunction getSuggestionsForImplements(token2, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeperator) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({ name: name2 }) => name2);\n  const inlineInterfaces = /* @__PURE__ */ new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a2, _b, _c, _d, _e;\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a2 = state.prevState) == null ? void 0 : _a2.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) == null ? void 0 : _b.getInterfaces().find(({ name: name2 }) => name2 === state.name);\n          if (existingType) {\n            return;\n          }\n          const type2 = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) == null ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(__spreadProps(__spreadValues({}, interfaceConfig), {\n            interfaces: [\n              ...interfaceConfig.interfaces,\n              type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })\n            ]\n          }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) == null ? void 0 : _d.getInterfaces().find(({ name: name2 }) => name2 === state.name);\n          if (existingType) {\n            return;\n          }\n          const type2 = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) == null ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(__spreadProps(__spreadValues({}, objectTypeConfig), {\n            interfaces: [\n              ...objectTypeConfig.interfaces,\n              type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })\n            ]\n          }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend == null ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({ name: name2 }) => name2);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name2) => ({ name: name2 }))).filter(({ name: name2 }) => name2 !== (currentTypeToExtend == null ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name2));\n  return hintList$2(token2, possibleInterfaces.map((type2) => {\n    const result2 = {\n      label: type2.name,\n      kind: CompletionItemKind$1.Interface,\n      type: type2\n    };\n    if (type2 == null ? void 0 : type2.description) {\n      result2.documentation = type2.description;\n    }\n    return result2;\n  }));\n}\nfunction getSuggestionsForFragmentTypeConditions(token2, typeInfo, schema, _kind) {\n  let possibleTypes;\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);\n      possibleObjTypes.forEach((type2) => {\n        type2.getInterfaces().forEach((iface) => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n  return hintList$2(token2, possibleTypes.map((type2) => {\n    const namedType = getNamedType(type2);\n    return {\n      label: String(type2),\n      documentation: namedType && namedType.description || \"\",\n      kind: CompletionItemKind$1.Field\n    };\n  }));\n}\nfunction getSuggestionsForFragmentSpread(token2, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token2.state);\n  const fragments = getFragmentDefinitions(queryText);\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList$2(token2, relevantFrags.map((frag) => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind$1.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\nconst getParentDefinition = (state, kind2) => {\n  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  if (((_a2 = state.prevState) == null ? void 0 : _a2.kind) === kind2) {\n    return state.prevState;\n  }\n  if (((_c = (_b = state.prevState) == null ? void 0 : _b.prevState) == null ? void 0 : _c.kind) === kind2) {\n    return state.prevState.prevState;\n  }\n  if (((_f = (_e = (_d = state.prevState) == null ? void 0 : _d.prevState) == null ? void 0 : _e.prevState) == null ? void 0 : _f.kind) === kind2) {\n    return state.prevState.prevState.prevState;\n  }\n  if (((_j = (_i = (_h = (_g = state.prevState) == null ? void 0 : _g.prevState) == null ? void 0 : _h.prevState) == null ? void 0 : _i.prevState) == null ? void 0 : _j.kind) === kind2) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n};\nfunction getVariableCompletions(queryText, schema, token2) {\n  let variableName = null;\n  let variableType;\n  const definitions = /* @__PURE__ */ Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if ((state == null ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n    if ((state == null ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n      if (parentDefinition == null ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition == null ? void 0 : parentDefinition.type);\n      }\n    }\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          insertText: token2.string === \"$\" ? variableName : \"$\" + variableName,\n          label: variableName,\n          type: variableType,\n          kind: CompletionItemKind$1.Variable\n        };\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\nfunction getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\nfunction getSuggestionsForVariableDefinition(token2, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList$2(token2, inputTypes.map((type2) => ({\n    label: type2.name,\n    documentation: type2.description,\n    kind: CompletionItemKind$1.Variable\n  })));\n}\nfunction getSuggestionsForDirective(token2, state, schema, _kind) {\n  if (state.prevState && state.prevState.kind) {\n    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));\n    return hintList$2(token2, directives.map((directive) => ({\n      label: directive.name,\n      documentation: directive.description || \"\",\n      kind: CompletionItemKind$1.Function\n    })));\n  }\n  return [];\n}\nfunction getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token2 = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = __spreadValues({}, state);\n        stringAtCursor = stream.current();\n        return \"BREAK\";\n      }\n    }\n  });\n  return {\n    start: token2.start,\n    end: token2.end,\n    string: stringAtCursor || token2.string,\n    state: stateAtCursor || token2.state,\n    style: styleAtCursor || token2.style\n  };\n}\nfunction runOnlineParser(queryText, callback) {\n  const lines = queryText.split(\"\\n\");\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = \"\";\n  let stream = new CharacterStream(\"\");\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code3 = callback(stream, state, style, i);\n      if (code3 === \"BREAK\") {\n        break;\n      }\n    }\n    callback(stream, state, style, i);\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\nfunction canUseDirective(state, directive) {\n  if (!state || !state.kind) {\n    return false;\n  }\n  const kind2 = state.kind;\n  const locations = directive.locations;\n  switch (kind2) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = state.prevState && state.prevState.kind;\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n  }\n  return false;\n}\nfunction getTypeInfo$3(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type2;\n  let interfaceDef;\n  forEachState$2(tokenState, (state) => {\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case \"ShortQuery\":\n        type2 = schema.getQueryType();\n        break;\n      case RuleKinds.MUTATION:\n        type2 = schema.getMutationType();\n        break;\n      case RuleKinds.SUBSCRIPTION:\n        type2 = schema.getSubscriptionType();\n        break;\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type2 = schema.getType(state.type);\n        }\n        break;\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD: {\n        if (!type2 || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef$1(schema, parentType, state.name) : null;\n          type2 = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      }\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type2);\n        break;\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.ARGUMENTS: {\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case RuleKinds.ALIASED_FIELD: {\n              const name2 = state.prevState && state.prevState.name;\n              if (!name2) {\n                argDefs = null;\n                break;\n              }\n              const field = parentType ? getFieldDef$1(schema, parentType, name2) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            }\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      }\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef && argDef.type;\n        break;\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;\n        break;\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField && objectField.type;\n        break;\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type2 = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type: type2,\n    interfaceDef,\n    objectTypeDef\n  };\n}\nvar nullthrows$2 = { exports: {} };\nfunction nullthrows(x2, message) {\n  if (x2 != null) {\n    return x2;\n  }\n  var error2 = new Error(message !== void 0 ? message : \"Got unexpected \" + x2);\n  error2.framesToPop = 1;\n  throw error2;\n}\nnullthrows$2.exports = nullthrows;\nnullthrows$2.exports.default = nullthrows;\nObject.defineProperty(nullthrows$2.exports, \"__esModule\", { value: true });\nvar nullthrows$1 = /* @__PURE__ */ getDefaultExportFromCjs(nullthrows$2.exports);\nconst getFragmentDependencies = (operationString, fragmentDefinitions) => {\n  if (!fragmentDefinitions) {\n    return [];\n  }\n  let parsedOperation;\n  try {\n    parsedOperation = parse$1(operationString);\n  } catch (error2) {\n    return [];\n  }\n  return getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);\n};\nconst getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {\n  if (!fragmentDefinitions) {\n    return [];\n  }\n  const existingFrags = /* @__PURE__ */ new Map();\n  const referencedFragNames = /* @__PURE__ */ new Set();\n  visit(parsedOperation, {\n    FragmentDefinition(node) {\n      existingFrags.set(node.name.value, true);\n    },\n    FragmentSpread(node) {\n      if (!referencedFragNames.has(node.name.value)) {\n        referencedFragNames.add(node.name.value);\n      }\n    }\n  });\n  const asts = /* @__PURE__ */ new Set();\n  referencedFragNames.forEach((name2) => {\n    if (!existingFrags.has(name2) && fragmentDefinitions.has(name2)) {\n      asts.add(nullthrows$1(fragmentDefinitions.get(name2)));\n    }\n  });\n  const referencedFragments = [];\n  asts.forEach((ast2) => {\n    visit(ast2, {\n      FragmentSpread(node) {\n        if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {\n          asts.add(nullthrows$1(fragmentDefinitions.get(node.name.value)));\n          referencedFragNames.add(node.name.value);\n        }\n      }\n    });\n    if (!existingFrags.has(ast2.name.value)) {\n      referencedFragments.push(ast2);\n    }\n  });\n  return referencedFragments;\n};\nfunction text$3(into, newText) {\n  into.push(newText);\n}\nfunction renderType$4(into, t2) {\n  if (isNonNullType(t2)) {\n    renderType$4(into, t2.ofType);\n    text$3(into, \"!\");\n  } else if (isListType(t2)) {\n    text$3(into, \"[\");\n    renderType$4(into, t2.ofType);\n    text$3(into, \"]\");\n  } else {\n    text$3(into, t2.name);\n  }\n}\nfunction renderTypeToString(t2, useMarkdown) {\n  const into = [];\n  if (useMarkdown) {\n    text$3(into, \"```graphql\\n\");\n  }\n  renderType$4(into, t2);\n  if (useMarkdown) {\n    text$3(into, \"\\n```\");\n  }\n  return into.join(\"\");\n}\nconst scalarTypesMap = {\n  Int: \"integer\",\n  String: \"string\",\n  Float: \"number\",\n  ID: \"string\",\n  Boolean: \"boolean\",\n  DateTime: \"string\"\n};\nfunction getJSONSchemaFromGraphQLType(type2, options) {\n  var _a2;\n  let required = false;\n  let definition = /* @__PURE__ */ Object.create(null);\n  const definitions = /* @__PURE__ */ Object.create(null);\n  if (\"defaultValue\" in type2 && type2.defaultValue !== void 0) {\n    definition.default = type2.defaultValue;\n  }\n  if (isEnumType(type2)) {\n    definition.type = \"string\";\n    definition.enum = type2.getValues().map((val) => val.name);\n  }\n  if (isScalarType(type2)) {\n    definition.type = (_a2 = scalarTypesMap[type2.name]) != null ? _a2 : \"any\";\n  }\n  if (isListType(type2)) {\n    definition.type = \"array\";\n    const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type2.ofType, options);\n    if (def.$ref) {\n      definition.items = { $ref: def.$ref };\n    } else {\n      definition.items = def;\n    }\n    if (defs) {\n      Object.keys(defs).forEach((defName) => {\n        definitions[defName] = defs[defName];\n      });\n    }\n  }\n  if (isNonNullType(type2)) {\n    required = true;\n    const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type2.ofType, options);\n    definition = def;\n    if (defs) {\n      Object.keys(defs).forEach((defName) => {\n        definitions[defName] = defs[defName];\n      });\n    }\n  }\n  if (isInputObjectType(type2)) {\n    definition.$ref = `#/definitions/${type2.name}`;\n    const fields = type2.getFields();\n    const fieldDef = {\n      type: \"object\",\n      properties: {},\n      required: []\n    };\n    if (type2.description) {\n      fieldDef.description = type2.description + `\n` + renderTypeToString(type2);\n      if (options == null ? void 0 : options.useMarkdownDescription) {\n        fieldDef.markdownDescription = type2.description + `\n` + renderTypeToString(type2, true);\n      }\n    } else {\n      fieldDef.description = renderTypeToString(type2);\n      if (options == null ? void 0 : options.useMarkdownDescription) {\n        fieldDef.markdownDescription = renderTypeToString(type2, true);\n      }\n    }\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const { required: fieldRequired, definition: typeDefinition, definitions: typeDefinitions } = getJSONSchemaFromGraphQLType(field.type, options);\n      const { definition: fieldDefinition } = getJSONSchemaFromGraphQLType(field, options);\n      fieldDef.properties[fieldName] = __spreadValues(__spreadValues({}, typeDefinition), fieldDefinition);\n      const renderedField = renderTypeToString(field.type);\n      fieldDef.properties[fieldName].description = field.description ? field.description + \"\\n\" + renderedField : renderedField;\n      if (options == null ? void 0 : options.useMarkdownDescription) {\n        const renderedFieldMarkdown = renderTypeToString(field.type, true);\n        fieldDef.properties[fieldName].markdownDescription = field.description ? field.description + \"\\n\" + renderedFieldMarkdown : renderedFieldMarkdown;\n      }\n      if (fieldRequired) {\n        fieldDef.required.push(fieldName);\n      }\n      if (typeDefinitions) {\n        Object.keys(typeDefinitions).map((defName) => {\n          definitions[defName] = typeDefinitions[defName];\n        });\n      }\n    });\n    definitions[type2.name] = fieldDef;\n  }\n  if (\"description\" in type2 && !isScalarType(type2) && type2.description && !definition.description) {\n    definition.description = type2.description + \"\\n\" + renderTypeToString(type2);\n    if (options == null ? void 0 : options.useMarkdownDescription) {\n      definition.markdownDescription = type2.description + \"\\n\" + renderTypeToString(type2, true);\n    }\n  } else {\n    definition.description = renderTypeToString(type2);\n    if (options == null ? void 0 : options.useMarkdownDescription) {\n      definition.markdownDescription = renderTypeToString(type2, true);\n    }\n  }\n  return { required, definition, definitions };\n}\nfunction getVariablesJSONSchema(variableToType, options) {\n  const jsonSchema = {\n    $schema: \"https://json-schema.org/draft/2020-12/schema\",\n    type: \"object\",\n    properties: {},\n    required: []\n  };\n  if (variableToType) {\n    Object.entries(variableToType).forEach(([variableName, type2]) => {\n      var _a2;\n      const { definition, required, definitions } = getJSONSchemaFromGraphQLType(type2, options);\n      jsonSchema.properties[variableName] = definition;\n      if (required) {\n        (_a2 = jsonSchema.required) == null ? void 0 : _a2.push(variableName);\n      }\n      if (definitions) {\n        jsonSchema.definitions = __spreadValues(__spreadValues({}, jsonSchema == null ? void 0 : jsonSchema.definitions), definitions);\n      }\n    });\n  }\n  return jsonSchema;\n}\nfunction getASTNodeAtPosition(query, ast2, point) {\n  const offset = pointToOffset(query, point);\n  let nodeContainingPosition;\n  visit(ast2, {\n    enter(node) {\n      if (node.kind !== \"Name\" && node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n        nodeContainingPosition = node;\n      } else {\n        return false;\n      }\n    },\n    leave(node) {\n      if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {\n        return false;\n      }\n    }\n  });\n  return nodeContainingPosition;\n}\nfunction pointToOffset(text3, point) {\n  const linesUntilPosition = text3.split(\"\\n\").slice(0, point.line);\n  return point.character + linesUntilPosition.map((line) => line.length + 1).reduce((a, b) => a + b, 0);\n}\nclass Range {\n  constructor(start2, end2) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start2;\n    this.end = end2;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\nfunction offsetToPosition(text3, loc) {\n  const EOL = \"\\n\";\n  const buf = text3.slice(0, loc);\n  const lines = buf.split(EOL).length - 1;\n  const lastLineIndex = buf.lastIndexOf(EOL);\n  return new Position(lines, loc - lastLineIndex - 1);\n}\nfunction locToRange(text3, loc) {\n  const start2 = offsetToPosition(text3, loc.start);\n  const end2 = offsetToPosition(text3, loc.end);\n  return new Range(start2, end2);\n}\nconst specifiedSDLRules = [\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule\n];\nfunction validateWithCustomRules(schema, ast2, customRules, isRelayCompatMode, isSchemaDocument) {\n  const rules = specifiedRules.filter((rule) => {\n    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n      return false;\n    }\n    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n      return false;\n    }\n    return true;\n  });\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n  if (isSchemaDocument) {\n    Array.prototype.push.apply(rules, specifiedSDLRules);\n  }\n  const errors2 = validate(schema, ast2, rules);\n  return errors2.filter((error2) => {\n    if (error2.message.indexOf(\"Unknown directive\") !== -1 && error2.nodes) {\n      const node = error2.nodes[0];\n      if (node && node.kind === Kind.DIRECTIVE) {\n        const name2 = node.name.value;\n        if (name2 === \"arguments\" || name2 === \"argumentDefinitions\") {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n}\nfunction collectVariables(schema, documentAST) {\n  const variableToType = /* @__PURE__ */ Object.create(null);\n  documentAST.definitions.forEach((definition) => {\n    if (definition.kind === \"OperationDefinition\") {\n      const variableDefinitions = definition.variableDefinitions;\n      if (variableDefinitions) {\n        variableDefinitions.forEach(({ variable, type: type2 }) => {\n          const inputType = typeFromAST(schema, type2);\n          if (inputType) {\n            variableToType[variable.name.value] = inputType;\n          } else if (type2.kind === Kind.NAMED_TYPE) {\n            if (type2.name.value === \"Float\") {\n              variableToType[variable.name.value] = GraphQLFloat;\n            }\n          }\n        });\n      }\n    }\n  });\n  return variableToType;\n}\nfunction getOperationASTFacts(documentAST, schema) {\n  const variableToType = schema ? collectVariables(schema, documentAST) : void 0;\n  const operations = [];\n  visit(documentAST, {\n    OperationDefinition(node) {\n      operations.push(node);\n    }\n  });\n  return { variableToType, operations };\n}\nfunction getOperationFacts(schema, documentString) {\n  if (!documentString) {\n    return;\n  }\n  try {\n    const documentAST = parse$1(documentString);\n    return __spreadProps(__spreadValues({}, getOperationASTFacts(documentAST, schema)), {\n      documentAST\n    });\n  } catch {\n    return;\n  }\n}\nconst getQueryFacts = getOperationFacts;\nconst LANGUAGE = \"GraphQL\";\nfunction assert(value, message) {\n  if (!value) {\n    throw new Error(message);\n  }\n}\nfunction getRange$1(text3, node) {\n  const location = node.loc;\n  assert(location, \"Expected ASTNode to have a location.\");\n  return locToRange(text3, location);\n}\nfunction getPosition(text3, node) {\n  const location = node.loc;\n  assert(location, \"Expected ASTNode to have a location.\");\n  return offsetToPosition(text3, location.start);\n}\nasync function getDefinitionQueryResultForNamedType(text3, node, dependencies) {\n  const name2 = node.name.value;\n  const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name2);\n  if (defNodes.length === 0) {\n    throw Error(`Definition not found for GraphQL type ${name2}`);\n  }\n  const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || \"\", content, definition));\n  return {\n    definitions,\n    queryRange: definitions.map((_) => getRange$1(text3, node))\n  };\n}\nasync function getDefinitionQueryResultForFragmentSpread(text3, fragment, dependencies) {\n  const name2 = fragment.name.value;\n  const defNodes = dependencies.filter(({ definition }) => definition.name.value === name2);\n  if (defNodes.length === 0) {\n    throw Error(`Definition not found for GraphQL fragment ${name2}`);\n  }\n  const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || \"\", content, definition));\n  return {\n    definitions,\n    queryRange: definitions.map((_) => getRange$1(text3, fragment))\n  };\n}\nfunction getDefinitionQueryResultForDefinitionNode(path, text3, definition) {\n  return {\n    definitions: [getDefinitionForFragmentDefinition(path, text3, definition)],\n    queryRange: definition.name ? [getRange$1(text3, definition.name)] : []\n  };\n}\nfunction getDefinitionForFragmentDefinition(path, text3, definition) {\n  const name2 = definition.name;\n  if (!name2) {\n    throw Error(\"Expected ASTNode to have a Name.\");\n  }\n  return {\n    path,\n    position: getPosition(text3, definition),\n    range: getRange$1(text3, definition),\n    name: name2.value || \"\",\n    language: LANGUAGE,\n    projectRoot: path\n  };\n}\nfunction getDefinitionForNodeDefinition(path, text3, definition) {\n  const name2 = definition.name;\n  assert(name2, \"Expected ASTNode to have a Name.\");\n  return {\n    path,\n    position: getPosition(text3, definition),\n    range: getRange$1(text3, definition),\n    name: name2.value || \"\",\n    language: LANGUAGE,\n    projectRoot: path\n  };\n}\nconst SEVERITY$1 = {\n  Error: \"Error\",\n  Warning: \"Warning\",\n  Information: \"Information\",\n  Hint: \"Hint\"\n};\nconst DIAGNOSTIC_SEVERITY = {\n  [SEVERITY$1.Error]: 1,\n  [SEVERITY$1.Warning]: 2,\n  [SEVERITY$1.Information]: 3,\n  [SEVERITY$1.Hint]: 4\n};\nconst invariant$1 = (condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\nfunction getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n  let ast2 = null;\n  if (externalFragments) {\n    if (typeof externalFragments === \"string\") {\n      query += \"\\n\\n\" + externalFragments;\n    } else {\n      query += \"\\n\\n\" + externalFragments.reduce((agg, node) => {\n        agg += print(node) + \"\\n\\n\";\n        return agg;\n      }, \"\");\n    }\n  }\n  try {\n    ast2 = parse$1(query);\n  } catch (error2) {\n    const range2 = getRange(error2.locations[0], query);\n    return [\n      {\n        severity: DIAGNOSTIC_SEVERITY.Error,\n        message: error2.message,\n        source: \"GraphQL: Syntax\",\n        range: range2\n      }\n    ];\n  }\n  return validateQuery(ast2, schema, customRules, isRelayCompatMode);\n}\nfunction validateQuery(ast2, schema = null, customRules, isRelayCompatMode) {\n  if (!schema) {\n    return [];\n  }\n  const validationErrorAnnotations = mapCat$1(validateWithCustomRules(schema, ast2, customRules, isRelayCompatMode), (error2) => annotations(error2, DIAGNOSTIC_SEVERITY.Error, \"Validation\"));\n  const deprecationWarningAnnotations = mapCat$1(validate(schema, ast2, [NoDeprecatedCustomRule]), (error2) => annotations(error2, DIAGNOSTIC_SEVERITY.Warning, \"Deprecation\"));\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\nfunction mapCat$1(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\nfunction annotations(error2, severity, type2) {\n  if (!error2.nodes) {\n    return [];\n  }\n  const highlightedNodes = [];\n  error2.nodes.forEach((node) => {\n    const highlightNode = node.kind !== \"Variable\" && \"name\" in node && node.name !== void 0 ? node.name : \"variable\" in node && node.variable !== void 0 ? node.variable : node;\n    if (highlightNode) {\n      invariant$1(error2.locations, \"GraphQL validation error requires locations.\");\n      const loc = error2.locations[0];\n      const highlightLoc = getLocation(highlightNode);\n      const end2 = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: `GraphQL: ${type2}`,\n        message: error2.message,\n        severity,\n        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end2))\n      });\n    }\n  });\n  return highlightedNodes;\n}\nfunction getRange(location, queryText) {\n  const parser = onlineParser();\n  const state = parser.startState();\n  const lines = queryText.split(\"\\n\");\n  invariant$1(lines.length >= location.line, \"Query text must have more lines than where the error happened\");\n  let stream = null;\n  for (let i = 0; i < location.line; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      const style = parser.token(stream, state);\n      if (style === \"invalidchar\") {\n        break;\n      }\n    }\n  }\n  invariant$1(stream, \"Expected Parser stream to be available.\");\n  const line = location.line - 1;\n  const start2 = stream.getStartOfToken();\n  const end2 = stream.getCurrentPosition();\n  return new Range(new Position(line, start2), new Position(line, end2));\n}\nfunction getLocation(node) {\n  const typeCastedNode = node;\n  const location = typeCastedNode.loc;\n  invariant$1(location, \"Expected ASTNode to have a location.\");\n  return location;\n}\nconst { INLINE_FRAGMENT } = Kind;\nfunction getOutline(documentText) {\n  let ast2;\n  try {\n    ast2 = parse$1(documentText);\n  } catch (error2) {\n    return null;\n  }\n  const visitorFns = outlineTreeConverter(documentText);\n  const outlineTrees = visit(ast2, {\n    leave(node) {\n      if (visitorFns !== void 0 && node.kind in visitorFns) {\n        return visitorFns[node.kind](node);\n      }\n      return null;\n    }\n  });\n  return { outlineTrees };\n}\nfunction outlineTreeConverter(docText) {\n  const meta = (node) => {\n    return {\n      representativeName: node.name,\n      startPosition: offsetToPosition(docText, node.loc.start),\n      endPosition: offsetToPosition(docText, node.loc.end),\n      kind: node.kind,\n      children: node.selectionSet || node.fields || node.values || node.arguments || []\n    };\n  };\n  return {\n    Field: (node) => {\n      const tokenizedText = node.alias ? [buildToken(\"plain\", node.alias), buildToken(\"plain\", \": \")] : [];\n      tokenizedText.push(buildToken(\"plain\", node.name));\n      return __spreadValues({ tokenizedText }, meta(node));\n    },\n    OperationDefinition: (node) => __spreadValues({\n      tokenizedText: [\n        buildToken(\"keyword\", node.operation),\n        buildToken(\"whitespace\", \" \"),\n        buildToken(\"class-name\", node.name)\n      ]\n    }, meta(node)),\n    Document: (node) => node.definitions,\n    SelectionSet: (node) => concatMap(node.selections, (child) => {\n      return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;\n    }),\n    Name: (node) => node.value,\n    FragmentDefinition: (node) => __spreadValues({\n      tokenizedText: [\n        buildToken(\"keyword\", \"fragment\"),\n        buildToken(\"whitespace\", \" \"),\n        buildToken(\"class-name\", node.name)\n      ]\n    }, meta(node)),\n    InterfaceTypeDefinition: (node) => __spreadValues({\n      tokenizedText: [\n        buildToken(\"keyword\", \"interface\"),\n        buildToken(\"whitespace\", \" \"),\n        buildToken(\"class-name\", node.name)\n      ]\n    }, meta(node)),\n    EnumTypeDefinition: (node) => __spreadValues({\n      tokenizedText: [\n        buildToken(\"keyword\", \"enum\"),\n        buildToken(\"whitespace\", \" \"),\n        buildToken(\"class-name\", node.name)\n      ]\n    }, meta(node)),\n    EnumValueDefinition: (node) => __spreadValues({\n      tokenizedText: [buildToken(\"plain\", node.name)]\n    }, meta(node)),\n    ObjectTypeDefinition: (node) => __spreadValues({\n      tokenizedText: [\n        buildToken(\"keyword\", \"type\"),\n        buildToken(\"whitespace\", \" \"),\n        buildToken(\"class-name\", node.name)\n      ]\n    }, meta(node)),\n    InputObjectTypeDefinition: (node) => __spreadValues({\n      tokenizedText: [\n        buildToken(\"keyword\", \"input\"),\n        buildToken(\"whitespace\", \" \"),\n        buildToken(\"class-name\", node.name)\n      ]\n    }, meta(node)),\n    FragmentSpread: (node) => __spreadValues({\n      tokenizedText: [\n        buildToken(\"plain\", \"...\"),\n        buildToken(\"class-name\", node.name)\n      ]\n    }, meta(node)),\n    InputValueDefinition: (node) => {\n      return __spreadValues({\n        tokenizedText: [buildToken(\"plain\", node.name)]\n      }, meta(node));\n    },\n    FieldDefinition: (node) => {\n      return __spreadValues({\n        tokenizedText: [buildToken(\"plain\", node.name)]\n      }, meta(node));\n    },\n    InlineFragment: (node) => node.selectionSet\n  };\n}\nfunction buildToken(kind2, value) {\n  return { kind: kind2, value };\n}\nfunction concatMap(arr, fn) {\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    const x2 = fn(arr[i], i);\n    if (Array.isArray(x2)) {\n      res.push(...x2);\n    } else {\n      res.push(x2);\n    }\n  }\n  return res;\n}\nfunction getHoverInformation(schema, queryText, cursor, contextToken, config2) {\n  const token2 = contextToken || getTokenAtPosition(queryText, cursor);\n  if (!schema || !token2 || !token2.state) {\n    return \"\";\n  }\n  const state = token2.state;\n  const kind2 = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo$3(schema, token2.state);\n  const options = __spreadProps(__spreadValues({}, config2), { schema });\n  if (kind2 === \"Field\" && step === 0 && typeInfo.fieldDef || kind2 === \"AliasedField\" && step === 2 && typeInfo.fieldDef) {\n    const into = [];\n    renderMdCodeStart(into, options);\n    renderField$1(into, typeInfo, options);\n    renderMdCodeEnd(into, options);\n    renderDescription$1(into, options, typeInfo.fieldDef);\n    return into.join(\"\").trim();\n  } else if (kind2 === \"Directive\" && step === 1 && typeInfo.directiveDef) {\n    const into = [];\n    renderMdCodeStart(into, options);\n    renderDirective$1(into, typeInfo);\n    renderMdCodeEnd(into, options);\n    renderDescription$1(into, options, typeInfo.directiveDef);\n    return into.join(\"\").trim();\n  } else if (kind2 === \"Argument\" && step === 0 && typeInfo.argDef) {\n    const into = [];\n    renderMdCodeStart(into, options);\n    renderArg$1(into, typeInfo, options);\n    renderMdCodeEnd(into, options);\n    renderDescription$1(into, options, typeInfo.argDef);\n    return into.join(\"\").trim();\n  } else if (kind2 === \"EnumValue\" && typeInfo.enumValue && \"description\" in typeInfo.enumValue) {\n    const into = [];\n    renderMdCodeStart(into, options);\n    renderEnumValue$1(into, typeInfo, options);\n    renderMdCodeEnd(into, options);\n    renderDescription$1(into, options, typeInfo.enumValue);\n    return into.join(\"\").trim();\n  } else if (kind2 === \"NamedType\" && typeInfo.type && \"description\" in typeInfo.type) {\n    const into = [];\n    renderMdCodeStart(into, options);\n    renderType$3(into, typeInfo, options, typeInfo.type);\n    renderMdCodeEnd(into, options);\n    renderDescription$1(into, options, typeInfo.type);\n    return into.join(\"\").trim();\n  }\n  return \"\";\n}\nfunction renderMdCodeStart(into, options) {\n  if (options.useMarkdown) {\n    text$2(into, \"```graphql\\n\");\n  }\n}\nfunction renderMdCodeEnd(into, options) {\n  if (options.useMarkdown) {\n    text$2(into, \"\\n```\");\n  }\n}\nfunction renderField$1(into, typeInfo, options) {\n  renderQualifiedField$1(into, typeInfo, options);\n  renderTypeAnnotation$1(into, typeInfo, options, typeInfo.type);\n}\nfunction renderQualifiedField$1(into, typeInfo, options) {\n  if (!typeInfo.fieldDef) {\n    return;\n  }\n  const fieldName = typeInfo.fieldDef.name;\n  if (fieldName.slice(0, 2) !== \"__\") {\n    renderType$3(into, typeInfo, options, typeInfo.parentType);\n    text$2(into, \".\");\n  }\n  text$2(into, fieldName);\n}\nfunction renderDirective$1(into, typeInfo, _options) {\n  if (!typeInfo.directiveDef) {\n    return;\n  }\n  const name2 = \"@\" + typeInfo.directiveDef.name;\n  text$2(into, name2);\n}\nfunction renderArg$1(into, typeInfo, options) {\n  if (typeInfo.directiveDef) {\n    renderDirective$1(into, typeInfo);\n  } else if (typeInfo.fieldDef) {\n    renderQualifiedField$1(into, typeInfo, options);\n  }\n  if (!typeInfo.argDef) {\n    return;\n  }\n  const name2 = typeInfo.argDef.name;\n  text$2(into, \"(\");\n  text$2(into, name2);\n  renderTypeAnnotation$1(into, typeInfo, options, typeInfo.inputType);\n  text$2(into, \")\");\n}\nfunction renderTypeAnnotation$1(into, typeInfo, options, t2) {\n  text$2(into, \": \");\n  renderType$3(into, typeInfo, options, t2);\n}\nfunction renderEnumValue$1(into, typeInfo, options) {\n  if (!typeInfo.enumValue) {\n    return;\n  }\n  const name2 = typeInfo.enumValue.name;\n  renderType$3(into, typeInfo, options, typeInfo.inputType);\n  text$2(into, \".\");\n  text$2(into, name2);\n}\nfunction renderType$3(into, typeInfo, options, t2) {\n  if (!t2) {\n    return;\n  }\n  if (t2 instanceof GraphQLNonNull) {\n    renderType$3(into, typeInfo, options, t2.ofType);\n    text$2(into, \"!\");\n  } else if (t2 instanceof GraphQLList) {\n    text$2(into, \"[\");\n    renderType$3(into, typeInfo, options, t2.ofType);\n    text$2(into, \"]\");\n  } else {\n    text$2(into, t2.name);\n  }\n}\nfunction renderDescription$1(into, options, def) {\n  if (!def) {\n    return;\n  }\n  const description = typeof def.description === \"string\" ? def.description : null;\n  if (description) {\n    text$2(into, \"\\n\\n\");\n    text$2(into, description);\n  }\n  renderDeprecation$1(into, options, def);\n}\nfunction renderDeprecation$1(into, _options, def) {\n  if (!def) {\n    return;\n  }\n  const reason = def.deprecationReason ? def.deprecationReason : null;\n  if (!reason) {\n    return;\n  }\n  text$2(into, \"\\n\\n\");\n  text$2(into, \"Deprecated: \");\n  text$2(into, reason);\n}\nfunction text$2(into, content) {\n  into.push(content);\n}\nconst FileChangeTypeKind = {\n  Created: 1,\n  Changed: 2,\n  Deleted: 3\n};\nvar CompletionItemKind;\n(function(CompletionItemKind2) {\n  CompletionItemKind2.Text = 1;\n  CompletionItemKind2.Method = 2;\n  CompletionItemKind2.Function = 3;\n  CompletionItemKind2.Constructor = 4;\n  CompletionItemKind2.Field = 5;\n  CompletionItemKind2.Variable = 6;\n  CompletionItemKind2.Class = 7;\n  CompletionItemKind2.Interface = 8;\n  CompletionItemKind2.Module = 9;\n  CompletionItemKind2.Property = 10;\n  CompletionItemKind2.Unit = 11;\n  CompletionItemKind2.Value = 12;\n  CompletionItemKind2.Enum = 13;\n  CompletionItemKind2.Keyword = 14;\n  CompletionItemKind2.Snippet = 15;\n  CompletionItemKind2.Color = 16;\n  CompletionItemKind2.File = 17;\n  CompletionItemKind2.Reference = 18;\n  CompletionItemKind2.Folder = 19;\n  CompletionItemKind2.EnumMember = 20;\n  CompletionItemKind2.Constant = 21;\n  CompletionItemKind2.Struct = 22;\n  CompletionItemKind2.Event = 23;\n  CompletionItemKind2.Operator = 24;\n  CompletionItemKind2.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\nvar esm = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  getAutocompleteSuggestions,\n  getDefinitionQueryResultForDefinitionNode,\n  getDefinitionQueryResultForFragmentSpread,\n  getDefinitionQueryResultForNamedType,\n  getDefinitionState,\n  getDiagnostics,\n  getFieldDef: getFieldDef$1,\n  getFragmentDefinitions,\n  getHoverInformation,\n  getOutline,\n  getRange,\n  getTokenAtPosition,\n  getTypeInfo: getTypeInfo$3,\n  getVariableCompletions,\n  SEVERITY: SEVERITY$1,\n  DIAGNOSTIC_SEVERITY,\n  canUseDirective,\n  SuggestionCommand,\n  validateQuery,\n  onlineParser,\n  ParseRules: ParseRules$2,\n  CharacterStream,\n  RuleKinds,\n  LexRules: LexRules$2,\n  isIgnored,\n  p,\n  list: list$1,\n  t,\n  opt,\n  get CompletionItemKind() {\n    return CompletionItemKind;\n  },\n  FileChangeTypeKind,\n  getASTNodeAtPosition,\n  getFragmentDependencies,\n  getFragmentDependenciesForAST,\n  getOperationASTFacts,\n  getOperationFacts,\n  getQueryFacts,\n  getVariablesJSONSchema,\n  offsetToPosition,\n  pointToOffset,\n  Position,\n  collectVariables,\n  validateWithCustomRules,\n  Range\n});\nvar __extends$f = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar ExecuteButton = function(_super2) {\n  __extends$f(ExecuteButton2, _super2);\n  function ExecuteButton2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this._onClick = function() {\n      if (_this.props.isRunning) {\n        _this.props.onStop();\n      } else {\n        _this.props.onRun();\n      }\n    };\n    _this._onOptionSelected = function(operation) {\n      _this.setState({ optionsOpen: false });\n      _this.props.onRun(operation.name && operation.name.value);\n    };\n    _this._onOptionsOpen = function(downEvent) {\n      var initialPress = true;\n      var downTarget = downEvent.currentTarget;\n      _this.setState({ highlight: null, optionsOpen: true });\n      var onMouseUp = function(upEvent) {\n        var _a2;\n        if (initialPress && upEvent.target === downTarget) {\n          initialPress = false;\n        } else {\n          document.removeEventListener(\"mouseup\", onMouseUp);\n          onMouseUp = null;\n          var isOptionsMenuClicked = upEvent.currentTarget && ((_a2 = downTarget.parentNode) === null || _a2 === void 0 ? void 0 : _a2.compareDocumentPosition(upEvent.currentTarget)) && Node.DOCUMENT_POSITION_CONTAINED_BY;\n          if (!isOptionsMenuClicked) {\n            _this.setState({ optionsOpen: false });\n          }\n        }\n      };\n      document.addEventListener(\"mouseup\", onMouseUp);\n    };\n    _this.state = {\n      optionsOpen: false,\n      highlight: null\n    };\n    return _this;\n  }\n  ExecuteButton2.prototype.render = function() {\n    var _this = this;\n    var operations = this.props.operations || [];\n    var optionsOpen = this.state.optionsOpen;\n    var hasOptions = operations && operations.length > 1;\n    var options = null;\n    if (hasOptions && optionsOpen) {\n      var highlight_1 = this.state.highlight;\n      options = React$1.createElement(\"ul\", { className: \"execute-options\" }, operations.map(function(operation, i) {\n        var opName = operation.name ? operation.name.value : \"<Unnamed \" + operation.operation + \">\";\n        return React$1.createElement(\"li\", { key: opName + \"-\" + i, className: operation === highlight_1 ? \"selected\" : void 0, onMouseOver: function() {\n          return _this.setState({ highlight: operation });\n        }, onMouseOut: function() {\n          return _this.setState({ highlight: null });\n        }, onMouseUp: function() {\n          return _this._onOptionSelected(operation);\n        } }, opName);\n      }));\n    }\n    var onClick;\n    if (this.props.isRunning || !hasOptions) {\n      onClick = this._onClick;\n    }\n    var onMouseDown = function() {\n    };\n    if (!this.props.isRunning && hasOptions && !optionsOpen) {\n      onMouseDown = this._onOptionsOpen;\n    }\n    var pathJSX = this.props.isRunning ? React$1.createElement(\"path\", { d: \"M 10 10 L 23 10 L 23 23 L 10 23 z\" }) : React$1.createElement(\"path\", { d: \"M 11 9 L 24 16 L 11 23 z\" });\n    return React$1.createElement(\"div\", { className: \"execute-button-wrap\" }, React$1.createElement(\"button\", { type: \"button\", className: \"execute-button\", onMouseDown, onClick, title: \"Execute Query (Ctrl-Enter)\" }, React$1.createElement(\"svg\", { width: \"34\", height: \"34\" }, pathJSX)), options);\n  };\n  return ExecuteButton2;\n}(React$1.Component);\nvar __extends$e = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nfunction tokenToURL(token2) {\n  if (token2.type !== \"string\") {\n    return;\n  }\n  var value = token2.string.slice(1).slice(0, -1).trim();\n  try {\n    var location_1 = window.location;\n    return new URL(value, location_1.protocol + \"//\" + location_1.host);\n  } catch (err) {\n    return;\n  }\n}\nfunction isImageURL(url) {\n  return /(bmp|gif|jpeg|jpg|png|svg)$/.test(url.pathname);\n}\nvar ImagePreview = function(_super2) {\n  __extends$e(ImagePreview2, _super2);\n  function ImagePreview2() {\n    var _this = _super2 !== null && _super2.apply(this, arguments) || this;\n    _this._node = null;\n    _this.state = {\n      width: null,\n      height: null,\n      src: null,\n      mime: null\n    };\n    return _this;\n  }\n  ImagePreview2.shouldRender = function(token2) {\n    var url = tokenToURL(token2);\n    return url ? isImageURL(url) : false;\n  };\n  ImagePreview2.prototype.componentDidMount = function() {\n    this._updateMetadata();\n  };\n  ImagePreview2.prototype.componentDidUpdate = function() {\n    this._updateMetadata();\n  };\n  ImagePreview2.prototype.render = function() {\n    var _this = this;\n    var _a2;\n    var dims = null;\n    if (this.state.width !== null && this.state.height !== null) {\n      var dimensions = this.state.width + \"x\" + this.state.height;\n      if (this.state.mime !== null) {\n        dimensions += \" \" + this.state.mime;\n      }\n      dims = React$1.createElement(\"div\", null, dimensions);\n    }\n    return React$1.createElement(\"div\", null, React$1.createElement(\"img\", { onLoad: function() {\n      return _this._updateMetadata();\n    }, ref: function(node) {\n      _this._node = node;\n    }, src: (_a2 = tokenToURL(this.props.token)) === null || _a2 === void 0 ? void 0 : _a2.href }), dims);\n  };\n  ImagePreview2.prototype._updateMetadata = function() {\n    var _this = this;\n    if (!this._node) {\n      return;\n    }\n    var width = this._node.naturalWidth;\n    var height = this._node.naturalHeight;\n    var src = this._node.src;\n    if (src !== this.state.src) {\n      this.setState({ src });\n      fetch(src, { method: \"HEAD\" }).then(function(response) {\n        _this.setState({\n          mime: response.headers.get(\"Content-Type\")\n        });\n      });\n    }\n    if (width !== this.state.width || height !== this.state.height) {\n      this.setState({ height, width });\n    }\n  };\n  return ImagePreview2;\n}(React$1.Component);\nvar __extends$d = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar ToolbarButton = function(_super2) {\n  __extends$d(ToolbarButton2, _super2);\n  function ToolbarButton2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.handleClick = function() {\n      try {\n        _this.props.onClick();\n        _this.setState({ error: null });\n      } catch (error2) {\n        _this.setState({ error: error2 });\n      }\n    };\n    _this.state = { error: null };\n    return _this;\n  }\n  ToolbarButton2.prototype.render = function() {\n    var error2 = this.state.error;\n    return React$1.createElement(\"button\", { className: \"toolbar-button\" + (error2 ? \" error\" : \"\"), onClick: this.handleClick, title: error2 ? error2.message : this.props.title, \"aria-invalid\": error2 ? \"true\" : \"false\" }, this.props.label);\n  };\n  return ToolbarButton2;\n}(React$1.Component);\nfunction ToolbarGroup(_a2) {\n  var children = _a2.children;\n  return React$1.createElement(\"div\", { className: \"toolbar-button-group\" }, children);\n}\nvar __extends$c = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar ToolbarMenu = function(_super2) {\n  __extends$c(ToolbarMenu2, _super2);\n  function ToolbarMenu2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this._node = null;\n    _this._listener = null;\n    _this.handleOpen = function(e) {\n      preventDefault$1(e);\n      _this.setState({ visible: true });\n      _this._subscribe();\n    };\n    _this.state = { visible: false };\n    return _this;\n  }\n  ToolbarMenu2.prototype.componentWillUnmount = function() {\n    this._release();\n  };\n  ToolbarMenu2.prototype.render = function() {\n    var _this = this;\n    var visible = this.state.visible;\n    return React$1.createElement(\"a\", { className: \"toolbar-menu toolbar-button\", onClick: this.handleOpen.bind(this), onMouseDown: preventDefault$1, ref: function(node) {\n      if (node) {\n        _this._node = node;\n      }\n    }, title: this.props.title }, this.props.label, React$1.createElement(\"svg\", { width: \"14\", height: \"8\" }, React$1.createElement(\"path\", { fill: \"#666\", d: \"M 5 1.5 L 14 1.5 L 9.5 7 z\" })), React$1.createElement(\"ul\", { className: \"toolbar-menu-items\" + (visible ? \" open\" : \"\") }, this.props.children));\n  };\n  ToolbarMenu2.prototype._subscribe = function() {\n    if (!this._listener) {\n      this._listener = this.handleClick.bind(this);\n      document.addEventListener(\"click\", this._listener);\n    }\n  };\n  ToolbarMenu2.prototype._release = function() {\n    if (this._listener) {\n      document.removeEventListener(\"click\", this._listener);\n      this._listener = null;\n    }\n  };\n  ToolbarMenu2.prototype.handleClick = function(e) {\n    if (this._node !== e.target) {\n      e.preventDefault();\n      this.setState({ visible: false });\n      this._release();\n    }\n  };\n  return ToolbarMenu2;\n}(React$1.Component);\nvar ToolbarMenuItem = function(_a2) {\n  var onSelect = _a2.onSelect, title = _a2.title, label = _a2.label;\n  return React$1.createElement(\"li\", { onMouseOver: function(e) {\n    e.currentTarget.className = \"hover\";\n  }, onMouseOut: function(e) {\n    e.currentTarget.className = \"\";\n  }, onMouseDown: preventDefault$1, onMouseUp: onSelect, title }, label);\n};\nfunction preventDefault$1(e) {\n  e.preventDefault();\n}\nvar utils$1 = {};\nconst Aacute = \"\\xC1\";\nconst aacute = \"\\xE1\";\nconst Abreve = \"\\u0102\";\nconst abreve = \"\\u0103\";\nconst ac = \"\\u223E\";\nconst acd = \"\\u223F\";\nconst acE = \"\\u223E\\u0333\";\nconst Acirc = \"\\xC2\";\nconst acirc = \"\\xE2\";\nconst acute = \"\\xB4\";\nconst Acy = \"\\u0410\";\nconst acy = \"\\u0430\";\nconst AElig = \"\\xC6\";\nconst aelig = \"\\xE6\";\nconst af = \"\\u2061\";\nconst Afr = \"\\u{1D504}\";\nconst afr = \"\\u{1D51E}\";\nconst Agrave = \"\\xC0\";\nconst agrave = \"\\xE0\";\nconst alefsym = \"\\u2135\";\nconst aleph = \"\\u2135\";\nconst Alpha = \"\\u0391\";\nconst alpha = \"\\u03B1\";\nconst Amacr = \"\\u0100\";\nconst amacr = \"\\u0101\";\nconst amalg = \"\\u2A3F\";\nconst amp = \"&\";\nconst AMP = \"&\";\nconst andand = \"\\u2A55\";\nconst And = \"\\u2A53\";\nconst and = \"\\u2227\";\nconst andd = \"\\u2A5C\";\nconst andslope = \"\\u2A58\";\nconst andv = \"\\u2A5A\";\nconst ang = \"\\u2220\";\nconst ange = \"\\u29A4\";\nconst angle = \"\\u2220\";\nconst angmsdaa = \"\\u29A8\";\nconst angmsdab = \"\\u29A9\";\nconst angmsdac = \"\\u29AA\";\nconst angmsdad = \"\\u29AB\";\nconst angmsdae = \"\\u29AC\";\nconst angmsdaf = \"\\u29AD\";\nconst angmsdag = \"\\u29AE\";\nconst angmsdah = \"\\u29AF\";\nconst angmsd = \"\\u2221\";\nconst angrt = \"\\u221F\";\nconst angrtvb = \"\\u22BE\";\nconst angrtvbd = \"\\u299D\";\nconst angsph = \"\\u2222\";\nconst angst = \"\\xC5\";\nconst angzarr = \"\\u237C\";\nconst Aogon = \"\\u0104\";\nconst aogon = \"\\u0105\";\nconst Aopf = \"\\u{1D538}\";\nconst aopf = \"\\u{1D552}\";\nconst apacir = \"\\u2A6F\";\nconst ap = \"\\u2248\";\nconst apE = \"\\u2A70\";\nconst ape = \"\\u224A\";\nconst apid = \"\\u224B\";\nconst apos = \"'\";\nconst ApplyFunction = \"\\u2061\";\nconst approx = \"\\u2248\";\nconst approxeq = \"\\u224A\";\nconst Aring = \"\\xC5\";\nconst aring = \"\\xE5\";\nconst Ascr = \"\\u{1D49C}\";\nconst ascr = \"\\u{1D4B6}\";\nconst Assign = \"\\u2254\";\nconst ast = \"*\";\nconst asymp = \"\\u2248\";\nconst asympeq = \"\\u224D\";\nconst Atilde = \"\\xC3\";\nconst atilde = \"\\xE3\";\nconst Auml = \"\\xC4\";\nconst auml = \"\\xE4\";\nconst awconint = \"\\u2233\";\nconst awint = \"\\u2A11\";\nconst backcong = \"\\u224C\";\nconst backepsilon = \"\\u03F6\";\nconst backprime = \"\\u2035\";\nconst backsim = \"\\u223D\";\nconst backsimeq = \"\\u22CD\";\nconst Backslash = \"\\u2216\";\nconst Barv = \"\\u2AE7\";\nconst barvee = \"\\u22BD\";\nconst barwed = \"\\u2305\";\nconst Barwed = \"\\u2306\";\nconst barwedge = \"\\u2305\";\nconst bbrk = \"\\u23B5\";\nconst bbrktbrk = \"\\u23B6\";\nconst bcong = \"\\u224C\";\nconst Bcy = \"\\u0411\";\nconst bcy = \"\\u0431\";\nconst bdquo = \"\\u201E\";\nconst becaus = \"\\u2235\";\nconst because = \"\\u2235\";\nconst Because = \"\\u2235\";\nconst bemptyv = \"\\u29B0\";\nconst bepsi = \"\\u03F6\";\nconst bernou = \"\\u212C\";\nconst Bernoullis = \"\\u212C\";\nconst Beta = \"\\u0392\";\nconst beta = \"\\u03B2\";\nconst beth = \"\\u2136\";\nconst between = \"\\u226C\";\nconst Bfr = \"\\u{1D505}\";\nconst bfr = \"\\u{1D51F}\";\nconst bigcap = \"\\u22C2\";\nconst bigcirc = \"\\u25EF\";\nconst bigcup = \"\\u22C3\";\nconst bigodot = \"\\u2A00\";\nconst bigoplus = \"\\u2A01\";\nconst bigotimes = \"\\u2A02\";\nconst bigsqcup = \"\\u2A06\";\nconst bigstar = \"\\u2605\";\nconst bigtriangledown = \"\\u25BD\";\nconst bigtriangleup = \"\\u25B3\";\nconst biguplus = \"\\u2A04\";\nconst bigvee = \"\\u22C1\";\nconst bigwedge = \"\\u22C0\";\nconst bkarow = \"\\u290D\";\nconst blacklozenge = \"\\u29EB\";\nconst blacksquare = \"\\u25AA\";\nconst blacktriangle = \"\\u25B4\";\nconst blacktriangledown = \"\\u25BE\";\nconst blacktriangleleft = \"\\u25C2\";\nconst blacktriangleright = \"\\u25B8\";\nconst blank = \"\\u2423\";\nconst blk12 = \"\\u2592\";\nconst blk14 = \"\\u2591\";\nconst blk34 = \"\\u2593\";\nconst block$2 = \"\\u2588\";\nconst bne = \"=\\u20E5\";\nconst bnequiv = \"\\u2261\\u20E5\";\nconst bNot = \"\\u2AED\";\nconst bnot = \"\\u2310\";\nconst Bopf = \"\\u{1D539}\";\nconst bopf = \"\\u{1D553}\";\nconst bot = \"\\u22A5\";\nconst bottom = \"\\u22A5\";\nconst bowtie = \"\\u22C8\";\nconst boxbox = \"\\u29C9\";\nconst boxdl = \"\\u2510\";\nconst boxdL = \"\\u2555\";\nconst boxDl = \"\\u2556\";\nconst boxDL = \"\\u2557\";\nconst boxdr = \"\\u250C\";\nconst boxdR = \"\\u2552\";\nconst boxDr = \"\\u2553\";\nconst boxDR = \"\\u2554\";\nconst boxh = \"\\u2500\";\nconst boxH = \"\\u2550\";\nconst boxhd = \"\\u252C\";\nconst boxHd = \"\\u2564\";\nconst boxhD = \"\\u2565\";\nconst boxHD = \"\\u2566\";\nconst boxhu = \"\\u2534\";\nconst boxHu = \"\\u2567\";\nconst boxhU = \"\\u2568\";\nconst boxHU = \"\\u2569\";\nconst boxminus = \"\\u229F\";\nconst boxplus = \"\\u229E\";\nconst boxtimes = \"\\u22A0\";\nconst boxul = \"\\u2518\";\nconst boxuL = \"\\u255B\";\nconst boxUl = \"\\u255C\";\nconst boxUL = \"\\u255D\";\nconst boxur = \"\\u2514\";\nconst boxuR = \"\\u2558\";\nconst boxUr = \"\\u2559\";\nconst boxUR = \"\\u255A\";\nconst boxv = \"\\u2502\";\nconst boxV = \"\\u2551\";\nconst boxvh = \"\\u253C\";\nconst boxvH = \"\\u256A\";\nconst boxVh = \"\\u256B\";\nconst boxVH = \"\\u256C\";\nconst boxvl = \"\\u2524\";\nconst boxvL = \"\\u2561\";\nconst boxVl = \"\\u2562\";\nconst boxVL = \"\\u2563\";\nconst boxvr = \"\\u251C\";\nconst boxvR = \"\\u255E\";\nconst boxVr = \"\\u255F\";\nconst boxVR = \"\\u2560\";\nconst bprime = \"\\u2035\";\nconst breve = \"\\u02D8\";\nconst Breve = \"\\u02D8\";\nconst brvbar = \"\\xA6\";\nconst bscr = \"\\u{1D4B7}\";\nconst Bscr = \"\\u212C\";\nconst bsemi = \"\\u204F\";\nconst bsim = \"\\u223D\";\nconst bsime = \"\\u22CD\";\nconst bsolb = \"\\u29C5\";\nconst bsol = \"\\\\\";\nconst bsolhsub = \"\\u27C8\";\nconst bull = \"\\u2022\";\nconst bullet = \"\\u2022\";\nconst bump = \"\\u224E\";\nconst bumpE = \"\\u2AAE\";\nconst bumpe = \"\\u224F\";\nconst Bumpeq = \"\\u224E\";\nconst bumpeq = \"\\u224F\";\nconst Cacute = \"\\u0106\";\nconst cacute = \"\\u0107\";\nconst capand = \"\\u2A44\";\nconst capbrcup = \"\\u2A49\";\nconst capcap = \"\\u2A4B\";\nconst cap = \"\\u2229\";\nconst Cap = \"\\u22D2\";\nconst capcup = \"\\u2A47\";\nconst capdot = \"\\u2A40\";\nconst CapitalDifferentialD = \"\\u2145\";\nconst caps = \"\\u2229\\uFE00\";\nconst caret = \"\\u2041\";\nconst caron = \"\\u02C7\";\nconst Cayleys = \"\\u212D\";\nconst ccaps = \"\\u2A4D\";\nconst Ccaron = \"\\u010C\";\nconst ccaron = \"\\u010D\";\nconst Ccedil = \"\\xC7\";\nconst ccedil = \"\\xE7\";\nconst Ccirc = \"\\u0108\";\nconst ccirc = \"\\u0109\";\nconst Cconint = \"\\u2230\";\nconst ccups = \"\\u2A4C\";\nconst ccupssm = \"\\u2A50\";\nconst Cdot = \"\\u010A\";\nconst cdot = \"\\u010B\";\nconst cedil = \"\\xB8\";\nconst Cedilla = \"\\xB8\";\nconst cemptyv = \"\\u29B2\";\nconst cent = \"\\xA2\";\nconst centerdot = \"\\xB7\";\nconst CenterDot = \"\\xB7\";\nconst cfr = \"\\u{1D520}\";\nconst Cfr = \"\\u212D\";\nconst CHcy = \"\\u0427\";\nconst chcy = \"\\u0447\";\nconst check = \"\\u2713\";\nconst checkmark = \"\\u2713\";\nconst Chi = \"\\u03A7\";\nconst chi = \"\\u03C7\";\nconst circ = \"\\u02C6\";\nconst circeq = \"\\u2257\";\nconst circlearrowleft = \"\\u21BA\";\nconst circlearrowright = \"\\u21BB\";\nconst circledast = \"\\u229B\";\nconst circledcirc = \"\\u229A\";\nconst circleddash = \"\\u229D\";\nconst CircleDot = \"\\u2299\";\nconst circledR = \"\\xAE\";\nconst circledS = \"\\u24C8\";\nconst CircleMinus = \"\\u2296\";\nconst CirclePlus = \"\\u2295\";\nconst CircleTimes = \"\\u2297\";\nconst cir = \"\\u25CB\";\nconst cirE = \"\\u29C3\";\nconst cire = \"\\u2257\";\nconst cirfnint = \"\\u2A10\";\nconst cirmid = \"\\u2AEF\";\nconst cirscir = \"\\u29C2\";\nconst ClockwiseContourIntegral = \"\\u2232\";\nconst CloseCurlyDoubleQuote = \"\\u201D\";\nconst CloseCurlyQuote = \"\\u2019\";\nconst clubs = \"\\u2663\";\nconst clubsuit = \"\\u2663\";\nconst colon = \":\";\nconst Colon = \"\\u2237\";\nconst Colone = \"\\u2A74\";\nconst colone = \"\\u2254\";\nconst coloneq = \"\\u2254\";\nconst comma = \",\";\nconst commat = \"@\";\nconst comp = \"\\u2201\";\nconst compfn = \"\\u2218\";\nconst complement = \"\\u2201\";\nconst complexes = \"\\u2102\";\nconst cong = \"\\u2245\";\nconst congdot = \"\\u2A6D\";\nconst Congruent = \"\\u2261\";\nconst conint = \"\\u222E\";\nconst Conint = \"\\u222F\";\nconst ContourIntegral = \"\\u222E\";\nconst copf = \"\\u{1D554}\";\nconst Copf = \"\\u2102\";\nconst coprod = \"\\u2210\";\nconst Coproduct = \"\\u2210\";\nconst copy = \"\\xA9\";\nconst COPY = \"\\xA9\";\nconst copysr = \"\\u2117\";\nconst CounterClockwiseContourIntegral = \"\\u2233\";\nconst crarr = \"\\u21B5\";\nconst cross = \"\\u2717\";\nconst Cross = \"\\u2A2F\";\nconst Cscr = \"\\u{1D49E}\";\nconst cscr = \"\\u{1D4B8}\";\nconst csub = \"\\u2ACF\";\nconst csube = \"\\u2AD1\";\nconst csup = \"\\u2AD0\";\nconst csupe = \"\\u2AD2\";\nconst ctdot = \"\\u22EF\";\nconst cudarrl = \"\\u2938\";\nconst cudarrr = \"\\u2935\";\nconst cuepr = \"\\u22DE\";\nconst cuesc = \"\\u22DF\";\nconst cularr = \"\\u21B6\";\nconst cularrp = \"\\u293D\";\nconst cupbrcap = \"\\u2A48\";\nconst cupcap = \"\\u2A46\";\nconst CupCap = \"\\u224D\";\nconst cup = \"\\u222A\";\nconst Cup = \"\\u22D3\";\nconst cupcup = \"\\u2A4A\";\nconst cupdot = \"\\u228D\";\nconst cupor = \"\\u2A45\";\nconst cups = \"\\u222A\\uFE00\";\nconst curarr = \"\\u21B7\";\nconst curarrm = \"\\u293C\";\nconst curlyeqprec = \"\\u22DE\";\nconst curlyeqsucc = \"\\u22DF\";\nconst curlyvee = \"\\u22CE\";\nconst curlywedge = \"\\u22CF\";\nconst curren = \"\\xA4\";\nconst curvearrowleft = \"\\u21B6\";\nconst curvearrowright = \"\\u21B7\";\nconst cuvee = \"\\u22CE\";\nconst cuwed = \"\\u22CF\";\nconst cwconint = \"\\u2232\";\nconst cwint = \"\\u2231\";\nconst cylcty = \"\\u232D\";\nconst dagger = \"\\u2020\";\nconst Dagger = \"\\u2021\";\nconst daleth = \"\\u2138\";\nconst darr = \"\\u2193\";\nconst Darr = \"\\u21A1\";\nconst dArr = \"\\u21D3\";\nconst dash = \"\\u2010\";\nconst Dashv = \"\\u2AE4\";\nconst dashv = \"\\u22A3\";\nconst dbkarow = \"\\u290F\";\nconst dblac = \"\\u02DD\";\nconst Dcaron = \"\\u010E\";\nconst dcaron = \"\\u010F\";\nconst Dcy = \"\\u0414\";\nconst dcy = \"\\u0434\";\nconst ddagger = \"\\u2021\";\nconst ddarr = \"\\u21CA\";\nconst DD = \"\\u2145\";\nconst dd = \"\\u2146\";\nconst DDotrahd = \"\\u2911\";\nconst ddotseq = \"\\u2A77\";\nconst deg = \"\\xB0\";\nconst Del = \"\\u2207\";\nconst Delta = \"\\u0394\";\nconst delta = \"\\u03B4\";\nconst demptyv = \"\\u29B1\";\nconst dfisht = \"\\u297F\";\nconst Dfr = \"\\u{1D507}\";\nconst dfr = \"\\u{1D521}\";\nconst dHar = \"\\u2965\";\nconst dharl = \"\\u21C3\";\nconst dharr = \"\\u21C2\";\nconst DiacriticalAcute = \"\\xB4\";\nconst DiacriticalDot = \"\\u02D9\";\nconst DiacriticalDoubleAcute = \"\\u02DD\";\nconst DiacriticalGrave = \"`\";\nconst DiacriticalTilde = \"\\u02DC\";\nconst diam = \"\\u22C4\";\nconst diamond = \"\\u22C4\";\nconst Diamond = \"\\u22C4\";\nconst diamondsuit = \"\\u2666\";\nconst diams = \"\\u2666\";\nconst die = \"\\xA8\";\nconst DifferentialD = \"\\u2146\";\nconst digamma = \"\\u03DD\";\nconst disin = \"\\u22F2\";\nconst div = \"\\xF7\";\nconst divide = \"\\xF7\";\nconst divideontimes = \"\\u22C7\";\nconst divonx = \"\\u22C7\";\nconst DJcy = \"\\u0402\";\nconst djcy = \"\\u0452\";\nconst dlcorn = \"\\u231E\";\nconst dlcrop = \"\\u230D\";\nconst dollar = \"$\";\nconst Dopf = \"\\u{1D53B}\";\nconst dopf = \"\\u{1D555}\";\nconst Dot = \"\\xA8\";\nconst dot = \"\\u02D9\";\nconst DotDot = \"\\u20DC\";\nconst doteq = \"\\u2250\";\nconst doteqdot = \"\\u2251\";\nconst DotEqual = \"\\u2250\";\nconst dotminus = \"\\u2238\";\nconst dotplus = \"\\u2214\";\nconst dotsquare = \"\\u22A1\";\nconst doublebarwedge = \"\\u2306\";\nconst DoubleContourIntegral = \"\\u222F\";\nconst DoubleDot = \"\\xA8\";\nconst DoubleDownArrow = \"\\u21D3\";\nconst DoubleLeftArrow = \"\\u21D0\";\nconst DoubleLeftRightArrow = \"\\u21D4\";\nconst DoubleLeftTee = \"\\u2AE4\";\nconst DoubleLongLeftArrow = \"\\u27F8\";\nconst DoubleLongLeftRightArrow = \"\\u27FA\";\nconst DoubleLongRightArrow = \"\\u27F9\";\nconst DoubleRightArrow = \"\\u21D2\";\nconst DoubleRightTee = \"\\u22A8\";\nconst DoubleUpArrow = \"\\u21D1\";\nconst DoubleUpDownArrow = \"\\u21D5\";\nconst DoubleVerticalBar = \"\\u2225\";\nconst DownArrowBar = \"\\u2913\";\nconst downarrow = \"\\u2193\";\nconst DownArrow = \"\\u2193\";\nconst Downarrow = \"\\u21D3\";\nconst DownArrowUpArrow = \"\\u21F5\";\nconst DownBreve = \"\\u0311\";\nconst downdownarrows = \"\\u21CA\";\nconst downharpoonleft = \"\\u21C3\";\nconst downharpoonright = \"\\u21C2\";\nconst DownLeftRightVector = \"\\u2950\";\nconst DownLeftTeeVector = \"\\u295E\";\nconst DownLeftVectorBar = \"\\u2956\";\nconst DownLeftVector = \"\\u21BD\";\nconst DownRightTeeVector = \"\\u295F\";\nconst DownRightVectorBar = \"\\u2957\";\nconst DownRightVector = \"\\u21C1\";\nconst DownTeeArrow = \"\\u21A7\";\nconst DownTee = \"\\u22A4\";\nconst drbkarow = \"\\u2910\";\nconst drcorn = \"\\u231F\";\nconst drcrop = \"\\u230C\";\nconst Dscr = \"\\u{1D49F}\";\nconst dscr = \"\\u{1D4B9}\";\nconst DScy = \"\\u0405\";\nconst dscy = \"\\u0455\";\nconst dsol = \"\\u29F6\";\nconst Dstrok = \"\\u0110\";\nconst dstrok = \"\\u0111\";\nconst dtdot = \"\\u22F1\";\nconst dtri = \"\\u25BF\";\nconst dtrif = \"\\u25BE\";\nconst duarr = \"\\u21F5\";\nconst duhar = \"\\u296F\";\nconst dwangle = \"\\u29A6\";\nconst DZcy = \"\\u040F\";\nconst dzcy = \"\\u045F\";\nconst dzigrarr = \"\\u27FF\";\nconst Eacute = \"\\xC9\";\nconst eacute = \"\\xE9\";\nconst easter = \"\\u2A6E\";\nconst Ecaron = \"\\u011A\";\nconst ecaron = \"\\u011B\";\nconst Ecirc = \"\\xCA\";\nconst ecirc = \"\\xEA\";\nconst ecir = \"\\u2256\";\nconst ecolon = \"\\u2255\";\nconst Ecy = \"\\u042D\";\nconst ecy = \"\\u044D\";\nconst eDDot = \"\\u2A77\";\nconst Edot = \"\\u0116\";\nconst edot = \"\\u0117\";\nconst eDot = \"\\u2251\";\nconst ee = \"\\u2147\";\nconst efDot = \"\\u2252\";\nconst Efr = \"\\u{1D508}\";\nconst efr = \"\\u{1D522}\";\nconst eg = \"\\u2A9A\";\nconst Egrave = \"\\xC8\";\nconst egrave = \"\\xE8\";\nconst egs = \"\\u2A96\";\nconst egsdot = \"\\u2A98\";\nconst el = \"\\u2A99\";\nconst Element = \"\\u2208\";\nconst elinters = \"\\u23E7\";\nconst ell = \"\\u2113\";\nconst els = \"\\u2A95\";\nconst elsdot = \"\\u2A97\";\nconst Emacr = \"\\u0112\";\nconst emacr = \"\\u0113\";\nconst empty = \"\\u2205\";\nconst emptyset = \"\\u2205\";\nconst EmptySmallSquare = \"\\u25FB\";\nconst emptyv = \"\\u2205\";\nconst EmptyVerySmallSquare = \"\\u25AB\";\nconst emsp13 = \"\\u2004\";\nconst emsp14 = \"\\u2005\";\nconst emsp = \"\\u2003\";\nconst ENG = \"\\u014A\";\nconst eng = \"\\u014B\";\nconst ensp = \"\\u2002\";\nconst Eogon = \"\\u0118\";\nconst eogon = \"\\u0119\";\nconst Eopf = \"\\u{1D53C}\";\nconst eopf = \"\\u{1D556}\";\nconst epar = \"\\u22D5\";\nconst eparsl = \"\\u29E3\";\nconst eplus = \"\\u2A71\";\nconst epsi = \"\\u03B5\";\nconst Epsilon = \"\\u0395\";\nconst epsilon = \"\\u03B5\";\nconst epsiv = \"\\u03F5\";\nconst eqcirc = \"\\u2256\";\nconst eqcolon = \"\\u2255\";\nconst eqsim = \"\\u2242\";\nconst eqslantgtr = \"\\u2A96\";\nconst eqslantless = \"\\u2A95\";\nconst Equal = \"\\u2A75\";\nconst equals = \"=\";\nconst EqualTilde = \"\\u2242\";\nconst equest = \"\\u225F\";\nconst Equilibrium = \"\\u21CC\";\nconst equiv = \"\\u2261\";\nconst equivDD = \"\\u2A78\";\nconst eqvparsl = \"\\u29E5\";\nconst erarr = \"\\u2971\";\nconst erDot = \"\\u2253\";\nconst escr = \"\\u212F\";\nconst Escr = \"\\u2130\";\nconst esdot = \"\\u2250\";\nconst Esim = \"\\u2A73\";\nconst esim = \"\\u2242\";\nconst Eta = \"\\u0397\";\nconst eta = \"\\u03B7\";\nconst ETH = \"\\xD0\";\nconst eth = \"\\xF0\";\nconst Euml = \"\\xCB\";\nconst euml = \"\\xEB\";\nconst euro = \"\\u20AC\";\nconst excl = \"!\";\nconst exist = \"\\u2203\";\nconst Exists = \"\\u2203\";\nconst expectation = \"\\u2130\";\nconst exponentiale = \"\\u2147\";\nconst ExponentialE = \"\\u2147\";\nconst fallingdotseq = \"\\u2252\";\nconst Fcy = \"\\u0424\";\nconst fcy = \"\\u0444\";\nconst female = \"\\u2640\";\nconst ffilig = \"\\uFB03\";\nconst fflig = \"\\uFB00\";\nconst ffllig = \"\\uFB04\";\nconst Ffr = \"\\u{1D509}\";\nconst ffr = \"\\u{1D523}\";\nconst filig = \"\\uFB01\";\nconst FilledSmallSquare = \"\\u25FC\";\nconst FilledVerySmallSquare = \"\\u25AA\";\nconst fjlig = \"fj\";\nconst flat = \"\\u266D\";\nconst fllig = \"\\uFB02\";\nconst fltns = \"\\u25B1\";\nconst fnof = \"\\u0192\";\nconst Fopf = \"\\u{1D53D}\";\nconst fopf = \"\\u{1D557}\";\nconst forall = \"\\u2200\";\nconst ForAll = \"\\u2200\";\nconst fork = \"\\u22D4\";\nconst forkv = \"\\u2AD9\";\nconst Fouriertrf = \"\\u2131\";\nconst fpartint = \"\\u2A0D\";\nconst frac12 = \"\\xBD\";\nconst frac13 = \"\\u2153\";\nconst frac14 = \"\\xBC\";\nconst frac15 = \"\\u2155\";\nconst frac16 = \"\\u2159\";\nconst frac18 = \"\\u215B\";\nconst frac23 = \"\\u2154\";\nconst frac25 = \"\\u2156\";\nconst frac34 = \"\\xBE\";\nconst frac35 = \"\\u2157\";\nconst frac38 = \"\\u215C\";\nconst frac45 = \"\\u2158\";\nconst frac56 = \"\\u215A\";\nconst frac58 = \"\\u215D\";\nconst frac78 = \"\\u215E\";\nconst frasl = \"\\u2044\";\nconst frown = \"\\u2322\";\nconst fscr = \"\\u{1D4BB}\";\nconst Fscr = \"\\u2131\";\nconst gacute = \"\\u01F5\";\nconst Gamma = \"\\u0393\";\nconst gamma = \"\\u03B3\";\nconst Gammad = \"\\u03DC\";\nconst gammad = \"\\u03DD\";\nconst gap = \"\\u2A86\";\nconst Gbreve = \"\\u011E\";\nconst gbreve = \"\\u011F\";\nconst Gcedil = \"\\u0122\";\nconst Gcirc = \"\\u011C\";\nconst gcirc = \"\\u011D\";\nconst Gcy = \"\\u0413\";\nconst gcy = \"\\u0433\";\nconst Gdot = \"\\u0120\";\nconst gdot = \"\\u0121\";\nconst ge = \"\\u2265\";\nconst gE = \"\\u2267\";\nconst gEl = \"\\u2A8C\";\nconst gel = \"\\u22DB\";\nconst geq = \"\\u2265\";\nconst geqq = \"\\u2267\";\nconst geqslant = \"\\u2A7E\";\nconst gescc = \"\\u2AA9\";\nconst ges = \"\\u2A7E\";\nconst gesdot = \"\\u2A80\";\nconst gesdoto = \"\\u2A82\";\nconst gesdotol = \"\\u2A84\";\nconst gesl = \"\\u22DB\\uFE00\";\nconst gesles = \"\\u2A94\";\nconst Gfr = \"\\u{1D50A}\";\nconst gfr = \"\\u{1D524}\";\nconst gg = \"\\u226B\";\nconst Gg = \"\\u22D9\";\nconst ggg = \"\\u22D9\";\nconst gimel = \"\\u2137\";\nconst GJcy = \"\\u0403\";\nconst gjcy = \"\\u0453\";\nconst gla = \"\\u2AA5\";\nconst gl = \"\\u2277\";\nconst glE = \"\\u2A92\";\nconst glj = \"\\u2AA4\";\nconst gnap = \"\\u2A8A\";\nconst gnapprox = \"\\u2A8A\";\nconst gne = \"\\u2A88\";\nconst gnE = \"\\u2269\";\nconst gneq = \"\\u2A88\";\nconst gneqq = \"\\u2269\";\nconst gnsim = \"\\u22E7\";\nconst Gopf = \"\\u{1D53E}\";\nconst gopf = \"\\u{1D558}\";\nconst grave = \"`\";\nconst GreaterEqual = \"\\u2265\";\nconst GreaterEqualLess = \"\\u22DB\";\nconst GreaterFullEqual = \"\\u2267\";\nconst GreaterGreater = \"\\u2AA2\";\nconst GreaterLess = \"\\u2277\";\nconst GreaterSlantEqual = \"\\u2A7E\";\nconst GreaterTilde = \"\\u2273\";\nconst Gscr = \"\\u{1D4A2}\";\nconst gscr = \"\\u210A\";\nconst gsim = \"\\u2273\";\nconst gsime = \"\\u2A8E\";\nconst gsiml = \"\\u2A90\";\nconst gtcc = \"\\u2AA7\";\nconst gtcir = \"\\u2A7A\";\nconst gt = \">\";\nconst GT = \">\";\nconst Gt = \"\\u226B\";\nconst gtdot = \"\\u22D7\";\nconst gtlPar = \"\\u2995\";\nconst gtquest = \"\\u2A7C\";\nconst gtrapprox = \"\\u2A86\";\nconst gtrarr = \"\\u2978\";\nconst gtrdot = \"\\u22D7\";\nconst gtreqless = \"\\u22DB\";\nconst gtreqqless = \"\\u2A8C\";\nconst gtrless = \"\\u2277\";\nconst gtrsim = \"\\u2273\";\nconst gvertneqq = \"\\u2269\\uFE00\";\nconst gvnE = \"\\u2269\\uFE00\";\nconst Hacek = \"\\u02C7\";\nconst hairsp = \"\\u200A\";\nconst half = \"\\xBD\";\nconst hamilt = \"\\u210B\";\nconst HARDcy = \"\\u042A\";\nconst hardcy = \"\\u044A\";\nconst harrcir = \"\\u2948\";\nconst harr = \"\\u2194\";\nconst hArr = \"\\u21D4\";\nconst harrw = \"\\u21AD\";\nconst Hat = \"^\";\nconst hbar = \"\\u210F\";\nconst Hcirc = \"\\u0124\";\nconst hcirc = \"\\u0125\";\nconst hearts = \"\\u2665\";\nconst heartsuit = \"\\u2665\";\nconst hellip = \"\\u2026\";\nconst hercon = \"\\u22B9\";\nconst hfr = \"\\u{1D525}\";\nconst Hfr = \"\\u210C\";\nconst HilbertSpace = \"\\u210B\";\nconst hksearow = \"\\u2925\";\nconst hkswarow = \"\\u2926\";\nconst hoarr = \"\\u21FF\";\nconst homtht = \"\\u223B\";\nconst hookleftarrow = \"\\u21A9\";\nconst hookrightarrow = \"\\u21AA\";\nconst hopf = \"\\u{1D559}\";\nconst Hopf = \"\\u210D\";\nconst horbar = \"\\u2015\";\nconst HorizontalLine = \"\\u2500\";\nconst hscr = \"\\u{1D4BD}\";\nconst Hscr = \"\\u210B\";\nconst hslash = \"\\u210F\";\nconst Hstrok = \"\\u0126\";\nconst hstrok = \"\\u0127\";\nconst HumpDownHump = \"\\u224E\";\nconst HumpEqual = \"\\u224F\";\nconst hybull = \"\\u2043\";\nconst hyphen = \"\\u2010\";\nconst Iacute = \"\\xCD\";\nconst iacute = \"\\xED\";\nconst ic = \"\\u2063\";\nconst Icirc = \"\\xCE\";\nconst icirc = \"\\xEE\";\nconst Icy = \"\\u0418\";\nconst icy = \"\\u0438\";\nconst Idot = \"\\u0130\";\nconst IEcy = \"\\u0415\";\nconst iecy = \"\\u0435\";\nconst iexcl = \"\\xA1\";\nconst iff = \"\\u21D4\";\nconst ifr = \"\\u{1D526}\";\nconst Ifr = \"\\u2111\";\nconst Igrave = \"\\xCC\";\nconst igrave = \"\\xEC\";\nconst ii = \"\\u2148\";\nconst iiiint = \"\\u2A0C\";\nconst iiint = \"\\u222D\";\nconst iinfin = \"\\u29DC\";\nconst iiota = \"\\u2129\";\nconst IJlig = \"\\u0132\";\nconst ijlig = \"\\u0133\";\nconst Imacr = \"\\u012A\";\nconst imacr = \"\\u012B\";\nconst image$1 = \"\\u2111\";\nconst ImaginaryI = \"\\u2148\";\nconst imagline = \"\\u2110\";\nconst imagpart = \"\\u2111\";\nconst imath = \"\\u0131\";\nconst Im = \"\\u2111\";\nconst imof = \"\\u22B7\";\nconst imped = \"\\u01B5\";\nconst Implies = \"\\u21D2\";\nconst incare = \"\\u2105\";\nconst infin = \"\\u221E\";\nconst infintie = \"\\u29DD\";\nconst inodot = \"\\u0131\";\nconst intcal = \"\\u22BA\";\nconst int = \"\\u222B\";\nconst Int = \"\\u222C\";\nconst integers = \"\\u2124\";\nconst Integral = \"\\u222B\";\nconst intercal = \"\\u22BA\";\nconst Intersection = \"\\u22C2\";\nconst intlarhk = \"\\u2A17\";\nconst intprod = \"\\u2A3C\";\nconst InvisibleComma = \"\\u2063\";\nconst InvisibleTimes = \"\\u2062\";\nconst IOcy = \"\\u0401\";\nconst iocy = \"\\u0451\";\nconst Iogon = \"\\u012E\";\nconst iogon = \"\\u012F\";\nconst Iopf = \"\\u{1D540}\";\nconst iopf = \"\\u{1D55A}\";\nconst Iota = \"\\u0399\";\nconst iota = \"\\u03B9\";\nconst iprod = \"\\u2A3C\";\nconst iquest = \"\\xBF\";\nconst iscr = \"\\u{1D4BE}\";\nconst Iscr = \"\\u2110\";\nconst isin = \"\\u2208\";\nconst isindot = \"\\u22F5\";\nconst isinE = \"\\u22F9\";\nconst isins = \"\\u22F4\";\nconst isinsv = \"\\u22F3\";\nconst isinv = \"\\u2208\";\nconst it = \"\\u2062\";\nconst Itilde = \"\\u0128\";\nconst itilde = \"\\u0129\";\nconst Iukcy = \"\\u0406\";\nconst iukcy = \"\\u0456\";\nconst Iuml = \"\\xCF\";\nconst iuml = \"\\xEF\";\nconst Jcirc = \"\\u0134\";\nconst jcirc = \"\\u0135\";\nconst Jcy = \"\\u0419\";\nconst jcy = \"\\u0439\";\nconst Jfr = \"\\u{1D50D}\";\nconst jfr = \"\\u{1D527}\";\nconst jmath = \"\\u0237\";\nconst Jopf = \"\\u{1D541}\";\nconst jopf = \"\\u{1D55B}\";\nconst Jscr = \"\\u{1D4A5}\";\nconst jscr = \"\\u{1D4BF}\";\nconst Jsercy = \"\\u0408\";\nconst jsercy = \"\\u0458\";\nconst Jukcy = \"\\u0404\";\nconst jukcy = \"\\u0454\";\nconst Kappa = \"\\u039A\";\nconst kappa = \"\\u03BA\";\nconst kappav = \"\\u03F0\";\nconst Kcedil = \"\\u0136\";\nconst kcedil = \"\\u0137\";\nconst Kcy = \"\\u041A\";\nconst kcy = \"\\u043A\";\nconst Kfr = \"\\u{1D50E}\";\nconst kfr = \"\\u{1D528}\";\nconst kgreen = \"\\u0138\";\nconst KHcy = \"\\u0425\";\nconst khcy = \"\\u0445\";\nconst KJcy = \"\\u040C\";\nconst kjcy = \"\\u045C\";\nconst Kopf = \"\\u{1D542}\";\nconst kopf = \"\\u{1D55C}\";\nconst Kscr = \"\\u{1D4A6}\";\nconst kscr = \"\\u{1D4C0}\";\nconst lAarr = \"\\u21DA\";\nconst Lacute = \"\\u0139\";\nconst lacute = \"\\u013A\";\nconst laemptyv = \"\\u29B4\";\nconst lagran = \"\\u2112\";\nconst Lambda = \"\\u039B\";\nconst lambda = \"\\u03BB\";\nconst lang = \"\\u27E8\";\nconst Lang = \"\\u27EA\";\nconst langd = \"\\u2991\";\nconst langle = \"\\u27E8\";\nconst lap = \"\\u2A85\";\nconst Laplacetrf = \"\\u2112\";\nconst laquo = \"\\xAB\";\nconst larrb = \"\\u21E4\";\nconst larrbfs = \"\\u291F\";\nconst larr = \"\\u2190\";\nconst Larr = \"\\u219E\";\nconst lArr = \"\\u21D0\";\nconst larrfs = \"\\u291D\";\nconst larrhk = \"\\u21A9\";\nconst larrlp = \"\\u21AB\";\nconst larrpl = \"\\u2939\";\nconst larrsim = \"\\u2973\";\nconst larrtl = \"\\u21A2\";\nconst latail = \"\\u2919\";\nconst lAtail = \"\\u291B\";\nconst lat = \"\\u2AAB\";\nconst late = \"\\u2AAD\";\nconst lates = \"\\u2AAD\\uFE00\";\nconst lbarr = \"\\u290C\";\nconst lBarr = \"\\u290E\";\nconst lbbrk = \"\\u2772\";\nconst lbrace = \"{\";\nconst lbrack = \"[\";\nconst lbrke = \"\\u298B\";\nconst lbrksld = \"\\u298F\";\nconst lbrkslu = \"\\u298D\";\nconst Lcaron = \"\\u013D\";\nconst lcaron = \"\\u013E\";\nconst Lcedil = \"\\u013B\";\nconst lcedil = \"\\u013C\";\nconst lceil = \"\\u2308\";\nconst lcub = \"{\";\nconst Lcy = \"\\u041B\";\nconst lcy = \"\\u043B\";\nconst ldca = \"\\u2936\";\nconst ldquo = \"\\u201C\";\nconst ldquor = \"\\u201E\";\nconst ldrdhar = \"\\u2967\";\nconst ldrushar = \"\\u294B\";\nconst ldsh = \"\\u21B2\";\nconst le = \"\\u2264\";\nconst lE = \"\\u2266\";\nconst LeftAngleBracket = \"\\u27E8\";\nconst LeftArrowBar = \"\\u21E4\";\nconst leftarrow = \"\\u2190\";\nconst LeftArrow = \"\\u2190\";\nconst Leftarrow = \"\\u21D0\";\nconst LeftArrowRightArrow = \"\\u21C6\";\nconst leftarrowtail = \"\\u21A2\";\nconst LeftCeiling = \"\\u2308\";\nconst LeftDoubleBracket = \"\\u27E6\";\nconst LeftDownTeeVector = \"\\u2961\";\nconst LeftDownVectorBar = \"\\u2959\";\nconst LeftDownVector = \"\\u21C3\";\nconst LeftFloor = \"\\u230A\";\nconst leftharpoondown = \"\\u21BD\";\nconst leftharpoonup = \"\\u21BC\";\nconst leftleftarrows = \"\\u21C7\";\nconst leftrightarrow = \"\\u2194\";\nconst LeftRightArrow = \"\\u2194\";\nconst Leftrightarrow = \"\\u21D4\";\nconst leftrightarrows = \"\\u21C6\";\nconst leftrightharpoons = \"\\u21CB\";\nconst leftrightsquigarrow = \"\\u21AD\";\nconst LeftRightVector = \"\\u294E\";\nconst LeftTeeArrow = \"\\u21A4\";\nconst LeftTee = \"\\u22A3\";\nconst LeftTeeVector = \"\\u295A\";\nconst leftthreetimes = \"\\u22CB\";\nconst LeftTriangleBar = \"\\u29CF\";\nconst LeftTriangle = \"\\u22B2\";\nconst LeftTriangleEqual = \"\\u22B4\";\nconst LeftUpDownVector = \"\\u2951\";\nconst LeftUpTeeVector = \"\\u2960\";\nconst LeftUpVectorBar = \"\\u2958\";\nconst LeftUpVector = \"\\u21BF\";\nconst LeftVectorBar = \"\\u2952\";\nconst LeftVector = \"\\u21BC\";\nconst lEg = \"\\u2A8B\";\nconst leg = \"\\u22DA\";\nconst leq = \"\\u2264\";\nconst leqq = \"\\u2266\";\nconst leqslant = \"\\u2A7D\";\nconst lescc = \"\\u2AA8\";\nconst les = \"\\u2A7D\";\nconst lesdot = \"\\u2A7F\";\nconst lesdoto = \"\\u2A81\";\nconst lesdotor = \"\\u2A83\";\nconst lesg = \"\\u22DA\\uFE00\";\nconst lesges = \"\\u2A93\";\nconst lessapprox = \"\\u2A85\";\nconst lessdot = \"\\u22D6\";\nconst lesseqgtr = \"\\u22DA\";\nconst lesseqqgtr = \"\\u2A8B\";\nconst LessEqualGreater = \"\\u22DA\";\nconst LessFullEqual = \"\\u2266\";\nconst LessGreater = \"\\u2276\";\nconst lessgtr = \"\\u2276\";\nconst LessLess = \"\\u2AA1\";\nconst lesssim = \"\\u2272\";\nconst LessSlantEqual = \"\\u2A7D\";\nconst LessTilde = \"\\u2272\";\nconst lfisht = \"\\u297C\";\nconst lfloor = \"\\u230A\";\nconst Lfr = \"\\u{1D50F}\";\nconst lfr = \"\\u{1D529}\";\nconst lg = \"\\u2276\";\nconst lgE = \"\\u2A91\";\nconst lHar = \"\\u2962\";\nconst lhard = \"\\u21BD\";\nconst lharu = \"\\u21BC\";\nconst lharul = \"\\u296A\";\nconst lhblk = \"\\u2584\";\nconst LJcy = \"\\u0409\";\nconst ljcy = \"\\u0459\";\nconst llarr = \"\\u21C7\";\nconst ll = \"\\u226A\";\nconst Ll = \"\\u22D8\";\nconst llcorner = \"\\u231E\";\nconst Lleftarrow = \"\\u21DA\";\nconst llhard = \"\\u296B\";\nconst lltri = \"\\u25FA\";\nconst Lmidot = \"\\u013F\";\nconst lmidot = \"\\u0140\";\nconst lmoustache = \"\\u23B0\";\nconst lmoust = \"\\u23B0\";\nconst lnap = \"\\u2A89\";\nconst lnapprox = \"\\u2A89\";\nconst lne = \"\\u2A87\";\nconst lnE = \"\\u2268\";\nconst lneq = \"\\u2A87\";\nconst lneqq = \"\\u2268\";\nconst lnsim = \"\\u22E6\";\nconst loang = \"\\u27EC\";\nconst loarr = \"\\u21FD\";\nconst lobrk = \"\\u27E6\";\nconst longleftarrow = \"\\u27F5\";\nconst LongLeftArrow = \"\\u27F5\";\nconst Longleftarrow = \"\\u27F8\";\nconst longleftrightarrow = \"\\u27F7\";\nconst LongLeftRightArrow = \"\\u27F7\";\nconst Longleftrightarrow = \"\\u27FA\";\nconst longmapsto = \"\\u27FC\";\nconst longrightarrow = \"\\u27F6\";\nconst LongRightArrow = \"\\u27F6\";\nconst Longrightarrow = \"\\u27F9\";\nconst looparrowleft = \"\\u21AB\";\nconst looparrowright = \"\\u21AC\";\nconst lopar = \"\\u2985\";\nconst Lopf = \"\\u{1D543}\";\nconst lopf = \"\\u{1D55D}\";\nconst loplus = \"\\u2A2D\";\nconst lotimes = \"\\u2A34\";\nconst lowast = \"\\u2217\";\nconst lowbar = \"_\";\nconst LowerLeftArrow = \"\\u2199\";\nconst LowerRightArrow = \"\\u2198\";\nconst loz = \"\\u25CA\";\nconst lozenge = \"\\u25CA\";\nconst lozf = \"\\u29EB\";\nconst lpar = \"(\";\nconst lparlt = \"\\u2993\";\nconst lrarr = \"\\u21C6\";\nconst lrcorner = \"\\u231F\";\nconst lrhar = \"\\u21CB\";\nconst lrhard = \"\\u296D\";\nconst lrm = \"\\u200E\";\nconst lrtri = \"\\u22BF\";\nconst lsaquo = \"\\u2039\";\nconst lscr = \"\\u{1D4C1}\";\nconst Lscr = \"\\u2112\";\nconst lsh = \"\\u21B0\";\nconst Lsh = \"\\u21B0\";\nconst lsim = \"\\u2272\";\nconst lsime = \"\\u2A8D\";\nconst lsimg = \"\\u2A8F\";\nconst lsqb = \"[\";\nconst lsquo = \"\\u2018\";\nconst lsquor = \"\\u201A\";\nconst Lstrok = \"\\u0141\";\nconst lstrok = \"\\u0142\";\nconst ltcc = \"\\u2AA6\";\nconst ltcir = \"\\u2A79\";\nconst lt = \"<\";\nconst LT = \"<\";\nconst Lt = \"\\u226A\";\nconst ltdot = \"\\u22D6\";\nconst lthree = \"\\u22CB\";\nconst ltimes = \"\\u22C9\";\nconst ltlarr = \"\\u2976\";\nconst ltquest = \"\\u2A7B\";\nconst ltri = \"\\u25C3\";\nconst ltrie = \"\\u22B4\";\nconst ltrif = \"\\u25C2\";\nconst ltrPar = \"\\u2996\";\nconst lurdshar = \"\\u294A\";\nconst luruhar = \"\\u2966\";\nconst lvertneqq = \"\\u2268\\uFE00\";\nconst lvnE = \"\\u2268\\uFE00\";\nconst macr = \"\\xAF\";\nconst male = \"\\u2642\";\nconst malt = \"\\u2720\";\nconst maltese = \"\\u2720\";\nconst map$1 = \"\\u21A6\";\nconst mapsto = \"\\u21A6\";\nconst mapstodown = \"\\u21A7\";\nconst mapstoleft = \"\\u21A4\";\nconst mapstoup = \"\\u21A5\";\nconst marker = \"\\u25AE\";\nconst mcomma = \"\\u2A29\";\nconst Mcy = \"\\u041C\";\nconst mcy = \"\\u043C\";\nconst mdash = \"\\u2014\";\nconst mDDot = \"\\u223A\";\nconst measuredangle = \"\\u2221\";\nconst MediumSpace = \"\\u205F\";\nconst Mellintrf = \"\\u2133\";\nconst Mfr = \"\\u{1D510}\";\nconst mfr = \"\\u{1D52A}\";\nconst mho = \"\\u2127\";\nconst micro = \"\\xB5\";\nconst midast = \"*\";\nconst midcir = \"\\u2AF0\";\nconst mid = \"\\u2223\";\nconst middot = \"\\xB7\";\nconst minusb = \"\\u229F\";\nconst minus = \"\\u2212\";\nconst minusd = \"\\u2238\";\nconst minusdu = \"\\u2A2A\";\nconst MinusPlus = \"\\u2213\";\nconst mlcp = \"\\u2ADB\";\nconst mldr = \"\\u2026\";\nconst mnplus = \"\\u2213\";\nconst models = \"\\u22A7\";\nconst Mopf = \"\\u{1D544}\";\nconst mopf = \"\\u{1D55E}\";\nconst mp = \"\\u2213\";\nconst mscr = \"\\u{1D4C2}\";\nconst Mscr = \"\\u2133\";\nconst mstpos = \"\\u223E\";\nconst Mu = \"\\u039C\";\nconst mu = \"\\u03BC\";\nconst multimap = \"\\u22B8\";\nconst mumap = \"\\u22B8\";\nconst nabla = \"\\u2207\";\nconst Nacute = \"\\u0143\";\nconst nacute = \"\\u0144\";\nconst nang = \"\\u2220\\u20D2\";\nconst nap = \"\\u2249\";\nconst napE = \"\\u2A70\\u0338\";\nconst napid = \"\\u224B\\u0338\";\nconst napos = \"\\u0149\";\nconst napprox = \"\\u2249\";\nconst natural = \"\\u266E\";\nconst naturals = \"\\u2115\";\nconst natur = \"\\u266E\";\nconst nbsp = \"\\xA0\";\nconst nbump = \"\\u224E\\u0338\";\nconst nbumpe = \"\\u224F\\u0338\";\nconst ncap = \"\\u2A43\";\nconst Ncaron = \"\\u0147\";\nconst ncaron = \"\\u0148\";\nconst Ncedil = \"\\u0145\";\nconst ncedil = \"\\u0146\";\nconst ncong = \"\\u2247\";\nconst ncongdot = \"\\u2A6D\\u0338\";\nconst ncup = \"\\u2A42\";\nconst Ncy = \"\\u041D\";\nconst ncy = \"\\u043D\";\nconst ndash = \"\\u2013\";\nconst nearhk = \"\\u2924\";\nconst nearr = \"\\u2197\";\nconst neArr = \"\\u21D7\";\nconst nearrow = \"\\u2197\";\nconst ne = \"\\u2260\";\nconst nedot = \"\\u2250\\u0338\";\nconst NegativeMediumSpace = \"\\u200B\";\nconst NegativeThickSpace = \"\\u200B\";\nconst NegativeThinSpace = \"\\u200B\";\nconst NegativeVeryThinSpace = \"\\u200B\";\nconst nequiv = \"\\u2262\";\nconst nesear = \"\\u2928\";\nconst nesim = \"\\u2242\\u0338\";\nconst NestedGreaterGreater = \"\\u226B\";\nconst NestedLessLess = \"\\u226A\";\nconst NewLine = \"\\n\";\nconst nexist = \"\\u2204\";\nconst nexists = \"\\u2204\";\nconst Nfr = \"\\u{1D511}\";\nconst nfr = \"\\u{1D52B}\";\nconst ngE = \"\\u2267\\u0338\";\nconst nge = \"\\u2271\";\nconst ngeq = \"\\u2271\";\nconst ngeqq = \"\\u2267\\u0338\";\nconst ngeqslant = \"\\u2A7E\\u0338\";\nconst nges = \"\\u2A7E\\u0338\";\nconst nGg = \"\\u22D9\\u0338\";\nconst ngsim = \"\\u2275\";\nconst nGt = \"\\u226B\\u20D2\";\nconst ngt = \"\\u226F\";\nconst ngtr = \"\\u226F\";\nconst nGtv = \"\\u226B\\u0338\";\nconst nharr = \"\\u21AE\";\nconst nhArr = \"\\u21CE\";\nconst nhpar = \"\\u2AF2\";\nconst ni = \"\\u220B\";\nconst nis = \"\\u22FC\";\nconst nisd = \"\\u22FA\";\nconst niv = \"\\u220B\";\nconst NJcy = \"\\u040A\";\nconst njcy = \"\\u045A\";\nconst nlarr = \"\\u219A\";\nconst nlArr = \"\\u21CD\";\nconst nldr = \"\\u2025\";\nconst nlE = \"\\u2266\\u0338\";\nconst nle = \"\\u2270\";\nconst nleftarrow = \"\\u219A\";\nconst nLeftarrow = \"\\u21CD\";\nconst nleftrightarrow = \"\\u21AE\";\nconst nLeftrightarrow = \"\\u21CE\";\nconst nleq = \"\\u2270\";\nconst nleqq = \"\\u2266\\u0338\";\nconst nleqslant = \"\\u2A7D\\u0338\";\nconst nles = \"\\u2A7D\\u0338\";\nconst nless = \"\\u226E\";\nconst nLl = \"\\u22D8\\u0338\";\nconst nlsim = \"\\u2274\";\nconst nLt = \"\\u226A\\u20D2\";\nconst nlt = \"\\u226E\";\nconst nltri = \"\\u22EA\";\nconst nltrie = \"\\u22EC\";\nconst nLtv = \"\\u226A\\u0338\";\nconst nmid = \"\\u2224\";\nconst NoBreak = \"\\u2060\";\nconst NonBreakingSpace = \"\\xA0\";\nconst nopf = \"\\u{1D55F}\";\nconst Nopf = \"\\u2115\";\nconst Not = \"\\u2AEC\";\nconst not = \"\\xAC\";\nconst NotCongruent = \"\\u2262\";\nconst NotCupCap = \"\\u226D\";\nconst NotDoubleVerticalBar = \"\\u2226\";\nconst NotElement = \"\\u2209\";\nconst NotEqual = \"\\u2260\";\nconst NotEqualTilde = \"\\u2242\\u0338\";\nconst NotExists = \"\\u2204\";\nconst NotGreater = \"\\u226F\";\nconst NotGreaterEqual = \"\\u2271\";\nconst NotGreaterFullEqual = \"\\u2267\\u0338\";\nconst NotGreaterGreater = \"\\u226B\\u0338\";\nconst NotGreaterLess = \"\\u2279\";\nconst NotGreaterSlantEqual = \"\\u2A7E\\u0338\";\nconst NotGreaterTilde = \"\\u2275\";\nconst NotHumpDownHump = \"\\u224E\\u0338\";\nconst NotHumpEqual = \"\\u224F\\u0338\";\nconst notin = \"\\u2209\";\nconst notindot = \"\\u22F5\\u0338\";\nconst notinE = \"\\u22F9\\u0338\";\nconst notinva = \"\\u2209\";\nconst notinvb = \"\\u22F7\";\nconst notinvc = \"\\u22F6\";\nconst NotLeftTriangleBar = \"\\u29CF\\u0338\";\nconst NotLeftTriangle = \"\\u22EA\";\nconst NotLeftTriangleEqual = \"\\u22EC\";\nconst NotLess = \"\\u226E\";\nconst NotLessEqual = \"\\u2270\";\nconst NotLessGreater = \"\\u2278\";\nconst NotLessLess = \"\\u226A\\u0338\";\nconst NotLessSlantEqual = \"\\u2A7D\\u0338\";\nconst NotLessTilde = \"\\u2274\";\nconst NotNestedGreaterGreater = \"\\u2AA2\\u0338\";\nconst NotNestedLessLess = \"\\u2AA1\\u0338\";\nconst notni = \"\\u220C\";\nconst notniva = \"\\u220C\";\nconst notnivb = \"\\u22FE\";\nconst notnivc = \"\\u22FD\";\nconst NotPrecedes = \"\\u2280\";\nconst NotPrecedesEqual = \"\\u2AAF\\u0338\";\nconst NotPrecedesSlantEqual = \"\\u22E0\";\nconst NotReverseElement = \"\\u220C\";\nconst NotRightTriangleBar = \"\\u29D0\\u0338\";\nconst NotRightTriangle = \"\\u22EB\";\nconst NotRightTriangleEqual = \"\\u22ED\";\nconst NotSquareSubset = \"\\u228F\\u0338\";\nconst NotSquareSubsetEqual = \"\\u22E2\";\nconst NotSquareSuperset = \"\\u2290\\u0338\";\nconst NotSquareSupersetEqual = \"\\u22E3\";\nconst NotSubset = \"\\u2282\\u20D2\";\nconst NotSubsetEqual = \"\\u2288\";\nconst NotSucceeds = \"\\u2281\";\nconst NotSucceedsEqual = \"\\u2AB0\\u0338\";\nconst NotSucceedsSlantEqual = \"\\u22E1\";\nconst NotSucceedsTilde = \"\\u227F\\u0338\";\nconst NotSuperset = \"\\u2283\\u20D2\";\nconst NotSupersetEqual = \"\\u2289\";\nconst NotTilde = \"\\u2241\";\nconst NotTildeEqual = \"\\u2244\";\nconst NotTildeFullEqual = \"\\u2247\";\nconst NotTildeTilde = \"\\u2249\";\nconst NotVerticalBar = \"\\u2224\";\nconst nparallel = \"\\u2226\";\nconst npar = \"\\u2226\";\nconst nparsl = \"\\u2AFD\\u20E5\";\nconst npart = \"\\u2202\\u0338\";\nconst npolint = \"\\u2A14\";\nconst npr = \"\\u2280\";\nconst nprcue = \"\\u22E0\";\nconst nprec = \"\\u2280\";\nconst npreceq = \"\\u2AAF\\u0338\";\nconst npre = \"\\u2AAF\\u0338\";\nconst nrarrc = \"\\u2933\\u0338\";\nconst nrarr = \"\\u219B\";\nconst nrArr = \"\\u21CF\";\nconst nrarrw = \"\\u219D\\u0338\";\nconst nrightarrow = \"\\u219B\";\nconst nRightarrow = \"\\u21CF\";\nconst nrtri = \"\\u22EB\";\nconst nrtrie = \"\\u22ED\";\nconst nsc = \"\\u2281\";\nconst nsccue = \"\\u22E1\";\nconst nsce = \"\\u2AB0\\u0338\";\nconst Nscr = \"\\u{1D4A9}\";\nconst nscr = \"\\u{1D4C3}\";\nconst nshortmid = \"\\u2224\";\nconst nshortparallel = \"\\u2226\";\nconst nsim = \"\\u2241\";\nconst nsime = \"\\u2244\";\nconst nsimeq = \"\\u2244\";\nconst nsmid = \"\\u2224\";\nconst nspar = \"\\u2226\";\nconst nsqsube = \"\\u22E2\";\nconst nsqsupe = \"\\u22E3\";\nconst nsub = \"\\u2284\";\nconst nsubE = \"\\u2AC5\\u0338\";\nconst nsube = \"\\u2288\";\nconst nsubset = \"\\u2282\\u20D2\";\nconst nsubseteq = \"\\u2288\";\nconst nsubseteqq = \"\\u2AC5\\u0338\";\nconst nsucc = \"\\u2281\";\nconst nsucceq = \"\\u2AB0\\u0338\";\nconst nsup = \"\\u2285\";\nconst nsupE = \"\\u2AC6\\u0338\";\nconst nsupe = \"\\u2289\";\nconst nsupset = \"\\u2283\\u20D2\";\nconst nsupseteq = \"\\u2289\";\nconst nsupseteqq = \"\\u2AC6\\u0338\";\nconst ntgl = \"\\u2279\";\nconst Ntilde = \"\\xD1\";\nconst ntilde = \"\\xF1\";\nconst ntlg = \"\\u2278\";\nconst ntriangleleft = \"\\u22EA\";\nconst ntrianglelefteq = \"\\u22EC\";\nconst ntriangleright = \"\\u22EB\";\nconst ntrianglerighteq = \"\\u22ED\";\nconst Nu = \"\\u039D\";\nconst nu = \"\\u03BD\";\nconst num = \"#\";\nconst numero = \"\\u2116\";\nconst numsp = \"\\u2007\";\nconst nvap = \"\\u224D\\u20D2\";\nconst nvdash = \"\\u22AC\";\nconst nvDash = \"\\u22AD\";\nconst nVdash = \"\\u22AE\";\nconst nVDash = \"\\u22AF\";\nconst nvge = \"\\u2265\\u20D2\";\nconst nvgt = \">\\u20D2\";\nconst nvHarr = \"\\u2904\";\nconst nvinfin = \"\\u29DE\";\nconst nvlArr = \"\\u2902\";\nconst nvle = \"\\u2264\\u20D2\";\nconst nvlt = \"<\\u20D2\";\nconst nvltrie = \"\\u22B4\\u20D2\";\nconst nvrArr = \"\\u2903\";\nconst nvrtrie = \"\\u22B5\\u20D2\";\nconst nvsim = \"\\u223C\\u20D2\";\nconst nwarhk = \"\\u2923\";\nconst nwarr = \"\\u2196\";\nconst nwArr = \"\\u21D6\";\nconst nwarrow = \"\\u2196\";\nconst nwnear = \"\\u2927\";\nconst Oacute = \"\\xD3\";\nconst oacute = \"\\xF3\";\nconst oast = \"\\u229B\";\nconst Ocirc = \"\\xD4\";\nconst ocirc = \"\\xF4\";\nconst ocir = \"\\u229A\";\nconst Ocy = \"\\u041E\";\nconst ocy = \"\\u043E\";\nconst odash = \"\\u229D\";\nconst Odblac = \"\\u0150\";\nconst odblac = \"\\u0151\";\nconst odiv = \"\\u2A38\";\nconst odot = \"\\u2299\";\nconst odsold = \"\\u29BC\";\nconst OElig = \"\\u0152\";\nconst oelig = \"\\u0153\";\nconst ofcir = \"\\u29BF\";\nconst Ofr = \"\\u{1D512}\";\nconst ofr = \"\\u{1D52C}\";\nconst ogon = \"\\u02DB\";\nconst Ograve = \"\\xD2\";\nconst ograve = \"\\xF2\";\nconst ogt = \"\\u29C1\";\nconst ohbar = \"\\u29B5\";\nconst ohm = \"\\u03A9\";\nconst oint = \"\\u222E\";\nconst olarr = \"\\u21BA\";\nconst olcir = \"\\u29BE\";\nconst olcross = \"\\u29BB\";\nconst oline = \"\\u203E\";\nconst olt = \"\\u29C0\";\nconst Omacr = \"\\u014C\";\nconst omacr = \"\\u014D\";\nconst Omega = \"\\u03A9\";\nconst omega = \"\\u03C9\";\nconst Omicron = \"\\u039F\";\nconst omicron = \"\\u03BF\";\nconst omid = \"\\u29B6\";\nconst ominus = \"\\u2296\";\nconst Oopf = \"\\u{1D546}\";\nconst oopf = \"\\u{1D560}\";\nconst opar = \"\\u29B7\";\nconst OpenCurlyDoubleQuote = \"\\u201C\";\nconst OpenCurlyQuote = \"\\u2018\";\nconst operp = \"\\u29B9\";\nconst oplus = \"\\u2295\";\nconst orarr = \"\\u21BB\";\nconst Or = \"\\u2A54\";\nconst or = \"\\u2228\";\nconst ord = \"\\u2A5D\";\nconst order = \"\\u2134\";\nconst orderof = \"\\u2134\";\nconst ordf = \"\\xAA\";\nconst ordm = \"\\xBA\";\nconst origof = \"\\u22B6\";\nconst oror = \"\\u2A56\";\nconst orslope = \"\\u2A57\";\nconst orv = \"\\u2A5B\";\nconst oS = \"\\u24C8\";\nconst Oscr = \"\\u{1D4AA}\";\nconst oscr = \"\\u2134\";\nconst Oslash = \"\\xD8\";\nconst oslash = \"\\xF8\";\nconst osol = \"\\u2298\";\nconst Otilde = \"\\xD5\";\nconst otilde = \"\\xF5\";\nconst otimesas = \"\\u2A36\";\nconst Otimes = \"\\u2A37\";\nconst otimes = \"\\u2297\";\nconst Ouml = \"\\xD6\";\nconst ouml = \"\\xF6\";\nconst ovbar = \"\\u233D\";\nconst OverBar = \"\\u203E\";\nconst OverBrace = \"\\u23DE\";\nconst OverBracket = \"\\u23B4\";\nconst OverParenthesis = \"\\u23DC\";\nconst para = \"\\xB6\";\nconst parallel = \"\\u2225\";\nconst par = \"\\u2225\";\nconst parsim = \"\\u2AF3\";\nconst parsl = \"\\u2AFD\";\nconst part = \"\\u2202\";\nconst PartialD = \"\\u2202\";\nconst Pcy = \"\\u041F\";\nconst pcy = \"\\u043F\";\nconst percnt = \"%\";\nconst period = \".\";\nconst permil = \"\\u2030\";\nconst perp = \"\\u22A5\";\nconst pertenk = \"\\u2031\";\nconst Pfr = \"\\u{1D513}\";\nconst pfr = \"\\u{1D52D}\";\nconst Phi = \"\\u03A6\";\nconst phi = \"\\u03C6\";\nconst phiv = \"\\u03D5\";\nconst phmmat = \"\\u2133\";\nconst phone = \"\\u260E\";\nconst Pi = \"\\u03A0\";\nconst pi = \"\\u03C0\";\nconst pitchfork = \"\\u22D4\";\nconst piv = \"\\u03D6\";\nconst planck = \"\\u210F\";\nconst planckh = \"\\u210E\";\nconst plankv = \"\\u210F\";\nconst plusacir = \"\\u2A23\";\nconst plusb = \"\\u229E\";\nconst pluscir = \"\\u2A22\";\nconst plus = \"+\";\nconst plusdo = \"\\u2214\";\nconst plusdu = \"\\u2A25\";\nconst pluse = \"\\u2A72\";\nconst PlusMinus = \"\\xB1\";\nconst plusmn = \"\\xB1\";\nconst plussim = \"\\u2A26\";\nconst plustwo = \"\\u2A27\";\nconst pm = \"\\xB1\";\nconst Poincareplane = \"\\u210C\";\nconst pointint = \"\\u2A15\";\nconst popf = \"\\u{1D561}\";\nconst Popf = \"\\u2119\";\nconst pound = \"\\xA3\";\nconst prap = \"\\u2AB7\";\nconst Pr = \"\\u2ABB\";\nconst pr = \"\\u227A\";\nconst prcue = \"\\u227C\";\nconst precapprox = \"\\u2AB7\";\nconst prec = \"\\u227A\";\nconst preccurlyeq = \"\\u227C\";\nconst Precedes = \"\\u227A\";\nconst PrecedesEqual = \"\\u2AAF\";\nconst PrecedesSlantEqual = \"\\u227C\";\nconst PrecedesTilde = \"\\u227E\";\nconst preceq = \"\\u2AAF\";\nconst precnapprox = \"\\u2AB9\";\nconst precneqq = \"\\u2AB5\";\nconst precnsim = \"\\u22E8\";\nconst pre = \"\\u2AAF\";\nconst prE = \"\\u2AB3\";\nconst precsim = \"\\u227E\";\nconst prime = \"\\u2032\";\nconst Prime = \"\\u2033\";\nconst primes = \"\\u2119\";\nconst prnap = \"\\u2AB9\";\nconst prnE = \"\\u2AB5\";\nconst prnsim = \"\\u22E8\";\nconst prod = \"\\u220F\";\nconst Product = \"\\u220F\";\nconst profalar = \"\\u232E\";\nconst profline = \"\\u2312\";\nconst profsurf = \"\\u2313\";\nconst prop = \"\\u221D\";\nconst Proportional = \"\\u221D\";\nconst Proportion = \"\\u2237\";\nconst propto = \"\\u221D\";\nconst prsim = \"\\u227E\";\nconst prurel = \"\\u22B0\";\nconst Pscr = \"\\u{1D4AB}\";\nconst pscr = \"\\u{1D4C5}\";\nconst Psi = \"\\u03A8\";\nconst psi = \"\\u03C8\";\nconst puncsp = \"\\u2008\";\nconst Qfr = \"\\u{1D514}\";\nconst qfr = \"\\u{1D52E}\";\nconst qint = \"\\u2A0C\";\nconst qopf = \"\\u{1D562}\";\nconst Qopf = \"\\u211A\";\nconst qprime = \"\\u2057\";\nconst Qscr = \"\\u{1D4AC}\";\nconst qscr = \"\\u{1D4C6}\";\nconst quaternions = \"\\u210D\";\nconst quatint = \"\\u2A16\";\nconst quest = \"?\";\nconst questeq = \"\\u225F\";\nconst quot = '\"';\nconst QUOT = '\"';\nconst rAarr = \"\\u21DB\";\nconst race = \"\\u223D\\u0331\";\nconst Racute = \"\\u0154\";\nconst racute = \"\\u0155\";\nconst radic = \"\\u221A\";\nconst raemptyv = \"\\u29B3\";\nconst rang = \"\\u27E9\";\nconst Rang = \"\\u27EB\";\nconst rangd = \"\\u2992\";\nconst range = \"\\u29A5\";\nconst rangle = \"\\u27E9\";\nconst raquo = \"\\xBB\";\nconst rarrap = \"\\u2975\";\nconst rarrb = \"\\u21E5\";\nconst rarrbfs = \"\\u2920\";\nconst rarrc = \"\\u2933\";\nconst rarr = \"\\u2192\";\nconst Rarr = \"\\u21A0\";\nconst rArr = \"\\u21D2\";\nconst rarrfs = \"\\u291E\";\nconst rarrhk = \"\\u21AA\";\nconst rarrlp = \"\\u21AC\";\nconst rarrpl = \"\\u2945\";\nconst rarrsim = \"\\u2974\";\nconst Rarrtl = \"\\u2916\";\nconst rarrtl = \"\\u21A3\";\nconst rarrw = \"\\u219D\";\nconst ratail = \"\\u291A\";\nconst rAtail = \"\\u291C\";\nconst ratio = \"\\u2236\";\nconst rationals = \"\\u211A\";\nconst rbarr = \"\\u290D\";\nconst rBarr = \"\\u290F\";\nconst RBarr = \"\\u2910\";\nconst rbbrk = \"\\u2773\";\nconst rbrace = \"}\";\nconst rbrack = \"]\";\nconst rbrke = \"\\u298C\";\nconst rbrksld = \"\\u298E\";\nconst rbrkslu = \"\\u2990\";\nconst Rcaron = \"\\u0158\";\nconst rcaron = \"\\u0159\";\nconst Rcedil = \"\\u0156\";\nconst rcedil = \"\\u0157\";\nconst rceil = \"\\u2309\";\nconst rcub = \"}\";\nconst Rcy = \"\\u0420\";\nconst rcy = \"\\u0440\";\nconst rdca = \"\\u2937\";\nconst rdldhar = \"\\u2969\";\nconst rdquo = \"\\u201D\";\nconst rdquor = \"\\u201D\";\nconst rdsh = \"\\u21B3\";\nconst real = \"\\u211C\";\nconst realine = \"\\u211B\";\nconst realpart = \"\\u211C\";\nconst reals = \"\\u211D\";\nconst Re = \"\\u211C\";\nconst rect = \"\\u25AD\";\nconst reg = \"\\xAE\";\nconst REG = \"\\xAE\";\nconst ReverseElement = \"\\u220B\";\nconst ReverseEquilibrium = \"\\u21CB\";\nconst ReverseUpEquilibrium = \"\\u296F\";\nconst rfisht = \"\\u297D\";\nconst rfloor = \"\\u230B\";\nconst rfr = \"\\u{1D52F}\";\nconst Rfr = \"\\u211C\";\nconst rHar = \"\\u2964\";\nconst rhard = \"\\u21C1\";\nconst rharu = \"\\u21C0\";\nconst rharul = \"\\u296C\";\nconst Rho = \"\\u03A1\";\nconst rho = \"\\u03C1\";\nconst rhov = \"\\u03F1\";\nconst RightAngleBracket = \"\\u27E9\";\nconst RightArrowBar = \"\\u21E5\";\nconst rightarrow = \"\\u2192\";\nconst RightArrow = \"\\u2192\";\nconst Rightarrow = \"\\u21D2\";\nconst RightArrowLeftArrow = \"\\u21C4\";\nconst rightarrowtail = \"\\u21A3\";\nconst RightCeiling = \"\\u2309\";\nconst RightDoubleBracket = \"\\u27E7\";\nconst RightDownTeeVector = \"\\u295D\";\nconst RightDownVectorBar = \"\\u2955\";\nconst RightDownVector = \"\\u21C2\";\nconst RightFloor = \"\\u230B\";\nconst rightharpoondown = \"\\u21C1\";\nconst rightharpoonup = \"\\u21C0\";\nconst rightleftarrows = \"\\u21C4\";\nconst rightleftharpoons = \"\\u21CC\";\nconst rightrightarrows = \"\\u21C9\";\nconst rightsquigarrow = \"\\u219D\";\nconst RightTeeArrow = \"\\u21A6\";\nconst RightTee = \"\\u22A2\";\nconst RightTeeVector = \"\\u295B\";\nconst rightthreetimes = \"\\u22CC\";\nconst RightTriangleBar = \"\\u29D0\";\nconst RightTriangle = \"\\u22B3\";\nconst RightTriangleEqual = \"\\u22B5\";\nconst RightUpDownVector = \"\\u294F\";\nconst RightUpTeeVector = \"\\u295C\";\nconst RightUpVectorBar = \"\\u2954\";\nconst RightUpVector = \"\\u21BE\";\nconst RightVectorBar = \"\\u2953\";\nconst RightVector = \"\\u21C0\";\nconst ring = \"\\u02DA\";\nconst risingdotseq = \"\\u2253\";\nconst rlarr = \"\\u21C4\";\nconst rlhar = \"\\u21CC\";\nconst rlm = \"\\u200F\";\nconst rmoustache = \"\\u23B1\";\nconst rmoust = \"\\u23B1\";\nconst rnmid = \"\\u2AEE\";\nconst roang = \"\\u27ED\";\nconst roarr = \"\\u21FE\";\nconst robrk = \"\\u27E7\";\nconst ropar = \"\\u2986\";\nconst ropf = \"\\u{1D563}\";\nconst Ropf = \"\\u211D\";\nconst roplus = \"\\u2A2E\";\nconst rotimes = \"\\u2A35\";\nconst RoundImplies = \"\\u2970\";\nconst rpar = \")\";\nconst rpargt = \"\\u2994\";\nconst rppolint = \"\\u2A12\";\nconst rrarr = \"\\u21C9\";\nconst Rrightarrow = \"\\u21DB\";\nconst rsaquo = \"\\u203A\";\nconst rscr = \"\\u{1D4C7}\";\nconst Rscr = \"\\u211B\";\nconst rsh = \"\\u21B1\";\nconst Rsh = \"\\u21B1\";\nconst rsqb = \"]\";\nconst rsquo = \"\\u2019\";\nconst rsquor = \"\\u2019\";\nconst rthree = \"\\u22CC\";\nconst rtimes = \"\\u22CA\";\nconst rtri = \"\\u25B9\";\nconst rtrie = \"\\u22B5\";\nconst rtrif = \"\\u25B8\";\nconst rtriltri = \"\\u29CE\";\nconst RuleDelayed = \"\\u29F4\";\nconst ruluhar = \"\\u2968\";\nconst rx = \"\\u211E\";\nconst Sacute = \"\\u015A\";\nconst sacute = \"\\u015B\";\nconst sbquo = \"\\u201A\";\nconst scap = \"\\u2AB8\";\nconst Scaron = \"\\u0160\";\nconst scaron = \"\\u0161\";\nconst Sc = \"\\u2ABC\";\nconst sc = \"\\u227B\";\nconst sccue = \"\\u227D\";\nconst sce = \"\\u2AB0\";\nconst scE = \"\\u2AB4\";\nconst Scedil = \"\\u015E\";\nconst scedil = \"\\u015F\";\nconst Scirc = \"\\u015C\";\nconst scirc = \"\\u015D\";\nconst scnap = \"\\u2ABA\";\nconst scnE = \"\\u2AB6\";\nconst scnsim = \"\\u22E9\";\nconst scpolint = \"\\u2A13\";\nconst scsim = \"\\u227F\";\nconst Scy = \"\\u0421\";\nconst scy = \"\\u0441\";\nconst sdotb = \"\\u22A1\";\nconst sdot = \"\\u22C5\";\nconst sdote = \"\\u2A66\";\nconst searhk = \"\\u2925\";\nconst searr = \"\\u2198\";\nconst seArr = \"\\u21D8\";\nconst searrow = \"\\u2198\";\nconst sect = \"\\xA7\";\nconst semi = \";\";\nconst seswar = \"\\u2929\";\nconst setminus = \"\\u2216\";\nconst setmn = \"\\u2216\";\nconst sext = \"\\u2736\";\nconst Sfr = \"\\u{1D516}\";\nconst sfr = \"\\u{1D530}\";\nconst sfrown = \"\\u2322\";\nconst sharp = \"\\u266F\";\nconst SHCHcy = \"\\u0429\";\nconst shchcy = \"\\u0449\";\nconst SHcy = \"\\u0428\";\nconst shcy = \"\\u0448\";\nconst ShortDownArrow = \"\\u2193\";\nconst ShortLeftArrow = \"\\u2190\";\nconst shortmid = \"\\u2223\";\nconst shortparallel = \"\\u2225\";\nconst ShortRightArrow = \"\\u2192\";\nconst ShortUpArrow = \"\\u2191\";\nconst shy = \"\\xAD\";\nconst Sigma = \"\\u03A3\";\nconst sigma = \"\\u03C3\";\nconst sigmaf = \"\\u03C2\";\nconst sigmav = \"\\u03C2\";\nconst sim = \"\\u223C\";\nconst simdot = \"\\u2A6A\";\nconst sime = \"\\u2243\";\nconst simeq = \"\\u2243\";\nconst simg = \"\\u2A9E\";\nconst simgE = \"\\u2AA0\";\nconst siml = \"\\u2A9D\";\nconst simlE = \"\\u2A9F\";\nconst simne = \"\\u2246\";\nconst simplus = \"\\u2A24\";\nconst simrarr = \"\\u2972\";\nconst slarr = \"\\u2190\";\nconst SmallCircle = \"\\u2218\";\nconst smallsetminus = \"\\u2216\";\nconst smashp = \"\\u2A33\";\nconst smeparsl = \"\\u29E4\";\nconst smid = \"\\u2223\";\nconst smile = \"\\u2323\";\nconst smt = \"\\u2AAA\";\nconst smte = \"\\u2AAC\";\nconst smtes = \"\\u2AAC\\uFE00\";\nconst SOFTcy = \"\\u042C\";\nconst softcy = \"\\u044C\";\nconst solbar = \"\\u233F\";\nconst solb = \"\\u29C4\";\nconst sol = \"/\";\nconst Sopf = \"\\u{1D54A}\";\nconst sopf = \"\\u{1D564}\";\nconst spades = \"\\u2660\";\nconst spadesuit = \"\\u2660\";\nconst spar = \"\\u2225\";\nconst sqcap = \"\\u2293\";\nconst sqcaps = \"\\u2293\\uFE00\";\nconst sqcup = \"\\u2294\";\nconst sqcups = \"\\u2294\\uFE00\";\nconst Sqrt = \"\\u221A\";\nconst sqsub = \"\\u228F\";\nconst sqsube = \"\\u2291\";\nconst sqsubset = \"\\u228F\";\nconst sqsubseteq = \"\\u2291\";\nconst sqsup = \"\\u2290\";\nconst sqsupe = \"\\u2292\";\nconst sqsupset = \"\\u2290\";\nconst sqsupseteq = \"\\u2292\";\nconst square = \"\\u25A1\";\nconst Square = \"\\u25A1\";\nconst SquareIntersection = \"\\u2293\";\nconst SquareSubset = \"\\u228F\";\nconst SquareSubsetEqual = \"\\u2291\";\nconst SquareSuperset = \"\\u2290\";\nconst SquareSupersetEqual = \"\\u2292\";\nconst SquareUnion = \"\\u2294\";\nconst squarf = \"\\u25AA\";\nconst squ = \"\\u25A1\";\nconst squf = \"\\u25AA\";\nconst srarr = \"\\u2192\";\nconst Sscr = \"\\u{1D4AE}\";\nconst sscr = \"\\u{1D4C8}\";\nconst ssetmn = \"\\u2216\";\nconst ssmile = \"\\u2323\";\nconst sstarf = \"\\u22C6\";\nconst Star = \"\\u22C6\";\nconst star = \"\\u2606\";\nconst starf = \"\\u2605\";\nconst straightepsilon = \"\\u03F5\";\nconst straightphi = \"\\u03D5\";\nconst strns = \"\\xAF\";\nconst sub = \"\\u2282\";\nconst Sub = \"\\u22D0\";\nconst subdot = \"\\u2ABD\";\nconst subE = \"\\u2AC5\";\nconst sube = \"\\u2286\";\nconst subedot = \"\\u2AC3\";\nconst submult = \"\\u2AC1\";\nconst subnE = \"\\u2ACB\";\nconst subne = \"\\u228A\";\nconst subplus = \"\\u2ABF\";\nconst subrarr = \"\\u2979\";\nconst subset = \"\\u2282\";\nconst Subset = \"\\u22D0\";\nconst subseteq = \"\\u2286\";\nconst subseteqq = \"\\u2AC5\";\nconst SubsetEqual = \"\\u2286\";\nconst subsetneq = \"\\u228A\";\nconst subsetneqq = \"\\u2ACB\";\nconst subsim = \"\\u2AC7\";\nconst subsub = \"\\u2AD5\";\nconst subsup = \"\\u2AD3\";\nconst succapprox = \"\\u2AB8\";\nconst succ = \"\\u227B\";\nconst succcurlyeq = \"\\u227D\";\nconst Succeeds = \"\\u227B\";\nconst SucceedsEqual = \"\\u2AB0\";\nconst SucceedsSlantEqual = \"\\u227D\";\nconst SucceedsTilde = \"\\u227F\";\nconst succeq = \"\\u2AB0\";\nconst succnapprox = \"\\u2ABA\";\nconst succneqq = \"\\u2AB6\";\nconst succnsim = \"\\u22E9\";\nconst succsim = \"\\u227F\";\nconst SuchThat = \"\\u220B\";\nconst sum = \"\\u2211\";\nconst Sum = \"\\u2211\";\nconst sung = \"\\u266A\";\nconst sup1 = \"\\xB9\";\nconst sup2 = \"\\xB2\";\nconst sup3 = \"\\xB3\";\nconst sup = \"\\u2283\";\nconst Sup = \"\\u22D1\";\nconst supdot = \"\\u2ABE\";\nconst supdsub = \"\\u2AD8\";\nconst supE = \"\\u2AC6\";\nconst supe = \"\\u2287\";\nconst supedot = \"\\u2AC4\";\nconst Superset = \"\\u2283\";\nconst SupersetEqual = \"\\u2287\";\nconst suphsol = \"\\u27C9\";\nconst suphsub = \"\\u2AD7\";\nconst suplarr = \"\\u297B\";\nconst supmult = \"\\u2AC2\";\nconst supnE = \"\\u2ACC\";\nconst supne = \"\\u228B\";\nconst supplus = \"\\u2AC0\";\nconst supset = \"\\u2283\";\nconst Supset = \"\\u22D1\";\nconst supseteq = \"\\u2287\";\nconst supseteqq = \"\\u2AC6\";\nconst supsetneq = \"\\u228B\";\nconst supsetneqq = \"\\u2ACC\";\nconst supsim = \"\\u2AC8\";\nconst supsub = \"\\u2AD4\";\nconst supsup = \"\\u2AD6\";\nconst swarhk = \"\\u2926\";\nconst swarr = \"\\u2199\";\nconst swArr = \"\\u21D9\";\nconst swarrow = \"\\u2199\";\nconst swnwar = \"\\u292A\";\nconst szlig = \"\\xDF\";\nconst Tab$1 = \"\t\";\nconst target = \"\\u2316\";\nconst Tau = \"\\u03A4\";\nconst tau = \"\\u03C4\";\nconst tbrk = \"\\u23B4\";\nconst Tcaron = \"\\u0164\";\nconst tcaron = \"\\u0165\";\nconst Tcedil = \"\\u0162\";\nconst tcedil = \"\\u0163\";\nconst Tcy = \"\\u0422\";\nconst tcy = \"\\u0442\";\nconst tdot = \"\\u20DB\";\nconst telrec = \"\\u2315\";\nconst Tfr = \"\\u{1D517}\";\nconst tfr = \"\\u{1D531}\";\nconst there4 = \"\\u2234\";\nconst therefore = \"\\u2234\";\nconst Therefore = \"\\u2234\";\nconst Theta = \"\\u0398\";\nconst theta = \"\\u03B8\";\nconst thetasym = \"\\u03D1\";\nconst thetav = \"\\u03D1\";\nconst thickapprox = \"\\u2248\";\nconst thicksim = \"\\u223C\";\nconst ThickSpace = \"\\u205F\\u200A\";\nconst ThinSpace = \"\\u2009\";\nconst thinsp = \"\\u2009\";\nconst thkap = \"\\u2248\";\nconst thksim = \"\\u223C\";\nconst THORN = \"\\xDE\";\nconst thorn = \"\\xFE\";\nconst tilde = \"\\u02DC\";\nconst Tilde = \"\\u223C\";\nconst TildeEqual = \"\\u2243\";\nconst TildeFullEqual = \"\\u2245\";\nconst TildeTilde = \"\\u2248\";\nconst timesbar = \"\\u2A31\";\nconst timesb = \"\\u22A0\";\nconst times = \"\\xD7\";\nconst timesd = \"\\u2A30\";\nconst tint = \"\\u222D\";\nconst toea = \"\\u2928\";\nconst topbot = \"\\u2336\";\nconst topcir = \"\\u2AF1\";\nconst top = \"\\u22A4\";\nconst Topf = \"\\u{1D54B}\";\nconst topf = \"\\u{1D565}\";\nconst topfork = \"\\u2ADA\";\nconst tosa = \"\\u2929\";\nconst tprime = \"\\u2034\";\nconst trade = \"\\u2122\";\nconst TRADE = \"\\u2122\";\nconst triangle = \"\\u25B5\";\nconst triangledown = \"\\u25BF\";\nconst triangleleft = \"\\u25C3\";\nconst trianglelefteq = \"\\u22B4\";\nconst triangleq = \"\\u225C\";\nconst triangleright = \"\\u25B9\";\nconst trianglerighteq = \"\\u22B5\";\nconst tridot = \"\\u25EC\";\nconst trie = \"\\u225C\";\nconst triminus = \"\\u2A3A\";\nconst TripleDot = \"\\u20DB\";\nconst triplus = \"\\u2A39\";\nconst trisb = \"\\u29CD\";\nconst tritime = \"\\u2A3B\";\nconst trpezium = \"\\u23E2\";\nconst Tscr = \"\\u{1D4AF}\";\nconst tscr = \"\\u{1D4C9}\";\nconst TScy = \"\\u0426\";\nconst tscy = \"\\u0446\";\nconst TSHcy = \"\\u040B\";\nconst tshcy = \"\\u045B\";\nconst Tstrok = \"\\u0166\";\nconst tstrok = \"\\u0167\";\nconst twixt = \"\\u226C\";\nconst twoheadleftarrow = \"\\u219E\";\nconst twoheadrightarrow = \"\\u21A0\";\nconst Uacute = \"\\xDA\";\nconst uacute = \"\\xFA\";\nconst uarr = \"\\u2191\";\nconst Uarr = \"\\u219F\";\nconst uArr = \"\\u21D1\";\nconst Uarrocir = \"\\u2949\";\nconst Ubrcy = \"\\u040E\";\nconst ubrcy = \"\\u045E\";\nconst Ubreve = \"\\u016C\";\nconst ubreve = \"\\u016D\";\nconst Ucirc = \"\\xDB\";\nconst ucirc = \"\\xFB\";\nconst Ucy = \"\\u0423\";\nconst ucy = \"\\u0443\";\nconst udarr = \"\\u21C5\";\nconst Udblac = \"\\u0170\";\nconst udblac = \"\\u0171\";\nconst udhar = \"\\u296E\";\nconst ufisht = \"\\u297E\";\nconst Ufr = \"\\u{1D518}\";\nconst ufr = \"\\u{1D532}\";\nconst Ugrave = \"\\xD9\";\nconst ugrave = \"\\xF9\";\nconst uHar = \"\\u2963\";\nconst uharl = \"\\u21BF\";\nconst uharr = \"\\u21BE\";\nconst uhblk = \"\\u2580\";\nconst ulcorn = \"\\u231C\";\nconst ulcorner = \"\\u231C\";\nconst ulcrop = \"\\u230F\";\nconst ultri = \"\\u25F8\";\nconst Umacr = \"\\u016A\";\nconst umacr = \"\\u016B\";\nconst uml = \"\\xA8\";\nconst UnderBar = \"_\";\nconst UnderBrace = \"\\u23DF\";\nconst UnderBracket = \"\\u23B5\";\nconst UnderParenthesis = \"\\u23DD\";\nconst Union = \"\\u22C3\";\nconst UnionPlus = \"\\u228E\";\nconst Uogon = \"\\u0172\";\nconst uogon = \"\\u0173\";\nconst Uopf = \"\\u{1D54C}\";\nconst uopf = \"\\u{1D566}\";\nconst UpArrowBar = \"\\u2912\";\nconst uparrow = \"\\u2191\";\nconst UpArrow = \"\\u2191\";\nconst Uparrow = \"\\u21D1\";\nconst UpArrowDownArrow = \"\\u21C5\";\nconst updownarrow = \"\\u2195\";\nconst UpDownArrow = \"\\u2195\";\nconst Updownarrow = \"\\u21D5\";\nconst UpEquilibrium = \"\\u296E\";\nconst upharpoonleft = \"\\u21BF\";\nconst upharpoonright = \"\\u21BE\";\nconst uplus = \"\\u228E\";\nconst UpperLeftArrow = \"\\u2196\";\nconst UpperRightArrow = \"\\u2197\";\nconst upsi = \"\\u03C5\";\nconst Upsi = \"\\u03D2\";\nconst upsih = \"\\u03D2\";\nconst Upsilon = \"\\u03A5\";\nconst upsilon = \"\\u03C5\";\nconst UpTeeArrow = \"\\u21A5\";\nconst UpTee = \"\\u22A5\";\nconst upuparrows = \"\\u21C8\";\nconst urcorn = \"\\u231D\";\nconst urcorner = \"\\u231D\";\nconst urcrop = \"\\u230E\";\nconst Uring = \"\\u016E\";\nconst uring = \"\\u016F\";\nconst urtri = \"\\u25F9\";\nconst Uscr = \"\\u{1D4B0}\";\nconst uscr = \"\\u{1D4CA}\";\nconst utdot = \"\\u22F0\";\nconst Utilde = \"\\u0168\";\nconst utilde = \"\\u0169\";\nconst utri = \"\\u25B5\";\nconst utrif = \"\\u25B4\";\nconst uuarr = \"\\u21C8\";\nconst Uuml = \"\\xDC\";\nconst uuml = \"\\xFC\";\nconst uwangle = \"\\u29A7\";\nconst vangrt = \"\\u299C\";\nconst varepsilon = \"\\u03F5\";\nconst varkappa = \"\\u03F0\";\nconst varnothing = \"\\u2205\";\nconst varphi = \"\\u03D5\";\nconst varpi = \"\\u03D6\";\nconst varpropto = \"\\u221D\";\nconst varr = \"\\u2195\";\nconst vArr = \"\\u21D5\";\nconst varrho = \"\\u03F1\";\nconst varsigma = \"\\u03C2\";\nconst varsubsetneq = \"\\u228A\\uFE00\";\nconst varsubsetneqq = \"\\u2ACB\\uFE00\";\nconst varsupsetneq = \"\\u228B\\uFE00\";\nconst varsupsetneqq = \"\\u2ACC\\uFE00\";\nconst vartheta = \"\\u03D1\";\nconst vartriangleleft = \"\\u22B2\";\nconst vartriangleright = \"\\u22B3\";\nconst vBar = \"\\u2AE8\";\nconst Vbar = \"\\u2AEB\";\nconst vBarv = \"\\u2AE9\";\nconst Vcy = \"\\u0412\";\nconst vcy = \"\\u0432\";\nconst vdash = \"\\u22A2\";\nconst vDash = \"\\u22A8\";\nconst Vdash = \"\\u22A9\";\nconst VDash = \"\\u22AB\";\nconst Vdashl = \"\\u2AE6\";\nconst veebar = \"\\u22BB\";\nconst vee = \"\\u2228\";\nconst Vee = \"\\u22C1\";\nconst veeeq = \"\\u225A\";\nconst vellip = \"\\u22EE\";\nconst verbar = \"|\";\nconst Verbar = \"\\u2016\";\nconst vert = \"|\";\nconst Vert = \"\\u2016\";\nconst VerticalBar = \"\\u2223\";\nconst VerticalLine = \"|\";\nconst VerticalSeparator = \"\\u2758\";\nconst VerticalTilde = \"\\u2240\";\nconst VeryThinSpace = \"\\u200A\";\nconst Vfr = \"\\u{1D519}\";\nconst vfr = \"\\u{1D533}\";\nconst vltri = \"\\u22B2\";\nconst vnsub = \"\\u2282\\u20D2\";\nconst vnsup = \"\\u2283\\u20D2\";\nconst Vopf = \"\\u{1D54D}\";\nconst vopf = \"\\u{1D567}\";\nconst vprop = \"\\u221D\";\nconst vrtri = \"\\u22B3\";\nconst Vscr = \"\\u{1D4B1}\";\nconst vscr = \"\\u{1D4CB}\";\nconst vsubnE = \"\\u2ACB\\uFE00\";\nconst vsubne = \"\\u228A\\uFE00\";\nconst vsupnE = \"\\u2ACC\\uFE00\";\nconst vsupne = \"\\u228B\\uFE00\";\nconst Vvdash = \"\\u22AA\";\nconst vzigzag = \"\\u299A\";\nconst Wcirc = \"\\u0174\";\nconst wcirc = \"\\u0175\";\nconst wedbar = \"\\u2A5F\";\nconst wedge = \"\\u2227\";\nconst Wedge = \"\\u22C0\";\nconst wedgeq = \"\\u2259\";\nconst weierp = \"\\u2118\";\nconst Wfr = \"\\u{1D51A}\";\nconst wfr = \"\\u{1D534}\";\nconst Wopf = \"\\u{1D54E}\";\nconst wopf = \"\\u{1D568}\";\nconst wp = \"\\u2118\";\nconst wr = \"\\u2240\";\nconst wreath = \"\\u2240\";\nconst Wscr = \"\\u{1D4B2}\";\nconst wscr = \"\\u{1D4CC}\";\nconst xcap = \"\\u22C2\";\nconst xcirc = \"\\u25EF\";\nconst xcup = \"\\u22C3\";\nconst xdtri = \"\\u25BD\";\nconst Xfr = \"\\u{1D51B}\";\nconst xfr = \"\\u{1D535}\";\nconst xharr = \"\\u27F7\";\nconst xhArr = \"\\u27FA\";\nconst Xi = \"\\u039E\";\nconst xi = \"\\u03BE\";\nconst xlarr = \"\\u27F5\";\nconst xlArr = \"\\u27F8\";\nconst xmap = \"\\u27FC\";\nconst xnis = \"\\u22FB\";\nconst xodot = \"\\u2A00\";\nconst Xopf = \"\\u{1D54F}\";\nconst xopf = \"\\u{1D569}\";\nconst xoplus = \"\\u2A01\";\nconst xotime = \"\\u2A02\";\nconst xrarr = \"\\u27F6\";\nconst xrArr = \"\\u27F9\";\nconst Xscr = \"\\u{1D4B3}\";\nconst xscr = \"\\u{1D4CD}\";\nconst xsqcup = \"\\u2A06\";\nconst xuplus = \"\\u2A04\";\nconst xutri = \"\\u25B3\";\nconst xvee = \"\\u22C1\";\nconst xwedge = \"\\u22C0\";\nconst Yacute = \"\\xDD\";\nconst yacute = \"\\xFD\";\nconst YAcy = \"\\u042F\";\nconst yacy = \"\\u044F\";\nconst Ycirc = \"\\u0176\";\nconst ycirc = \"\\u0177\";\nconst Ycy = \"\\u042B\";\nconst ycy = \"\\u044B\";\nconst yen = \"\\xA5\";\nconst Yfr = \"\\u{1D51C}\";\nconst yfr = \"\\u{1D536}\";\nconst YIcy = \"\\u0407\";\nconst yicy = \"\\u0457\";\nconst Yopf = \"\\u{1D550}\";\nconst yopf = \"\\u{1D56A}\";\nconst Yscr = \"\\u{1D4B4}\";\nconst yscr = \"\\u{1D4CE}\";\nconst YUcy = \"\\u042E\";\nconst yucy = \"\\u044E\";\nconst yuml = \"\\xFF\";\nconst Yuml = \"\\u0178\";\nconst Zacute = \"\\u0179\";\nconst zacute = \"\\u017A\";\nconst Zcaron = \"\\u017D\";\nconst zcaron = \"\\u017E\";\nconst Zcy = \"\\u0417\";\nconst zcy = \"\\u0437\";\nconst Zdot = \"\\u017B\";\nconst zdot = \"\\u017C\";\nconst zeetrf = \"\\u2128\";\nconst ZeroWidthSpace = \"\\u200B\";\nconst Zeta = \"\\u0396\";\nconst zeta = \"\\u03B6\";\nconst zfr = \"\\u{1D537}\";\nconst Zfr = \"\\u2128\";\nconst ZHcy = \"\\u0416\";\nconst zhcy = \"\\u0436\";\nconst zigrarr = \"\\u21DD\";\nconst zopf = \"\\u{1D56B}\";\nconst Zopf = \"\\u2124\";\nconst Zscr = \"\\u{1D4B5}\";\nconst zscr = \"\\u{1D4CF}\";\nconst zwj = \"\\u200D\";\nconst zwnj = \"\\u200C\";\nvar require$$0 = {\n  Aacute,\n  aacute,\n  Abreve,\n  abreve,\n  ac,\n  acd,\n  acE,\n  Acirc,\n  acirc,\n  acute,\n  Acy,\n  acy,\n  AElig,\n  aelig,\n  af,\n  Afr,\n  afr,\n  Agrave,\n  agrave,\n  alefsym,\n  aleph,\n  Alpha,\n  alpha,\n  Amacr,\n  amacr,\n  amalg,\n  amp,\n  AMP,\n  andand,\n  And,\n  and,\n  andd,\n  andslope,\n  andv,\n  ang,\n  ange,\n  angle,\n  angmsdaa,\n  angmsdab,\n  angmsdac,\n  angmsdad,\n  angmsdae,\n  angmsdaf,\n  angmsdag,\n  angmsdah,\n  angmsd,\n  angrt,\n  angrtvb,\n  angrtvbd,\n  angsph,\n  angst,\n  angzarr,\n  Aogon,\n  aogon,\n  Aopf,\n  aopf,\n  apacir,\n  ap,\n  apE,\n  ape,\n  apid,\n  apos,\n  ApplyFunction,\n  approx,\n  approxeq,\n  Aring,\n  aring,\n  Ascr,\n  ascr,\n  Assign,\n  ast,\n  asymp,\n  asympeq,\n  Atilde,\n  atilde,\n  Auml,\n  auml,\n  awconint,\n  awint,\n  backcong,\n  backepsilon,\n  backprime,\n  backsim,\n  backsimeq,\n  Backslash,\n  Barv,\n  barvee,\n  barwed,\n  Barwed,\n  barwedge,\n  bbrk,\n  bbrktbrk,\n  bcong,\n  Bcy,\n  bcy,\n  bdquo,\n  becaus,\n  because,\n  Because,\n  bemptyv,\n  bepsi,\n  bernou,\n  Bernoullis,\n  Beta,\n  beta,\n  beth,\n  between,\n  Bfr,\n  bfr,\n  bigcap,\n  bigcirc,\n  bigcup,\n  bigodot,\n  bigoplus,\n  bigotimes,\n  bigsqcup,\n  bigstar,\n  bigtriangledown,\n  bigtriangleup,\n  biguplus,\n  bigvee,\n  bigwedge,\n  bkarow,\n  blacklozenge,\n  blacksquare,\n  blacktriangle,\n  blacktriangledown,\n  blacktriangleleft,\n  blacktriangleright,\n  blank,\n  blk12,\n  blk14,\n  blk34,\n  block: block$2,\n  bne,\n  bnequiv,\n  bNot,\n  bnot,\n  Bopf,\n  bopf,\n  bot,\n  bottom,\n  bowtie,\n  boxbox,\n  boxdl,\n  boxdL,\n  boxDl,\n  boxDL,\n  boxdr,\n  boxdR,\n  boxDr,\n  boxDR,\n  boxh,\n  boxH,\n  boxhd,\n  boxHd,\n  boxhD,\n  boxHD,\n  boxhu,\n  boxHu,\n  boxhU,\n  boxHU,\n  boxminus,\n  boxplus,\n  boxtimes,\n  boxul,\n  boxuL,\n  boxUl,\n  boxUL,\n  boxur,\n  boxuR,\n  boxUr,\n  boxUR,\n  boxv,\n  boxV,\n  boxvh,\n  boxvH,\n  boxVh,\n  boxVH,\n  boxvl,\n  boxvL,\n  boxVl,\n  boxVL,\n  boxvr,\n  boxvR,\n  boxVr,\n  boxVR,\n  bprime,\n  breve,\n  Breve,\n  brvbar,\n  bscr,\n  Bscr,\n  bsemi,\n  bsim,\n  bsime,\n  bsolb,\n  bsol,\n  bsolhsub,\n  bull,\n  bullet,\n  bump,\n  bumpE,\n  bumpe,\n  Bumpeq,\n  bumpeq,\n  Cacute,\n  cacute,\n  capand,\n  capbrcup,\n  capcap,\n  cap,\n  Cap,\n  capcup,\n  capdot,\n  CapitalDifferentialD,\n  caps,\n  caret,\n  caron,\n  Cayleys,\n  ccaps,\n  Ccaron,\n  ccaron,\n  Ccedil,\n  ccedil,\n  Ccirc,\n  ccirc,\n  Cconint,\n  ccups,\n  ccupssm,\n  Cdot,\n  cdot,\n  cedil,\n  Cedilla,\n  cemptyv,\n  cent,\n  centerdot,\n  CenterDot,\n  cfr,\n  Cfr,\n  CHcy,\n  chcy,\n  check,\n  checkmark,\n  Chi,\n  chi,\n  circ,\n  circeq,\n  circlearrowleft,\n  circlearrowright,\n  circledast,\n  circledcirc,\n  circleddash,\n  CircleDot,\n  circledR,\n  circledS,\n  CircleMinus,\n  CirclePlus,\n  CircleTimes,\n  cir,\n  cirE,\n  cire,\n  cirfnint,\n  cirmid,\n  cirscir,\n  ClockwiseContourIntegral,\n  CloseCurlyDoubleQuote,\n  CloseCurlyQuote,\n  clubs,\n  clubsuit,\n  colon,\n  Colon,\n  Colone,\n  colone,\n  coloneq,\n  comma,\n  commat,\n  comp,\n  compfn,\n  complement,\n  complexes,\n  cong,\n  congdot,\n  Congruent,\n  conint,\n  Conint,\n  ContourIntegral,\n  copf,\n  Copf,\n  coprod,\n  Coproduct,\n  copy,\n  COPY,\n  copysr,\n  CounterClockwiseContourIntegral,\n  crarr,\n  cross,\n  Cross,\n  Cscr,\n  cscr,\n  csub,\n  csube,\n  csup,\n  csupe,\n  ctdot,\n  cudarrl,\n  cudarrr,\n  cuepr,\n  cuesc,\n  cularr,\n  cularrp,\n  cupbrcap,\n  cupcap,\n  CupCap,\n  cup,\n  Cup,\n  cupcup,\n  cupdot,\n  cupor,\n  cups,\n  curarr,\n  curarrm,\n  curlyeqprec,\n  curlyeqsucc,\n  curlyvee,\n  curlywedge,\n  curren,\n  curvearrowleft,\n  curvearrowright,\n  cuvee,\n  cuwed,\n  cwconint,\n  cwint,\n  cylcty,\n  dagger,\n  Dagger,\n  daleth,\n  darr,\n  Darr,\n  dArr,\n  dash,\n  Dashv,\n  dashv,\n  dbkarow,\n  dblac,\n  Dcaron,\n  dcaron,\n  Dcy,\n  dcy,\n  ddagger,\n  ddarr,\n  DD,\n  dd,\n  DDotrahd,\n  ddotseq,\n  deg,\n  Del,\n  Delta,\n  delta,\n  demptyv,\n  dfisht,\n  Dfr,\n  dfr,\n  dHar,\n  dharl,\n  dharr,\n  DiacriticalAcute,\n  DiacriticalDot,\n  DiacriticalDoubleAcute,\n  DiacriticalGrave,\n  DiacriticalTilde,\n  diam,\n  diamond,\n  Diamond,\n  diamondsuit,\n  diams,\n  die,\n  DifferentialD,\n  digamma,\n  disin,\n  div,\n  divide,\n  divideontimes,\n  divonx,\n  DJcy,\n  djcy,\n  dlcorn,\n  dlcrop,\n  dollar,\n  Dopf,\n  dopf,\n  Dot,\n  dot,\n  DotDot,\n  doteq,\n  doteqdot,\n  DotEqual,\n  dotminus,\n  dotplus,\n  dotsquare,\n  doublebarwedge,\n  DoubleContourIntegral,\n  DoubleDot,\n  DoubleDownArrow,\n  DoubleLeftArrow,\n  DoubleLeftRightArrow,\n  DoubleLeftTee,\n  DoubleLongLeftArrow,\n  DoubleLongLeftRightArrow,\n  DoubleLongRightArrow,\n  DoubleRightArrow,\n  DoubleRightTee,\n  DoubleUpArrow,\n  DoubleUpDownArrow,\n  DoubleVerticalBar,\n  DownArrowBar,\n  downarrow,\n  DownArrow,\n  Downarrow,\n  DownArrowUpArrow,\n  DownBreve,\n  downdownarrows,\n  downharpoonleft,\n  downharpoonright,\n  DownLeftRightVector,\n  DownLeftTeeVector,\n  DownLeftVectorBar,\n  DownLeftVector,\n  DownRightTeeVector,\n  DownRightVectorBar,\n  DownRightVector,\n  DownTeeArrow,\n  DownTee,\n  drbkarow,\n  drcorn,\n  drcrop,\n  Dscr,\n  dscr,\n  DScy,\n  dscy,\n  dsol,\n  Dstrok,\n  dstrok,\n  dtdot,\n  dtri,\n  dtrif,\n  duarr,\n  duhar,\n  dwangle,\n  DZcy,\n  dzcy,\n  dzigrarr,\n  Eacute,\n  eacute,\n  easter,\n  Ecaron,\n  ecaron,\n  Ecirc,\n  ecirc,\n  ecir,\n  ecolon,\n  Ecy,\n  ecy,\n  eDDot,\n  Edot,\n  edot,\n  eDot,\n  ee,\n  efDot,\n  Efr,\n  efr,\n  eg,\n  Egrave,\n  egrave,\n  egs,\n  egsdot,\n  el,\n  Element,\n  elinters,\n  ell,\n  els,\n  elsdot,\n  Emacr,\n  emacr,\n  empty,\n  emptyset,\n  EmptySmallSquare,\n  emptyv,\n  EmptyVerySmallSquare,\n  emsp13,\n  emsp14,\n  emsp,\n  ENG,\n  eng,\n  ensp,\n  Eogon,\n  eogon,\n  Eopf,\n  eopf,\n  epar,\n  eparsl,\n  eplus,\n  epsi,\n  Epsilon,\n  epsilon,\n  epsiv,\n  eqcirc,\n  eqcolon,\n  eqsim,\n  eqslantgtr,\n  eqslantless,\n  Equal,\n  equals,\n  EqualTilde,\n  equest,\n  Equilibrium,\n  equiv,\n  equivDD,\n  eqvparsl,\n  erarr,\n  erDot,\n  escr,\n  Escr,\n  esdot,\n  Esim,\n  esim,\n  Eta,\n  eta,\n  ETH,\n  eth,\n  Euml,\n  euml,\n  euro,\n  excl,\n  exist,\n  Exists,\n  expectation,\n  exponentiale,\n  ExponentialE,\n  fallingdotseq,\n  Fcy,\n  fcy,\n  female,\n  ffilig,\n  fflig,\n  ffllig,\n  Ffr,\n  ffr,\n  filig,\n  FilledSmallSquare,\n  FilledVerySmallSquare,\n  fjlig,\n  flat,\n  fllig,\n  fltns,\n  fnof,\n  Fopf,\n  fopf,\n  forall,\n  ForAll,\n  fork,\n  forkv,\n  Fouriertrf,\n  fpartint,\n  frac12,\n  frac13,\n  frac14,\n  frac15,\n  frac16,\n  frac18,\n  frac23,\n  frac25,\n  frac34,\n  frac35,\n  frac38,\n  frac45,\n  frac56,\n  frac58,\n  frac78,\n  frasl,\n  frown,\n  fscr,\n  Fscr,\n  gacute,\n  Gamma,\n  gamma,\n  Gammad,\n  gammad,\n  gap,\n  Gbreve,\n  gbreve,\n  Gcedil,\n  Gcirc,\n  gcirc,\n  Gcy,\n  gcy,\n  Gdot,\n  gdot,\n  ge,\n  gE,\n  gEl,\n  gel,\n  geq,\n  geqq,\n  geqslant,\n  gescc,\n  ges,\n  gesdot,\n  gesdoto,\n  gesdotol,\n  gesl,\n  gesles,\n  Gfr,\n  gfr,\n  gg,\n  Gg,\n  ggg,\n  gimel,\n  GJcy,\n  gjcy,\n  gla,\n  gl,\n  glE,\n  glj,\n  gnap,\n  gnapprox,\n  gne,\n  gnE,\n  gneq,\n  gneqq,\n  gnsim,\n  Gopf,\n  gopf,\n  grave,\n  GreaterEqual,\n  GreaterEqualLess,\n  GreaterFullEqual,\n  GreaterGreater,\n  GreaterLess,\n  GreaterSlantEqual,\n  GreaterTilde,\n  Gscr,\n  gscr,\n  gsim,\n  gsime,\n  gsiml,\n  gtcc,\n  gtcir,\n  gt,\n  GT,\n  Gt,\n  gtdot,\n  gtlPar,\n  gtquest,\n  gtrapprox,\n  gtrarr,\n  gtrdot,\n  gtreqless,\n  gtreqqless,\n  gtrless,\n  gtrsim,\n  gvertneqq,\n  gvnE,\n  Hacek,\n  hairsp,\n  half,\n  hamilt,\n  HARDcy,\n  hardcy,\n  harrcir,\n  harr,\n  hArr,\n  harrw,\n  Hat,\n  hbar,\n  Hcirc,\n  hcirc,\n  hearts,\n  heartsuit,\n  hellip,\n  hercon,\n  hfr,\n  Hfr,\n  HilbertSpace,\n  hksearow,\n  hkswarow,\n  hoarr,\n  homtht,\n  hookleftarrow,\n  hookrightarrow,\n  hopf,\n  Hopf,\n  horbar,\n  HorizontalLine,\n  hscr,\n  Hscr,\n  hslash,\n  Hstrok,\n  hstrok,\n  HumpDownHump,\n  HumpEqual,\n  hybull,\n  hyphen,\n  Iacute,\n  iacute,\n  ic,\n  Icirc,\n  icirc,\n  Icy,\n  icy,\n  Idot,\n  IEcy,\n  iecy,\n  iexcl,\n  iff,\n  ifr,\n  Ifr,\n  Igrave,\n  igrave,\n  ii,\n  iiiint,\n  iiint,\n  iinfin,\n  iiota,\n  IJlig,\n  ijlig,\n  Imacr,\n  imacr,\n  image: image$1,\n  ImaginaryI,\n  imagline,\n  imagpart,\n  imath,\n  Im,\n  imof,\n  imped,\n  Implies,\n  incare,\n  \"in\": \"\\u2208\",\n  infin,\n  infintie,\n  inodot,\n  intcal,\n  int,\n  Int,\n  integers,\n  Integral,\n  intercal,\n  Intersection,\n  intlarhk,\n  intprod,\n  InvisibleComma,\n  InvisibleTimes,\n  IOcy,\n  iocy,\n  Iogon,\n  iogon,\n  Iopf,\n  iopf,\n  Iota,\n  iota,\n  iprod,\n  iquest,\n  iscr,\n  Iscr,\n  isin,\n  isindot,\n  isinE,\n  isins,\n  isinsv,\n  isinv,\n  it,\n  Itilde,\n  itilde,\n  Iukcy,\n  iukcy,\n  Iuml,\n  iuml,\n  Jcirc,\n  jcirc,\n  Jcy,\n  jcy,\n  Jfr,\n  jfr,\n  jmath,\n  Jopf,\n  jopf,\n  Jscr,\n  jscr,\n  Jsercy,\n  jsercy,\n  Jukcy,\n  jukcy,\n  Kappa,\n  kappa,\n  kappav,\n  Kcedil,\n  kcedil,\n  Kcy,\n  kcy,\n  Kfr,\n  kfr,\n  kgreen,\n  KHcy,\n  khcy,\n  KJcy,\n  kjcy,\n  Kopf,\n  kopf,\n  Kscr,\n  kscr,\n  lAarr,\n  Lacute,\n  lacute,\n  laemptyv,\n  lagran,\n  Lambda,\n  lambda,\n  lang,\n  Lang,\n  langd,\n  langle,\n  lap,\n  Laplacetrf,\n  laquo,\n  larrb,\n  larrbfs,\n  larr,\n  Larr,\n  lArr,\n  larrfs,\n  larrhk,\n  larrlp,\n  larrpl,\n  larrsim,\n  larrtl,\n  latail,\n  lAtail,\n  lat,\n  late,\n  lates,\n  lbarr,\n  lBarr,\n  lbbrk,\n  lbrace,\n  lbrack,\n  lbrke,\n  lbrksld,\n  lbrkslu,\n  Lcaron,\n  lcaron,\n  Lcedil,\n  lcedil,\n  lceil,\n  lcub,\n  Lcy,\n  lcy,\n  ldca,\n  ldquo,\n  ldquor,\n  ldrdhar,\n  ldrushar,\n  ldsh,\n  le,\n  lE,\n  LeftAngleBracket,\n  LeftArrowBar,\n  leftarrow,\n  LeftArrow,\n  Leftarrow,\n  LeftArrowRightArrow,\n  leftarrowtail,\n  LeftCeiling,\n  LeftDoubleBracket,\n  LeftDownTeeVector,\n  LeftDownVectorBar,\n  LeftDownVector,\n  LeftFloor,\n  leftharpoondown,\n  leftharpoonup,\n  leftleftarrows,\n  leftrightarrow,\n  LeftRightArrow,\n  Leftrightarrow,\n  leftrightarrows,\n  leftrightharpoons,\n  leftrightsquigarrow,\n  LeftRightVector,\n  LeftTeeArrow,\n  LeftTee,\n  LeftTeeVector,\n  leftthreetimes,\n  LeftTriangleBar,\n  LeftTriangle,\n  LeftTriangleEqual,\n  LeftUpDownVector,\n  LeftUpTeeVector,\n  LeftUpVectorBar,\n  LeftUpVector,\n  LeftVectorBar,\n  LeftVector,\n  lEg,\n  leg,\n  leq,\n  leqq,\n  leqslant,\n  lescc,\n  les,\n  lesdot,\n  lesdoto,\n  lesdotor,\n  lesg,\n  lesges,\n  lessapprox,\n  lessdot,\n  lesseqgtr,\n  lesseqqgtr,\n  LessEqualGreater,\n  LessFullEqual,\n  LessGreater,\n  lessgtr,\n  LessLess,\n  lesssim,\n  LessSlantEqual,\n  LessTilde,\n  lfisht,\n  lfloor,\n  Lfr,\n  lfr,\n  lg,\n  lgE,\n  lHar,\n  lhard,\n  lharu,\n  lharul,\n  lhblk,\n  LJcy,\n  ljcy,\n  llarr,\n  ll,\n  Ll,\n  llcorner,\n  Lleftarrow,\n  llhard,\n  lltri,\n  Lmidot,\n  lmidot,\n  lmoustache,\n  lmoust,\n  lnap,\n  lnapprox,\n  lne,\n  lnE,\n  lneq,\n  lneqq,\n  lnsim,\n  loang,\n  loarr,\n  lobrk,\n  longleftarrow,\n  LongLeftArrow,\n  Longleftarrow,\n  longleftrightarrow,\n  LongLeftRightArrow,\n  Longleftrightarrow,\n  longmapsto,\n  longrightarrow,\n  LongRightArrow,\n  Longrightarrow,\n  looparrowleft,\n  looparrowright,\n  lopar,\n  Lopf,\n  lopf,\n  loplus,\n  lotimes,\n  lowast,\n  lowbar,\n  LowerLeftArrow,\n  LowerRightArrow,\n  loz,\n  lozenge,\n  lozf,\n  lpar,\n  lparlt,\n  lrarr,\n  lrcorner,\n  lrhar,\n  lrhard,\n  lrm,\n  lrtri,\n  lsaquo,\n  lscr,\n  Lscr,\n  lsh,\n  Lsh,\n  lsim,\n  lsime,\n  lsimg,\n  lsqb,\n  lsquo,\n  lsquor,\n  Lstrok,\n  lstrok,\n  ltcc,\n  ltcir,\n  lt,\n  LT,\n  Lt,\n  ltdot,\n  lthree,\n  ltimes,\n  ltlarr,\n  ltquest,\n  ltri,\n  ltrie,\n  ltrif,\n  ltrPar,\n  lurdshar,\n  luruhar,\n  lvertneqq,\n  lvnE,\n  macr,\n  male,\n  malt,\n  maltese,\n  \"Map\": \"\\u2905\",\n  map: map$1,\n  mapsto,\n  mapstodown,\n  mapstoleft,\n  mapstoup,\n  marker,\n  mcomma,\n  Mcy,\n  mcy,\n  mdash,\n  mDDot,\n  measuredangle,\n  MediumSpace,\n  Mellintrf,\n  Mfr,\n  mfr,\n  mho,\n  micro,\n  midast,\n  midcir,\n  mid,\n  middot,\n  minusb,\n  minus,\n  minusd,\n  minusdu,\n  MinusPlus,\n  mlcp,\n  mldr,\n  mnplus,\n  models,\n  Mopf,\n  mopf,\n  mp,\n  mscr,\n  Mscr,\n  mstpos,\n  Mu,\n  mu,\n  multimap,\n  mumap,\n  nabla,\n  Nacute,\n  nacute,\n  nang,\n  nap,\n  napE,\n  napid,\n  napos,\n  napprox,\n  natural,\n  naturals,\n  natur,\n  nbsp,\n  nbump,\n  nbumpe,\n  ncap,\n  Ncaron,\n  ncaron,\n  Ncedil,\n  ncedil,\n  ncong,\n  ncongdot,\n  ncup,\n  Ncy,\n  ncy,\n  ndash,\n  nearhk,\n  nearr,\n  neArr,\n  nearrow,\n  ne,\n  nedot,\n  NegativeMediumSpace,\n  NegativeThickSpace,\n  NegativeThinSpace,\n  NegativeVeryThinSpace,\n  nequiv,\n  nesear,\n  nesim,\n  NestedGreaterGreater,\n  NestedLessLess,\n  NewLine,\n  nexist,\n  nexists,\n  Nfr,\n  nfr,\n  ngE,\n  nge,\n  ngeq,\n  ngeqq,\n  ngeqslant,\n  nges,\n  nGg,\n  ngsim,\n  nGt,\n  ngt,\n  ngtr,\n  nGtv,\n  nharr,\n  nhArr,\n  nhpar,\n  ni,\n  nis,\n  nisd,\n  niv,\n  NJcy,\n  njcy,\n  nlarr,\n  nlArr,\n  nldr,\n  nlE,\n  nle,\n  nleftarrow,\n  nLeftarrow,\n  nleftrightarrow,\n  nLeftrightarrow,\n  nleq,\n  nleqq,\n  nleqslant,\n  nles,\n  nless,\n  nLl,\n  nlsim,\n  nLt,\n  nlt,\n  nltri,\n  nltrie,\n  nLtv,\n  nmid,\n  NoBreak,\n  NonBreakingSpace,\n  nopf,\n  Nopf,\n  Not,\n  not,\n  NotCongruent,\n  NotCupCap,\n  NotDoubleVerticalBar,\n  NotElement,\n  NotEqual,\n  NotEqualTilde,\n  NotExists,\n  NotGreater,\n  NotGreaterEqual,\n  NotGreaterFullEqual,\n  NotGreaterGreater,\n  NotGreaterLess,\n  NotGreaterSlantEqual,\n  NotGreaterTilde,\n  NotHumpDownHump,\n  NotHumpEqual,\n  notin,\n  notindot,\n  notinE,\n  notinva,\n  notinvb,\n  notinvc,\n  NotLeftTriangleBar,\n  NotLeftTriangle,\n  NotLeftTriangleEqual,\n  NotLess,\n  NotLessEqual,\n  NotLessGreater,\n  NotLessLess,\n  NotLessSlantEqual,\n  NotLessTilde,\n  NotNestedGreaterGreater,\n  NotNestedLessLess,\n  notni,\n  notniva,\n  notnivb,\n  notnivc,\n  NotPrecedes,\n  NotPrecedesEqual,\n  NotPrecedesSlantEqual,\n  NotReverseElement,\n  NotRightTriangleBar,\n  NotRightTriangle,\n  NotRightTriangleEqual,\n  NotSquareSubset,\n  NotSquareSubsetEqual,\n  NotSquareSuperset,\n  NotSquareSupersetEqual,\n  NotSubset,\n  NotSubsetEqual,\n  NotSucceeds,\n  NotSucceedsEqual,\n  NotSucceedsSlantEqual,\n  NotSucceedsTilde,\n  NotSuperset,\n  NotSupersetEqual,\n  NotTilde,\n  NotTildeEqual,\n  NotTildeFullEqual,\n  NotTildeTilde,\n  NotVerticalBar,\n  nparallel,\n  npar,\n  nparsl,\n  npart,\n  npolint,\n  npr,\n  nprcue,\n  nprec,\n  npreceq,\n  npre,\n  nrarrc,\n  nrarr,\n  nrArr,\n  nrarrw,\n  nrightarrow,\n  nRightarrow,\n  nrtri,\n  nrtrie,\n  nsc,\n  nsccue,\n  nsce,\n  Nscr,\n  nscr,\n  nshortmid,\n  nshortparallel,\n  nsim,\n  nsime,\n  nsimeq,\n  nsmid,\n  nspar,\n  nsqsube,\n  nsqsupe,\n  nsub,\n  nsubE,\n  nsube,\n  nsubset,\n  nsubseteq,\n  nsubseteqq,\n  nsucc,\n  nsucceq,\n  nsup,\n  nsupE,\n  nsupe,\n  nsupset,\n  nsupseteq,\n  nsupseteqq,\n  ntgl,\n  Ntilde,\n  ntilde,\n  ntlg,\n  ntriangleleft,\n  ntrianglelefteq,\n  ntriangleright,\n  ntrianglerighteq,\n  Nu,\n  nu,\n  num,\n  numero,\n  numsp,\n  nvap,\n  nvdash,\n  nvDash,\n  nVdash,\n  nVDash,\n  nvge,\n  nvgt,\n  nvHarr,\n  nvinfin,\n  nvlArr,\n  nvle,\n  nvlt,\n  nvltrie,\n  nvrArr,\n  nvrtrie,\n  nvsim,\n  nwarhk,\n  nwarr,\n  nwArr,\n  nwarrow,\n  nwnear,\n  Oacute,\n  oacute,\n  oast,\n  Ocirc,\n  ocirc,\n  ocir,\n  Ocy,\n  ocy,\n  odash,\n  Odblac,\n  odblac,\n  odiv,\n  odot,\n  odsold,\n  OElig,\n  oelig,\n  ofcir,\n  Ofr,\n  ofr,\n  ogon,\n  Ograve,\n  ograve,\n  ogt,\n  ohbar,\n  ohm,\n  oint,\n  olarr,\n  olcir,\n  olcross,\n  oline,\n  olt,\n  Omacr,\n  omacr,\n  Omega,\n  omega,\n  Omicron,\n  omicron,\n  omid,\n  ominus,\n  Oopf,\n  oopf,\n  opar,\n  OpenCurlyDoubleQuote,\n  OpenCurlyQuote,\n  operp,\n  oplus,\n  orarr,\n  Or,\n  or,\n  ord,\n  order,\n  orderof,\n  ordf,\n  ordm,\n  origof,\n  oror,\n  orslope,\n  orv,\n  oS,\n  Oscr,\n  oscr,\n  Oslash,\n  oslash,\n  osol,\n  Otilde,\n  otilde,\n  otimesas,\n  Otimes,\n  otimes,\n  Ouml,\n  ouml,\n  ovbar,\n  OverBar,\n  OverBrace,\n  OverBracket,\n  OverParenthesis,\n  para,\n  parallel,\n  par,\n  parsim,\n  parsl,\n  part,\n  PartialD,\n  Pcy,\n  pcy,\n  percnt,\n  period,\n  permil,\n  perp,\n  pertenk,\n  Pfr,\n  pfr,\n  Phi,\n  phi,\n  phiv,\n  phmmat,\n  phone,\n  Pi,\n  pi,\n  pitchfork,\n  piv,\n  planck,\n  planckh,\n  plankv,\n  plusacir,\n  plusb,\n  pluscir,\n  plus,\n  plusdo,\n  plusdu,\n  pluse,\n  PlusMinus,\n  plusmn,\n  plussim,\n  plustwo,\n  pm,\n  Poincareplane,\n  pointint,\n  popf,\n  Popf,\n  pound,\n  prap,\n  Pr,\n  pr,\n  prcue,\n  precapprox,\n  prec,\n  preccurlyeq,\n  Precedes,\n  PrecedesEqual,\n  PrecedesSlantEqual,\n  PrecedesTilde,\n  preceq,\n  precnapprox,\n  precneqq,\n  precnsim,\n  pre,\n  prE,\n  precsim,\n  prime,\n  Prime,\n  primes,\n  prnap,\n  prnE,\n  prnsim,\n  prod,\n  Product,\n  profalar,\n  profline,\n  profsurf,\n  prop,\n  Proportional,\n  Proportion,\n  propto,\n  prsim,\n  prurel,\n  Pscr,\n  pscr,\n  Psi,\n  psi,\n  puncsp,\n  Qfr,\n  qfr,\n  qint,\n  qopf,\n  Qopf,\n  qprime,\n  Qscr,\n  qscr,\n  quaternions,\n  quatint,\n  quest,\n  questeq,\n  quot,\n  QUOT,\n  rAarr,\n  race,\n  Racute,\n  racute,\n  radic,\n  raemptyv,\n  rang,\n  Rang,\n  rangd,\n  range,\n  rangle,\n  raquo,\n  rarrap,\n  rarrb,\n  rarrbfs,\n  rarrc,\n  rarr,\n  Rarr,\n  rArr,\n  rarrfs,\n  rarrhk,\n  rarrlp,\n  rarrpl,\n  rarrsim,\n  Rarrtl,\n  rarrtl,\n  rarrw,\n  ratail,\n  rAtail,\n  ratio,\n  rationals,\n  rbarr,\n  rBarr,\n  RBarr,\n  rbbrk,\n  rbrace,\n  rbrack,\n  rbrke,\n  rbrksld,\n  rbrkslu,\n  Rcaron,\n  rcaron,\n  Rcedil,\n  rcedil,\n  rceil,\n  rcub,\n  Rcy,\n  rcy,\n  rdca,\n  rdldhar,\n  rdquo,\n  rdquor,\n  rdsh,\n  real,\n  realine,\n  realpart,\n  reals,\n  Re,\n  rect,\n  reg,\n  REG,\n  ReverseElement,\n  ReverseEquilibrium,\n  ReverseUpEquilibrium,\n  rfisht,\n  rfloor,\n  rfr,\n  Rfr,\n  rHar,\n  rhard,\n  rharu,\n  rharul,\n  Rho,\n  rho,\n  rhov,\n  RightAngleBracket,\n  RightArrowBar,\n  rightarrow,\n  RightArrow,\n  Rightarrow,\n  RightArrowLeftArrow,\n  rightarrowtail,\n  RightCeiling,\n  RightDoubleBracket,\n  RightDownTeeVector,\n  RightDownVectorBar,\n  RightDownVector,\n  RightFloor,\n  rightharpoondown,\n  rightharpoonup,\n  rightleftarrows,\n  rightleftharpoons,\n  rightrightarrows,\n  rightsquigarrow,\n  RightTeeArrow,\n  RightTee,\n  RightTeeVector,\n  rightthreetimes,\n  RightTriangleBar,\n  RightTriangle,\n  RightTriangleEqual,\n  RightUpDownVector,\n  RightUpTeeVector,\n  RightUpVectorBar,\n  RightUpVector,\n  RightVectorBar,\n  RightVector,\n  ring,\n  risingdotseq,\n  rlarr,\n  rlhar,\n  rlm,\n  rmoustache,\n  rmoust,\n  rnmid,\n  roang,\n  roarr,\n  robrk,\n  ropar,\n  ropf,\n  Ropf,\n  roplus,\n  rotimes,\n  RoundImplies,\n  rpar,\n  rpargt,\n  rppolint,\n  rrarr,\n  Rrightarrow,\n  rsaquo,\n  rscr,\n  Rscr,\n  rsh,\n  Rsh,\n  rsqb,\n  rsquo,\n  rsquor,\n  rthree,\n  rtimes,\n  rtri,\n  rtrie,\n  rtrif,\n  rtriltri,\n  RuleDelayed,\n  ruluhar,\n  rx,\n  Sacute,\n  sacute,\n  sbquo,\n  scap,\n  Scaron,\n  scaron,\n  Sc,\n  sc,\n  sccue,\n  sce,\n  scE,\n  Scedil,\n  scedil,\n  Scirc,\n  scirc,\n  scnap,\n  scnE,\n  scnsim,\n  scpolint,\n  scsim,\n  Scy,\n  scy,\n  sdotb,\n  sdot,\n  sdote,\n  searhk,\n  searr,\n  seArr,\n  searrow,\n  sect,\n  semi,\n  seswar,\n  setminus,\n  setmn,\n  sext,\n  Sfr,\n  sfr,\n  sfrown,\n  sharp,\n  SHCHcy,\n  shchcy,\n  SHcy,\n  shcy,\n  ShortDownArrow,\n  ShortLeftArrow,\n  shortmid,\n  shortparallel,\n  ShortRightArrow,\n  ShortUpArrow,\n  shy,\n  Sigma,\n  sigma,\n  sigmaf,\n  sigmav,\n  sim,\n  simdot,\n  sime,\n  simeq,\n  simg,\n  simgE,\n  siml,\n  simlE,\n  simne,\n  simplus,\n  simrarr,\n  slarr,\n  SmallCircle,\n  smallsetminus,\n  smashp,\n  smeparsl,\n  smid,\n  smile,\n  smt,\n  smte,\n  smtes,\n  SOFTcy,\n  softcy,\n  solbar,\n  solb,\n  sol,\n  Sopf,\n  sopf,\n  spades,\n  spadesuit,\n  spar,\n  sqcap,\n  sqcaps,\n  sqcup,\n  sqcups,\n  Sqrt,\n  sqsub,\n  sqsube,\n  sqsubset,\n  sqsubseteq,\n  sqsup,\n  sqsupe,\n  sqsupset,\n  sqsupseteq,\n  square,\n  Square,\n  SquareIntersection,\n  SquareSubset,\n  SquareSubsetEqual,\n  SquareSuperset,\n  SquareSupersetEqual,\n  SquareUnion,\n  squarf,\n  squ,\n  squf,\n  srarr,\n  Sscr,\n  sscr,\n  ssetmn,\n  ssmile,\n  sstarf,\n  Star,\n  star,\n  starf,\n  straightepsilon,\n  straightphi,\n  strns,\n  sub,\n  Sub,\n  subdot,\n  subE,\n  sube,\n  subedot,\n  submult,\n  subnE,\n  subne,\n  subplus,\n  subrarr,\n  subset,\n  Subset,\n  subseteq,\n  subseteqq,\n  SubsetEqual,\n  subsetneq,\n  subsetneqq,\n  subsim,\n  subsub,\n  subsup,\n  succapprox,\n  succ,\n  succcurlyeq,\n  Succeeds,\n  SucceedsEqual,\n  SucceedsSlantEqual,\n  SucceedsTilde,\n  succeq,\n  succnapprox,\n  succneqq,\n  succnsim,\n  succsim,\n  SuchThat,\n  sum,\n  Sum,\n  sung,\n  sup1,\n  sup2,\n  sup3,\n  sup,\n  Sup,\n  supdot,\n  supdsub,\n  supE,\n  supe,\n  supedot,\n  Superset,\n  SupersetEqual,\n  suphsol,\n  suphsub,\n  suplarr,\n  supmult,\n  supnE,\n  supne,\n  supplus,\n  supset,\n  Supset,\n  supseteq,\n  supseteqq,\n  supsetneq,\n  supsetneqq,\n  supsim,\n  supsub,\n  supsup,\n  swarhk,\n  swarr,\n  swArr,\n  swarrow,\n  swnwar,\n  szlig,\n  Tab: Tab$1,\n  target,\n  Tau,\n  tau,\n  tbrk,\n  Tcaron,\n  tcaron,\n  Tcedil,\n  tcedil,\n  Tcy,\n  tcy,\n  tdot,\n  telrec,\n  Tfr,\n  tfr,\n  there4,\n  therefore,\n  Therefore,\n  Theta,\n  theta,\n  thetasym,\n  thetav,\n  thickapprox,\n  thicksim,\n  ThickSpace,\n  ThinSpace,\n  thinsp,\n  thkap,\n  thksim,\n  THORN,\n  thorn,\n  tilde,\n  Tilde,\n  TildeEqual,\n  TildeFullEqual,\n  TildeTilde,\n  timesbar,\n  timesb,\n  times,\n  timesd,\n  tint,\n  toea,\n  topbot,\n  topcir,\n  top,\n  Topf,\n  topf,\n  topfork,\n  tosa,\n  tprime,\n  trade,\n  TRADE,\n  triangle,\n  triangledown,\n  triangleleft,\n  trianglelefteq,\n  triangleq,\n  triangleright,\n  trianglerighteq,\n  tridot,\n  trie,\n  triminus,\n  TripleDot,\n  triplus,\n  trisb,\n  tritime,\n  trpezium,\n  Tscr,\n  tscr,\n  TScy,\n  tscy,\n  TSHcy,\n  tshcy,\n  Tstrok,\n  tstrok,\n  twixt,\n  twoheadleftarrow,\n  twoheadrightarrow,\n  Uacute,\n  uacute,\n  uarr,\n  Uarr,\n  uArr,\n  Uarrocir,\n  Ubrcy,\n  ubrcy,\n  Ubreve,\n  ubreve,\n  Ucirc,\n  ucirc,\n  Ucy,\n  ucy,\n  udarr,\n  Udblac,\n  udblac,\n  udhar,\n  ufisht,\n  Ufr,\n  ufr,\n  Ugrave,\n  ugrave,\n  uHar,\n  uharl,\n  uharr,\n  uhblk,\n  ulcorn,\n  ulcorner,\n  ulcrop,\n  ultri,\n  Umacr,\n  umacr,\n  uml,\n  UnderBar,\n  UnderBrace,\n  UnderBracket,\n  UnderParenthesis,\n  Union,\n  UnionPlus,\n  Uogon,\n  uogon,\n  Uopf,\n  uopf,\n  UpArrowBar,\n  uparrow,\n  UpArrow,\n  Uparrow,\n  UpArrowDownArrow,\n  updownarrow,\n  UpDownArrow,\n  Updownarrow,\n  UpEquilibrium,\n  upharpoonleft,\n  upharpoonright,\n  uplus,\n  UpperLeftArrow,\n  UpperRightArrow,\n  upsi,\n  Upsi,\n  upsih,\n  Upsilon,\n  upsilon,\n  UpTeeArrow,\n  UpTee,\n  upuparrows,\n  urcorn,\n  urcorner,\n  urcrop,\n  Uring,\n  uring,\n  urtri,\n  Uscr,\n  uscr,\n  utdot,\n  Utilde,\n  utilde,\n  utri,\n  utrif,\n  uuarr,\n  Uuml,\n  uuml,\n  uwangle,\n  vangrt,\n  varepsilon,\n  varkappa,\n  varnothing,\n  varphi,\n  varpi,\n  varpropto,\n  varr,\n  vArr,\n  varrho,\n  varsigma,\n  varsubsetneq,\n  varsubsetneqq,\n  varsupsetneq,\n  varsupsetneqq,\n  vartheta,\n  vartriangleleft,\n  vartriangleright,\n  vBar,\n  Vbar,\n  vBarv,\n  Vcy,\n  vcy,\n  vdash,\n  vDash,\n  Vdash,\n  VDash,\n  Vdashl,\n  veebar,\n  vee,\n  Vee,\n  veeeq,\n  vellip,\n  verbar,\n  Verbar,\n  vert,\n  Vert,\n  VerticalBar,\n  VerticalLine,\n  VerticalSeparator,\n  VerticalTilde,\n  VeryThinSpace,\n  Vfr,\n  vfr,\n  vltri,\n  vnsub,\n  vnsup,\n  Vopf,\n  vopf,\n  vprop,\n  vrtri,\n  Vscr,\n  vscr,\n  vsubnE,\n  vsubne,\n  vsupnE,\n  vsupne,\n  Vvdash,\n  vzigzag,\n  Wcirc,\n  wcirc,\n  wedbar,\n  wedge,\n  Wedge,\n  wedgeq,\n  weierp,\n  Wfr,\n  wfr,\n  Wopf,\n  wopf,\n  wp,\n  wr,\n  wreath,\n  Wscr,\n  wscr,\n  xcap,\n  xcirc,\n  xcup,\n  xdtri,\n  Xfr,\n  xfr,\n  xharr,\n  xhArr,\n  Xi,\n  xi,\n  xlarr,\n  xlArr,\n  xmap,\n  xnis,\n  xodot,\n  Xopf,\n  xopf,\n  xoplus,\n  xotime,\n  xrarr,\n  xrArr,\n  Xscr,\n  xscr,\n  xsqcup,\n  xuplus,\n  xutri,\n  xvee,\n  xwedge,\n  Yacute,\n  yacute,\n  YAcy,\n  yacy,\n  Ycirc,\n  ycirc,\n  Ycy,\n  ycy,\n  yen,\n  Yfr,\n  yfr,\n  YIcy,\n  yicy,\n  Yopf,\n  yopf,\n  Yscr,\n  yscr,\n  YUcy,\n  yucy,\n  yuml,\n  Yuml,\n  Zacute,\n  zacute,\n  Zcaron,\n  zcaron,\n  Zcy,\n  zcy,\n  Zdot,\n  zdot,\n  zeetrf,\n  ZeroWidthSpace,\n  Zeta,\n  zeta,\n  zfr,\n  Zfr,\n  ZHcy,\n  zhcy,\n  zigrarr,\n  zopf,\n  Zopf,\n  Zscr,\n  zscr,\n  zwj,\n  zwnj\n};\nvar entities$1 = require$$0;\nvar regex$4 = /[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/;\nvar mdurl$1 = {};\nvar encodeCache = {};\nfunction getEncodeCache(exclude) {\n  var i, ch2, cache = encodeCache[exclude];\n  if (cache) {\n    return cache;\n  }\n  cache = encodeCache[exclude] = [];\n  for (i = 0; i < 128; i++) {\n    ch2 = String.fromCharCode(i);\n    if (/^[0-9a-z]$/i.test(ch2)) {\n      cache.push(ch2);\n    } else {\n      cache.push(\"%\" + (\"0\" + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n  return cache;\n}\nfunction encode$1(string2, exclude, keepEscaped) {\n  var i, l2, code3, nextCode, cache, result2 = \"\";\n  if (typeof exclude !== \"string\") {\n    keepEscaped = exclude;\n    exclude = encode$1.defaultChars;\n  }\n  if (typeof keepEscaped === \"undefined\") {\n    keepEscaped = true;\n  }\n  cache = getEncodeCache(exclude);\n  for (i = 0, l2 = string2.length; i < l2; i++) {\n    code3 = string2.charCodeAt(i);\n    if (keepEscaped && code3 === 37 && i + 2 < l2) {\n      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {\n        result2 += string2.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n    if (code3 < 128) {\n      result2 += cache[code3];\n      continue;\n    }\n    if (code3 >= 55296 && code3 <= 57343) {\n      if (code3 >= 55296 && code3 <= 56319 && i + 1 < l2) {\n        nextCode = string2.charCodeAt(i + 1);\n        if (nextCode >= 56320 && nextCode <= 57343) {\n          result2 += encodeURIComponent(string2[i] + string2[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result2 += \"%EF%BF%BD\";\n      continue;\n    }\n    result2 += encodeURIComponent(string2[i]);\n  }\n  return result2;\n}\nencode$1.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode$1.componentChars = \"-_.!~*'()\";\nvar encode_1 = encode$1;\nvar decodeCache = {};\nfunction getDecodeCache(exclude) {\n  var i, ch2, cache = decodeCache[exclude];\n  if (cache) {\n    return cache;\n  }\n  cache = decodeCache[exclude] = [];\n  for (i = 0; i < 128; i++) {\n    ch2 = String.fromCharCode(i);\n    cache.push(ch2);\n  }\n  for (i = 0; i < exclude.length; i++) {\n    ch2 = exclude.charCodeAt(i);\n    cache[ch2] = \"%\" + (\"0\" + ch2.toString(16).toUpperCase()).slice(-2);\n  }\n  return cache;\n}\nfunction decode$1(string2, exclude) {\n  var cache;\n  if (typeof exclude !== \"string\") {\n    exclude = decode$1.defaultChars;\n  }\n  cache = getDecodeCache(exclude);\n  return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n    var i, l2, b1, b2, b3, b4, chr, result2 = \"\";\n    for (i = 0, l2 = seq.length; i < l2; i += 3) {\n      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n      if (b1 < 128) {\n        result2 += cache[b1];\n        continue;\n      }\n      if ((b1 & 224) === 192 && i + 3 < l2) {\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        if ((b2 & 192) === 128) {\n          chr = b1 << 6 & 1984 | b2 & 63;\n          if (chr < 128) {\n            result2 += \"\\uFFFD\\uFFFD\";\n          } else {\n            result2 += String.fromCharCode(chr);\n          }\n          i += 3;\n          continue;\n        }\n      }\n      if ((b1 & 240) === 224 && i + 6 < l2) {\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        if ((b2 & 192) === 128 && (b3 & 192) === 128) {\n          chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;\n          if (chr < 2048 || chr >= 55296 && chr <= 57343) {\n            result2 += \"\\uFFFD\\uFFFD\\uFFFD\";\n          } else {\n            result2 += String.fromCharCode(chr);\n          }\n          i += 6;\n          continue;\n        }\n      }\n      if ((b1 & 248) === 240 && i + 9 < l2) {\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {\n          chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;\n          if (chr < 65536 || chr > 1114111) {\n            result2 += \"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\";\n          } else {\n            chr -= 65536;\n            result2 += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));\n          }\n          i += 9;\n          continue;\n        }\n      }\n      result2 += \"\\uFFFD\";\n    }\n    return result2;\n  });\n}\ndecode$1.defaultChars = \";/?:@&=+$,#\";\ndecode$1.componentChars = \"\";\nvar decode_1 = decode$1;\nvar format = function format2(url) {\n  var result2 = \"\";\n  result2 += url.protocol || \"\";\n  result2 += url.slashes ? \"//\" : \"\";\n  result2 += url.auth ? url.auth + \"@\" : \"\";\n  if (url.hostname && url.hostname.indexOf(\":\") !== -1) {\n    result2 += \"[\" + url.hostname + \"]\";\n  } else {\n    result2 += url.hostname || \"\";\n  }\n  result2 += url.port ? \":\" + url.port : \"\";\n  result2 += url.pathname || \"\";\n  result2 += url.search || \"\";\n  result2 += url.hash || \"\";\n  return result2;\n};\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\nvar protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/, delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\t\"], unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims), autoEscape = [\"'\"].concat(unwise), nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape), hostEndingChars = [\"/\", \"?\", \"#\"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {\n  \"javascript\": true,\n  \"javascript:\": true\n}, slashedProtocol = {\n  \"http\": true,\n  \"https\": true,\n  \"ftp\": true,\n  \"gopher\": true,\n  \"file\": true,\n  \"http:\": true,\n  \"https:\": true,\n  \"ftp:\": true,\n  \"gopher:\": true,\n  \"file:\": true\n};\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) {\n    return url;\n  }\n  var u2 = new Url();\n  u2.parse(url, slashesDenoteHost);\n  return u2;\n}\nUrl.prototype.parse = function(url, slashesDenoteHost) {\n  var i, l2, lowerProto, hec, slashes, rest = url;\n  rest = rest.trim();\n  if (!slashesDenoteHost && url.split(\"#\").length === 1) {\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === \"//\";\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    var hostEnd = -1;\n    for (i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    var auth, atSign;\n    if (hostEnd === -1) {\n      atSign = rest.lastIndexOf(\"@\");\n    } else {\n      atSign = rest.lastIndexOf(\"@\", hostEnd);\n    }\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n    hostEnd = -1;\n    for (i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n    if (rest[hostEnd - 1] === \":\") {\n      hostEnd--;\n    }\n    var host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n    this.parseHost(host);\n    this.hostname = this.hostname || \"\";\n    var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (i = 0, l2 = hostparts.length; i < l2; i++) {\n        var part2 = hostparts[i];\n        if (!part2) {\n          continue;\n        }\n        if (!part2.match(hostnamePartPattern)) {\n          var newpart = \"\";\n          for (var j = 0, k = part2.length; j < k; j++) {\n            if (part2.charCodeAt(j) > 127) {\n              newpart += \"x\";\n            } else {\n              newpart += part2[j];\n            }\n          }\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part2.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join(\".\") + rest;\n            }\n            this.hostname = validParts.join(\".\");\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = \"\";\n    }\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n  var hash = rest.indexOf(\"#\");\n  if (hash !== -1) {\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf(\"?\");\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) {\n    this.pathname = rest;\n  }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = \"\";\n  }\n  return this;\n};\nUrl.prototype.parseHost = function(host) {\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== \":\") {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) {\n    this.hostname = host;\n  }\n};\nvar parse = urlParse;\nmdurl$1.encode = encode_1;\nmdurl$1.decode = decode_1;\nmdurl$1.format = format;\nmdurl$1.parse = parse;\nvar uc_micro = {};\nvar regex$3 = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar regex$2 = /[\\0-\\x1F\\x7F-\\x9F]/;\nvar regex$1 = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/;\nvar regex = /[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\nuc_micro.Any = regex$3;\nuc_micro.Cc = regex$2;\nuc_micro.Cf = regex$1;\nuc_micro.P = regex$4;\nuc_micro.Z = regex;\n(function(exports) {\n  function _class2(obj) {\n    return Object.prototype.toString.call(obj);\n  }\n  function isString2(obj) {\n    return _class2(obj) === \"[object String]\";\n  }\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  function has2(object, key) {\n    return _hasOwnProperty.call(object, key);\n  }\n  function assign2(obj) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    sources.forEach(function(source) {\n      if (!source) {\n        return;\n      }\n      if (typeof source !== \"object\") {\n        throw new TypeError(source + \"must be object\");\n      }\n      Object.keys(source).forEach(function(key) {\n        obj[key] = source[key];\n      });\n    });\n    return obj;\n  }\n  function arrayReplaceAt2(src, pos, newElements) {\n    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n  }\n  function isValidEntityCode2(c) {\n    if (c >= 55296 && c <= 57343) {\n      return false;\n    }\n    if (c >= 64976 && c <= 65007) {\n      return false;\n    }\n    if ((c & 65535) === 65535 || (c & 65535) === 65534) {\n      return false;\n    }\n    if (c >= 0 && c <= 8) {\n      return false;\n    }\n    if (c === 11) {\n      return false;\n    }\n    if (c >= 14 && c <= 31) {\n      return false;\n    }\n    if (c >= 127 && c <= 159) {\n      return false;\n    }\n    if (c > 1114111) {\n      return false;\n    }\n    return true;\n  }\n  function fromCodePoint2(c) {\n    if (c > 65535) {\n      c -= 65536;\n      var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);\n      return String.fromCharCode(surrogate1, surrogate2);\n    }\n    return String.fromCharCode(c);\n  }\n  var UNESCAPE_MD_RE = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\n  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\n  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + \"|\" + ENTITY_RE.source, \"gi\");\n  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n  var entities2 = entities$1;\n  function replaceEntityPattern(match2, name2) {\n    var code3 = 0;\n    if (has2(entities2, name2)) {\n      return entities2[name2];\n    }\n    if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {\n      code3 = name2[1].toLowerCase() === \"x\" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);\n      if (isValidEntityCode2(code3)) {\n        return fromCodePoint2(code3);\n      }\n    }\n    return match2;\n  }\n  function unescapeMd(str) {\n    if (str.indexOf(\"\\\\\") < 0) {\n      return str;\n    }\n    return str.replace(UNESCAPE_MD_RE, \"$1\");\n  }\n  function unescapeAll2(str) {\n    if (str.indexOf(\"\\\\\") < 0 && str.indexOf(\"&\") < 0) {\n      return str;\n    }\n    return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity3) {\n      if (escaped) {\n        return escaped;\n      }\n      return replaceEntityPattern(match2, entity3);\n    });\n  }\n  var HTML_ESCAPE_TEST_RE = /[&<>\"]/;\n  var HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\n  var HTML_REPLACEMENTS = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\"\n  };\n  function replaceUnsafeChar(ch2) {\n    return HTML_REPLACEMENTS[ch2];\n  }\n  function escapeHtml2(str) {\n    if (HTML_ESCAPE_TEST_RE.test(str)) {\n      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n    }\n    return str;\n  }\n  var REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n  function escapeRE2(str) {\n    return str.replace(REGEXP_ESCAPE_RE, \"\\\\$&\");\n  }\n  function isSpace2(code3) {\n    switch (code3) {\n      case 9:\n      case 32:\n        return true;\n    }\n    return false;\n  }\n  function isWhiteSpace2(code3) {\n    if (code3 >= 8192 && code3 <= 8202) {\n      return true;\n    }\n    switch (code3) {\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 32:\n      case 160:\n      case 5760:\n      case 8239:\n      case 8287:\n      case 12288:\n        return true;\n    }\n    return false;\n  }\n  var UNICODE_PUNCT_RE = regex$4;\n  function isPunctChar2(ch2) {\n    return UNICODE_PUNCT_RE.test(ch2);\n  }\n  function isMdAsciiPunct2(ch2) {\n    switch (ch2) {\n      case 33:\n      case 34:\n      case 35:\n      case 36:\n      case 37:\n      case 38:\n      case 39:\n      case 40:\n      case 41:\n      case 42:\n      case 43:\n      case 44:\n      case 45:\n      case 46:\n      case 47:\n      case 58:\n      case 59:\n      case 60:\n      case 61:\n      case 62:\n      case 63:\n      case 64:\n      case 91:\n      case 92:\n      case 93:\n      case 94:\n      case 95:\n      case 96:\n      case 123:\n      case 124:\n      case 125:\n      case 126:\n        return true;\n      default:\n        return false;\n    }\n  }\n  function normalizeReference2(str) {\n    str = str.trim().replace(/\\s+/g, \" \");\n    if (\"\\u1E9E\".toLowerCase() === \"\\u1E7E\") {\n      str = str.replace(/ẞ/g, \"\\xDF\");\n    }\n    return str.toLowerCase().toUpperCase();\n  }\n  exports.lib = {};\n  exports.lib.mdurl = mdurl$1;\n  exports.lib.ucmicro = uc_micro;\n  exports.assign = assign2;\n  exports.isString = isString2;\n  exports.has = has2;\n  exports.unescapeMd = unescapeMd;\n  exports.unescapeAll = unescapeAll2;\n  exports.isValidEntityCode = isValidEntityCode2;\n  exports.fromCodePoint = fromCodePoint2;\n  exports.escapeHtml = escapeHtml2;\n  exports.arrayReplaceAt = arrayReplaceAt2;\n  exports.isSpace = isSpace2;\n  exports.isWhiteSpace = isWhiteSpace2;\n  exports.isMdAsciiPunct = isMdAsciiPunct2;\n  exports.isPunctChar = isPunctChar2;\n  exports.escapeRE = escapeRE2;\n  exports.normalizeReference = normalizeReference2;\n})(utils$1);\nvar helpers$1 = {};\nvar parse_link_label = function parseLinkLabel(state, start2, disableNested) {\n  var level, found, marker2, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;\n  state.pos = start2 + 1;\n  level = 1;\n  while (state.pos < max) {\n    marker2 = state.src.charCodeAt(state.pos);\n    if (marker2 === 93) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker2 === 91) {\n      if (prevPos === state.pos - 1) {\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n  if (found) {\n    labelEnd = state.pos;\n  }\n  state.pos = oldPos;\n  return labelEnd;\n};\nvar unescapeAll$2 = utils$1.unescapeAll;\nvar parse_link_destination = function parseLinkDestination(str, pos, max) {\n  var code3, level, lines = 0, start2 = pos, result2 = {\n    ok: false,\n    pos: 0,\n    lines: 0,\n    str: \"\"\n  };\n  if (str.charCodeAt(pos) === 60) {\n    pos++;\n    while (pos < max) {\n      code3 = str.charCodeAt(pos);\n      if (code3 === 10) {\n        return result2;\n      }\n      if (code3 === 60) {\n        return result2;\n      }\n      if (code3 === 62) {\n        result2.pos = pos + 1;\n        result2.str = unescapeAll$2(str.slice(start2 + 1, pos));\n        result2.ok = true;\n        return result2;\n      }\n      if (code3 === 92 && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n      pos++;\n    }\n    return result2;\n  }\n  level = 0;\n  while (pos < max) {\n    code3 = str.charCodeAt(pos);\n    if (code3 === 32) {\n      break;\n    }\n    if (code3 < 32 || code3 === 127) {\n      break;\n    }\n    if (code3 === 92 && pos + 1 < max) {\n      if (str.charCodeAt(pos + 1) === 32) {\n        break;\n      }\n      pos += 2;\n      continue;\n    }\n    if (code3 === 40) {\n      level++;\n      if (level > 32) {\n        return result2;\n      }\n    }\n    if (code3 === 41) {\n      if (level === 0) {\n        break;\n      }\n      level--;\n    }\n    pos++;\n  }\n  if (start2 === pos) {\n    return result2;\n  }\n  if (level !== 0) {\n    return result2;\n  }\n  result2.str = unescapeAll$2(str.slice(start2, pos));\n  result2.lines = lines;\n  result2.pos = pos;\n  result2.ok = true;\n  return result2;\n};\nvar unescapeAll$1 = utils$1.unescapeAll;\nvar parse_link_title = function parseLinkTitle(str, pos, max) {\n  var code3, marker2, lines = 0, start2 = pos, result2 = {\n    ok: false,\n    pos: 0,\n    lines: 0,\n    str: \"\"\n  };\n  if (pos >= max) {\n    return result2;\n  }\n  marker2 = str.charCodeAt(pos);\n  if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {\n    return result2;\n  }\n  pos++;\n  if (marker2 === 40) {\n    marker2 = 41;\n  }\n  while (pos < max) {\n    code3 = str.charCodeAt(pos);\n    if (code3 === marker2) {\n      result2.pos = pos + 1;\n      result2.lines = lines;\n      result2.str = unescapeAll$1(str.slice(start2 + 1, pos));\n      result2.ok = true;\n      return result2;\n    } else if (code3 === 40 && marker2 === 41) {\n      return result2;\n    } else if (code3 === 10) {\n      lines++;\n    } else if (code3 === 92 && pos + 1 < max) {\n      pos++;\n      if (str.charCodeAt(pos) === 10) {\n        lines++;\n      }\n    }\n    pos++;\n  }\n  return result2;\n};\nhelpers$1.parseLinkLabel = parse_link_label;\nhelpers$1.parseLinkDestination = parse_link_destination;\nhelpers$1.parseLinkTitle = parse_link_title;\nvar assign$1 = utils$1.assign;\nvar unescapeAll = utils$1.unescapeAll;\nvar escapeHtml$1 = utils$1.escapeHtml;\nvar default_rules = {};\ndefault_rules.code_inline = function(tokens, idx, options, env, slf) {\n  var token2 = tokens[idx];\n  return \"<code\" + slf.renderAttrs(token2) + \">\" + escapeHtml$1(tokens[idx].content) + \"</code>\";\n};\ndefault_rules.code_block = function(tokens, idx, options, env, slf) {\n  var token2 = tokens[idx];\n  return \"<pre\" + slf.renderAttrs(token2) + \"><code>\" + escapeHtml$1(tokens[idx].content) + \"</code></pre>\\n\";\n};\ndefault_rules.fence = function(tokens, idx, options, env, slf) {\n  var token2 = tokens[idx], info2 = token2.info ? unescapeAll(token2.info).trim() : \"\", langName = \"\", langAttrs = \"\", highlighted, i, arr, tmpAttrs, tmpToken;\n  if (info2) {\n    arr = info2.split(/(\\s+)/g);\n    langName = arr[0];\n    langAttrs = arr.slice(2).join(\"\");\n  }\n  if (options.highlight) {\n    highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml$1(token2.content);\n  } else {\n    highlighted = escapeHtml$1(token2.content);\n  }\n  if (highlighted.indexOf(\"<pre\") === 0) {\n    return highlighted + \"\\n\";\n  }\n  if (info2) {\n    i = token2.attrIndex(\"class\");\n    tmpAttrs = token2.attrs ? token2.attrs.slice() : [];\n    if (i < 0) {\n      tmpAttrs.push([\"class\", options.langPrefix + langName]);\n    } else {\n      tmpAttrs[i] = tmpAttrs[i].slice();\n      tmpAttrs[i][1] += \" \" + options.langPrefix + langName;\n    }\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n    return \"<pre><code\" + slf.renderAttrs(tmpToken) + \">\" + highlighted + \"</code></pre>\\n\";\n  }\n  return \"<pre><code\" + slf.renderAttrs(token2) + \">\" + highlighted + \"</code></pre>\\n\";\n};\ndefault_rules.image = function(tokens, idx, options, env, slf) {\n  var token2 = tokens[idx];\n  token2.attrs[token2.attrIndex(\"alt\")][1] = slf.renderInlineAsText(token2.children, options, env);\n  return slf.renderToken(tokens, idx, options);\n};\ndefault_rules.hardbreak = function(tokens, idx, options) {\n  return options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\";\n};\ndefault_rules.softbreak = function(tokens, idx, options) {\n  return options.breaks ? options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\" : \"\\n\";\n};\ndefault_rules.text = function(tokens, idx) {\n  return escapeHtml$1(tokens[idx].content);\n};\ndefault_rules.html_block = function(tokens, idx) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function(tokens, idx) {\n  return tokens[idx].content;\n};\nfunction Renderer$1() {\n  this.rules = assign$1({}, default_rules);\n}\nRenderer$1.prototype.renderAttrs = function renderAttrs(token2) {\n  var i, l2, result2;\n  if (!token2.attrs) {\n    return \"\";\n  }\n  result2 = \"\";\n  for (i = 0, l2 = token2.attrs.length; i < l2; i++) {\n    result2 += \" \" + escapeHtml$1(token2.attrs[i][0]) + '=\"' + escapeHtml$1(token2.attrs[i][1]) + '\"';\n  }\n  return result2;\n};\nRenderer$1.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken, result2 = \"\", needLf = false, token2 = tokens[idx];\n  if (token2.hidden) {\n    return \"\";\n  }\n  if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result2 += \"\\n\";\n  }\n  result2 += (token2.nesting === -1 ? \"</\" : \"<\") + token2.tag;\n  result2 += this.renderAttrs(token2);\n  if (token2.nesting === 0 && options.xhtmlOut) {\n    result2 += \" /\";\n  }\n  if (token2.block) {\n    needLf = true;\n    if (token2.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n        if (nextToken.type === \"inline\" || nextToken.hidden) {\n          needLf = false;\n        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {\n          needLf = false;\n        }\n      }\n    }\n  }\n  result2 += needLf ? \">\\n\" : \">\";\n  return result2;\n};\nRenderer$1.prototype.renderInline = function(tokens, options, env) {\n  var type2, result2 = \"\", rules = this.rules;\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type2 = tokens[i].type;\n    if (typeof rules[type2] !== \"undefined\") {\n      result2 += rules[type2](tokens, i, options, env, this);\n    } else {\n      result2 += this.renderToken(tokens, i, options);\n    }\n  }\n  return result2;\n};\nRenderer$1.prototype.renderInlineAsText = function(tokens, options, env) {\n  var result2 = \"\";\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === \"text\") {\n      result2 += tokens[i].content;\n    } else if (tokens[i].type === \"image\") {\n      result2 += this.renderInlineAsText(tokens[i].children, options, env);\n    } else if (tokens[i].type === \"softbreak\") {\n      result2 += \"\\n\";\n    }\n  }\n  return result2;\n};\nRenderer$1.prototype.render = function(tokens, options, env) {\n  var i, len, type2, result2 = \"\", rules = this.rules;\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type2 = tokens[i].type;\n    if (type2 === \"inline\") {\n      result2 += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type2] !== \"undefined\") {\n      result2 += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result2 += this.renderToken(tokens, i, options, env);\n    }\n  }\n  return result2;\n};\nvar renderer = Renderer$1;\nfunction Ruler$3() {\n  this.__rules__ = [];\n  this.__cache__ = null;\n}\nRuler$3.prototype.__find__ = function(name2) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name2) {\n      return i;\n    }\n  }\n  return -1;\n};\nRuler$3.prototype.__compile__ = function() {\n  var self2 = this;\n  var chains = [\"\"];\n  self2.__rules__.forEach(function(rule) {\n    if (!rule.enabled) {\n      return;\n    }\n    rule.alt.forEach(function(altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n  self2.__cache__ = {};\n  chains.forEach(function(chain) {\n    self2.__cache__[chain] = [];\n    self2.__rules__.forEach(function(rule) {\n      if (!rule.enabled) {\n        return;\n      }\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n      self2.__cache__[chain].push(rule.fn);\n    });\n  });\n};\nRuler$3.prototype.at = function(name2, fn, options) {\n  var index = this.__find__(name2);\n  var opt2 = options || {};\n  if (index === -1) {\n    throw new Error(\"Parser rule not found: \" + name2);\n  }\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt2.alt || [];\n  this.__cache__ = null;\n};\nRuler$3.prototype.before = function(beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt2 = options || {};\n  if (index === -1) {\n    throw new Error(\"Parser rule not found: \" + beforeName);\n  }\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt2.alt || []\n  });\n  this.__cache__ = null;\n};\nRuler$3.prototype.after = function(afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt2 = options || {};\n  if (index === -1) {\n    throw new Error(\"Parser rule not found: \" + afterName);\n  }\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt2.alt || []\n  });\n  this.__cache__ = null;\n};\nRuler$3.prototype.push = function(ruleName, fn, options) {\n  var opt2 = options || {};\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt2.alt || []\n  });\n  this.__cache__ = null;\n};\nRuler$3.prototype.enable = function(list3, ignoreInvalid) {\n  if (!Array.isArray(list3)) {\n    list3 = [list3];\n  }\n  var result2 = [];\n  list3.forEach(function(name2) {\n    var idx = this.__find__(name2);\n    if (idx < 0) {\n      if (ignoreInvalid) {\n        return;\n      }\n      throw new Error(\"Rules manager: invalid rule name \" + name2);\n    }\n    this.__rules__[idx].enabled = true;\n    result2.push(name2);\n  }, this);\n  this.__cache__ = null;\n  return result2;\n};\nRuler$3.prototype.enableOnly = function(list3, ignoreInvalid) {\n  if (!Array.isArray(list3)) {\n    list3 = [list3];\n  }\n  this.__rules__.forEach(function(rule) {\n    rule.enabled = false;\n  });\n  this.enable(list3, ignoreInvalid);\n};\nRuler$3.prototype.disable = function(list3, ignoreInvalid) {\n  if (!Array.isArray(list3)) {\n    list3 = [list3];\n  }\n  var result2 = [];\n  list3.forEach(function(name2) {\n    var idx = this.__find__(name2);\n    if (idx < 0) {\n      if (ignoreInvalid) {\n        return;\n      }\n      throw new Error(\"Rules manager: invalid rule name \" + name2);\n    }\n    this.__rules__[idx].enabled = false;\n    result2.push(name2);\n  }, this);\n  this.__cache__ = null;\n  return result2;\n};\nRuler$3.prototype.getRules = function(chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n  return this.__cache__[chainName] || [];\n};\nvar ruler = Ruler$3;\nvar NEWLINES_RE = /\\r\\n?|\\n/g;\nvar NULL_RE = /\\0/g;\nvar normalize = function normalize2(state) {\n  var str;\n  str = state.src.replace(NEWLINES_RE, \"\\n\");\n  str = str.replace(NULL_RE, \"\\uFFFD\");\n  state.src = str;\n};\nvar block$1 = function block(state) {\n  var token2;\n  if (state.inlineMode) {\n    token2 = new state.Token(\"inline\", \"\", 0);\n    token2.content = state.src;\n    token2.map = [0, 1];\n    token2.children = [];\n    state.tokens.push(token2);\n  } else {\n    state.md.block.parse(state.src, state.md, state.env, state.tokens);\n  }\n};\nvar inline = function inline2(state) {\n  var tokens = state.tokens, tok, i, l2;\n  for (i = 0, l2 = tokens.length; i < l2; i++) {\n    tok = tokens[i];\n    if (tok.type === \"inline\") {\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n    }\n  }\n};\nvar arrayReplaceAt = utils$1.arrayReplaceAt;\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\nvar linkify = function linkify2(state) {\n  var i, j, l2, tokens, token2, currentToken, nodes, ln, text3, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;\n  if (!state.md.options.linkify) {\n    return;\n  }\n  for (j = 0, l2 = blockTokens.length; j < l2; j++) {\n    if (blockTokens[j].type !== \"inline\" || !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n    tokens = blockTokens[j].children;\n    htmlLinkLevel = 0;\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n      if (currentToken.type === \"link_close\") {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== \"link_open\") {\n          i--;\n        }\n        continue;\n      }\n      if (currentToken.type === \"html_inline\") {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n      if (currentToken.type === \"text\" && state.md.linkify.test(currentToken.content)) {\n        text3 = currentToken.content;\n        links = state.md.linkify.match(text3);\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n        for (ln = 0; ln < links.length; ln++) {\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) {\n            continue;\n          }\n          urlText = links[ln].text;\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText(\"http://\" + urlText).replace(/^http:\\/\\//, \"\");\n          } else if (links[ln].schema === \"mailto:\" && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText(\"mailto:\" + urlText).replace(/^mailto:/, \"\");\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n          pos = links[ln].index;\n          if (pos > lastPos) {\n            token2 = new state.Token(\"text\", \"\", 0);\n            token2.content = text3.slice(lastPos, pos);\n            token2.level = level;\n            nodes.push(token2);\n          }\n          token2 = new state.Token(\"link_open\", \"a\", 1);\n          token2.attrs = [[\"href\", fullUrl]];\n          token2.level = level++;\n          token2.markup = \"linkify\";\n          token2.info = \"auto\";\n          nodes.push(token2);\n          token2 = new state.Token(\"text\", \"\", 0);\n          token2.content = urlText;\n          token2.level = level;\n          nodes.push(token2);\n          token2 = new state.Token(\"link_close\", \"a\", -1);\n          token2.level = --level;\n          token2.markup = \"linkify\";\n          token2.info = \"auto\";\n          nodes.push(token2);\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text3.length) {\n          token2 = new state.Token(\"text\", \"\", 0);\n          token2.content = text3.slice(lastPos);\n          token2.level = level;\n          nodes.push(token2);\n        }\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\nvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  c: \"\\xA9\",\n  r: \"\\xAE\",\n  p: \"\\xA7\",\n  tm: \"\\u2122\"\n};\nfunction replaceFn(match2, name2) {\n  return SCOPED_ABBR[name2.toLowerCase()];\n}\nfunction replace_scoped(inlineTokens) {\n  var i, token2, inside_autolink = 0;\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token2 = inlineTokens[i];\n    if (token2.type === \"text\" && !inside_autolink) {\n      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);\n    }\n    if (token2.type === \"link_open\" && token2.info === \"auto\") {\n      inside_autolink--;\n    }\n    if (token2.type === \"link_close\" && token2.info === \"auto\") {\n      inside_autolink++;\n    }\n  }\n}\nfunction replace_rare(inlineTokens) {\n  var i, token2, inside_autolink = 0;\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token2 = inlineTokens[i];\n    if (token2.type === \"text\" && !inside_autolink) {\n      if (RARE_RE.test(token2.content)) {\n        token2.content = token2.content.replace(/\\+-/g, \"\\xB1\").replace(/\\.{2,}/g, \"\\u2026\").replace(/([?!])…/g, \"$1..\").replace(/([?!]){4,}/g, \"$1$1$1\").replace(/,{2,}/g, \",\").replace(/(^|[^-])---(?=[^-]|$)/mg, \"$1\\u2014\").replace(/(^|\\s)--(?=\\s|$)/mg, \"$1\\u2013\").replace(/(^|[^-\\s])--(?=[^-\\s]|$)/mg, \"$1\\u2013\");\n      }\n    }\n    if (token2.type === \"link_open\" && token2.info === \"auto\") {\n      inside_autolink--;\n    }\n    if (token2.type === \"link_close\" && token2.info === \"auto\") {\n      inside_autolink++;\n    }\n  }\n}\nvar replacements = function replace(state) {\n  var blkIdx;\n  if (!state.md.options.typographer) {\n    return;\n  }\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== \"inline\") {\n      continue;\n    }\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n      replace_scoped(state.tokens[blkIdx].children);\n    }\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n      replace_rare(state.tokens[blkIdx].children);\n    }\n  }\n};\nvar isWhiteSpace$1 = utils$1.isWhiteSpace;\nvar isPunctChar$1 = utils$1.isPunctChar;\nvar isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = \"\\u2019\";\nfunction replaceAt(str, index, ch2) {\n  return str.substr(0, index) + ch2 + str.substr(index + 1);\n}\nfunction process_inlines(tokens, state) {\n  var i, token2, text3, t2, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n  stack = [];\n  for (i = 0; i < tokens.length; i++) {\n    token2 = tokens[i];\n    thisLevel = tokens[i].level;\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) {\n        break;\n      }\n    }\n    stack.length = j + 1;\n    if (token2.type !== \"text\") {\n      continue;\n    }\n    text3 = token2.content;\n    pos = 0;\n    max = text3.length;\n    OUTER:\n      while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t2 = QUOTE_RE.exec(text3);\n        if (!t2) {\n          break;\n        }\n        canOpen = canClose = true;\n        pos = t2.index + 1;\n        isSingle = t2[0] === \"'\";\n        lastChar = 32;\n        if (t2.index - 1 >= 0) {\n          lastChar = text3.charCodeAt(t2.index - 1);\n        } else {\n          for (j = i - 1; j >= 0; j--) {\n            if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\")\n              break;\n            if (!tokens[j].content)\n              continue;\n            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n            break;\n          }\n        }\n        nextChar = 32;\n        if (pos < max) {\n          nextChar = text3.charCodeAt(pos);\n        } else {\n          for (j = i + 1; j < tokens.length; j++) {\n            if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\")\n              break;\n            if (!tokens[j].content)\n              continue;\n            nextChar = tokens[j].content.charCodeAt(0);\n            break;\n          }\n        }\n        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));\n        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));\n        isLastWhiteSpace = isWhiteSpace$1(lastChar);\n        isNextWhiteSpace = isWhiteSpace$1(nextChar);\n        if (isNextWhiteSpace) {\n          canOpen = false;\n        } else if (isNextPunctChar) {\n          if (!(isLastWhiteSpace || isLastPunctChar)) {\n            canOpen = false;\n          }\n        }\n        if (isLastWhiteSpace) {\n          canClose = false;\n        } else if (isLastPunctChar) {\n          if (!(isNextWhiteSpace || isNextPunctChar)) {\n            canClose = false;\n          }\n        }\n        if (nextChar === 34 && t2[0] === '\"') {\n          if (lastChar >= 48 && lastChar <= 57) {\n            canClose = canOpen = false;\n          }\n        }\n        if (canOpen && canClose) {\n          canOpen = isLastPunctChar;\n          canClose = isNextPunctChar;\n        }\n        if (!canOpen && !canClose) {\n          if (isSingle) {\n            token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);\n          }\n          continue;\n        }\n        if (canClose) {\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n            if (stack[j].level < thisLevel) {\n              break;\n            }\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n              if (isSingle) {\n                openQuote = state.md.options.quotes[2];\n                closeQuote = state.md.options.quotes[3];\n              } else {\n                openQuote = state.md.options.quotes[0];\n                closeQuote = state.md.options.quotes[1];\n              }\n              token2.content = replaceAt(token2.content, t2.index, closeQuote);\n              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);\n              pos += closeQuote.length - 1;\n              if (item.token === i) {\n                pos += openQuote.length - 1;\n              }\n              text3 = token2.content;\n              max = text3.length;\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t2.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);\n        }\n      }\n  }\n}\nvar smartquotes = function smartquotes2(state) {\n  var blkIdx;\n  if (!state.md.options.typographer) {\n    return;\n  }\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== \"inline\" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\nfunction Token$3(type2, tag, nesting) {\n  this.type = type2;\n  this.tag = tag;\n  this.attrs = null;\n  this.map = null;\n  this.nesting = nesting;\n  this.level = 0;\n  this.children = null;\n  this.content = \"\";\n  this.markup = \"\";\n  this.info = \"\";\n  this.meta = null;\n  this.block = false;\n  this.hidden = false;\n}\nToken$3.prototype.attrIndex = function attrIndex(name2) {\n  var attrs, i, len;\n  if (!this.attrs) {\n    return -1;\n  }\n  attrs = this.attrs;\n  for (i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name2) {\n      return i;\n    }\n  }\n  return -1;\n};\nToken$3.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [attrData];\n  }\n};\nToken$3.prototype.attrSet = function attrSet(name2, value) {\n  var idx = this.attrIndex(name2), attrData = [name2, value];\n  if (idx < 0) {\n    this.attrPush(attrData);\n  } else {\n    this.attrs[idx] = attrData;\n  }\n};\nToken$3.prototype.attrGet = function attrGet(name2) {\n  var idx = this.attrIndex(name2), value = null;\n  if (idx >= 0) {\n    value = this.attrs[idx][1];\n  }\n  return value;\n};\nToken$3.prototype.attrJoin = function attrJoin(name2, value) {\n  var idx = this.attrIndex(name2);\n  if (idx < 0) {\n    this.attrPush([name2, value]);\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + \" \" + value;\n  }\n};\nvar token = Token$3;\nvar Token$2 = token;\nfunction StateCore(src, md2, env) {\n  this.src = src;\n  this.env = env;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.md = md2;\n}\nStateCore.prototype.Token = Token$2;\nvar state_core = StateCore;\nvar Ruler$2 = ruler;\nvar _rules$2 = [\n  [\"normalize\", normalize],\n  [\"block\", block$1],\n  [\"inline\", inline],\n  [\"linkify\", linkify],\n  [\"replacements\", replacements],\n  [\"smartquotes\", smartquotes]\n];\nfunction Core() {\n  this.ruler = new Ruler$2();\n  for (var i = 0; i < _rules$2.length; i++) {\n    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n  }\n}\nCore.prototype.process = function(state) {\n  var i, l2, rules;\n  rules = this.ruler.getRules(\"\");\n  for (i = 0, l2 = rules.length; i < l2; i++) {\n    rules[i](state);\n  }\n};\nCore.prototype.State = state_core;\nvar parser_core = Core;\nvar isSpace$a = utils$1.isSpace;\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];\n  return state.src.substr(pos, max - pos);\n}\nfunction escapedSplit(str) {\n  var result2 = [], pos = 0, max = str.length, ch2, isEscaped = false, lastPos = 0, current = \"\";\n  ch2 = str.charCodeAt(pos);\n  while (pos < max) {\n    if (ch2 === 124) {\n      if (!isEscaped) {\n        result2.push(current + str.substring(lastPos, pos));\n        current = \"\";\n        lastPos = pos + 1;\n      } else {\n        current += str.substring(lastPos, pos - 1);\n        lastPos = pos;\n      }\n    }\n    isEscaped = ch2 === 92;\n    pos++;\n    ch2 = str.charCodeAt(pos);\n  }\n  result2.push(current + str.substring(lastPos));\n  return result2;\n}\nvar table = function table2(state, startLine, endLine, silent) {\n  var ch2, lineText, pos, i, l2, nextLine, columns, columnCount, token2, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n  nextLine = startLine + 1;\n  if (state.sCount[nextLine] < state.blkIndent) {\n    return false;\n  }\n  if (state.sCount[nextLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n  firstCh = state.src.charCodeAt(pos++);\n  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {\n    return false;\n  }\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n  secondCh = state.src.charCodeAt(pos++);\n  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {\n    return false;\n  }\n  if (firstCh === 45 && isSpace$a(secondCh)) {\n    return false;\n  }\n  while (pos < state.eMarks[nextLine]) {\n    ch2 = state.src.charCodeAt(pos);\n    if (ch2 !== 124 && ch2 !== 45 && ch2 !== 58 && !isSpace$a(ch2)) {\n      return false;\n    }\n    pos++;\n  }\n  lineText = getLine(state, startLine + 1);\n  columns = lineText.split(\"|\");\n  aligns = [];\n  for (i = 0; i < columns.length; i++) {\n    t2 = columns[i].trim();\n    if (!t2) {\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n    if (!/^:?-+:?$/.test(t2)) {\n      return false;\n    }\n    if (t2.charCodeAt(t2.length - 1) === 58) {\n      aligns.push(t2.charCodeAt(0) === 58 ? \"center\" : \"right\");\n    } else if (t2.charCodeAt(0) === 58) {\n      aligns.push(\"left\");\n    } else {\n      aligns.push(\"\");\n    }\n  }\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf(\"|\") === -1) {\n    return false;\n  }\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  columns = escapedSplit(lineText);\n  if (columns.length && columns[0] === \"\")\n    columns.shift();\n  if (columns.length && columns[columns.length - 1] === \"\")\n    columns.pop();\n  columnCount = columns.length;\n  if (columnCount === 0 || columnCount !== aligns.length) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  oldParentType = state.parentType;\n  state.parentType = \"table\";\n  terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n  token2 = state.push(\"table_open\", \"table\", 1);\n  token2.map = tableLines = [startLine, 0];\n  token2 = state.push(\"thead_open\", \"thead\", 1);\n  token2.map = [startLine, startLine + 1];\n  token2 = state.push(\"tr_open\", \"tr\", 1);\n  token2.map = [startLine, startLine + 1];\n  for (i = 0; i < columns.length; i++) {\n    token2 = state.push(\"th_open\", \"th\", 1);\n    if (aligns[i]) {\n      token2.attrs = [[\"style\", \"text-align:\" + aligns[i]]];\n    }\n    token2 = state.push(\"inline\", \"\", 0);\n    token2.content = columns[i].trim();\n    token2.children = [];\n    token2 = state.push(\"th_close\", \"th\", -1);\n  }\n  token2 = state.push(\"tr_close\", \"tr\", -1);\n  token2 = state.push(\"thead_close\", \"thead\", -1);\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n    terminate = false;\n    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n    lineText = getLine(state, nextLine).trim();\n    if (!lineText) {\n      break;\n    }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      break;\n    }\n    columns = escapedSplit(lineText);\n    if (columns.length && columns[0] === \"\")\n      columns.shift();\n    if (columns.length && columns[columns.length - 1] === \"\")\n      columns.pop();\n    if (nextLine === startLine + 2) {\n      token2 = state.push(\"tbody_open\", \"tbody\", 1);\n      token2.map = tbodyLines = [startLine + 2, 0];\n    }\n    token2 = state.push(\"tr_open\", \"tr\", 1);\n    token2.map = [nextLine, nextLine + 1];\n    for (i = 0; i < columnCount; i++) {\n      token2 = state.push(\"td_open\", \"td\", 1);\n      if (aligns[i]) {\n        token2.attrs = [[\"style\", \"text-align:\" + aligns[i]]];\n      }\n      token2 = state.push(\"inline\", \"\", 0);\n      token2.content = columns[i] ? columns[i].trim() : \"\";\n      token2.children = [];\n      token2 = state.push(\"td_close\", \"td\", -1);\n    }\n    token2 = state.push(\"tr_close\", \"tr\", -1);\n  }\n  if (tbodyLines) {\n    token2 = state.push(\"tbody_close\", \"tbody\", -1);\n    tbodyLines[1] = nextLine;\n  }\n  token2 = state.push(\"table_close\", \"table\", -1);\n  tableLines[1] = nextLine;\n  state.parentType = oldParentType;\n  state.line = nextLine;\n  return true;\n};\nvar code$2 = function code(state, startLine, endLine) {\n  var nextLine, last, token2;\n  if (state.sCount[startLine] - state.blkIndent < 4) {\n    return false;\n  }\n  last = nextLine = startLine + 1;\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n  state.line = last;\n  token2 = state.push(\"code_block\", \"code\", 0);\n  token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + \"\\n\";\n  token2.map = [startLine, state.line];\n  return true;\n};\nvar fence = function fence2(state, startLine, endLine, silent) {\n  var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (pos + 3 > max) {\n    return false;\n  }\n  marker2 = state.src.charCodeAt(pos);\n  if (marker2 !== 126 && marker2 !== 96) {\n    return false;\n  }\n  mem = pos;\n  pos = state.skipChars(pos, marker2);\n  len = pos - mem;\n  if (len < 3) {\n    return false;\n  }\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n  if (marker2 === 96) {\n    if (params.indexOf(String.fromCharCode(marker2)) >= 0) {\n      return false;\n    }\n  }\n  if (silent) {\n    return true;\n  }\n  nextLine = startLine;\n  for (; ; ) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      break;\n    }\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n    if (state.src.charCodeAt(pos) !== marker2) {\n      continue;\n    }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      continue;\n    }\n    pos = state.skipChars(pos, marker2);\n    if (pos - mem < len) {\n      continue;\n    }\n    pos = state.skipSpaces(pos);\n    if (pos < max) {\n      continue;\n    }\n    haveEndMarker = true;\n    break;\n  }\n  len = state.sCount[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  token2 = state.push(\"fence\", \"code\", 0);\n  token2.info = params;\n  token2.content = state.getLines(startLine + 1, nextLine, len, true);\n  token2.markup = markup;\n  token2.map = [startLine, state.line];\n  return true;\n};\nvar isSpace$9 = utils$1.isSpace;\nvar blockquote = function blockquote2(state, startLine, endLine, silent) {\n  var adjustTab, ch2, i, initial, l2, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (state.src.charCodeAt(pos++) !== 62) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  initial = offset = state.sCount[startLine] + 1;\n  if (state.src.charCodeAt(pos) === 32) {\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 9) {\n    spaceAfterMarker = true;\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos;\n  while (pos < max) {\n    ch2 = state.src.charCodeAt(pos);\n    if (isSpace$9(ch2)) {\n      if (ch2 === 9) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n    pos++;\n  }\n  oldBSCount = [state.bsCount[startLine]];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n  lastLineEmpty = pos >= max;\n  oldSCount = [state.sCount[startLine]];\n  state.sCount[startLine] = offset - initial;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n  oldParentType = state.parentType;\n  state.parentType = \"blockquote\";\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    isOutdented = state.sCount[nextLine] < state.blkIndent;\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n    if (pos >= max) {\n      break;\n    }\n    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {\n      initial = offset = state.sCount[nextLine] + 1;\n      if (state.src.charCodeAt(pos) === 32) {\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 9) {\n        spaceAfterMarker = true;\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n      while (pos < max) {\n        ch2 = state.src.charCodeAt(pos);\n        if (isSpace$9(ch2)) {\n          if (ch2 === 9) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n        pos++;\n      }\n      lastLineEmpty = pos >= max;\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n    if (lastLineEmpty) {\n      break;\n    }\n    terminate = false;\n    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      state.lineMax = nextLine;\n      if (state.blkIndent !== 0) {\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n      break;\n    }\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n    state.sCount[nextLine] = -1;\n  }\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  token2 = state.push(\"blockquote_open\", \"blockquote\", 1);\n  token2.markup = \">\";\n  token2.map = lines = [startLine, 0];\n  state.md.block.tokenize(state, startLine, nextLine);\n  token2 = state.push(\"blockquote_close\", \"blockquote\", -1);\n  token2.markup = \">\";\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n  return true;\n};\nvar isSpace$8 = utils$1.isSpace;\nvar hr = function hr2(state, startLine, endLine, silent) {\n  var marker2, cnt, ch2, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  marker2 = state.src.charCodeAt(pos++);\n  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {\n    return false;\n  }\n  cnt = 1;\n  while (pos < max) {\n    ch2 = state.src.charCodeAt(pos++);\n    if (ch2 !== marker2 && !isSpace$8(ch2)) {\n      return false;\n    }\n    if (ch2 === marker2) {\n      cnt++;\n    }\n  }\n  if (cnt < 3) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  state.line = startLine + 1;\n  token2 = state.push(\"hr\", \"hr\", 0);\n  token2.map = [startLine, state.line];\n  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));\n  return true;\n};\nvar isSpace$7 = utils$1.isSpace;\nfunction skipBulletListMarker(state, startLine) {\n  var marker2, pos, max, ch2;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n  marker2 = state.src.charCodeAt(pos++);\n  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {\n    return -1;\n  }\n  if (pos < max) {\n    ch2 = state.src.charCodeAt(pos);\n    if (!isSpace$7(ch2)) {\n      return -1;\n    }\n  }\n  return pos;\n}\nfunction skipOrderedListMarker(state, startLine) {\n  var ch2, start2 = state.bMarks[startLine] + state.tShift[startLine], pos = start2, max = state.eMarks[startLine];\n  if (pos + 1 >= max) {\n    return -1;\n  }\n  ch2 = state.src.charCodeAt(pos++);\n  if (ch2 < 48 || ch2 > 57) {\n    return -1;\n  }\n  for (; ; ) {\n    if (pos >= max) {\n      return -1;\n    }\n    ch2 = state.src.charCodeAt(pos++);\n    if (ch2 >= 48 && ch2 <= 57) {\n      if (pos - start2 >= 10) {\n        return -1;\n      }\n      continue;\n    }\n    if (ch2 === 41 || ch2 === 46) {\n      break;\n    }\n    return -1;\n  }\n  if (pos < max) {\n    ch2 = state.src.charCodeAt(pos);\n    if (!isSpace$7(ch2)) {\n      return -1;\n    }\n  }\n  return pos;\n}\nfunction markTightParagraphs(state, idx) {\n  var i, l2, level = state.level + 2;\n  for (i = idx + 2, l2 = state.tokens.length - 2; i < l2; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === \"paragraph_open\") {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\nvar list = function list2(state, startLine, endLine, silent) {\n  var ch2, contentStart, i, indent2, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {\n    return false;\n  }\n  if (silent && state.parentType === \"paragraph\") {\n    if (state.sCount[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start2 = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.slice(start2, posAfterMarker - 1));\n    if (isTerminatingParagraph && markerValue !== 1)\n      return false;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])\n      return false;\n  }\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n  if (silent) {\n    return true;\n  }\n  listTokIdx = state.tokens.length;\n  if (isOrdered) {\n    token2 = state.push(\"ordered_list_open\", \"ol\", 1);\n    if (markerValue !== 1) {\n      token2.attrs = [[\"start\", markerValue]];\n    }\n  } else {\n    token2 = state.push(\"bullet_list_open\", \"ul\", 1);\n  }\n  token2.map = listLines = [startLine, 0];\n  token2.markup = String.fromCharCode(markerCharCode);\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules(\"list\");\n  oldParentType = state.parentType;\n  state.parentType = \"list\";\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n    while (pos < max) {\n      ch2 = state.src.charCodeAt(pos);\n      if (ch2 === 9) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch2 === 32) {\n        offset++;\n      } else {\n        break;\n      }\n      pos++;\n    }\n    contentStart = pos;\n    if (contentStart >= max) {\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    }\n    indent2 = initial + indentAfterMarker;\n    token2 = state.push(\"list_item_open\", \"li\", 1);\n    token2.markup = String.fromCharCode(markerCharCode);\n    token2.map = itemLines = [startLine, 0];\n    if (isOrdered) {\n      token2.info = state.src.slice(start2, posAfterMarker - 1);\n    }\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent2;\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n    token2 = state.push(\"list_item_close\", \"li\", -1);\n    token2.markup = String.fromCharCode(markerCharCode);\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n    if (nextLine >= endLine) {\n      break;\n    }\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n      break;\n    }\n    terminate = false;\n    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n      start2 = state.bMarks[nextLine] + state.tShift[nextLine];\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  }\n  if (isOrdered) {\n    token2 = state.push(\"ordered_list_close\", \"ol\", -1);\n  } else {\n    token2 = state.push(\"bullet_list_close\", \"ul\", -1);\n  }\n  token2.markup = String.fromCharCode(markerCharCode);\n  listLines[1] = nextLine;\n  state.line = nextLine;\n  state.parentType = oldParentType;\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n  return true;\n};\nvar normalizeReference$2 = utils$1.normalizeReference;\nvar isSpace$6 = utils$1.isSpace;\nvar reference = function reference2(state, startLine, _endLine, silent) {\n  var ch2, destEndPos, destEndLineNo, endLine, href, i, l2, label, labelEnd, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (state.src.charCodeAt(pos) !== 91) {\n    return false;\n  }\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {\n      if (pos + 1 === max) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos + 1) !== 58) {\n        return false;\n      }\n      break;\n    }\n  }\n  endLine = state.lineMax;\n  terminatorRules = state.md.block.ruler.getRules(\"reference\");\n  oldParentType = state.parentType;\n  state.parentType = \"reference\";\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n    terminate = false;\n    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n  for (pos = 1; pos < max; pos++) {\n    ch2 = str.charCodeAt(pos);\n    if (ch2 === 91) {\n      return false;\n    } else if (ch2 === 93) {\n      labelEnd = pos;\n      break;\n    } else if (ch2 === 10) {\n      lines++;\n    } else if (ch2 === 92) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 10) {\n        lines++;\n      }\n    }\n  }\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {\n    return false;\n  }\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch2 = str.charCodeAt(pos);\n    if (ch2 === 10) {\n      lines++;\n    } else if (isSpace$6(ch2))\n      ;\n    else {\n      break;\n    }\n  }\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) {\n    return false;\n  }\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) {\n    return false;\n  }\n  pos = res.pos;\n  lines += res.lines;\n  destEndPos = pos;\n  destEndLineNo = lines;\n  start2 = pos;\n  for (; pos < max; pos++) {\n    ch2 = str.charCodeAt(pos);\n    if (ch2 === 10) {\n      lines++;\n    } else if (isSpace$6(ch2))\n      ;\n    else {\n      break;\n    }\n  }\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start2 !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = \"\";\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n  while (pos < max) {\n    ch2 = str.charCodeAt(pos);\n    if (!isSpace$6(ch2)) {\n      break;\n    }\n    pos++;\n  }\n  if (pos < max && str.charCodeAt(pos) !== 10) {\n    if (title) {\n      title = \"\";\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch2 = str.charCodeAt(pos);\n        if (!isSpace$6(ch2)) {\n          break;\n        }\n        pos++;\n      }\n    }\n  }\n  if (pos < max && str.charCodeAt(pos) !== 10) {\n    return false;\n  }\n  label = normalizeReference$2(str.slice(1, labelEnd));\n  if (!label) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  if (typeof state.env.references === \"undefined\") {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === \"undefined\") {\n    state.env.references[label] = { title, href };\n  }\n  state.parentType = oldParentType;\n  state.line = startLine + lines + 1;\n  return true;\n};\nvar html_blocks = [\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"base\",\n  \"basefont\",\n  \"blockquote\",\n  \"body\",\n  \"caption\",\n  \"center\",\n  \"col\",\n  \"colgroup\",\n  \"dd\",\n  \"details\",\n  \"dialog\",\n  \"dir\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"frame\",\n  \"frameset\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hr\",\n  \"html\",\n  \"iframe\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"menu\",\n  \"menuitem\",\n  \"nav\",\n  \"noframes\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"p\",\n  \"param\",\n  \"section\",\n  \"source\",\n  \"summary\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"ul\"\n];\nvar html_re = {};\nvar attr_name = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\nvar unquoted = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\nvar single_quoted = \"'[^']*'\";\nvar double_quoted = '\"[^\"]*\"';\nvar attr_value = \"(?:\" + unquoted + \"|\" + single_quoted + \"|\" + double_quoted + \")\";\nvar attribute = \"(?:\\\\s+\" + attr_name + \"(?:\\\\s*=\\\\s*\" + attr_value + \")?)\";\nvar open_tag = \"<[A-Za-z][A-Za-z0-9\\\\-]*\" + attribute + \"*\\\\s*\\\\/?>\";\nvar close_tag = \"<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>\";\nvar comment$3 = \"<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->\";\nvar processing = \"<[?][\\\\s\\\\S]*?[?]>\";\nvar declaration = \"<![A-Z]+\\\\s+[^>]*>\";\nvar cdata = \"<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\";\nvar HTML_TAG_RE$1 = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \"|\" + comment$3 + \"|\" + processing + \"|\" + declaration + \"|\" + cdata + \")\");\nvar HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \")\");\nhtml_re.HTML_TAG_RE = HTML_TAG_RE$1;\nhtml_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;\nvar block_names = html_blocks;\nvar HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;\nvar HTML_SEQUENCES = [\n  [/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true],\n  [/^<!--/, /-->/, true],\n  [/^<\\?/, /\\?>/, true],\n  [/^<![A-Z]/, />/, true],\n  [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n  [new RegExp(\"^</?(\" + block_names.join(\"|\") + \")(?=(\\\\s|/?>|$))\", \"i\"), /^$/, true],\n  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + \"\\\\s*$\"), /^$/, false]\n];\nvar html_block = function html_block2(state, startLine, endLine, silent) {\n  var i, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (!state.md.options.html) {\n    return false;\n  }\n  if (state.src.charCodeAt(pos) !== 60) {\n    return false;\n  }\n  lineText = state.src.slice(pos, max);\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) {\n      break;\n    }\n  }\n  if (i === HTML_SEQUENCES.length) {\n    return false;\n  }\n  if (silent) {\n    return HTML_SEQUENCES[i][2];\n  }\n  nextLine = startLine + 1;\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) {\n        break;\n      }\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) {\n          nextLine++;\n        }\n        break;\n      }\n    }\n  }\n  state.line = nextLine;\n  token2 = state.push(\"html_block\", \"\", 0);\n  token2.map = [startLine, nextLine];\n  token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n  return true;\n};\nvar isSpace$5 = utils$1.isSpace;\nvar heading = function heading2(state, startLine, endLine, silent) {\n  var ch2, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  ch2 = state.src.charCodeAt(pos);\n  if (ch2 !== 35 || pos >= max) {\n    return false;\n  }\n  level = 1;\n  ch2 = state.src.charCodeAt(++pos);\n  while (ch2 === 35 && pos < max && level <= 6) {\n    level++;\n    ch2 = state.src.charCodeAt(++pos);\n  }\n  if (level > 6 || pos < max && !isSpace$5(ch2)) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  max = state.skipSpacesBack(max, pos);\n  tmp = state.skipCharsBack(max, 35, pos);\n  if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {\n    max = tmp;\n  }\n  state.line = startLine + 1;\n  token2 = state.push(\"heading_open\", \"h\" + String(level), 1);\n  token2.markup = \"########\".slice(0, level);\n  token2.map = [startLine, state.line];\n  token2 = state.push(\"inline\", \"\", 0);\n  token2.content = state.src.slice(pos, max).trim();\n  token2.map = [startLine, state.line];\n  token2.children = [];\n  token2 = state.push(\"heading_close\", \"h\" + String(level), -1);\n  token2.markup = \"########\".slice(0, level);\n  return true;\n};\nvar lheading = function lheading2(state, startLine, endLine) {\n  var content, terminate, i, l2, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules(\"paragraph\");\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  oldParentType = state.parentType;\n  state.parentType = \"paragraph\";\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      if (pos < max) {\n        marker2 = state.src.charCodeAt(pos);\n        if (marker2 === 45 || marker2 === 61) {\n          pos = state.skipChars(pos, marker2);\n          pos = state.skipSpaces(pos);\n          if (pos >= max) {\n            level = marker2 === 61 ? 1 : 2;\n            break;\n          }\n        }\n      }\n    }\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n    terminate = false;\n    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  if (!level) {\n    return false;\n  }\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine + 1;\n  token2 = state.push(\"heading_open\", \"h\" + String(level), 1);\n  token2.markup = String.fromCharCode(marker2);\n  token2.map = [startLine, state.line];\n  token2 = state.push(\"inline\", \"\", 0);\n  token2.content = content;\n  token2.map = [startLine, state.line - 1];\n  token2.children = [];\n  token2 = state.push(\"heading_close\", \"h\" + String(level), -1);\n  token2.markup = String.fromCharCode(marker2);\n  state.parentType = oldParentType;\n  return true;\n};\nvar paragraph = function paragraph2(state, startLine) {\n  var content, terminate, i, l2, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules(\"paragraph\"), endLine = state.lineMax;\n  oldParentType = state.parentType;\n  state.parentType = \"paragraph\";\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n    terminate = false;\n    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n  token2 = state.push(\"paragraph_open\", \"p\", 1);\n  token2.map = [startLine, state.line];\n  token2 = state.push(\"inline\", \"\", 0);\n  token2.content = content;\n  token2.map = [startLine, state.line];\n  token2.children = [];\n  token2 = state.push(\"paragraph_close\", \"p\", -1);\n  state.parentType = oldParentType;\n  return true;\n};\nvar Token$1 = token;\nvar isSpace$4 = utils$1.isSpace;\nfunction StateBlock(src, md2, env, tokens) {\n  var ch2, s, start2, pos, len, indent2, offset, indent_found;\n  this.src = src;\n  this.md = md2;\n  this.env = env;\n  this.tokens = tokens;\n  this.bMarks = [];\n  this.eMarks = [];\n  this.tShift = [];\n  this.sCount = [];\n  this.bsCount = [];\n  this.blkIndent = 0;\n  this.line = 0;\n  this.lineMax = 0;\n  this.tight = false;\n  this.ddIndent = -1;\n  this.listIndent = -1;\n  this.parentType = \"root\";\n  this.level = 0;\n  this.result = \"\";\n  s = this.src;\n  indent_found = false;\n  for (start2 = pos = indent2 = offset = 0, len = s.length; pos < len; pos++) {\n    ch2 = s.charCodeAt(pos);\n    if (!indent_found) {\n      if (isSpace$4(ch2)) {\n        indent2++;\n        if (ch2 === 9) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n    if (ch2 === 10 || pos === len - 1) {\n      if (ch2 !== 10) {\n        pos++;\n      }\n      this.bMarks.push(start2);\n      this.eMarks.push(pos);\n      this.tShift.push(indent2);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n      indent_found = false;\n      indent2 = 0;\n      offset = 0;\n      start2 = pos + 1;\n    }\n  }\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n  this.lineMax = this.bMarks.length - 1;\n}\nStateBlock.prototype.push = function(type2, tag, nesting) {\n  var token2 = new Token$1(type2, tag, nesting);\n  token2.block = true;\n  if (nesting < 0)\n    this.level--;\n  token2.level = this.level;\n  if (nesting > 0)\n    this.level++;\n  this.tokens.push(token2);\n  return token2;\n};\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch2;\n  for (var max = this.src.length; pos < max; pos++) {\n    ch2 = this.src.charCodeAt(pos);\n    if (!isSpace$4(ch2)) {\n      break;\n    }\n  }\n  return pos;\n};\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) {\n    return pos;\n  }\n  while (pos > min) {\n    if (!isSpace$4(this.src.charCodeAt(--pos))) {\n      return pos + 1;\n    }\n  }\n  return pos;\n};\nStateBlock.prototype.skipChars = function skipChars(pos, code3) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code3) {\n      break;\n    }\n  }\n  return pos;\n};\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code3, min) {\n  if (pos <= min) {\n    return pos;\n  }\n  while (pos > min) {\n    if (code3 !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n  return pos;\n};\nStateBlock.prototype.getLines = function getLines(begin, end2, indent2, keepLastLF) {\n  var i, lineIndent, ch2, first, last, queue, lineStart, line = begin;\n  if (begin >= end2) {\n    return \"\";\n  }\n  queue = new Array(end2 - begin);\n  for (i = 0; line < end2; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n    if (line + 1 < end2 || keepLastLF) {\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n    while (first < last && lineIndent < indent2) {\n      ch2 = this.src.charCodeAt(first);\n      if (isSpace$4(ch2)) {\n        if (ch2 === 9) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        lineIndent++;\n      } else {\n        break;\n      }\n      first++;\n    }\n    if (lineIndent > indent2) {\n      queue[i] = new Array(lineIndent - indent2 + 1).join(\" \") + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n  return queue.join(\"\");\n};\nStateBlock.prototype.Token = Token$1;\nvar state_block = StateBlock;\nvar Ruler$1 = ruler;\nvar _rules$1 = [\n  [\"table\", table, [\"paragraph\", \"reference\"]],\n  [\"code\", code$2],\n  [\"fence\", fence, [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n  [\"blockquote\", blockquote, [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n  [\"hr\", hr, [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n  [\"list\", list, [\"paragraph\", \"reference\", \"blockquote\"]],\n  [\"reference\", reference],\n  [\"html_block\", html_block, [\"paragraph\", \"reference\", \"blockquote\"]],\n  [\"heading\", heading, [\"paragraph\", \"reference\", \"blockquote\"]],\n  [\"lheading\", lheading],\n  [\"paragraph\", paragraph]\n];\nfunction ParserBlock$1() {\n  this.ruler = new Ruler$1();\n  for (var i = 0; i < _rules$1.length; i++) {\n    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });\n  }\n}\nParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {\n  var ok2, i, rules = this.ruler.getRules(\"\"), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n    if (state.sCount[line] < state.blkIndent) {\n      break;\n    }\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n    for (i = 0; i < len; i++) {\n      ok2 = rules[i](state, line, endLine, false);\n      if (ok2) {\n        break;\n      }\n    }\n    state.tight = !hasEmptyLines;\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n    line = state.line;\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\nParserBlock$1.prototype.parse = function(src, md2, env, outTokens) {\n  var state;\n  if (!src) {\n    return;\n  }\n  state = new this.State(src, md2, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\nParserBlock$1.prototype.State = state_block;\nvar parser_block = ParserBlock$1;\nfunction isTerminatorChar(ch2) {\n  switch (ch2) {\n    case 10:\n    case 33:\n    case 35:\n    case 36:\n    case 37:\n    case 38:\n    case 42:\n    case 43:\n    case 45:\n    case 58:\n    case 60:\n    case 61:\n    case 62:\n    case 64:\n    case 91:\n    case 92:\n    case 93:\n    case 94:\n    case 95:\n    case 96:\n    case 123:\n    case 125:\n    case 126:\n      return true;\n    default:\n      return false;\n  }\n}\nvar text$1 = function text(state, silent) {\n  var pos = state.pos;\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n  if (pos === state.pos) {\n    return false;\n  }\n  if (!silent) {\n    state.pending += state.src.slice(state.pos, pos);\n  }\n  state.pos = pos;\n  return true;\n};\nvar isSpace$3 = utils$1.isSpace;\nvar newline = function newline2(state, silent) {\n  var pmax, max, ws2, pos = state.pos;\n  if (state.src.charCodeAt(pos) !== 10) {\n    return false;\n  }\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {\n        ws2 = pmax - 1;\n        while (ws2 >= 1 && state.pending.charCodeAt(ws2 - 1) === 32)\n          ws2--;\n        state.pending = state.pending.slice(0, ws2);\n        state.push(\"hardbreak\", \"br\", 0);\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push(\"softbreak\", \"br\", 0);\n      }\n    } else {\n      state.push(\"softbreak\", \"br\", 0);\n    }\n  }\n  pos++;\n  while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n  state.pos = pos;\n  return true;\n};\nvar isSpace$2 = utils$1.isSpace;\nvar ESCAPED = [];\nfor (var i$1 = 0; i$1 < 256; i$1++) {\n  ESCAPED.push(0);\n}\n\"\\\\!\\\"#$%&'()*+,./:;<=>?@[]^_`{|}~-\".split(\"\").forEach(function(ch2) {\n  ESCAPED[ch2.charCodeAt(0)] = 1;\n});\nvar _escape = function escape2(state, silent) {\n  var ch2, pos = state.pos, max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 92) {\n    return false;\n  }\n  pos++;\n  if (pos < max) {\n    ch2 = state.src.charCodeAt(pos);\n    if (ch2 < 256 && ESCAPED[ch2] !== 0) {\n      if (!silent) {\n        state.pending += state.src[pos];\n      }\n      state.pos += 2;\n      return true;\n    }\n    if (ch2 === 10) {\n      if (!silent) {\n        state.push(\"hardbreak\", \"br\", 0);\n      }\n      pos++;\n      while (pos < max) {\n        ch2 = state.src.charCodeAt(pos);\n        if (!isSpace$2(ch2)) {\n          break;\n        }\n        pos++;\n      }\n      state.pos = pos;\n      return true;\n    }\n  }\n  if (!silent) {\n    state.pending += \"\\\\\";\n  }\n  state.pos++;\n  return true;\n};\nvar backticks = function backtick(state, silent) {\n  var start2, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch2 = state.src.charCodeAt(pos);\n  if (ch2 !== 96) {\n    return false;\n  }\n  start2 = pos;\n  pos++;\n  max = state.posMax;\n  while (pos < max && state.src.charCodeAt(pos) === 96) {\n    pos++;\n  }\n  marker2 = state.src.slice(start2, pos);\n  openerLength = marker2.length;\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {\n    if (!silent)\n      state.pending += marker2;\n    state.pos += openerLength;\n    return true;\n  }\n  matchStart = matchEnd = pos;\n  while ((matchStart = state.src.indexOf(\"`\", matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {\n      matchEnd++;\n    }\n    closerLength = matchEnd - matchStart;\n    if (closerLength === openerLength) {\n      if (!silent) {\n        token2 = state.push(\"code_inline\", \"code\", 0);\n        token2.markup = marker2;\n        token2.content = state.src.slice(pos, matchStart).replace(/\\n/g, \" \").replace(/^ (.+) $/, \"$1\");\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n    state.backticks[closerLength] = matchStart;\n  }\n  state.backticksScanned = true;\n  if (!silent)\n    state.pending += marker2;\n  state.pos += openerLength;\n  return true;\n};\nvar strikethrough = {};\nstrikethrough.tokenize = function strikethrough2(state, silent) {\n  var i, scanned, token2, len, ch2, start2 = state.pos, marker2 = state.src.charCodeAt(start2);\n  if (silent) {\n    return false;\n  }\n  if (marker2 !== 126) {\n    return false;\n  }\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch2 = String.fromCharCode(marker2);\n  if (len < 2) {\n    return false;\n  }\n  if (len % 2) {\n    token2 = state.push(\"text\", \"\", 0);\n    token2.content = ch2;\n    len--;\n  }\n  for (i = 0; i < len; i += 2) {\n    token2 = state.push(\"text\", \"\", 0);\n    token2.content = ch2 + ch2;\n    state.delimiters.push({\n      marker: marker2,\n      length: 0,\n      token: state.tokens.length - 1,\n      end: -1,\n      open: scanned.can_open,\n      close: scanned.can_close\n    });\n  }\n  state.pos += scanned.length;\n  return true;\n};\nfunction postProcess$1(state, delimiters) {\n  var i, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n    if (startDelim.marker !== 126) {\n      continue;\n    }\n    if (startDelim.end === -1) {\n      continue;\n    }\n    endDelim = delimiters[startDelim.end];\n    token2 = state.tokens[startDelim.token];\n    token2.type = \"s_open\";\n    token2.tag = \"s\";\n    token2.nesting = 1;\n    token2.markup = \"~~\";\n    token2.content = \"\";\n    token2 = state.tokens[endDelim.token];\n    token2.type = \"s_close\";\n    token2.tag = \"s\";\n    token2.nesting = -1;\n    token2.markup = \"~~\";\n    token2.content = \"\";\n    if (state.tokens[endDelim.token - 1].type === \"text\" && state.tokens[endDelim.token - 1].content === \"~\") {\n      loneMarkers.push(endDelim.token - 1);\n    }\n  }\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n    while (j < state.tokens.length && state.tokens[j].type === \"s_close\") {\n      j++;\n    }\n    j--;\n    if (i !== j) {\n      token2 = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token2;\n    }\n  }\n}\nstrikethrough.postProcess = function strikethrough3(state) {\n  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;\n  postProcess$1(state, state.delimiters);\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess$1(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\nvar emphasis = {};\nemphasis.tokenize = function emphasis2(state, silent) {\n  var i, scanned, token2, start2 = state.pos, marker2 = state.src.charCodeAt(start2);\n  if (silent) {\n    return false;\n  }\n  if (marker2 !== 95 && marker2 !== 42) {\n    return false;\n  }\n  scanned = state.scanDelims(state.pos, marker2 === 42);\n  for (i = 0; i < scanned.length; i++) {\n    token2 = state.push(\"text\", \"\", 0);\n    token2.content = String.fromCharCode(marker2);\n    state.delimiters.push({\n      marker: marker2,\n      length: scanned.length,\n      token: state.tokens.length - 1,\n      end: -1,\n      open: scanned.can_open,\n      close: scanned.can_close\n    });\n  }\n  state.pos += scanned.length;\n  return true;\n};\nfunction postProcess(state, delimiters) {\n  var i, startDelim, endDelim, token2, ch2, isStrong, max = delimiters.length;\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n    if (startDelim.marker !== 95 && startDelim.marker !== 42) {\n      continue;\n    }\n    if (startDelim.end === -1) {\n      continue;\n    }\n    endDelim = delimiters[startDelim.end];\n    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;\n    ch2 = String.fromCharCode(startDelim.marker);\n    token2 = state.tokens[startDelim.token];\n    token2.type = isStrong ? \"strong_open\" : \"em_open\";\n    token2.tag = isStrong ? \"strong\" : \"em\";\n    token2.nesting = 1;\n    token2.markup = isStrong ? ch2 + ch2 : ch2;\n    token2.content = \"\";\n    token2 = state.tokens[endDelim.token];\n    token2.type = isStrong ? \"strong_close\" : \"em_close\";\n    token2.tag = isStrong ? \"strong\" : \"em\";\n    token2.nesting = -1;\n    token2.markup = isStrong ? ch2 + ch2 : ch2;\n    token2.content = \"\";\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = \"\";\n      state.tokens[delimiters[startDelim.end + 1].token].content = \"\";\n      i--;\n    }\n  }\n}\nemphasis.postProcess = function emphasis3(state) {\n  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;\n  postProcess(state, state.delimiters);\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\nvar normalizeReference$1 = utils$1.normalizeReference;\nvar isSpace$1 = utils$1.isSpace;\nvar link = function link2(state, silent) {\n  var attrs, code3, label, labelEnd, labelStart, pos, res, ref, token2, href = \"\", title = \"\", oldPos = state.pos, max = state.posMax, start2 = state.pos, parseReference = true;\n  if (state.src.charCodeAt(state.pos) !== 91) {\n    return false;\n  }\n  labelStart = state.pos + 1;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n  if (labelEnd < 0) {\n    return false;\n  }\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 40) {\n    parseReference = false;\n    pos++;\n    for (; pos < max; pos++) {\n      code3 = state.src.charCodeAt(pos);\n      if (!isSpace$1(code3) && code3 !== 10) {\n        break;\n      }\n    }\n    if (pos >= max) {\n      return false;\n    }\n    start2 = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = \"\";\n      }\n      start2 = pos;\n      for (; pos < max; pos++) {\n        code3 = state.src.charCodeAt(pos);\n        if (!isSpace$1(code3) && code3 !== 10) {\n          break;\n        }\n      }\n      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n      if (pos < max && start2 !== pos && res.ok) {\n        title = res.str;\n        pos = res.pos;\n        for (; pos < max; pos++) {\n          code3 = state.src.charCodeAt(pos);\n          if (!isSpace$1(code3) && code3 !== 10) {\n            break;\n          }\n        }\n      }\n    }\n    if (pos >= max || state.src.charCodeAt(pos) !== 41) {\n      parseReference = true;\n    }\n    pos++;\n  }\n  if (parseReference) {\n    if (typeof state.env.references === \"undefined\") {\n      return false;\n    }\n    if (pos < max && state.src.charCodeAt(pos) === 91) {\n      start2 = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start2, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n    if (!label) {\n      label = state.src.slice(labelStart, labelEnd);\n    }\n    ref = state.env.references[normalizeReference$1(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n    token2 = state.push(\"link_open\", \"a\", 1);\n    token2.attrs = attrs = [[\"href\", href]];\n    if (title) {\n      attrs.push([\"title\", title]);\n    }\n    state.md.inline.tokenize(state);\n    token2 = state.push(\"link_close\", \"a\", -1);\n  }\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\nvar normalizeReference = utils$1.normalizeReference;\nvar isSpace = utils$1.isSpace;\nvar image = function image2(state, silent) {\n  var attrs, code3, content, label, labelEnd, labelStart, pos, ref, res, title, token2, tokens, start2, href = \"\", oldPos = state.pos, max = state.posMax;\n  if (state.src.charCodeAt(state.pos) !== 33) {\n    return false;\n  }\n  if (state.src.charCodeAt(state.pos + 1) !== 91) {\n    return false;\n  }\n  labelStart = state.pos + 2;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n  if (labelEnd < 0) {\n    return false;\n  }\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 40) {\n    pos++;\n    for (; pos < max; pos++) {\n      code3 = state.src.charCodeAt(pos);\n      if (!isSpace(code3) && code3 !== 10) {\n        break;\n      }\n    }\n    if (pos >= max) {\n      return false;\n    }\n    start2 = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = \"\";\n      }\n    }\n    start2 = pos;\n    for (; pos < max; pos++) {\n      code3 = state.src.charCodeAt(pos);\n      if (!isSpace(code3) && code3 !== 10) {\n        break;\n      }\n    }\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start2 !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n      for (; pos < max; pos++) {\n        code3 = state.src.charCodeAt(pos);\n        if (!isSpace(code3) && code3 !== 10) {\n          break;\n        }\n      }\n    } else {\n      title = \"\";\n    }\n    if (pos >= max || state.src.charCodeAt(pos) !== 41) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    if (typeof state.env.references === \"undefined\") {\n      return false;\n    }\n    if (pos < max && state.src.charCodeAt(pos) === 91) {\n      start2 = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start2, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n    if (!label) {\n      label = state.src.slice(labelStart, labelEnd);\n    }\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n    state.md.inline.parse(content, state.md, state.env, tokens = []);\n    token2 = state.push(\"image\", \"img\", 0);\n    token2.attrs = attrs = [[\"src\", href], [\"alt\", \"\"]];\n    token2.children = tokens;\n    token2.content = content;\n    if (title) {\n      attrs.push([\"title\", title]);\n    }\n  }\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\nvar EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;\nvar AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)$/;\nvar autolink = function autolink2(state, silent) {\n  var url, fullUrl, token2, ch2, start2, max, pos = state.pos;\n  if (state.src.charCodeAt(pos) !== 60) {\n    return false;\n  }\n  start2 = state.pos;\n  max = state.posMax;\n  for (; ; ) {\n    if (++pos >= max)\n      return false;\n    ch2 = state.src.charCodeAt(pos);\n    if (ch2 === 60)\n      return false;\n    if (ch2 === 62)\n      break;\n  }\n  url = state.src.slice(start2 + 1, pos);\n  if (AUTOLINK_RE.test(url)) {\n    fullUrl = state.md.normalizeLink(url);\n    if (!state.md.validateLink(fullUrl)) {\n      return false;\n    }\n    if (!silent) {\n      token2 = state.push(\"link_open\", \"a\", 1);\n      token2.attrs = [[\"href\", fullUrl]];\n      token2.markup = \"autolink\";\n      token2.info = \"auto\";\n      token2 = state.push(\"text\", \"\", 0);\n      token2.content = state.md.normalizeLinkText(url);\n      token2 = state.push(\"link_close\", \"a\", -1);\n      token2.markup = \"autolink\";\n      token2.info = \"auto\";\n    }\n    state.pos += url.length + 2;\n    return true;\n  }\n  if (EMAIL_RE.test(url)) {\n    fullUrl = state.md.normalizeLink(\"mailto:\" + url);\n    if (!state.md.validateLink(fullUrl)) {\n      return false;\n    }\n    if (!silent) {\n      token2 = state.push(\"link_open\", \"a\", 1);\n      token2.attrs = [[\"href\", fullUrl]];\n      token2.markup = \"autolink\";\n      token2.info = \"auto\";\n      token2 = state.push(\"text\", \"\", 0);\n      token2.content = state.md.normalizeLinkText(url);\n      token2 = state.push(\"link_close\", \"a\", -1);\n      token2.markup = \"autolink\";\n      token2.info = \"auto\";\n    }\n    state.pos += url.length + 2;\n    return true;\n  }\n  return false;\n};\nvar HTML_TAG_RE = html_re.HTML_TAG_RE;\nfunction isLetter(ch2) {\n  var lc2 = ch2 | 32;\n  return lc2 >= 97 && lc2 <= 122;\n}\nvar html_inline = function html_inline2(state, silent) {\n  var ch2, match2, max, token2, pos = state.pos;\n  if (!state.md.options.html) {\n    return false;\n  }\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {\n    return false;\n  }\n  ch2 = state.src.charCodeAt(pos + 1);\n  if (ch2 !== 33 && ch2 !== 63 && ch2 !== 47 && !isLetter(ch2)) {\n    return false;\n  }\n  match2 = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match2) {\n    return false;\n  }\n  if (!silent) {\n    token2 = state.push(\"html_inline\", \"\", 0);\n    token2.content = state.src.slice(pos, pos + match2[0].length);\n  }\n  state.pos += match2[0].length;\n  return true;\n};\nvar entities = entities$1;\nvar has = utils$1.has;\nvar isValidEntityCode = utils$1.isValidEntityCode;\nvar fromCodePoint = utils$1.fromCodePoint;\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;\nvar NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\nvar entity = function entity2(state, silent) {\n  var ch2, code3, match2, pos = state.pos, max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 38) {\n    return false;\n  }\n  if (pos + 1 < max) {\n    ch2 = state.src.charCodeAt(pos + 1);\n    if (ch2 === 35) {\n      match2 = state.src.slice(pos).match(DIGITAL_RE);\n      if (match2) {\n        if (!silent) {\n          code3 = match2[1][0].toLowerCase() === \"x\" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);\n          state.pending += isValidEntityCode(code3) ? fromCodePoint(code3) : fromCodePoint(65533);\n        }\n        state.pos += match2[0].length;\n        return true;\n      }\n    } else {\n      match2 = state.src.slice(pos).match(NAMED_RE);\n      if (match2) {\n        if (has(entities, match2[1])) {\n          if (!silent) {\n            state.pending += entities[match2[1]];\n          }\n          state.pos += match2[0].length;\n          return true;\n        }\n      }\n    }\n  }\n  if (!silent) {\n    state.pending += \"&\";\n  }\n  state.pos++;\n  return true;\n};\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;\n  if (!max)\n    return;\n  var headerIdx = 0;\n  var lastTokenIdx = -2;\n  var jumps = [];\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n    jumps.push(0);\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx;\n    }\n    lastTokenIdx = closer.token;\n    closer.length = closer.length || 0;\n    if (!closer.close)\n      continue;\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];\n    }\n    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];\n    openerIdx = headerIdx - jumps[headerIdx] - 1;\n    newMinOpenerIdx = openerIdx;\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      opener = delimiters[openerIdx];\n      if (opener.marker !== closer.marker)\n        continue;\n      if (opener.open && opener.end < 0) {\n        isOddMatch = false;\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n        if (!isOddMatch) {\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n          jumps[openerIdx] = lastJump;\n          closer.open = false;\n          opener.end = closerIdx;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          lastTokenIdx = -2;\n          break;\n        }\n      }\n    }\n    if (newMinOpenerIdx !== -1) {\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\nvar balance_pairs = function link_pairs(state) {\n  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;\n  processDelimiters(state, state.delimiters);\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\nvar text_collapse = function text_collapse2(state) {\n  var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;\n  for (curr = last = 0; curr < max; curr++) {\n    if (tokens[curr].nesting < 0)\n      level--;\n    tokens[curr].level = level;\n    if (tokens[curr].nesting > 0)\n      level++;\n    if (tokens[curr].type === \"text\" && curr + 1 < max && tokens[curr + 1].type === \"text\") {\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n    } else {\n      if (curr !== last) {\n        tokens[last] = tokens[curr];\n      }\n      last++;\n    }\n  }\n  if (curr !== last) {\n    tokens.length = last;\n  }\n};\nvar Token = token;\nvar isWhiteSpace = utils$1.isWhiteSpace;\nvar isPunctChar = utils$1.isPunctChar;\nvar isMdAsciiPunct = utils$1.isMdAsciiPunct;\nfunction StateInline(src, md2, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md2;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = \"\";\n  this.pendingLevel = 0;\n  this.cache = {};\n  this.delimiters = [];\n  this._prev_delimiters = [];\n  this.backticks = {};\n  this.backticksScanned = false;\n}\nStateInline.prototype.pushPending = function() {\n  var token2 = new Token(\"text\", \"\", 0);\n  token2.content = this.pending;\n  token2.level = this.pendingLevel;\n  this.tokens.push(token2);\n  this.pending = \"\";\n  return token2;\n};\nStateInline.prototype.push = function(type2, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n  var token2 = new Token(type2, tag, nesting);\n  var token_meta = null;\n  if (nesting < 0) {\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n  token2.level = this.level;\n  if (nesting > 0) {\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = { delimiters: this.delimiters };\n  }\n  this.pendingLevel = this.level;\n  this.tokens.push(token2);\n  this.tokens_meta.push(token_meta);\n  return token2;\n};\nStateInline.prototype.scanDelims = function(start2, canSplitWord) {\n  var pos = start2, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start2);\n  lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;\n  while (pos < max && this.src.charCodeAt(pos) === marker2) {\n    pos++;\n  }\n  count = pos - start2;\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 32;\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n  if (!canSplitWord) {\n    can_open = left_flanking && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking || isNextPunctChar);\n  } else {\n    can_open = left_flanking;\n    can_close = right_flanking;\n  }\n  return {\n    can_open,\n    can_close,\n    length: count\n  };\n};\nStateInline.prototype.Token = Token;\nvar state_inline = StateInline;\nvar Ruler = ruler;\nvar _rules = [\n  [\"text\", text$1],\n  [\"newline\", newline],\n  [\"escape\", _escape],\n  [\"backticks\", backticks],\n  [\"strikethrough\", strikethrough.tokenize],\n  [\"emphasis\", emphasis.tokenize],\n  [\"link\", link],\n  [\"image\", image],\n  [\"autolink\", autolink],\n  [\"html_inline\", html_inline],\n  [\"entity\", entity]\n];\nvar _rules2 = [\n  [\"balance_pairs\", balance_pairs],\n  [\"strikethrough\", strikethrough.postProcess],\n  [\"emphasis\", emphasis.postProcess],\n  [\"text_collapse\", text_collapse]\n];\nfunction ParserInline$1() {\n  var i;\n  this.ruler = new Ruler();\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n  this.ruler2 = new Ruler();\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\nParserInline$1.prototype.skipToken = function(state) {\n  var ok2, i, pos = state.pos, rules = this.ruler.getRules(\"\"), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;\n  if (typeof cache[pos] !== \"undefined\") {\n    state.pos = cache[pos];\n    return;\n  }\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      state.level++;\n      ok2 = rules[i](state, true);\n      state.level--;\n      if (ok2) {\n        break;\n      }\n    }\n  } else {\n    state.pos = state.posMax;\n  }\n  if (!ok2) {\n    state.pos++;\n  }\n  cache[pos] = state.pos;\n};\nParserInline$1.prototype.tokenize = function(state) {\n  var ok2, i, rules = this.ruler.getRules(\"\"), len = rules.length, end2 = state.posMax, maxNesting = state.md.options.maxNesting;\n  while (state.pos < end2) {\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok2 = rules[i](state, false);\n        if (ok2) {\n          break;\n        }\n      }\n    }\n    if (ok2) {\n      if (state.pos >= end2) {\n        break;\n      }\n      continue;\n    }\n    state.pending += state.src[state.pos++];\n  }\n  if (state.pending) {\n    state.pushPending();\n  }\n};\nParserInline$1.prototype.parse = function(str, md2, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md2, env, outTokens);\n  this.tokenize(state);\n  rules = this.ruler2.getRules(\"\");\n  len = rules.length;\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\nParserInline$1.prototype.State = state_inline;\nvar parser_inline = ParserInline$1;\nvar re = function(opts) {\n  var re2 = {};\n  re2.src_Any = regex$3.source;\n  re2.src_Cc = regex$2.source;\n  re2.src_Z = regex.source;\n  re2.src_P = regex$4.source;\n  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join(\"|\");\n  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join(\"|\");\n  var text_separators = \"[><\\uFF5C]\";\n  re2.src_pseudo_letter = \"(?:(?!\" + text_separators + \"|\" + re2.src_ZPCc + \")\" + re2.src_Any + \")\";\n  re2.src_ip4 = \"(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\";\n  re2.src_auth = \"(?:(?:(?!\" + re2.src_ZCc + \"|[@/\\\\[\\\\]()]).)+@)?\";\n  re2.src_port = \"(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?\";\n  re2.src_host_terminator = \"(?=$|\" + text_separators + \"|\" + re2.src_ZPCc + \")(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|\" + re2.src_ZPCc + \"))\";\n  re2.src_path = \"(?:[/?#](?:(?!\" + re2.src_ZCc + \"|\" + text_separators + `|[()[\\\\]{}.,\"'?!\\\\-;]).|\\\\[(?:(?!` + re2.src_ZCc + \"|\\\\]).)*\\\\]|\\\\((?:(?!\" + re2.src_ZCc + \"|[)]).)*\\\\)|\\\\{(?:(?!\" + re2.src_ZCc + '|[}]).)*\\\\}|\\\\\"(?:(?!' + re2.src_ZCc + `|[\"]).)+\\\\\"|\\\\'(?:(?!` + re2.src_ZCc + \"|[']).)+\\\\'|\\\\'(?=\" + re2.src_pseudo_letter + \"|[-]).|\\\\.{2,}[a-zA-Z0-9%/&]|\\\\.(?!\" + re2.src_ZCc + \"|[.]).|\" + (opts && opts[\"---\"] ? \"\\\\-(?!--(?:[^-]|$))(?:-*)|\" : \"\\\\-+|\") + \",(?!\" + re2.src_ZCc + \").|;(?!\" + re2.src_ZCc + \").|\\\\!+(?!\" + re2.src_ZCc + \"|[!]).|\\\\?(?!\" + re2.src_ZCc + \"|[?]).)+|\\\\/)?\";\n  re2.src_email_name = '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n  re2.src_xn = \"xn--[a-z0-9\\\\-]{1,59}\";\n  re2.src_domain_root = \"(?:\" + re2.src_xn + \"|\" + re2.src_pseudo_letter + \"{1,63})\";\n  re2.src_domain = \"(?:\" + re2.src_xn + \"|(?:\" + re2.src_pseudo_letter + \")|(?:\" + re2.src_pseudo_letter + \"(?:-|\" + re2.src_pseudo_letter + \"){0,61}\" + re2.src_pseudo_letter + \"))\";\n  re2.src_host = \"(?:(?:(?:(?:\" + re2.src_domain + \")\\\\.)*\" + re2.src_domain + \"))\";\n  re2.tpl_host_fuzzy = \"(?:\" + re2.src_ip4 + \"|(?:(?:(?:\" + re2.src_domain + \")\\\\.)+(?:%TLDS%)))\";\n  re2.tpl_host_no_ip_fuzzy = \"(?:(?:(?:\" + re2.src_domain + \")\\\\.)+(?:%TLDS%))\";\n  re2.src_host_strict = re2.src_host + re2.src_host_terminator;\n  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;\n  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;\n  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;\n  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;\n  re2.tpl_host_fuzzy_test = \"localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:\" + re2.src_ZPCc + \"|>|$))\";\n  re2.tpl_email_fuzzy = \"(^|\" + text_separators + '|\"|\\\\(|' + re2.src_ZCc + \")(\" + re2.src_email_name + \"@\" + re2.tpl_host_fuzzy_strict + \")\";\n  re2.tpl_link_fuzzy = \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uFF5C]|\" + re2.src_ZPCc + \"))((?![$+<=>^`|\\uFF5C])\" + re2.tpl_host_port_fuzzy_strict + re2.src_path + \")\";\n  re2.tpl_link_no_ip_fuzzy = \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uFF5C]|\" + re2.src_ZPCc + \"))((?![$+<=>^`|\\uFF5C])\" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + \")\";\n  return re2;\n};\nfunction assign(obj) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  sources.forEach(function(source) {\n    if (!source) {\n      return;\n    }\n    Object.keys(source).forEach(function(key) {\n      obj[key] = source[key];\n    });\n  });\n  return obj;\n}\nfunction _class(obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isString$2(obj) {\n  return _class(obj) === \"[object String]\";\n}\nfunction isObject$4(obj) {\n  return _class(obj) === \"[object Object]\";\n}\nfunction isRegExp(obj) {\n  return _class(obj) === \"[object RegExp]\";\n}\nfunction isFunction(obj) {\n  return _class(obj) === \"[object Function]\";\n}\nfunction escapeRE(str) {\n  return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n}\nvar defaultOptions = {\n  fuzzyLink: true,\n  fuzzyEmail: true,\n  fuzzyIP: false\n};\nfunction isOptionsObj(obj) {\n  return Object.keys(obj || {}).reduce(function(acc, k) {\n    return acc || defaultOptions.hasOwnProperty(k);\n  }, false);\n}\nvar defaultSchemas = {\n  \"http:\": {\n    validate: function(text3, pos, self2) {\n      var tail = text3.slice(pos);\n      if (!self2.re.http) {\n        self2.re.http = new RegExp(\"^\\\\/\\\\/\" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, \"i\");\n      }\n      if (self2.re.http.test(tail)) {\n        return tail.match(self2.re.http)[0].length;\n      }\n      return 0;\n    }\n  },\n  \"https:\": \"http:\",\n  \"ftp:\": \"http:\",\n  \"//\": {\n    validate: function(text3, pos, self2) {\n      var tail = text3.slice(pos);\n      if (!self2.re.no_http) {\n        self2.re.no_http = new RegExp(\"^\" + self2.re.src_auth + \"(?:localhost|(?:(?:\" + self2.re.src_domain + \")\\\\.)+\" + self2.re.src_domain_root + \")\" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, \"i\");\n      }\n      if (self2.re.no_http.test(tail)) {\n        if (pos >= 3 && text3[pos - 3] === \":\") {\n          return 0;\n        }\n        if (pos >= 3 && text3[pos - 3] === \"/\") {\n          return 0;\n        }\n        return tail.match(self2.re.no_http)[0].length;\n      }\n      return 0;\n    }\n  },\n  \"mailto:\": {\n    validate: function(text3, pos, self2) {\n      var tail = text3.slice(pos);\n      if (!self2.re.mailto) {\n        self2.re.mailto = new RegExp(\"^\" + self2.re.src_email_name + \"@\" + self2.re.src_host_strict, \"i\");\n      }\n      if (self2.re.mailto.test(tail)) {\n        return tail.match(self2.re.mailto)[0].length;\n      }\n      return 0;\n    }\n  }\n};\nvar tlds_2ch_src_re = \"a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]\";\nvar tlds_default = \"biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\\u0440\\u0444\".split(\"|\");\nfunction resetScanCache(self2) {\n  self2.__index__ = -1;\n  self2.__text_cache__ = \"\";\n}\nfunction createValidator(re2) {\n  return function(text3, pos) {\n    var tail = text3.slice(pos);\n    if (re2.test(tail)) {\n      return tail.match(re2)[0].length;\n    }\n    return 0;\n  };\n}\nfunction createNormalizer() {\n  return function(match2, self2) {\n    self2.normalize(match2);\n  };\n}\nfunction compile(self2) {\n  var re$12 = self2.re = re(self2.__opts__);\n  var tlds2 = self2.__tlds__.slice();\n  self2.onCompile();\n  if (!self2.__tlds_replaced__) {\n    tlds2.push(tlds_2ch_src_re);\n  }\n  tlds2.push(re$12.src_xn);\n  re$12.src_tlds = tlds2.join(\"|\");\n  function untpl(tpl) {\n    return tpl.replace(\"%TLDS%\", re$12.src_tlds);\n  }\n  re$12.email_fuzzy = RegExp(untpl(re$12.tpl_email_fuzzy), \"i\");\n  re$12.link_fuzzy = RegExp(untpl(re$12.tpl_link_fuzzy), \"i\");\n  re$12.link_no_ip_fuzzy = RegExp(untpl(re$12.tpl_link_no_ip_fuzzy), \"i\");\n  re$12.host_fuzzy_test = RegExp(untpl(re$12.tpl_host_fuzzy_test), \"i\");\n  var aliases = [];\n  self2.__compiled__ = {};\n  function schemaError(name2, val) {\n    throw new Error('(LinkifyIt) Invalid schema \"' + name2 + '\": ' + val);\n  }\n  Object.keys(self2.__schemas__).forEach(function(name2) {\n    var val = self2.__schemas__[name2];\n    if (val === null) {\n      return;\n    }\n    var compiled = { validate: null, link: null };\n    self2.__compiled__[name2] = compiled;\n    if (isObject$4(val)) {\n      if (isRegExp(val.validate)) {\n        compiled.validate = createValidator(val.validate);\n      } else if (isFunction(val.validate)) {\n        compiled.validate = val.validate;\n      } else {\n        schemaError(name2, val);\n      }\n      if (isFunction(val.normalize)) {\n        compiled.normalize = val.normalize;\n      } else if (!val.normalize) {\n        compiled.normalize = createNormalizer();\n      } else {\n        schemaError(name2, val);\n      }\n      return;\n    }\n    if (isString$2(val)) {\n      aliases.push(name2);\n      return;\n    }\n    schemaError(name2, val);\n  });\n  aliases.forEach(function(alias) {\n    if (!self2.__compiled__[self2.__schemas__[alias]]) {\n      return;\n    }\n    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;\n    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;\n  });\n  self2.__compiled__[\"\"] = { validate: null, normalize: createNormalizer() };\n  var slist = Object.keys(self2.__compiled__).filter(function(name2) {\n    return name2.length > 0 && self2.__compiled__[name2];\n  }).map(escapeRE).join(\"|\");\n  self2.re.schema_test = RegExp(\"(^|(?!_)(?:[><\\uFF5C]|\" + re$12.src_ZPCc + \"))(\" + slist + \")\", \"i\");\n  self2.re.schema_search = RegExp(\"(^|(?!_)(?:[><\\uFF5C]|\" + re$12.src_ZPCc + \"))(\" + slist + \")\", \"ig\");\n  self2.re.pretest = RegExp(\"(\" + self2.re.schema_test.source + \")|(\" + self2.re.host_fuzzy_test.source + \")|@\", \"i\");\n  resetScanCache(self2);\n}\nfunction Match(self2, shift) {\n  var start2 = self2.__index__, end2 = self2.__last_index__, text3 = self2.__text_cache__.slice(start2, end2);\n  this.schema = self2.__schema__.toLowerCase();\n  this.index = start2 + shift;\n  this.lastIndex = end2 + shift;\n  this.raw = text3;\n  this.text = text3;\n  this.url = text3;\n}\nfunction createMatch(self2, shift) {\n  var match2 = new Match(self2, shift);\n  self2.__compiled__[match2.schema].normalize(match2, self2);\n  return match2;\n}\nfunction LinkifyIt$1(schemas, options) {\n  if (!(this instanceof LinkifyIt$1)) {\n    return new LinkifyIt$1(schemas, options);\n  }\n  if (!options) {\n    if (isOptionsObj(schemas)) {\n      options = schemas;\n      schemas = {};\n    }\n  }\n  this.__opts__ = assign({}, defaultOptions, options);\n  this.__index__ = -1;\n  this.__last_index__ = -1;\n  this.__schema__ = \"\";\n  this.__text_cache__ = \"\";\n  this.__schemas__ = assign({}, defaultSchemas, schemas);\n  this.__compiled__ = {};\n  this.__tlds__ = tlds_default;\n  this.__tlds_replaced__ = false;\n  this.re = {};\n  compile(this);\n}\nLinkifyIt$1.prototype.add = function add(schema, definition) {\n  this.__schemas__[schema] = definition;\n  compile(this);\n  return this;\n};\nLinkifyIt$1.prototype.set = function set(options) {\n  this.__opts__ = assign(this.__opts__, options);\n  return this;\n};\nLinkifyIt$1.prototype.test = function test(text3) {\n  this.__text_cache__ = text3;\n  this.__index__ = -1;\n  if (!text3.length) {\n    return false;\n  }\n  var m2, ml, me2, len, shift, next, re2, tld_pos, at_pos;\n  if (this.re.schema_test.test(text3)) {\n    re2 = this.re.schema_search;\n    re2.lastIndex = 0;\n    while ((m2 = re2.exec(text3)) !== null) {\n      len = this.testSchemaAt(text3, m2[2], re2.lastIndex);\n      if (len) {\n        this.__schema__ = m2[2];\n        this.__index__ = m2.index + m2[1].length;\n        this.__last_index__ = m2.index + m2[0].length + len;\n        break;\n      }\n    }\n  }\n  if (this.__opts__.fuzzyLink && this.__compiled__[\"http:\"]) {\n    tld_pos = text3.search(this.re.host_fuzzy_test);\n    if (tld_pos >= 0) {\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\n        if ((ml = text3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n          shift = ml.index + ml[1].length;\n          if (this.__index__ < 0 || shift < this.__index__) {\n            this.__schema__ = \"\";\n            this.__index__ = shift;\n            this.__last_index__ = ml.index + ml[0].length;\n          }\n        }\n      }\n    }\n  }\n  if (this.__opts__.fuzzyEmail && this.__compiled__[\"mailto:\"]) {\n    at_pos = text3.indexOf(\"@\");\n    if (at_pos >= 0) {\n      if ((me2 = text3.match(this.re.email_fuzzy)) !== null) {\n        shift = me2.index + me2[1].length;\n        next = me2.index + me2[0].length;\n        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {\n          this.__schema__ = \"mailto:\";\n          this.__index__ = shift;\n          this.__last_index__ = next;\n        }\n      }\n    }\n  }\n  return this.__index__ >= 0;\n};\nLinkifyIt$1.prototype.pretest = function pretest(text3) {\n  return this.re.pretest.test(text3);\n};\nLinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text3, schema, pos) {\n  if (!this.__compiled__[schema.toLowerCase()]) {\n    return 0;\n  }\n  return this.__compiled__[schema.toLowerCase()].validate(text3, pos, this);\n};\nLinkifyIt$1.prototype.match = function match(text3) {\n  var shift = 0, result2 = [];\n  if (this.__index__ >= 0 && this.__text_cache__ === text3) {\n    result2.push(createMatch(this, shift));\n    shift = this.__last_index__;\n  }\n  var tail = shift ? text3.slice(shift) : text3;\n  while (this.test(tail)) {\n    result2.push(createMatch(this, shift));\n    tail = tail.slice(this.__last_index__);\n    shift += this.__last_index__;\n  }\n  if (result2.length) {\n    return result2;\n  }\n  return null;\n};\nLinkifyIt$1.prototype.tlds = function tlds(list3, keepOld) {\n  list3 = Array.isArray(list3) ? list3 : [list3];\n  if (!keepOld) {\n    this.__tlds__ = list3.slice();\n    this.__tlds_replaced__ = true;\n    compile(this);\n    return this;\n  }\n  this.__tlds__ = this.__tlds__.concat(list3).sort().filter(function(el2, idx, arr) {\n    return el2 !== arr[idx - 1];\n  }).reverse();\n  compile(this);\n  return this;\n};\nLinkifyIt$1.prototype.normalize = function normalize3(match2) {\n  if (!match2.schema) {\n    match2.url = \"http://\" + match2.url;\n  }\n  if (match2.schema === \"mailto:\" && !/^mailto:/i.test(match2.url)) {\n    match2.url = \"mailto:\" + match2.url;\n  }\n};\nLinkifyIt$1.prototype.onCompile = function onCompile() {\n};\nvar linkifyIt = LinkifyIt$1;\nconst maxInt = 2147483647;\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128;\nconst delimiter = \"-\";\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/;\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst errors = {\n  \"overflow\": \"Overflow: input needs wider integers to process\",\n  \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n  \"invalid-input\": \"Invalid input\"\n};\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\nfunction error(type2) {\n  throw new RangeError(errors[type2]);\n}\nfunction map(array, fn) {\n  const result2 = [];\n  let length = array.length;\n  while (length--) {\n    result2[length] = fn(array[length]);\n  }\n  return result2;\n}\nfunction mapDomain(string2, fn) {\n  const parts = string2.split(\"@\");\n  let result2 = \"\";\n  if (parts.length > 1) {\n    result2 = parts[0] + \"@\";\n    string2 = parts[1];\n  }\n  string2 = string2.replace(regexSeparators, \".\");\n  const labels = string2.split(\".\");\n  const encoded = map(labels, fn).join(\".\");\n  return result2 + encoded;\n}\nfunction ucs2decode(string2) {\n  const output = [];\n  let counter = 0;\n  const length = string2.length;\n  while (counter < length) {\n    const value = string2.charCodeAt(counter++);\n    if (value >= 55296 && value <= 56319 && counter < length) {\n      const extra = string2.charCodeAt(counter++);\n      if ((extra & 64512) == 56320) {\n        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n      } else {\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n  return output;\n}\nconst ucs2encode = (array) => String.fromCodePoint(...array);\nconst basicToDigit = function(codePoint) {\n  if (codePoint - 48 < 10) {\n    return codePoint - 22;\n  }\n  if (codePoint - 65 < 26) {\n    return codePoint - 65;\n  }\n  if (codePoint - 97 < 26) {\n    return codePoint - 97;\n  }\n  return base;\n};\nconst digitToBasic = function(digit, flag) {\n  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\nconst adapt = function(delta2, numPoints, firstTime) {\n  let k = 0;\n  delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;\n  delta2 += floor(delta2 / numPoints);\n  for (; delta2 > baseMinusTMin * tMax >> 1; k += base) {\n    delta2 = floor(delta2 / baseMinusTMin);\n  }\n  return floor(k + (baseMinusTMin + 1) * delta2 / (delta2 + skew));\n};\nconst decode = function(input) {\n  const output = [];\n  const inputLength = input.length;\n  let i = 0;\n  let n2 = initialN;\n  let bias = initialBias;\n  let basic = input.lastIndexOf(delimiter);\n  if (basic < 0) {\n    basic = 0;\n  }\n  for (let j = 0; j < basic; ++j) {\n    if (input.charCodeAt(j) >= 128) {\n      error(\"not-basic\");\n    }\n    output.push(input.charCodeAt(j));\n  }\n  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n    let oldi = i;\n    for (let w = 1, k = base; ; k += base) {\n      if (index >= inputLength) {\n        error(\"invalid-input\");\n      }\n      const digit = basicToDigit(input.charCodeAt(index++));\n      if (digit >= base || digit > floor((maxInt - i) / w)) {\n        error(\"overflow\");\n      }\n      i += digit * w;\n      const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n      if (digit < t2) {\n        break;\n      }\n      const baseMinusT = base - t2;\n      if (w > floor(maxInt / baseMinusT)) {\n        error(\"overflow\");\n      }\n      w *= baseMinusT;\n    }\n    const out = output.length + 1;\n    bias = adapt(i - oldi, out, oldi == 0);\n    if (floor(i / out) > maxInt - n2) {\n      error(\"overflow\");\n    }\n    n2 += floor(i / out);\n    i %= out;\n    output.splice(i++, 0, n2);\n  }\n  return String.fromCodePoint(...output);\n};\nconst encode = function(input) {\n  const output = [];\n  input = ucs2decode(input);\n  let inputLength = input.length;\n  let n2 = initialN;\n  let delta2 = 0;\n  let bias = initialBias;\n  for (const currentValue of input) {\n    if (currentValue < 128) {\n      output.push(stringFromCharCode(currentValue));\n    }\n  }\n  let basicLength = output.length;\n  let handledCPCount = basicLength;\n  if (basicLength) {\n    output.push(delimiter);\n  }\n  while (handledCPCount < inputLength) {\n    let m2 = maxInt;\n    for (const currentValue of input) {\n      if (currentValue >= n2 && currentValue < m2) {\n        m2 = currentValue;\n      }\n    }\n    const handledCPCountPlusOne = handledCPCount + 1;\n    if (m2 - n2 > floor((maxInt - delta2) / handledCPCountPlusOne)) {\n      error(\"overflow\");\n    }\n    delta2 += (m2 - n2) * handledCPCountPlusOne;\n    n2 = m2;\n    for (const currentValue of input) {\n      if (currentValue < n2 && ++delta2 > maxInt) {\n        error(\"overflow\");\n      }\n      if (currentValue == n2) {\n        let q2 = delta2;\n        for (let k = base; ; k += base) {\n          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (q2 < t2) {\n            break;\n          }\n          const qMinusT = q2 - t2;\n          const baseMinusT = base - t2;\n          output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));\n          q2 = floor(qMinusT / baseMinusT);\n        }\n        output.push(stringFromCharCode(digitToBasic(q2, 0)));\n        bias = adapt(delta2, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta2 = 0;\n        ++handledCPCount;\n      }\n    }\n    ++delta2;\n    ++n2;\n  }\n  return output.join(\"\");\n};\nconst toUnicode = function(input) {\n  return mapDomain(input, function(string2) {\n    return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;\n  });\n};\nconst toASCII = function(input) {\n  return mapDomain(input, function(string2) {\n    return regexNonASCII.test(string2) ? \"xn--\" + encode(string2) : string2;\n  });\n};\nconst punycode$1 = {\n  \"version\": \"2.1.0\",\n  \"ucs2\": {\n    \"decode\": ucs2decode,\n    \"encode\": ucs2encode\n  },\n  \"decode\": decode,\n  \"encode\": encode,\n  \"toASCII\": toASCII,\n  \"toUnicode\": toUnicode\n};\nvar punycode_es6 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  ucs2decode,\n  ucs2encode,\n  decode,\n  encode,\n  toASCII,\n  toUnicode,\n  \"default\": punycode$1\n});\nvar require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);\nvar _default$1 = {\n  options: {\n    html: false,\n    xhtmlOut: false,\n    breaks: false,\n    langPrefix: \"language-\",\n    linkify: false,\n    typographer: false,\n    quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n    highlight: null,\n    maxNesting: 100\n  },\n  components: {\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\nvar zero = {\n  options: {\n    html: false,\n    xhtmlOut: false,\n    breaks: false,\n    langPrefix: \"language-\",\n    linkify: false,\n    typographer: false,\n    quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n    highlight: null,\n    maxNesting: 20\n  },\n  components: {\n    core: {\n      rules: [\n        \"normalize\",\n        \"block\",\n        \"inline\"\n      ]\n    },\n    block: {\n      rules: [\n        \"paragraph\"\n      ]\n    },\n    inline: {\n      rules: [\n        \"text\"\n      ],\n      rules2: [\n        \"balance_pairs\",\n        \"text_collapse\"\n      ]\n    }\n  }\n};\nvar commonmark = {\n  options: {\n    html: true,\n    xhtmlOut: true,\n    breaks: false,\n    langPrefix: \"language-\",\n    linkify: false,\n    typographer: false,\n    quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n    highlight: null,\n    maxNesting: 20\n  },\n  components: {\n    core: {\n      rules: [\n        \"normalize\",\n        \"block\",\n        \"inline\"\n      ]\n    },\n    block: {\n      rules: [\n        \"blockquote\",\n        \"code\",\n        \"fence\",\n        \"heading\",\n        \"hr\",\n        \"html_block\",\n        \"lheading\",\n        \"list\",\n        \"reference\",\n        \"paragraph\"\n      ]\n    },\n    inline: {\n      rules: [\n        \"autolink\",\n        \"backticks\",\n        \"emphasis\",\n        \"entity\",\n        \"escape\",\n        \"html_inline\",\n        \"image\",\n        \"link\",\n        \"newline\",\n        \"text\"\n      ],\n      rules2: [\n        \"balance_pairs\",\n        \"emphasis\",\n        \"text_collapse\"\n      ]\n    }\n  }\n};\nvar utils = utils$1;\nvar helpers = helpers$1;\nvar Renderer = renderer;\nvar ParserCore = parser_core;\nvar ParserBlock = parser_block;\nvar ParserInline = parser_inline;\nvar LinkifyIt = linkifyIt;\nvar mdurl = mdurl$1;\nvar punycode = require$$8;\nvar config = {\n  default: _default$1,\n  zero,\n  commonmark\n};\nvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\nvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\nfunction validateLink(url) {\n  var str = url.trim().toLowerCase();\n  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;\n}\nvar RECODE_HOSTNAME_FOR = [\"http:\", \"https:\", \"mailto:\"];\nfunction normalizeLink(url) {\n  var parsed = mdurl.parse(url, true);\n  if (parsed.hostname) {\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname);\n      } catch (er) {\n      }\n    }\n  }\n  return mdurl.encode(mdurl.format(parsed));\n}\nfunction normalizeLinkText(url) {\n  var parsed = mdurl.parse(url, true);\n  if (parsed.hostname) {\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toUnicode(parsed.hostname);\n      } catch (er) {\n      }\n    }\n  }\n  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + \"%\");\n}\nfunction MarkdownIt(presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options);\n  }\n  if (!options) {\n    if (!utils.isString(presetName)) {\n      options = presetName || {};\n      presetName = \"default\";\n    }\n  }\n  this.inline = new ParserInline();\n  this.block = new ParserBlock();\n  this.core = new ParserCore();\n  this.renderer = new Renderer();\n  this.linkify = new LinkifyIt();\n  this.validateLink = validateLink;\n  this.normalizeLink = normalizeLink;\n  this.normalizeLinkText = normalizeLinkText;\n  this.utils = utils;\n  this.helpers = utils.assign({}, helpers);\n  this.options = {};\n  this.configure(presetName);\n  if (options) {\n    this.set(options);\n  }\n}\nMarkdownIt.prototype.set = function(options) {\n  utils.assign(this.options, options);\n  return this;\n};\nMarkdownIt.prototype.configure = function(presets) {\n  var self2 = this, presetName;\n  if (utils.isString(presets)) {\n    presetName = presets;\n    presets = config[presetName];\n    if (!presets) {\n      throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name');\n    }\n  }\n  if (!presets) {\n    throw new Error(\"Wrong `markdown-it` preset, can't be empty\");\n  }\n  if (presets.options) {\n    self2.set(presets.options);\n  }\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function(name2) {\n      if (presets.components[name2].rules) {\n        self2[name2].ruler.enableOnly(presets.components[name2].rules);\n      }\n      if (presets.components[name2].rules2) {\n        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);\n      }\n    });\n  }\n  return this;\n};\nMarkdownIt.prototype.enable = function(list3, ignoreInvalid) {\n  var result2 = [];\n  if (!Array.isArray(list3)) {\n    list3 = [list3];\n  }\n  [\"core\", \"block\", \"inline\"].forEach(function(chain) {\n    result2 = result2.concat(this[chain].ruler.enable(list3, true));\n  }, this);\n  result2 = result2.concat(this.inline.ruler2.enable(list3, true));\n  var missed = list3.filter(function(name2) {\n    return result2.indexOf(name2) < 0;\n  });\n  if (missed.length && !ignoreInvalid) {\n    throw new Error(\"MarkdownIt. Failed to enable unknown rule(s): \" + missed);\n  }\n  return this;\n};\nMarkdownIt.prototype.disable = function(list3, ignoreInvalid) {\n  var result2 = [];\n  if (!Array.isArray(list3)) {\n    list3 = [list3];\n  }\n  [\"core\", \"block\", \"inline\"].forEach(function(chain) {\n    result2 = result2.concat(this[chain].ruler.disable(list3, true));\n  }, this);\n  result2 = result2.concat(this.inline.ruler2.disable(list3, true));\n  var missed = list3.filter(function(name2) {\n    return result2.indexOf(name2) < 0;\n  });\n  if (missed.length && !ignoreInvalid) {\n    throw new Error(\"MarkdownIt. Failed to disable unknown rule(s): \" + missed);\n  }\n  return this;\n};\nMarkdownIt.prototype.use = function(plugin) {\n  var args = [this].concat(Array.prototype.slice.call(arguments, 1));\n  plugin.apply(plugin, args);\n  return this;\n};\nMarkdownIt.prototype.parse = function(src, env) {\n  if (typeof src !== \"string\") {\n    throw new Error(\"Input data should be a String\");\n  }\n  var state = new this.core.State(src, this, env);\n  this.core.process(state);\n  return state.tokens;\n};\nMarkdownIt.prototype.render = function(src, env) {\n  env = env || {};\n  return this.renderer.render(this.parse(src, env), this.options, env);\n};\nMarkdownIt.prototype.parseInline = function(src, env) {\n  var state = new this.core.State(src, this, env);\n  state.inlineMode = true;\n  this.core.process(state);\n  return state.tokens;\n};\nMarkdownIt.prototype.renderInline = function(src, env) {\n  env = env || {};\n  return this.renderer.render(this.parseInline(src, env), this.options, env);\n};\nvar lib = MarkdownIt;\nvar markdownIt = lib;\nvar invalidCharacters = Array.from({ length: 11 }, function(_, i) {\n  return String.fromCharCode(8192 + i);\n}).concat([\"\\u2028\", \"\\u2029\", \"\\u202F\", \"\\xA0\"]);\nvar sanitizeRegex = new RegExp(\"[\" + invalidCharacters.join(\"\") + \"]\", \"g\");\nfunction normalizeWhitespace(line) {\n  return line.replace(sanitizeRegex, \" \");\n}\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\nvar matchHtmlRegExp = /[\"'&<>]/;\nvar escapeHtml_1 = escapeHtml;\nfunction escapeHtml(string2) {\n  var str = \"\" + string2;\n  var match2 = matchHtmlRegExp.exec(str);\n  if (!match2) {\n    return str;\n  }\n  var escape3;\n  var html = \"\";\n  var index = 0;\n  var lastIndex = 0;\n  for (index = match2.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escape3 = \"&quot;\";\n        break;\n      case 38:\n        escape3 = \"&amp;\";\n        break;\n      case 39:\n        escape3 = \"&#39;\";\n        break;\n      case 60:\n        escape3 = \"&lt;\";\n        break;\n      case 62:\n        escape3 = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escape3;\n  }\n  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n}\nvar md$2 = new markdownIt();\nfunction onHasCompletion(_cm, data, onHintInformationRender) {\n  Promise.resolve().then(function() {\n    return codemirror$1;\n  }).then(function(CodeMirror) {\n    var information;\n    var deprecation;\n    CodeMirror.on(data, \"select\", function(ctx, el2) {\n      if (!information) {\n        var hintsUl_1 = el2.parentNode;\n        information = document.createElement(\"div\");\n        information.className = \"CodeMirror-hint-information\";\n        hintsUl_1.appendChild(information);\n        deprecation = document.createElement(\"div\");\n        deprecation.className = \"CodeMirror-hint-deprecation\";\n        hintsUl_1.appendChild(deprecation);\n        var onRemoveFn_1;\n        hintsUl_1.addEventListener(\"DOMNodeRemoved\", onRemoveFn_1 = function(event) {\n          if (event.target === hintsUl_1) {\n            hintsUl_1.removeEventListener(\"DOMNodeRemoved\", onRemoveFn_1);\n            information = null;\n            deprecation = null;\n            onRemoveFn_1 = null;\n          }\n        });\n      }\n      var description = ctx.description ? md$2.render(ctx.description) : \"Self descriptive.\";\n      var type2 = ctx.type ? '<span class=\"infoType\">' + renderType$2(ctx.type) + \"</span>\" : \"\";\n      information.innerHTML = '<div class=\"content\">' + (description.slice(0, 3) === \"<p>\" ? \"<p>\" + type2 + description.slice(3) : type2 + description) + \"</div>\";\n      if (ctx && deprecation && ctx.deprecationReason) {\n        var reason = ctx.deprecationReason ? md$2.render(ctx.deprecationReason) : \"\";\n        deprecation.innerHTML = '<span class=\"deprecation-label\">Deprecated</span>' + reason;\n        deprecation.style.display = \"block\";\n      } else if (deprecation) {\n        deprecation.style.display = \"none\";\n      }\n      if (onHintInformationRender) {\n        onHintInformationRender(information);\n      }\n    });\n  });\n}\nfunction renderType$2(type2) {\n  if (type2 instanceof GraphQLNonNull) {\n    return renderType$2(type2.ofType) + \"!\";\n  }\n  if (type2 instanceof GraphQLList) {\n    return \"[\" + renderType$2(type2.ofType) + \"]\";\n  }\n  return '<a class=\"typeName\">' + escapeHtml_1(type2.name) + \"</a>\";\n}\nvar _a;\nvar isMacOs = false;\nif (typeof window === \"object\") {\n  isMacOs = window.navigator.platform === \"MacIntel\";\n}\nvar commonKeys = (_a = {}, _a[isMacOs ? \"Cmd-F\" : \"Ctrl-F\"] = \"findPersistent\", _a[\"Cmd-G\"] = \"findPersistent\", _a[\"Ctrl-G\"] = \"findPersistent\", _a[\"Ctrl-Left\"] = \"goSubwordLeft\", _a[\"Ctrl-Right\"] = \"goSubwordRight\", _a[\"Alt-Left\"] = \"goGroupLeft\", _a[\"Alt-Right\"] = \"goGroupRight\", _a);\nvar __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result2) {\n      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator$6 = globalThis && globalThis.__generator || function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f, y2, t2, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t2[1]) {\n              _.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _.label < t2[2]) {\n              _.label = t2[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n};\nvar commonCodeMirrorAddons = [\n  Promise.resolve().then(function() {\n    return showHint$1;\n  }),\n  Promise.resolve().then(function() {\n    return matchbrackets$1;\n  }),\n  Promise.resolve().then(function() {\n    return closebrackets$1;\n  }),\n  Promise.resolve().then(function() {\n    return braceFold$1;\n  }),\n  Promise.resolve().then(function() {\n    return foldgutter$1;\n  }),\n  Promise.resolve().then(function() {\n    return lint$5;\n  }),\n  Promise.resolve().then(function() {\n    return searchcursor$1;\n  }),\n  Promise.resolve().then(function() {\n    return jumpToLine$1;\n  }),\n  Promise.resolve().then(function() {\n    return dialog$1;\n  }),\n  Promise.resolve().then(function() {\n    return sublime$1;\n  })\n];\nfunction importCodeMirror(addons, options) {\n  return __awaiter$6(this, void 0, void 0, function() {\n    var CodeMirror, allAddons;\n    return __generator$6(this, function(_a2) {\n      switch (_a2.label) {\n        case 0:\n          return [4, Promise.resolve().then(function() {\n            return codemirror$1;\n          })];\n        case 1:\n          CodeMirror = _a2.sent().default;\n          allAddons = (options === null || options === void 0 ? void 0 : options.useCommonAddons) === false ? addons : commonCodeMirrorAddons.concat(addons);\n          return [4, Promise.all(allAddons.map(function(addon) {\n            return addon;\n          }))];\n        case 2:\n          _a2.sent();\n          return [2, CodeMirror];\n      }\n    });\n  });\n}\nvar __extends$b = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign$a = globalThis && globalThis.__assign || function() {\n  __assign$a = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$a.apply(this, arguments);\n};\nvar __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result2) {\n      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator$5 = globalThis && globalThis.__generator || function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f, y2, t2, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t2[1]) {\n              _.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _.label < t2[2]) {\n              _.label = t2[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n};\nvar md$1 = new markdownIt();\nvar AUTO_COMPLETE_AFTER_KEY = /^[a-zA-Z0-9_@(]$/;\nvar QueryEditor = function(_super2) {\n  __extends$b(QueryEditor2, _super2);\n  function QueryEditor2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.editor = null;\n    _this.ignoreChangeEvent = false;\n    _this._node = null;\n    _this.addonModules = function() {\n      return [\n        Promise.resolve().then(function() {\n          return comment$1;\n        }),\n        Promise.resolve().then(function() {\n          return search$1;\n        }),\n        Promise.resolve().then(function() {\n          return hint$2;\n        }),\n        Promise.resolve().then(function() {\n          return lint$2;\n        }),\n        Promise.resolve().then(function() {\n          return info;\n        }),\n        Promise.resolve().then(function() {\n          return jump;\n        }),\n        Promise.resolve().then(function() {\n          return mode$4;\n        })\n      ];\n    };\n    _this._onKeyUp = function(_cm, event) {\n      if (AUTO_COMPLETE_AFTER_KEY.test(event.key) && _this.editor) {\n        _this.editor.execCommand(\"autocomplete\");\n      }\n    };\n    _this._onEdit = function() {\n      if (!_this.ignoreChangeEvent && _this.editor) {\n        _this.cachedValue = _this.editor.getValue();\n        if (_this.props.onEdit) {\n          _this.props.onEdit(_this.cachedValue);\n        }\n      }\n    };\n    _this._onHasCompletion = function(cm, data) {\n      onHasCompletion(cm, data, _this.props.onHintInformationRender);\n    };\n    _this.cachedValue = props.value || \"\";\n    return _this;\n  }\n  QueryEditor2.prototype.componentDidMount = function() {\n    var _this = this;\n    this.initializeEditor().then(function(editor) {\n      if (editor) {\n        editor.on(\"change\", _this._onEdit);\n        editor.on(\"keyup\", _this._onKeyUp);\n        editor.on(\"hasCompletion\", _this._onHasCompletion);\n        editor.on(\"beforeChange\", _this._onBeforeChange);\n      }\n    }).catch(console.error);\n  };\n  QueryEditor2.prototype.componentDidUpdate = function(prevProps) {\n    this.ignoreChangeEvent = true;\n    var signalChange = false;\n    if (this.props.schema !== prevProps.schema && this.editor) {\n      this.editor.options.lint.schema = this.props.schema;\n      this.editor.options.hintOptions.schema = this.props.schema;\n      this.editor.options.info.schema = this.props.schema;\n      this.editor.options.jump.schema = this.props.schema;\n      signalChange = true;\n    }\n    if (this.props.externalFragments !== prevProps.externalFragments && this.editor) {\n      this.editor.options.lint.externalFragments = this.props.externalFragments;\n      this.editor.options.hintOptions.externalFragments = this.props.externalFragments;\n      signalChange = true;\n    }\n    if (signalChange) {\n      this.CodeMirror.signal(this.editor, \"change\", this.editor);\n    }\n    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue && this.editor) {\n      this.cachedValue = this.props.value;\n      this.editor.setValue(this.props.value);\n    }\n    this.ignoreChangeEvent = false;\n  };\n  QueryEditor2.prototype.componentWillUnmount = function() {\n    if (this.editor) {\n      this.editor.off(\"change\", this._onEdit);\n      this.editor.off(\"keyup\", this._onKeyUp);\n      this.editor.off(\"hasCompletion\", this._onHasCompletion);\n    }\n  };\n  QueryEditor2.prototype.render = function() {\n    var _this = this;\n    return React$1.createElement(\"section\", { className: \"query-editor\", \"aria-label\": \"Query Editor\", ref: function(node) {\n      _this._node = node;\n    } });\n  };\n  QueryEditor2.prototype.initializeEditor = function() {\n    var _a2, _b, _c, _d;\n    return __awaiter$5(this, void 0, void 0, function() {\n      var CodeMirror, _e, editor;\n      var _this = this;\n      return __generator$5(this, function(_f) {\n        switch (_f.label) {\n          case 0:\n            _e = this;\n            return [4, importCodeMirror(this.addonModules())];\n          case 1:\n            CodeMirror = _e.CodeMirror = _f.sent();\n            editor = this.editor = CodeMirror(this._node, {\n              value: (_a2 = this.props.value) !== null && _a2 !== void 0 ? _a2 : \"\",\n              lineNumbers: true,\n              tabSize: 2,\n              foldGutter: {\n                minFoldSize: 4\n              },\n              mode: \"graphql\",\n              theme: this.props.editorTheme || \"graphiql\",\n              keyMap: \"sublime\",\n              autoCloseBrackets: true,\n              matchBrackets: true,\n              showCursorWhenSelecting: true,\n              readOnly: this.props.readOnly ? \"nocursor\" : false,\n              lint: {\n                schema: this.props.schema,\n                validationRules: (_b = this.props.validationRules) !== null && _b !== void 0 ? _b : null,\n                externalFragments: (_c = this.props) === null || _c === void 0 ? void 0 : _c.externalFragments\n              },\n              hintOptions: {\n                schema: this.props.schema,\n                closeOnUnfocus: false,\n                completeSingle: false,\n                container: this._node,\n                externalFragments: (_d = this.props) === null || _d === void 0 ? void 0 : _d.externalFragments\n              },\n              info: {\n                schema: this.props.schema,\n                renderDescription: function(text3) {\n                  return md$1.render(text3);\n                },\n                onClick: function(reference3) {\n                  return _this.props.onClickReference && _this.props.onClickReference(reference3);\n                }\n              },\n              jump: {\n                schema: this.props.schema,\n                onClick: function(reference3) {\n                  return _this.props.onClickReference && _this.props.onClickReference(reference3);\n                }\n              },\n              gutters: [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"],\n              extraKeys: __assign$a(__assign$a({ \"Cmd-Space\": function() {\n                return editor.showHint({ completeSingle: true, container: _this._node });\n              }, \"Ctrl-Space\": function() {\n                return editor.showHint({ completeSingle: true, container: _this._node });\n              }, \"Alt-Space\": function() {\n                return editor.showHint({ completeSingle: true, container: _this._node });\n              }, \"Shift-Space\": function() {\n                return editor.showHint({ completeSingle: true, container: _this._node });\n              }, \"Shift-Alt-Space\": function() {\n                return editor.showHint({ completeSingle: true, container: _this._node });\n              }, \"Cmd-Enter\": function() {\n                if (_this.props.onRunQuery) {\n                  _this.props.onRunQuery();\n                }\n              }, \"Ctrl-Enter\": function() {\n                if (_this.props.onRunQuery) {\n                  _this.props.onRunQuery();\n                }\n              }, \"Shift-Ctrl-C\": function() {\n                if (_this.props.onCopyQuery) {\n                  _this.props.onCopyQuery();\n                }\n              }, \"Shift-Ctrl-P\": function() {\n                if (_this.props.onPrettifyQuery) {\n                  _this.props.onPrettifyQuery();\n                }\n              }, \"Shift-Ctrl-F\": function() {\n                if (_this.props.onPrettifyQuery) {\n                  _this.props.onPrettifyQuery();\n                }\n              }, \"Shift-Ctrl-M\": function() {\n                if (_this.props.onMergeQuery) {\n                  _this.props.onMergeQuery();\n                }\n              } }, commonKeys), { \"Cmd-S\": function() {\n                if (_this.props.onRunQuery)\n                  ;\n              }, \"Ctrl-S\": function() {\n                if (_this.props.onRunQuery)\n                  ;\n              } })\n            });\n            return [2, editor];\n        }\n      });\n    });\n  };\n  QueryEditor2.prototype.getCodeMirror = function() {\n    return this.editor;\n  };\n  QueryEditor2.prototype.getClientHeight = function() {\n    return this._node && this._node.clientHeight;\n  };\n  QueryEditor2.prototype._onBeforeChange = function(_instance, change) {\n    if (change.origin === \"paste\") {\n      var text3 = change.text.map(normalizeWhitespace);\n      change.update(change.from, change.to, text3);\n    }\n  };\n  return QueryEditor2;\n}(React$1.Component);\nvar __extends$a = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign$9 = globalThis && globalThis.__assign || function() {\n  __assign$9 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$9.apply(this, arguments);\n};\nvar __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result2) {\n      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator$4 = globalThis && globalThis.__generator || function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f, y2, t2, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t2[1]) {\n              _.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _.label < t2[2]) {\n              _.label = t2[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n};\nvar VariableEditor = function(_super2) {\n  __extends$a(VariableEditor2, _super2);\n  function VariableEditor2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.editor = null;\n    _this._node = null;\n    _this.ignoreChangeEvent = false;\n    _this.addonModules = function() {\n      return [\n        Promise.resolve().then(function() {\n          return hint;\n        }),\n        Promise.resolve().then(function() {\n          return lint;\n        }),\n        Promise.resolve().then(function() {\n          return mode$2;\n        })\n      ];\n    };\n    _this._onKeyUp = function(_cm, event) {\n      var code3 = event.keyCode;\n      if (!_this.editor) {\n        return;\n      }\n      if (code3 >= 65 && code3 <= 90 || !event.shiftKey && code3 >= 48 && code3 <= 57 || event.shiftKey && code3 === 189 || event.shiftKey && code3 === 222) {\n        _this.editor.execCommand(\"autocomplete\");\n      }\n    };\n    _this._onEdit = function() {\n      if (!_this.editor) {\n        return;\n      }\n      if (!_this.ignoreChangeEvent) {\n        _this.cachedValue = _this.editor.getValue();\n        if (_this.props.onEdit) {\n          _this.props.onEdit(_this.cachedValue);\n        }\n      }\n    };\n    _this._onHasCompletion = function(instance, changeObj) {\n      onHasCompletion(instance, changeObj, _this.props.onHintInformationRender);\n    };\n    _this.cachedValue = props.value || \"\";\n    return _this;\n  }\n  VariableEditor2.prototype.componentDidMount = function() {\n    var _this = this;\n    this.initializeEditor().then(function(editor) {\n      editor.on(\"change\", _this._onEdit);\n      editor.on(\"keyup\", _this._onKeyUp);\n      editor.on(\"hasCompletion\", _this._onHasCompletion);\n    }).catch(console.error);\n  };\n  VariableEditor2.prototype.componentDidUpdate = function(prevProps) {\n    if (!this.editor) {\n      return;\n    }\n    if (!this.CodeMirror) {\n      return;\n    }\n    this.ignoreChangeEvent = true;\n    if (this.props.variableToType !== prevProps.variableToType) {\n      this.editor.options.lint.variableToType = this.props.variableToType;\n      this.editor.options.hintOptions.variableToType = this.props.variableToType;\n      this.CodeMirror.signal(this.editor, \"change\", this.editor);\n    }\n    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {\n      var thisValue = this.props.value || \"\";\n      this.cachedValue = thisValue;\n      this.editor.setValue(thisValue);\n    }\n    this.ignoreChangeEvent = false;\n  };\n  VariableEditor2.prototype.componentWillUnmount = function() {\n    if (!this.editor) {\n      return;\n    }\n    this.editor.off(\"change\", this._onEdit);\n    this.editor.off(\"keyup\", this._onKeyUp);\n    this.editor.off(\"hasCompletion\", this._onHasCompletion);\n    this.editor = null;\n  };\n  VariableEditor2.prototype.render = function() {\n    var _this = this;\n    return React$1.createElement(\"div\", { className: \"codemirrorWrap\", style: {\n      position: this.props.active ? \"relative\" : \"absolute\",\n      visibility: this.props.active ? \"visible\" : \"hidden\"\n    }, ref: function(node) {\n      _this._node = node;\n    } });\n  };\n  VariableEditor2.prototype.initializeEditor = function() {\n    return __awaiter$4(this, void 0, void 0, function() {\n      var _a2, editor;\n      var _this = this;\n      return __generator$4(this, function(_b) {\n        switch (_b.label) {\n          case 0:\n            _a2 = this;\n            return [4, importCodeMirror(this.addonModules())];\n          case 1:\n            _a2.CodeMirror = _b.sent();\n            editor = this.editor = this.CodeMirror(this._node, {\n              value: this.props.value || \"\",\n              lineNumbers: true,\n              tabSize: 2,\n              mode: \"graphql-variables\",\n              theme: this.props.editorTheme || \"graphiql\",\n              keyMap: \"sublime\",\n              autoCloseBrackets: true,\n              matchBrackets: true,\n              showCursorWhenSelecting: true,\n              readOnly: this.props.readOnly ? \"nocursor\" : false,\n              foldGutter: {\n                minFoldSize: 4\n              },\n              lint: {\n                variableToType: this.props.variableToType\n              },\n              hintOptions: {\n                variableToType: this.props.variableToType,\n                closeOnUnfocus: false,\n                completeSingle: false,\n                container: this._node\n              },\n              gutters: [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"],\n              extraKeys: __assign$9({ \"Cmd-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Ctrl-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Alt-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Shift-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Cmd-Enter\": function() {\n                if (_this.props.onRunQuery) {\n                  _this.props.onRunQuery();\n                }\n              }, \"Ctrl-Enter\": function() {\n                if (_this.props.onRunQuery) {\n                  _this.props.onRunQuery();\n                }\n              }, \"Shift-Ctrl-P\": function() {\n                if (_this.props.onPrettifyQuery) {\n                  _this.props.onPrettifyQuery();\n                }\n              }, \"Shift-Ctrl-M\": function() {\n                if (_this.props.onMergeQuery) {\n                  _this.props.onMergeQuery();\n                }\n              } }, commonKeys)\n            });\n            return [2, editor];\n        }\n      });\n    });\n  };\n  VariableEditor2.prototype.getCodeMirror = function() {\n    return this.editor;\n  };\n  VariableEditor2.prototype.getClientHeight = function() {\n    return this._node && this._node.clientHeight;\n  };\n  return VariableEditor2;\n}(React$1.Component);\nvar __extends$9 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign$8 = globalThis && globalThis.__assign || function() {\n  __assign$8 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$8.apply(this, arguments);\n};\nvar __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result2) {\n      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator$3 = globalThis && globalThis.__generator || function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f, y2, t2, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t2[1]) {\n              _.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _.label < t2[2]) {\n              _.label = t2[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n};\nvar HeaderEditor = function(_super2) {\n  __extends$9(HeaderEditor2, _super2);\n  function HeaderEditor2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.editor = null;\n    _this._node = null;\n    _this.ignoreChangeEvent = false;\n    _this.addonModules = function() {\n      return [Promise.resolve().then(function() {\n        return javascript$1;\n      })];\n    };\n    _this._onKeyUp = function(_cm, event) {\n      var code3 = event.keyCode;\n      if (!_this.editor) {\n        return;\n      }\n      if (code3 >= 65 && code3 <= 90 || !event.shiftKey && code3 >= 48 && code3 <= 57 || event.shiftKey && code3 === 189 || event.shiftKey && code3 === 222) {\n        _this.editor.execCommand(\"autocomplete\");\n      }\n    };\n    _this._onEdit = function() {\n      if (!_this.editor) {\n        return;\n      }\n      if (!_this.ignoreChangeEvent) {\n        _this.cachedValue = _this.editor.getValue();\n        if (_this.props.onEdit) {\n          _this.props.onEdit(_this.cachedValue);\n        }\n      }\n    };\n    _this._onHasCompletion = function(instance, changeObj) {\n      onHasCompletion(instance, changeObj, _this.props.onHintInformationRender);\n    };\n    _this.cachedValue = props.value || \"\";\n    return _this;\n  }\n  HeaderEditor2.prototype.componentDidMount = function() {\n    var _this = this;\n    this.initializeEditor().then(function(editor) {\n      editor.on(\"change\", _this._onEdit);\n      editor.on(\"keyup\", _this._onKeyUp);\n      editor.on(\"hasCompletion\", _this._onHasCompletion);\n    }).catch(console.error);\n  };\n  HeaderEditor2.prototype.componentDidUpdate = function(prevProps) {\n    if (!this.editor) {\n      return;\n    }\n    this.ignoreChangeEvent = true;\n    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {\n      var thisValue = this.props.value || \"\";\n      this.cachedValue = thisValue;\n      this.editor.setValue(thisValue);\n    }\n    this.ignoreChangeEvent = false;\n  };\n  HeaderEditor2.prototype.componentWillUnmount = function() {\n    if (!this.editor) {\n      return;\n    }\n    this.editor.off(\"change\", this._onEdit);\n    this.editor.off(\"keyup\", this._onKeyUp);\n    this.editor.off(\"hasCompletion\", this._onHasCompletion);\n    this.editor = null;\n  };\n  HeaderEditor2.prototype.render = function() {\n    var _this = this;\n    return React$1.createElement(\"div\", { className: \"codemirrorWrap\", style: {\n      position: this.props.active ? \"relative\" : \"absolute\",\n      visibility: this.props.active ? \"visible\" : \"hidden\"\n    }, ref: function(node) {\n      _this._node = node;\n    } });\n  };\n  HeaderEditor2.prototype.initializeEditor = function() {\n    return __awaiter$3(this, void 0, void 0, function() {\n      var _a2, editor;\n      var _this = this;\n      return __generator$3(this, function(_b) {\n        switch (_b.label) {\n          case 0:\n            _a2 = this;\n            return [4, importCodeMirror(this.addonModules())];\n          case 1:\n            _a2.CodeMirror = _b.sent();\n            editor = this.editor = this.CodeMirror(this._node, {\n              value: this.props.value || \"\",\n              lineNumbers: true,\n              tabSize: 2,\n              mode: { name: \"javascript\", json: true },\n              theme: this.props.editorTheme || \"graphiql\",\n              keyMap: \"sublime\",\n              autoCloseBrackets: true,\n              matchBrackets: true,\n              showCursorWhenSelecting: true,\n              readOnly: this.props.readOnly ? \"nocursor\" : false,\n              foldGutter: {\n                minFoldSize: 4\n              },\n              gutters: [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"],\n              extraKeys: __assign$8({ \"Cmd-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Ctrl-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Alt-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Shift-Space\": function() {\n                return _this.editor.showHint({\n                  completeSingle: false,\n                  container: _this._node\n                });\n              }, \"Cmd-Enter\": function() {\n                if (_this.props.onRunQuery) {\n                  _this.props.onRunQuery();\n                }\n              }, \"Ctrl-Enter\": function() {\n                if (_this.props.onRunQuery) {\n                  _this.props.onRunQuery();\n                }\n              }, \"Shift-Ctrl-P\": function() {\n                if (_this.props.onPrettifyQuery) {\n                  _this.props.onPrettifyQuery();\n                }\n              }, \"Shift-Ctrl-M\": function() {\n                if (_this.props.onMergeQuery) {\n                  _this.props.onMergeQuery();\n                }\n              } }, commonKeys)\n            });\n            return [2, editor];\n        }\n      });\n    });\n  };\n  HeaderEditor2.prototype.getCodeMirror = function() {\n    return this.editor;\n  };\n  HeaderEditor2.prototype.getClientHeight = function() {\n    return this._node && this._node.clientHeight;\n  };\n  return HeaderEditor2;\n}(React$1.Component);\nvar __extends$8 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result2) {\n      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator$2 = globalThis && globalThis.__generator || function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f, y2, t2, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t2[1]) {\n              _.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _.label < t2[2]) {\n              _.label = t2[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n};\nvar ResultViewer = function(_super2) {\n  __extends$8(ResultViewer2, _super2);\n  function ResultViewer2() {\n    var _this = _super2 !== null && _super2.apply(this, arguments) || this;\n    _this.viewer = null;\n    _this._node = null;\n    _this.allAddons = function() {\n      return [\n        Promise.resolve().then(function() {\n          return foldgutter$1;\n        }),\n        Promise.resolve().then(function() {\n          return braceFold$1;\n        }),\n        Promise.resolve().then(function() {\n          return dialog$1;\n        }),\n        Promise.resolve().then(function() {\n          return search$1;\n        }),\n        Promise.resolve().then(function() {\n          return searchcursor$1;\n        }),\n        Promise.resolve().then(function() {\n          return jumpToLine$1;\n        }),\n        Promise.resolve().then(function() {\n          return sublime$1;\n        }),\n        Promise.resolve().then(function() {\n          return mode;\n        })\n      ];\n    };\n    return _this;\n  }\n  ResultViewer2.prototype.componentDidMount = function() {\n    this.initializeEditor();\n  };\n  ResultViewer2.prototype.shouldComponentUpdate = function(nextProps) {\n    return this.props.value !== nextProps.value;\n  };\n  ResultViewer2.prototype.componentDidUpdate = function() {\n    if (this.viewer) {\n      this.viewer.setValue(this.props.value || \"\");\n    }\n  };\n  ResultViewer2.prototype.componentWillUnmount = function() {\n    this.viewer = null;\n  };\n  ResultViewer2.prototype.render = function() {\n    var _this = this;\n    return React$1.createElement(\"section\", { className: \"result-window\", \"aria-label\": \"Result Window\", \"aria-live\": \"polite\", \"aria-atomic\": \"true\", ref: function(node) {\n      if (node) {\n        _this.props.registerRef(node);\n        _this._node = node;\n      }\n    } });\n  };\n  ResultViewer2.prototype.initializeEditor = function() {\n    return __awaiter$2(this, void 0, void 0, function() {\n      var CodeMirror, Tooltip, ImagePreview2, tooltipDiv_1;\n      return __generator$2(this, function(_a2) {\n        switch (_a2.label) {\n          case 0:\n            return [4, importCodeMirror(this.allAddons(), {\n              useCommonAddons: false\n            })];\n          case 1:\n            CodeMirror = _a2.sent();\n            Tooltip = this.props.ResultsTooltip;\n            ImagePreview2 = this.props.ImagePreview;\n            if (!(Tooltip || ImagePreview2))\n              return [3, 3];\n            return [4, Promise.resolve().then(function() {\n              return infoAddon;\n            })];\n          case 2:\n            _a2.sent();\n            tooltipDiv_1 = document.createElement(\"div\");\n            CodeMirror.registerHelper(\"info\", \"graphql-results\", function(token2, _options, _cm, pos) {\n              var infoElements = [];\n              if (Tooltip) {\n                infoElements.push(React$1.createElement(Tooltip, { pos }));\n              }\n              if (ImagePreview2 && typeof ImagePreview2.shouldRender === \"function\" && ImagePreview2.shouldRender(token2)) {\n                infoElements.push(React$1.createElement(ImagePreview2, { token: token2 }));\n              }\n              if (!infoElements.length) {\n                ReactDOM.unmountComponentAtNode(tooltipDiv_1);\n                return null;\n              }\n              ReactDOM.render(React$1.createElement(\"div\", null, infoElements), tooltipDiv_1);\n              return tooltipDiv_1;\n            });\n            _a2.label = 3;\n          case 3:\n            this.viewer = CodeMirror(this._node, {\n              lineWrapping: true,\n              value: this.props.value || \"\",\n              readOnly: true,\n              theme: this.props.editorTheme || \"graphiql\",\n              mode: \"graphql-results\",\n              keyMap: \"sublime\",\n              foldGutter: {\n                minFoldSize: 4\n              },\n              gutters: [\"CodeMirror-foldgutter\"],\n              info: Boolean(this.props.ResultsTooltip || this.props.ImagePreview),\n              extraKeys: commonKeys\n            });\n            return [2];\n        }\n      });\n    });\n  };\n  ResultViewer2.prototype.getCodeMirror = function() {\n    return this.viewer;\n  };\n  ResultViewer2.prototype.getClientHeight = function() {\n    return this._node && this._node.clientHeight;\n  };\n  return ResultViewer2;\n}(React$1.Component);\nfunction TypeLink(props) {\n  var onClick = props.onClick ? props.onClick : function() {\n    return null;\n  };\n  return renderType$1(props.type, onClick);\n}\nfunction renderType$1(type2, onClick) {\n  if (type2 instanceof GraphQLNonNull) {\n    return React$1.createElement(\"span\", null, renderType$1(type2.ofType, onClick), \"!\");\n  }\n  if (type2 instanceof GraphQLList) {\n    return React$1.createElement(\"span\", null, \"[\", renderType$1(type2.ofType, onClick), \"]\");\n  }\n  return React$1.createElement(\"a\", { className: \"type-name\", onClick: function(event) {\n    event.preventDefault();\n    onClick(type2, event);\n  }, href: \"#\" }, type2 === null || type2 === void 0 ? void 0 : type2.name);\n}\nvar printDefault = function(ast2) {\n  if (!ast2) {\n    return \"\";\n  }\n  return print(ast2);\n};\nfunction DefaultValue(_a2) {\n  var field = _a2.field;\n  if (\"defaultValue\" in field && field.defaultValue !== void 0) {\n    return React$1.createElement(\"span\", null, \" = \", React$1.createElement(\"span\", { className: \"arg-default-value\" }, printDefault(astFromValue(field.defaultValue, field.type))));\n  }\n  return null;\n}\nfunction Argument(_a2) {\n  var arg = _a2.arg, onClickType = _a2.onClickType, showDefaultValue = _a2.showDefaultValue;\n  return React$1.createElement(\"span\", { className: \"arg\" }, React$1.createElement(\"span\", { className: \"arg-name\" }, arg.name), \": \", React$1.createElement(TypeLink, { type: arg.type, onClick: onClickType }), showDefaultValue !== false && React$1.createElement(DefaultValue, { field: arg }));\n}\nfunction Directive(_a2) {\n  var directive = _a2.directive;\n  return React$1.createElement(\"span\", { className: \"doc-category-item\", id: directive.name.value }, \"@\", directive.name.value);\n}\nvar md = new markdownIt({\n  breaks: true,\n  linkify: true\n});\nfunction MarkdownContent(_a2) {\n  var markdown = _a2.markdown, className = _a2.className;\n  if (!markdown) {\n    return React$1.createElement(\"div\", null);\n  }\n  return React$1.createElement(\"div\", { className, dangerouslySetInnerHTML: { __html: md.render(markdown) } });\n}\nvar __read$5 = globalThis && globalThis.__read || function(o, n2) {\n  var m2 = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m2)\n    return o;\n  var i = m2.call(o), r2, ar = [], e;\n  try {\n    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)\n      ar.push(r2.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m2 = i[\"return\"]))\n        m2.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nfunction FieldDoc(_a2) {\n  var field = _a2.field, onClickType = _a2.onClickType;\n  var _b = __read$5(React$1.useState(false), 2), showDeprecated = _b[0], handleShowDeprecated = _b[1];\n  var argsDef;\n  var deprecatedArgsDef;\n  if (field && \"args\" in field && field.args.length > 0) {\n    argsDef = React$1.createElement(\"div\", { id: \"doc-args\", className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"arguments\"), field.args.filter(function(arg) {\n      return !arg.deprecationReason;\n    }).map(function(arg) {\n      return React$1.createElement(\"div\", { key: arg.name, className: \"doc-category-item\" }, React$1.createElement(\"div\", null, React$1.createElement(Argument, { arg, onClickType })), React$1.createElement(MarkdownContent, { className: \"doc-value-description\", markdown: arg.description }), arg && \"deprecationReason\" in arg && React$1.createElement(MarkdownContent, { className: \"doc-deprecation\", markdown: arg === null || arg === void 0 ? void 0 : arg.deprecationReason }));\n    }));\n    var deprecatedArgs = field.args.filter(function(arg) {\n      return Boolean(arg.deprecationReason);\n    });\n    if (deprecatedArgs.length > 0) {\n      deprecatedArgsDef = React$1.createElement(\"div\", { id: \"doc-deprecated-args\", className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"deprecated arguments\"), !showDeprecated ? React$1.createElement(\"button\", { className: \"show-btn\", onClick: function() {\n        return handleShowDeprecated(!showDeprecated);\n      } }, \"Show deprecated arguments...\") : deprecatedArgs.map(function(arg, i) {\n        return React$1.createElement(\"div\", { key: i }, React$1.createElement(\"div\", null, React$1.createElement(Argument, { arg, onClickType })), React$1.createElement(MarkdownContent, { className: \"doc-value-description\", markdown: arg.description }), arg && \"deprecationReason\" in arg && React$1.createElement(MarkdownContent, { className: \"doc-deprecation\", markdown: arg === null || arg === void 0 ? void 0 : arg.deprecationReason }));\n      }));\n    }\n  }\n  var directivesDef;\n  if (field && field.astNode && field.astNode.directives && field.astNode.directives.length > 0) {\n    directivesDef = React$1.createElement(\"div\", { id: \"doc-directives\", className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"directives\"), field.astNode.directives.map(function(directive) {\n      return React$1.createElement(\"div\", { key: directive.name.value, className: \"doc-category-item\" }, React$1.createElement(\"div\", null, React$1.createElement(Directive, { directive })));\n    }));\n  }\n  return React$1.createElement(\"div\", null, React$1.createElement(MarkdownContent, { className: \"doc-type-description\", markdown: (field === null || field === void 0 ? void 0 : field.description) || \"No Description\" }), field && \"deprecationReason\" in field && React$1.createElement(MarkdownContent, { className: \"doc-deprecation\", markdown: field === null || field === void 0 ? void 0 : field.deprecationReason }), React$1.createElement(\"div\", { className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"type\"), React$1.createElement(TypeLink, { type: field === null || field === void 0 ? void 0 : field.type, onClick: onClickType })), argsDef, directivesDef, deprecatedArgsDef);\n}\nfunction SchemaDoc(_a2) {\n  var schema = _a2.schema, onClickType = _a2.onClickType;\n  var queryType = schema.getQueryType();\n  var mutationType = schema.getMutationType && schema.getMutationType();\n  var subscriptionType = schema.getSubscriptionType && schema.getSubscriptionType();\n  return React$1.createElement(\"div\", null, React$1.createElement(MarkdownContent, { className: \"doc-type-description\", markdown: schema.description || \"A GraphQL schema provides a root type for each kind of operation.\" }), React$1.createElement(\"div\", { className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"root types\"), React$1.createElement(\"div\", { className: \"doc-category-item\" }, React$1.createElement(\"span\", { className: \"keyword\" }, \"query\"), \": \", React$1.createElement(TypeLink, { type: queryType, onClick: onClickType })), mutationType && React$1.createElement(\"div\", { className: \"doc-category-item\" }, React$1.createElement(\"span\", { className: \"keyword\" }, \"mutation\"), \": \", React$1.createElement(TypeLink, { type: mutationType, onClick: onClickType })), subscriptionType && React$1.createElement(\"div\", { className: \"doc-category-item\" }, React$1.createElement(\"span\", { className: \"keyword\" }, \"subscription\"), \": \", React$1.createElement(TypeLink, { type: subscriptionType, onClick: onClickType }))));\n}\nfunction debounce(duration, fn) {\n  var timeout;\n  return function() {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (timeout) {\n      window.clearTimeout(timeout);\n    }\n    timeout = window.setTimeout(function() {\n      timeout = null;\n      fn.apply(_this, args);\n    }, duration);\n  };\n}\nvar __extends$7 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar SearchBox = function(_super2) {\n  __extends$7(SearchBox2, _super2);\n  function SearchBox2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.handleChange = function(event) {\n      var value = event.currentTarget.value;\n      _this.setState({ value });\n      _this.debouncedOnSearch(value);\n    };\n    _this.handleClear = function() {\n      _this.setState({ value: \"\" });\n      _this.props.onSearch(\"\");\n    };\n    _this.state = { value: props.value || \"\" };\n    _this.debouncedOnSearch = debounce(200, _this.props.onSearch);\n    return _this;\n  }\n  SearchBox2.prototype.render = function() {\n    return React$1.createElement(\"label\", { className: \"search-box\" }, React$1.createElement(\"div\", { className: \"search-box-icon\", \"aria-hidden\": \"true\" }, \"\\u26B2\"), React$1.createElement(\"input\", { value: this.state.value, onChange: this.handleChange, type: \"text\", placeholder: this.props.placeholder, \"aria-label\": this.props.placeholder }), this.state.value && React$1.createElement(\"button\", { className: \"search-box-clear\", onClick: this.handleClear, \"aria-label\": \"Clear search input\" }, \"\\u2715\"));\n  };\n  return SearchBox2;\n}(React$1.Component);\nvar __extends$6 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values$3 = globalThis && globalThis.__values || function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m2 = s && o[s], i = 0;\n  if (m2)\n    return m2.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar SearchResults = function(_super2) {\n  __extends$6(SearchResults2, _super2);\n  function SearchResults2() {\n    return _super2 !== null && _super2.apply(this, arguments) || this;\n  }\n  SearchResults2.prototype.shouldComponentUpdate = function(nextProps) {\n    return this.props.schema !== nextProps.schema || this.props.searchValue !== nextProps.searchValue;\n  };\n  SearchResults2.prototype.render = function() {\n    var e_1, _a2;\n    var searchValue = this.props.searchValue;\n    var withinType = this.props.withinType;\n    var schema = this.props.schema;\n    var onClickType = this.props.onClickType;\n    var onClickField = this.props.onClickField;\n    var matchedWithin = [];\n    var matchedTypes = [];\n    var matchedFields = [];\n    var typeMap = schema.getTypeMap();\n    var typeNames = Object.keys(typeMap);\n    if (withinType) {\n      typeNames = typeNames.filter(function(n2) {\n        return n2 !== withinType.name;\n      });\n      typeNames.unshift(withinType.name);\n    }\n    var _loop_1 = function(typeName2) {\n      if (matchedWithin.length + matchedTypes.length + matchedFields.length >= 100) {\n        return \"break\";\n      }\n      var type2 = typeMap[typeName2];\n      if (withinType !== type2 && isMatch(typeName2, searchValue)) {\n        matchedTypes.push(React$1.createElement(\"div\", { className: \"doc-category-item\", key: typeName2 }, React$1.createElement(TypeLink, { type: type2, onClick: onClickType })));\n      }\n      if (type2 && \"getFields\" in type2) {\n        var fields_1 = type2.getFields();\n        Object.keys(fields_1).forEach(function(fieldName) {\n          var field = fields_1[fieldName];\n          var matchingArgs;\n          if (!isMatch(fieldName, searchValue)) {\n            if (\"args\" in field && field.args.length) {\n              matchingArgs = field.args.filter(function(arg) {\n                return isMatch(arg.name, searchValue);\n              });\n              if (matchingArgs.length === 0) {\n                return;\n              }\n            } else {\n              return;\n            }\n          }\n          var match2 = React$1.createElement(\"div\", { className: \"doc-category-item\", key: typeName2 + \".\" + fieldName }, withinType !== type2 && [\n            React$1.createElement(TypeLink, { key: \"type\", type: type2, onClick: onClickType }),\n            \".\"\n          ], React$1.createElement(\"a\", { className: \"field-name\", onClick: function(event) {\n            return onClickField(field, type2, event);\n          } }, field.name), matchingArgs && [\n            \"(\",\n            React$1.createElement(\"span\", { key: \"args\" }, matchingArgs.map(function(arg) {\n              return React$1.createElement(Argument, { key: arg.name, arg, onClickType, showDefaultValue: false });\n            })),\n            \")\"\n          ]);\n          if (withinType === type2) {\n            matchedWithin.push(match2);\n          } else {\n            matchedFields.push(match2);\n          }\n        });\n      }\n    };\n    try {\n      for (var typeNames_1 = __values$3(typeNames), typeNames_1_1 = typeNames_1.next(); !typeNames_1_1.done; typeNames_1_1 = typeNames_1.next()) {\n        var typeName = typeNames_1_1.value;\n        var state_1 = _loop_1(typeName);\n        if (state_1 === \"break\")\n          break;\n      }\n    } catch (e_1_1) {\n      e_1 = { error: e_1_1 };\n    } finally {\n      try {\n        if (typeNames_1_1 && !typeNames_1_1.done && (_a2 = typeNames_1.return))\n          _a2.call(typeNames_1);\n      } finally {\n        if (e_1)\n          throw e_1.error;\n      }\n    }\n    if (matchedWithin.length + matchedTypes.length + matchedFields.length === 0) {\n      return React$1.createElement(\"span\", { className: \"doc-alert-text\" }, \"No results found.\");\n    }\n    if (withinType && matchedTypes.length + matchedFields.length > 0) {\n      return React$1.createElement(\"div\", null, matchedWithin, React$1.createElement(\"div\", { className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"other results\"), matchedTypes, matchedFields));\n    }\n    return React$1.createElement(\"div\", { className: \"doc-search-items\" }, matchedWithin, matchedTypes, matchedFields);\n  };\n  return SearchResults2;\n}(React$1.Component);\nfunction isMatch(sourceText, searchValue) {\n  try {\n    var escaped = searchValue.replace(/[^_0-9A-Za-z]/g, function(ch2) {\n      return \"\\\\\" + ch2;\n    });\n    return sourceText.search(new RegExp(escaped, \"i\")) !== -1;\n  } catch (e) {\n    return sourceText.toLowerCase().indexOf(searchValue.toLowerCase()) !== -1;\n  }\n}\nvar __extends$5 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar TypeDoc = function(_super2) {\n  __extends$5(TypeDoc2, _super2);\n  function TypeDoc2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.handleShowDeprecated = function() {\n      return _this.setState({ showDeprecated: true });\n    };\n    _this.state = { showDeprecated: false };\n    return _this;\n  }\n  TypeDoc2.prototype.shouldComponentUpdate = function(nextProps, nextState) {\n    return this.props.type !== nextProps.type || this.props.schema !== nextProps.schema || this.state.showDeprecated !== nextState.showDeprecated;\n  };\n  TypeDoc2.prototype.render = function() {\n    var schema = this.props.schema;\n    var type2 = this.props.type;\n    var onClickType = this.props.onClickType;\n    var onClickField = this.props.onClickField;\n    var typesTitle = null;\n    var types = [];\n    if (type2 instanceof GraphQLUnionType) {\n      typesTitle = \"possible types\";\n      types = schema.getPossibleTypes(type2);\n    } else if (type2 instanceof GraphQLInterfaceType) {\n      typesTitle = \"implementations\";\n      types = schema.getPossibleTypes(type2);\n    } else if (type2 instanceof GraphQLObjectType) {\n      typesTitle = \"implements\";\n      types = type2.getInterfaces();\n    }\n    var typesDef;\n    if (types && types.length > 0) {\n      typesDef = React$1.createElement(\"div\", { id: \"doc-types\", className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, typesTitle), types.map(function(subtype) {\n        return React$1.createElement(\"div\", { key: subtype.name, className: \"doc-category-item\" }, React$1.createElement(TypeLink, { type: subtype, onClick: onClickType }));\n      }));\n    }\n    var fieldsDef;\n    var deprecatedFieldsDef;\n    if (type2 && \"getFields\" in type2) {\n      var fieldMap_1 = type2.getFields();\n      var fields = Object.keys(fieldMap_1).map(function(name2) {\n        return fieldMap_1[name2];\n      });\n      fieldsDef = React$1.createElement(\"div\", { id: \"doc-fields\", className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"fields\"), fields.filter(function(field) {\n        return !field.deprecationReason;\n      }).map(function(field) {\n        return React$1.createElement(Field, { key: field.name, type: type2, field, onClickType, onClickField });\n      }));\n      var deprecatedFields = fields.filter(function(field) {\n        return Boolean(field.deprecationReason);\n      });\n      if (deprecatedFields.length > 0) {\n        deprecatedFieldsDef = React$1.createElement(\"div\", { id: \"doc-deprecated-fields\", className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"deprecated fields\"), !this.state.showDeprecated ? React$1.createElement(\"button\", { className: \"show-btn\", onClick: this.handleShowDeprecated }, \"Show deprecated fields...\") : deprecatedFields.map(function(field) {\n          return React$1.createElement(Field, { key: field.name, type: type2, field, onClickType, onClickField });\n        }));\n      }\n    }\n    var valuesDef;\n    var deprecatedValuesDef;\n    if (type2 instanceof GraphQLEnumType) {\n      var values = type2.getValues();\n      valuesDef = React$1.createElement(\"div\", { className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"values\"), values.filter(function(value) {\n        return Boolean(!value.deprecationReason);\n      }).map(function(value) {\n        return React$1.createElement(EnumValue, { key: value.name, value });\n      }));\n      var deprecatedValues = values.filter(function(value) {\n        return Boolean(value.deprecationReason);\n      });\n      if (deprecatedValues.length > 0) {\n        deprecatedValuesDef = React$1.createElement(\"div\", { className: \"doc-category\" }, React$1.createElement(\"div\", { className: \"doc-category-title\" }, \"deprecated values\"), !this.state.showDeprecated ? React$1.createElement(\"button\", { className: \"show-btn\", onClick: this.handleShowDeprecated }, \"Show deprecated values...\") : deprecatedValues.map(function(value) {\n          return React$1.createElement(EnumValue, { key: value.name, value });\n        }));\n      }\n    }\n    return React$1.createElement(\"div\", null, React$1.createElement(MarkdownContent, { className: \"doc-type-description\", markdown: \"description\" in type2 && type2.description || \"No Description\" }), type2 instanceof GraphQLObjectType && typesDef, fieldsDef, deprecatedFieldsDef, valuesDef, deprecatedValuesDef, !(type2 instanceof GraphQLObjectType) && typesDef);\n  };\n  return TypeDoc2;\n}(React$1.Component);\nfunction Field(_a2) {\n  var type2 = _a2.type, field = _a2.field, onClickType = _a2.onClickType, onClickField = _a2.onClickField;\n  return React$1.createElement(\"div\", { className: \"doc-category-item\" }, React$1.createElement(\"a\", { className: \"field-name\", onClick: function(event) {\n    return onClickField(field, type2, event);\n  } }, field.name), \"args\" in field && field.args && field.args.length > 0 && [\n    \"(\",\n    React$1.createElement(\"span\", { key: \"args\" }, field.args.filter(function(arg) {\n      return !arg.deprecationReason;\n    }).map(function(arg) {\n      return React$1.createElement(Argument, { key: arg.name, arg, onClickType });\n    })),\n    \")\"\n  ], \": \", React$1.createElement(TypeLink, { type: field.type, onClick: onClickType }), React$1.createElement(DefaultValue, { field }), field.description && React$1.createElement(MarkdownContent, { className: \"field-short-description\", markdown: field.description }), \"deprecationReason\" in field && field.deprecationReason && React$1.createElement(MarkdownContent, { className: \"doc-deprecation\", markdown: field.deprecationReason }));\n}\nfunction EnumValue(_a2) {\n  var value = _a2.value;\n  return React$1.createElement(\"div\", { className: \"doc-category-item\" }, React$1.createElement(\"div\", { className: \"enum-value\" }, value.name), React$1.createElement(MarkdownContent, { className: \"doc-value-description\", markdown: value.description }), value.deprecationReason && React$1.createElement(MarkdownContent, { className: \"doc-deprecation\", markdown: value.deprecationReason }));\n}\nvar __extends$4 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign$7 = globalThis && globalThis.__assign || function() {\n  __assign$7 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$7.apply(this, arguments);\n};\nvar initialNav = {\n  name: \"Schema\",\n  title: \"Documentation Explorer\"\n};\nvar DocExplorer = function(_super2) {\n  __extends$4(DocExplorer2, _super2);\n  function DocExplorer2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.handleNavBackClick = function() {\n      if (_this.state.navStack.length > 1) {\n        _this.setState({ navStack: _this.state.navStack.slice(0, -1) });\n      }\n    };\n    _this.handleClickType = function(type2) {\n      _this.showDoc(type2);\n    };\n    _this.handleClickField = function(field) {\n      _this.showDoc(field);\n    };\n    _this.handleSearch = function(value) {\n      _this.showSearch(value);\n    };\n    _this.state = { navStack: [initialNav] };\n    return _this;\n  }\n  DocExplorer2.prototype.shouldComponentUpdate = function(nextProps, nextState) {\n    return this.props.schema !== nextProps.schema || this.state.navStack !== nextState.navStack || this.props.schemaErrors !== nextProps.schemaErrors;\n  };\n  DocExplorer2.prototype.render = function() {\n    var _a2 = this.props, schema = _a2.schema, schemaErrors = _a2.schemaErrors;\n    var navStack = this.state.navStack;\n    var navItem = navStack[navStack.length - 1];\n    var content;\n    if (schemaErrors) {\n      content = React$1.createElement(\"div\", { className: \"error-container\" }, \"Error fetching schema\");\n    } else if (schema === void 0) {\n      content = React$1.createElement(\"div\", { className: \"spinner-container\" }, React$1.createElement(\"div\", { className: \"spinner\" }));\n    } else if (!schema) {\n      content = React$1.createElement(\"div\", { className: \"error-container\" }, \"No Schema Available\");\n    } else if (navItem.search) {\n      content = React$1.createElement(SearchResults, { searchValue: navItem.search, withinType: navItem.def, schema, onClickType: this.handleClickType, onClickField: this.handleClickField });\n    } else if (navStack.length === 1) {\n      content = React$1.createElement(SchemaDoc, { schema, onClickType: this.handleClickType });\n    } else if (isType(navItem.def)) {\n      content = React$1.createElement(TypeDoc, { schema, type: navItem.def, onClickType: this.handleClickType, onClickField: this.handleClickField });\n    } else {\n      content = React$1.createElement(FieldDoc, { field: navItem.def, onClickType: this.handleClickType });\n    }\n    var shouldSearchBoxAppear = navStack.length === 1 || isType(navItem.def) && \"getFields\" in navItem.def;\n    var prevName;\n    if (navStack.length > 1) {\n      prevName = navStack[navStack.length - 2].name;\n    }\n    return React$1.createElement(\"section\", { className: \"doc-explorer\", key: navItem.name, \"aria-label\": \"Documentation Explorer\" }, React$1.createElement(\"div\", { className: \"doc-explorer-title-bar\" }, prevName && React$1.createElement(\"button\", { className: \"doc-explorer-back\", onClick: this.handleNavBackClick, \"aria-label\": \"Go back to \" + prevName }, prevName), React$1.createElement(\"div\", { className: \"doc-explorer-title\" }, navItem.title || navItem.name), React$1.createElement(\"div\", { className: \"doc-explorer-rhs\" }, this.props.children)), React$1.createElement(\"div\", { className: \"doc-explorer-contents\" }, shouldSearchBoxAppear && React$1.createElement(SearchBox, { value: navItem.search, placeholder: \"Search \" + navItem.name + \"...\", onSearch: this.handleSearch }), content));\n  };\n  DocExplorer2.prototype.showDoc = function(typeOrField) {\n    var navStack = this.state.navStack;\n    var topNav = navStack[navStack.length - 1];\n    if (topNav.def !== typeOrField) {\n      this.setState({\n        navStack: navStack.concat([\n          {\n            name: typeOrField.name,\n            def: typeOrField\n          }\n        ])\n      });\n    }\n  };\n  DocExplorer2.prototype.showDocForReference = function(reference3) {\n    if (reference3 && reference3.kind === \"Type\") {\n      this.showDoc(reference3.type);\n    } else if (reference3.kind === \"Field\") {\n      this.showDoc(reference3.field);\n    } else if (reference3.kind === \"Argument\" && reference3.field) {\n      this.showDoc(reference3.field);\n    } else if (reference3.kind === \"EnumValue\" && reference3.type) {\n      this.showDoc(reference3.type);\n    }\n  };\n  DocExplorer2.prototype.showSearch = function(search2) {\n    var navStack = this.state.navStack.slice();\n    var topNav = navStack[navStack.length - 1];\n    navStack[navStack.length - 1] = __assign$7(__assign$7({}, topNav), { search: search2 });\n    this.setState({ navStack });\n  };\n  DocExplorer2.prototype.reset = function() {\n    this.setState({ navStack: [initialNav] });\n  };\n  return DocExplorer2;\n}(React$1.Component);\nvar __extends$3 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar HistoryQuery = function(_super2) {\n  __extends$3(HistoryQuery2, _super2);\n  function HistoryQuery2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.state = {\n      editable: false\n    };\n    _this.editField = null;\n    return _this;\n  }\n  HistoryQuery2.prototype.render = function() {\n    var _this = this;\n    var _a2;\n    var displayName = this.props.label || this.props.operationName || ((_a2 = this.props.query) === null || _a2 === void 0 ? void 0 : _a2.split(\"\\n\").filter(function(line) {\n      return line.indexOf(\"#\") !== 0;\n    }).join(\"\"));\n    var starIcon = this.props.favorite ? \"\\u2605\" : \"\\u2606\";\n    return React$1.createElement(\"li\", { className: this.state.editable ? \"editable\" : void 0 }, this.state.editable ? React$1.createElement(\"input\", { type: \"text\", defaultValue: this.props.label, ref: function(c) {\n      _this.editField = c;\n    }, onBlur: this.handleFieldBlur.bind(this), onKeyDown: this.handleFieldKeyDown.bind(this), placeholder: \"Type a label\" }) : React$1.createElement(\"button\", { className: \"history-label\", onClick: this.handleClick.bind(this) }, displayName), React$1.createElement(\"button\", { onClick: this.handleEditClick.bind(this), \"aria-label\": \"Edit label\" }, \"\\u270E\"), React$1.createElement(\"button\", { className: this.props.favorite ? \"favorited\" : void 0, onClick: this.handleStarClick.bind(this), \"aria-label\": this.props.favorite ? \"Remove favorite\" : \"Add favorite\" }, starIcon));\n  };\n  HistoryQuery2.prototype.handleClick = function() {\n    this.props.onSelect(this.props.query, this.props.variables, this.props.headers, this.props.operationName, this.props.label);\n  };\n  HistoryQuery2.prototype.handleStarClick = function(e) {\n    e.stopPropagation();\n    this.props.handleToggleFavorite(this.props.query, this.props.variables, this.props.headers, this.props.operationName, this.props.label, this.props.favorite);\n  };\n  HistoryQuery2.prototype.handleFieldBlur = function(e) {\n    e.stopPropagation();\n    this.setState({ editable: false });\n    this.props.handleEditLabel(this.props.query, this.props.variables, this.props.headers, this.props.operationName, e.target.value, this.props.favorite);\n  };\n  HistoryQuery2.prototype.handleFieldKeyDown = function(e) {\n    if (e.keyCode === 13) {\n      e.stopPropagation();\n      this.setState({ editable: false });\n      this.props.handleEditLabel(this.props.query, this.props.variables, this.props.headers, this.props.operationName, e.currentTarget.value, this.props.favorite);\n    }\n  };\n  HistoryQuery2.prototype.handleEditClick = function(e) {\n    var _this = this;\n    e.stopPropagation();\n    this.setState({ editable: true }, function() {\n      if (_this.editField) {\n        _this.editField.focus();\n      }\n    });\n  };\n  return HistoryQuery2;\n}(React$1.Component);\nvar __read$4 = globalThis && globalThis.__read || function(o, n2) {\n  var m2 = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m2)\n    return o;\n  var i = m2.call(o), r2, ar = [], e;\n  try {\n    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)\n      ar.push(r2.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m2 = i[\"return\"]))\n        m2.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread$3 = globalThis && globalThis.__spread || function() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read$4(arguments[i]));\n  return ar;\n};\nvar QueryStore = function() {\n  function QueryStore2(key, storage, maxSize) {\n    if (maxSize === void 0) {\n      maxSize = null;\n    }\n    this.key = key;\n    this.storage = storage;\n    this.maxSize = maxSize;\n    this.items = this.fetchAll();\n  }\n  Object.defineProperty(QueryStore2.prototype, \"length\", {\n    get: function() {\n      return this.items.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  QueryStore2.prototype.contains = function(item) {\n    return this.items.some(function(x2) {\n      return x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName;\n    });\n  };\n  QueryStore2.prototype.edit = function(item) {\n    var itemIndex = this.items.findIndex(function(x2) {\n      return x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName;\n    });\n    if (itemIndex !== -1) {\n      this.items.splice(itemIndex, 1, item);\n      this.save();\n    }\n  };\n  QueryStore2.prototype.delete = function(item) {\n    var itemIndex = this.items.findIndex(function(x2) {\n      return x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName;\n    });\n    if (itemIndex !== -1) {\n      this.items.splice(itemIndex, 1);\n      this.save();\n    }\n  };\n  QueryStore2.prototype.fetchRecent = function() {\n    return this.items[this.items.length - 1];\n  };\n  QueryStore2.prototype.fetchAll = function() {\n    var raw = this.storage.get(this.key);\n    if (raw) {\n      return JSON.parse(raw)[this.key];\n    }\n    return [];\n  };\n  QueryStore2.prototype.push = function(item) {\n    var _a2;\n    var items = __spread$3(this.items, [item]);\n    if (this.maxSize && items.length > this.maxSize) {\n      items.shift();\n    }\n    for (var attempts = 0; attempts < 5; attempts++) {\n      var response = this.storage.set(this.key, JSON.stringify((_a2 = {}, _a2[this.key] = items, _a2)));\n      if (!response || !response.error) {\n        this.items = items;\n      } else if (response.isQuotaError && this.maxSize) {\n        items.shift();\n      } else {\n        return;\n      }\n    }\n  };\n  QueryStore2.prototype.save = function() {\n    var _a2;\n    this.storage.set(this.key, JSON.stringify((_a2 = {}, _a2[this.key] = this.items, _a2)));\n  };\n  return QueryStore2;\n}();\nvar __assign$6 = globalThis && globalThis.__assign || function() {\n  __assign$6 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$6.apply(this, arguments);\n};\nvar __read$3 = globalThis && globalThis.__read || function(o, n2) {\n  var m2 = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m2)\n    return o;\n  var i = m2.call(o), r2, ar = [], e;\n  try {\n    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)\n      ar.push(r2.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m2 = i[\"return\"]))\n        m2.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread$2 = globalThis && globalThis.__spread || function() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read$3(arguments[i]));\n  return ar;\n};\nvar MAX_QUERY_SIZE = 1e5;\nvar HistoryStore = function() {\n  function HistoryStore2(storage, maxHistoryLength) {\n    var _this = this;\n    this.storage = storage;\n    this.maxHistoryLength = maxHistoryLength;\n    this.shouldSaveQuery = function(query, variables, headers, lastQuerySaved) {\n      if (!query) {\n        return false;\n      }\n      try {\n        parse$1(query);\n      } catch (e) {\n        return false;\n      }\n      if (query.length > MAX_QUERY_SIZE) {\n        return false;\n      }\n      if (!lastQuerySaved) {\n        return true;\n      }\n      if (JSON.stringify(query) === JSON.stringify(lastQuerySaved.query)) {\n        if (JSON.stringify(variables) === JSON.stringify(lastQuerySaved.variables)) {\n          if (JSON.stringify(headers) === JSON.stringify(lastQuerySaved.headers)) {\n            return false;\n          }\n          if (headers && !lastQuerySaved.headers) {\n            return false;\n          }\n        }\n        if (variables && !lastQuerySaved.variables) {\n          return false;\n        }\n      }\n      return true;\n    };\n    this.fetchAllQueries = function() {\n      var historyQueries = _this.history.fetchAll();\n      var favoriteQueries = _this.favorite.fetchAll();\n      return historyQueries.concat(favoriteQueries);\n    };\n    this.updateHistory = function(query, variables, headers, operationName) {\n      if (_this.shouldSaveQuery(query, variables, headers, _this.history.fetchRecent())) {\n        _this.history.push({\n          query,\n          variables,\n          headers,\n          operationName\n        });\n        var historyQueries = _this.history.items;\n        var favoriteQueries = _this.favorite.items;\n        _this.queries = historyQueries.concat(favoriteQueries);\n      }\n    };\n    this.toggleFavorite = function(query, variables, headers, operationName, label, favorite) {\n      var item = {\n        query,\n        variables,\n        headers,\n        operationName,\n        label\n      };\n      if (!_this.favorite.contains(item)) {\n        item.favorite = true;\n        _this.favorite.push(item);\n      } else if (favorite) {\n        item.favorite = false;\n        _this.favorite.delete(item);\n      }\n      _this.queries = __spread$2(_this.history.items, _this.favorite.items);\n    };\n    this.editLabel = function(query, variables, headers, operationName, label, favorite) {\n      var item = {\n        query,\n        variables,\n        headers,\n        operationName,\n        label\n      };\n      if (favorite) {\n        _this.favorite.edit(__assign$6(__assign$6({}, item), { favorite }));\n      } else {\n        _this.history.edit(item);\n      }\n      _this.queries = __spread$2(_this.history.items, _this.favorite.items);\n    };\n    this.history = new QueryStore(\"queries\", this.storage, this.maxHistoryLength);\n    this.favorite = new QueryStore(\"favorites\", this.storage, null);\n    this.queries = this.fetchAllQueries();\n  }\n  return HistoryStore2;\n}();\nvar __extends$2 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign$5 = globalThis && globalThis.__assign || function() {\n  __assign$5 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$5.apply(this, arguments);\n};\nvar QueryHistory = function(_super2) {\n  __extends$2(QueryHistory2, _super2);\n  function QueryHistory2(props) {\n    var _this = _super2.call(this, props) || this;\n    _this.onUpdateHistory = function(query, variables, headers, operationName) {\n      _this.historyStore.updateHistory(query, variables, headers, operationName);\n      _this.setState({ queries: _this.historyStore.queries });\n    };\n    _this.onHandleEditLabel = function(query, variables, headers, operationName, label, favorite) {\n      _this.historyStore.editLabel(query, variables, headers, operationName, label, favorite);\n      _this.setState({ queries: _this.historyStore.queries });\n    };\n    _this.onToggleFavorite = function(query, variables, headers, operationName, label, favorite) {\n      _this.historyStore.toggleFavorite(query, variables, headers, operationName, label, favorite);\n      _this.setState({ queries: _this.historyStore.queries });\n    };\n    _this.historyStore = new HistoryStore(_this.props.storage, _this.props.maxHistoryLength);\n    var queries = _this.historyStore.queries;\n    _this.state = { queries };\n    return _this;\n  }\n  QueryHistory2.prototype.render = function() {\n    var _this = this;\n    var queries = this.state.queries.slice().reverse();\n    var queryNodes = queries.map(function(query, i) {\n      return React$1.createElement(HistoryQuery, __assign$5({ handleEditLabel: _this.onHandleEditLabel, handleToggleFavorite: _this.onToggleFavorite, key: i + \":\" + (query.label || query.query), onSelect: _this.props.onSelectQuery }, query));\n    });\n    return React$1.createElement(\"section\", { \"aria-label\": \"History\" }, React$1.createElement(\"div\", { className: \"history-title-bar\" }, React$1.createElement(\"div\", { className: \"history-title\" }, \"History\"), React$1.createElement(\"div\", { className: \"doc-explorer-rhs\" }, this.props.children)), React$1.createElement(\"ul\", { className: \"history-contents\" }, queryNodes));\n  };\n  return QueryHistory2;\n}(React$1.Component);\nvar CodeMirrorSizer = function() {\n  function CodeMirrorSizer2() {\n    this.sizes = [];\n  }\n  CodeMirrorSizer2.prototype.updateSizes = function(components) {\n    var _this = this;\n    components.forEach(function(component, i) {\n      if (component) {\n        var size = component.getClientHeight();\n        if (i <= _this.sizes.length && size !== _this.sizes[i]) {\n          var editor = component.getCodeMirror();\n          if (editor) {\n            editor.setSize(null, null);\n          }\n        }\n        _this.sizes[i] = size;\n      }\n    });\n  };\n  return CodeMirrorSizer2;\n}();\nfunction isQuotaError(storage, e) {\n  return e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === \"QuotaExceededError\" || e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && storage.length !== 0;\n}\nvar StorageAPI = function() {\n  function StorageAPI2(storage) {\n    this.storage = storage || (typeof window !== \"undefined\" ? window.localStorage : null);\n  }\n  StorageAPI2.prototype.get = function(name2) {\n    if (this.storage) {\n      var value = this.storage.getItem(\"graphiql:\" + name2);\n      if (value === \"null\" || value === \"undefined\") {\n        this.storage.removeItem(\"graphiql:\" + name2);\n        return null;\n      }\n      if (value) {\n        return value;\n      }\n    }\n    return null;\n  };\n  StorageAPI2.prototype.set = function(name2, value) {\n    var quotaError = false;\n    var error2 = null;\n    if (this.storage) {\n      var key = \"graphiql:\" + name2;\n      if (value) {\n        try {\n          this.storage.setItem(key, value);\n        } catch (e) {\n          error2 = e;\n          quotaError = isQuotaError(this.storage, e);\n        }\n      } else {\n        this.storage.removeItem(key);\n      }\n    }\n    return {\n      isQuotaError: quotaError,\n      error: error2\n    };\n  };\n  return StorageAPI2;\n}();\nfunction getSelectedOperationName(prevOperations, prevSelectedOperationName, operations) {\n  if (!operations || operations.length < 1) {\n    return;\n  }\n  var names = operations.map(function(op) {\n    return op.name && op.name.value;\n  });\n  if (prevSelectedOperationName && names.indexOf(prevSelectedOperationName) !== -1) {\n    return prevSelectedOperationName;\n  }\n  if (prevSelectedOperationName && prevOperations) {\n    var prevNames = prevOperations.map(function(op) {\n      return op.name && op.name.value;\n    });\n    var prevIndex = prevNames.indexOf(prevSelectedOperationName);\n    if (prevIndex !== -1 && prevIndex < names.length) {\n      return names[prevIndex];\n    }\n  }\n  return names[0];\n}\nfunction find$1(list3, predicate) {\n  for (var i = 0; i < list3.length; i++) {\n    if (predicate(list3[i])) {\n      return list3[i];\n    }\n  }\n}\nfunction fillLeafs(schema, docString, getDefaultFieldNames) {\n  var insertions = [];\n  if (!schema || !docString) {\n    return { insertions, result: docString };\n  }\n  var ast2;\n  try {\n    ast2 = parse$1(docString);\n  } catch (error2) {\n    return { insertions, result: docString };\n  }\n  var fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames$1;\n  var typeInfo = new TypeInfo(schema);\n  visit(ast2, {\n    leave: function(node) {\n      typeInfo.leave(node);\n    },\n    enter: function(node) {\n      typeInfo.enter(node);\n      if (node.kind === \"Field\" && !node.selectionSet) {\n        var fieldType = typeInfo.getType();\n        var selectionSet = buildSelectionSet(isFieldType(fieldType), fieldNameFn);\n        if (selectionSet && node.loc) {\n          var indent2 = getIndentation(docString, node.loc.start);\n          insertions.push({\n            index: node.loc.end,\n            string: \" \" + print(selectionSet).replace(/\\n/g, \"\\n\" + indent2)\n          });\n        }\n      }\n    }\n  });\n  return {\n    insertions,\n    result: withInsertions(docString, insertions)\n  };\n}\nfunction defaultGetDefaultFieldNames$1(type2) {\n  if (!(\"getFields\" in type2)) {\n    return [];\n  }\n  var fields = type2.getFields();\n  if (fields.id) {\n    return [\"id\"];\n  }\n  if (fields.edges) {\n    return [\"edges\"];\n  }\n  if (fields.node) {\n    return [\"node\"];\n  }\n  var leafFieldNames = [];\n  Object.keys(fields).forEach(function(fieldName) {\n    if (isLeafType(fields[fieldName].type)) {\n      leafFieldNames.push(fieldName);\n    }\n  });\n  return leafFieldNames;\n}\nfunction buildSelectionSet(type2, getDefaultFieldNames) {\n  var namedType = getNamedType(type2);\n  if (!type2 || isLeafType(type2)) {\n    return;\n  }\n  var fieldNames = getDefaultFieldNames(namedType);\n  if (!Array.isArray(fieldNames) || fieldNames.length === 0 || !(\"getFields\" in namedType)) {\n    return;\n  }\n  return {\n    kind: Kind.SELECTION_SET,\n    selections: fieldNames.map(function(fieldName) {\n      var fieldDef = namedType.getFields()[fieldName];\n      var fieldType = fieldDef ? fieldDef.type : null;\n      return {\n        kind: Kind.FIELD,\n        name: {\n          kind: Kind.NAME,\n          value: fieldName\n        },\n        selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)\n      };\n    })\n  };\n}\nfunction withInsertions(initial, insertions) {\n  if (insertions.length === 0) {\n    return initial;\n  }\n  var edited = \"\";\n  var prevIndex = 0;\n  insertions.forEach(function(_a2) {\n    var index = _a2.index, string2 = _a2.string;\n    edited += initial.slice(prevIndex, index) + string2;\n    prevIndex = index;\n  });\n  edited += initial.slice(prevIndex);\n  return edited;\n}\nfunction getIndentation(str, index) {\n  var indentStart = index;\n  var indentEnd = index;\n  while (indentStart) {\n    var c = str.charCodeAt(indentStart - 1);\n    if (c === 10 || c === 13 || c === 8232 || c === 8233) {\n      break;\n    }\n    indentStart--;\n    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {\n      indentEnd = indentStart;\n    }\n  }\n  return str.substring(indentStart, indentEnd);\n}\nfunction isFieldType(fieldType) {\n  if (fieldType) {\n    return fieldType;\n  }\n}\nfunction getLeft(initialElem) {\n  var pt = 0;\n  var elem = initialElem;\n  while (elem.offsetParent) {\n    pt += elem.offsetLeft;\n    elem = elem.offsetParent;\n  }\n  return pt;\n}\nfunction getTop(initialElem) {\n  var pt = 0;\n  var elem = initialElem;\n  while (elem.offsetParent) {\n    pt += elem.offsetTop;\n    elem = elem.offsetParent;\n  }\n  return pt;\n}\nvar __assign$4 = globalThis && globalThis.__assign || function() {\n  __assign$4 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$4.apply(this, arguments);\n};\nvar __values$2 = globalThis && globalThis.__values || function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m2 = s && o[s], i = 0;\n  if (m2)\n    return m2.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read$2 = globalThis && globalThis.__read || function(o, n2) {\n  var m2 = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m2)\n    return o;\n  var i = m2.call(o), r2, ar = [], e;\n  try {\n    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)\n      ar.push(r2.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m2 = i[\"return\"]))\n        m2.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread$1 = globalThis && globalThis.__spread || function() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read$2(arguments[i]));\n  return ar;\n};\nfunction uniqueBy(array, iteratee) {\n  var e_1, _a2;\n  var FilteredMap = /* @__PURE__ */ new Map();\n  var result2 = [];\n  try {\n    for (var array_1 = __values$2(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {\n      var item = array_1_1.value;\n      if (item.kind === \"Field\") {\n        var uniqueValue = iteratee(item);\n        var existing = FilteredMap.get(uniqueValue);\n        if (item.directives && item.directives.length) {\n          var itemClone = __assign$4({}, item);\n          result2.push(itemClone);\n        } else if (existing && existing.selectionSet && item.selectionSet) {\n          existing.selectionSet.selections = __spread$1(existing.selectionSet.selections, item.selectionSet.selections);\n        } else if (!existing) {\n          var itemClone = __assign$4({}, item);\n          FilteredMap.set(uniqueValue, itemClone);\n          result2.push(itemClone);\n        }\n      } else {\n        result2.push(item);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = { error: e_1_1 };\n  } finally {\n    try {\n      if (array_1_1 && !array_1_1.done && (_a2 = array_1.return))\n        _a2.call(array_1);\n    } finally {\n      if (e_1)\n        throw e_1.error;\n    }\n  }\n  return result2;\n}\nfunction inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {\n  var e_2, _a2;\n  var _b;\n  var selectionSetTypeName = selectionSetType ? getNamedType(selectionSetType).name : null;\n  var outputSelections = [];\n  var seenSpreads = [];\n  try {\n    for (var selections_1 = __values$2(selections), selections_1_1 = selections_1.next(); !selections_1_1.done; selections_1_1 = selections_1.next()) {\n      var selection = selections_1_1.value;\n      if (selection.kind === \"FragmentSpread\") {\n        var fragmentName = selection.name.value;\n        if (!selection.directives || selection.directives.length === 0) {\n          if (seenSpreads.indexOf(fragmentName) >= 0) {\n            continue;\n          } else {\n            seenSpreads.push(fragmentName);\n          }\n        }\n        var fragmentDefinition = fragmentDefinitions[selection.name.value];\n        if (fragmentDefinition) {\n          var typeCondition = fragmentDefinition.typeCondition, directives = fragmentDefinition.directives, selectionSet = fragmentDefinition.selectionSet;\n          selection = {\n            kind: Kind.INLINE_FRAGMENT,\n            typeCondition,\n            directives,\n            selectionSet\n          };\n        }\n      }\n      if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.directives || ((_b = selection.directives) === null || _b === void 0 ? void 0 : _b.length) === 0)) {\n        var fragmentTypeName = selection.typeCondition ? selection.typeCondition.name.value : null;\n        if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {\n          outputSelections.push.apply(outputSelections, __spread$1(inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType)));\n          continue;\n        }\n      }\n      outputSelections.push(selection);\n    }\n  } catch (e_2_1) {\n    e_2 = { error: e_2_1 };\n  } finally {\n    try {\n      if (selections_1_1 && !selections_1_1.done && (_a2 = selections_1.return))\n        _a2.call(selections_1);\n    } finally {\n      if (e_2)\n        throw e_2.error;\n    }\n  }\n  return outputSelections;\n}\nfunction mergeAST(documentAST, schema) {\n  var e_3, _a2;\n  var typeInfo = schema ? new TypeInfo(schema) : null;\n  var fragmentDefinitions = /* @__PURE__ */ Object.create(null);\n  try {\n    for (var _b = __values$2(documentAST.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var definition = _c.value;\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        fragmentDefinitions[definition.name.value] = definition;\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = { error: e_3_1 };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a2 = _b.return))\n        _a2.call(_b);\n    } finally {\n      if (e_3)\n        throw e_3.error;\n    }\n  }\n  var visitors = {\n    SelectionSet: function(node) {\n      var selectionSetType = typeInfo ? typeInfo.getParentType() : null;\n      var selections = node.selections;\n      selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);\n      selections = uniqueBy(selections, function(selection) {\n        return selection.alias ? selection.alias.value : selection.name.value;\n      });\n      return __assign$4(__assign$4({}, node), { selections });\n    },\n    FragmentDefinition: function() {\n      return null;\n    }\n  };\n  return visit(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);\n}\nvar staticName = \"IntrospectionQuery\";\nvar introspectionQueryName = staticName;\nfunction merge(a, b, k) {\n  if (typeof a === \"object\" && typeof b === \"object\") {\n    if (Array.isArray(a) && Array.isArray(b)) {\n      for (k = 0; k < b.length; k++) {\n        a[k] = merge(a[k], b[k]);\n      }\n    } else {\n      for (k in b) {\n        a[k] = merge(a[k], b[k]);\n      }\n    }\n    return a;\n  }\n  return b;\n}\nfunction dset(obj, keys, val) {\n  keys.split && (keys = keys.split(\".\"));\n  var i = 0, l2 = keys.length, t2 = obj, x2, k;\n  while (i < l2) {\n    k = keys[i++];\n    if (k === \"__proto__\" || k === \"constructor\" || k === \"prototype\")\n      break;\n    t2 = t2[k] = i === l2 ? merge(t2[k], val) : typeof (x2 = t2[k]) === typeof keys ? x2 : keys[i] * 0 !== 0 || !!~(\"\" + keys[i]).indexOf(\".\") ? {} : [];\n  }\n}\nvar __assign$3 = globalThis && globalThis.__assign || function() {\n  __assign$3 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$3.apply(this, arguments);\n};\nfunction TabCloseButton(props) {\n  return React$1.createElement(\"div\", { role: \"button\", \"aria-pressed\": false, className: \"close\", \"aria-label\": \"Close Tab\", title: \"Close Tab\", onClick: function(ev) {\n    ev.stopPropagation();\n    props.onClick();\n  } });\n}\nfunction Tab(props) {\n  return React$1.createElement(\"button\", __assign$3({}, props.tabProps, { role: \"tab\", type: \"button\", \"aria-selected\": props.isActive, title: props.title, className: \"tab\" + (props.isActive ? \" active\" : \"\"), onClick: props.onSelect }), props.title, props.isCloseable ? React$1.createElement(TabCloseButton, { onClick: function() {\n    return props.onClose();\n  } }) : null);\n}\nfunction TabAddButton(props) {\n  return React$1.createElement(\"button\", { onClick: props.onClick, className: \"tab-add\", title: \"Create new tab\" }, React$1.createElement(\"span\", null, \"+\"));\n}\nfunction Tabs(props) {\n  return React$1.createElement(\"div\", __assign$3({ role: \"tablist\", className: \"tabs\" }, props.tabsProps), props.children);\n}\nfunction fuzzyExtractOperationTitle(str) {\n  var _a2;\n  var regex2 = /^(?!.*#).*(query|subscription|mutation)\\s+([a-zA-Z0-9_]+)/;\n  var match2 = regex2.exec(str);\n  return (_a2 = match2 === null || match2 === void 0 ? void 0 : match2[2]) !== null && _a2 !== void 0 ? _a2 : \"<untitled>\";\n}\nfunction idFromTabContents(params) {\n  var _a2, _b, _c;\n  return [\n    (_a2 = params.query) !== null && _a2 !== void 0 ? _a2 : \"\",\n    (_b = params.variables) !== null && _b !== void 0 ? _b : \"\",\n    (_c = params.headers) !== null && _c !== void 0 ? _c : \"\"\n  ].join(\"|\");\n}\nfunction guid() {\n  var s4 = function() {\n    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);\n  };\n  return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + s4() + s4();\n}\nvar __extends$1 = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign$2 = globalThis && globalThis.__assign || function() {\n  __assign$2 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$2.apply(this, arguments);\n};\nvar __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result2) {\n      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator$1 = globalThis && globalThis.__generator || function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f, y2, t2, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t2[1]) {\n              _.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _.label < t2[2]) {\n              _.label = t2[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n};\nvar __rest = globalThis && globalThis.__rest || function(s, e) {\n  var t2 = {};\n  for (var p2 in s)\n    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)\n      t2[p2] = s[p2];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {\n      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))\n        t2[p2[i]] = s[p2[i]];\n    }\n  return t2;\n};\nvar __asyncValues$1 = globalThis && globalThis.__asyncValues || function(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m2 = o[Symbol.asyncIterator], i;\n  return m2 ? m2.call(o) : (o = typeof __values$1 === \"function\" ? __values$1(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n2) {\n    i[n2] = o[n2] && function(v2) {\n      return new Promise(function(resolve, reject2) {\n        v2 = o[n2](v2), settle(resolve, reject2, v2.done, v2.value);\n      });\n    };\n  }\n  function settle(resolve, reject2, d, v2) {\n    Promise.resolve(v2).then(function(v3) {\n      resolve({ value: v3, done: d });\n    }, reject2);\n  }\n};\nvar __read$1 = globalThis && globalThis.__read || function(o, n2) {\n  var m2 = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m2)\n    return o;\n  var i = m2.call(o), r2, ar = [], e;\n  try {\n    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)\n      ar.push(r2.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m2 = i[\"return\"]))\n        m2.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = globalThis && globalThis.__spread || function() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read$1(arguments[i]));\n  return ar;\n};\nvar __values$1 = globalThis && globalThis.__values || function(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m2 = s && o[s], i = 0;\n  if (m2)\n    return m2.call(o);\n  if (o && typeof o.length === \"number\")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return { value: o && o[i++], done: !o };\n      }\n    };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar DEFAULT_DOC_EXPLORER_WIDTH = 350;\nvar majorVersion = parseInt(React$1.version.slice(0, 2), 10);\nif (majorVersion < 16) {\n  throw Error([\n    \"GraphiQL 0.18.0 and after is not compatible with React 15 or below.\",\n    \"If you are using a CDN source (jsdelivr, unpkg, etc), follow this example:\",\n    \"https://github.com/graphql/graphiql/blob/master/examples/graphiql-cdn/index.html#L49\"\n  ].join(\"\\n\"));\n}\nvar stringify = function(obj) {\n  return JSON.stringify(obj, null, 2);\n};\nvar formatSingleError = function(error2) {\n  return __assign$2(__assign$2({}, error2), { message: error2.message, stack: error2.stack });\n};\nvar handleSingleError = function(error2) {\n  if (error2 instanceof GraphQLError) {\n    return error2.toString();\n  }\n  if (error2 instanceof Error) {\n    return formatSingleError(error2);\n  }\n  return error2;\n};\nvar GraphiQL = function(_super2) {\n  __extends$1(GraphiQL2, _super2);\n  function GraphiQL2(props) {\n    var e_1, _a2, e_2, _b;\n    var _c, _d, _e, _f, _g, _h, _j;\n    var _this = _super2.call(this, props) || this;\n    _this._editorQueryID = 0;\n    _this.safeSetState = function(nextState, callback) {\n      _this.componentIsMounted && _this.setState(nextState, callback);\n    };\n    _this.persistTabsState = function() {\n      var _a3, _b2;\n      if (_this.props.tabs) {\n        _this._storage.set(\"tabState\", JSON.stringify(_this.state.tabs, function(key, value) {\n          return key === \"response\" || _this.state.shouldPersistHeaders && key === \"headers\" ? void 0 : value;\n        }));\n        if (typeof _this.props.tabs === \"object\") {\n          (_b2 = (_a3 = _this.props.tabs).onTabChange) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, _this.state.tabs);\n        }\n      }\n    };\n    _this.makeHandleOnSelectTab = function(index2) {\n      return function() {\n        _this.handleStopQuery();\n        _this.setState(function(state) {\n          return stateOnSelectTabReducer(index2, state);\n        }, _this.persistTabsState);\n      };\n    };\n    _this.makeHandleOnCloseTab = function(index2) {\n      return function() {\n        if (_this.state.tabs.activeTabIndex === index2) {\n          _this.handleStopQuery();\n        }\n        _this.setState(function(state) {\n          return stateOnCloseTabReducer(index2, state);\n        }, _this.persistTabsState);\n      };\n    };\n    _this.handleOnAddTab = function() {\n      _this.setState(function(state) {\n        return stateOnTabAddReducer(state);\n      }, _this.persistTabsState);\n    };\n    _this.handleClickReference = function(reference3) {\n      _this.setState({ docExplorerOpen: true }, function() {\n        if (_this.docExplorerComponent) {\n          _this.docExplorerComponent.showDocForReference(reference3);\n        }\n      });\n      _this._storage.set(\"docExplorerOpen\", JSON.stringify(_this.state.docExplorerOpen));\n    };\n    _this.handleRunQuery = function(selectedOperationName) {\n      return __awaiter$1(_this, void 0, void 0, function() {\n        var queryID, editedQuery, variables2, headers2, shouldPersistHeaders2, operationName2, fullResponse_1, subscription, error_1;\n        var _this2 = this;\n        return __generator$1(this, function(_a3) {\n          switch (_a3.label) {\n            case 0:\n              this._editorQueryID++;\n              queryID = this._editorQueryID;\n              editedQuery = this.autoCompleteLeafs() || this.state.query;\n              variables2 = this.state.variables;\n              headers2 = this.state.headers;\n              shouldPersistHeaders2 = this.state.shouldPersistHeaders;\n              operationName2 = this.state.operationName;\n              if (selectedOperationName && selectedOperationName !== operationName2) {\n                operationName2 = selectedOperationName;\n                this.handleEditOperationName(operationName2);\n              }\n              _a3.label = 1;\n            case 1:\n              _a3.trys.push([1, 3, , 4]);\n              this.setState({\n                isWaitingForResponse: true,\n                response: void 0,\n                operationName: operationName2\n              });\n              this._storage.set(\"operationName\", operationName2);\n              if (this._queryHistory) {\n                this._queryHistory.onUpdateHistory(editedQuery, variables2, headers2, operationName2);\n              } else {\n                if (this._historyStore) {\n                  this._historyStore.updateHistory(editedQuery, variables2, headers2, operationName2);\n                }\n              }\n              fullResponse_1 = { data: {} };\n              return [4, this._fetchQuery(editedQuery, variables2, headers2, operationName2, shouldPersistHeaders2, function(result2) {\n                var e_3, _a4;\n                if (queryID === _this2._editorQueryID) {\n                  var maybeMultipart = Array.isArray(result2) ? result2 : false;\n                  if (!maybeMultipart && typeof result2 !== \"string\" && result2 !== null && \"hasNext\" in result2) {\n                    maybeMultipart = [result2];\n                  }\n                  if (maybeMultipart) {\n                    var payload = { data: fullResponse_1.data };\n                    var maybeErrors = __spread((fullResponse_1 === null || fullResponse_1 === void 0 ? void 0 : fullResponse_1.errors) || [], maybeMultipart.map(function(i) {\n                      return i.errors;\n                    }).flat().filter(Boolean));\n                    if (maybeErrors.length) {\n                      payload.errors = maybeErrors;\n                    }\n                    try {\n                      for (var maybeMultipart_1 = __values$1(maybeMultipart), maybeMultipart_1_1 = maybeMultipart_1.next(); !maybeMultipart_1_1.done; maybeMultipart_1_1 = maybeMultipart_1.next()) {\n                        var part2 = maybeMultipart_1_1.value;\n                        var path = part2.path, data = part2.data, _errors = part2.errors, rest = __rest(part2, [\"path\", \"data\", \"errors\"]);\n                        if (path) {\n                          if (!data) {\n                            throw new Error(\"Expected part to contain a data property, but got \" + part2);\n                          }\n                          dset(payload.data, path, data);\n                        } else if (data) {\n                          payload.data = part2.data;\n                        }\n                        fullResponse_1 = __assign$2(__assign$2({}, payload), rest);\n                      }\n                    } catch (e_3_1) {\n                      e_3 = { error: e_3_1 };\n                    } finally {\n                      try {\n                        if (maybeMultipart_1_1 && !maybeMultipart_1_1.done && (_a4 = maybeMultipart_1.return))\n                          _a4.call(maybeMultipart_1);\n                      } finally {\n                        if (e_3)\n                          throw e_3.error;\n                      }\n                    }\n                    _this2.setState({\n                      isWaitingForResponse: false,\n                      response: GraphiQL2.formatResult(fullResponse_1)\n                    });\n                  } else {\n                    var response_1 = GraphiQL2.formatResult(result2);\n                    _this2.setState(function(state) {\n                      return __assign$2(__assign$2({}, state), { tabs: __assign$2(__assign$2({}, state.tabs), { tabs: state.tabs.tabs.map(function(tab2, index2) {\n                        if (index2 !== state.tabs.activeTabIndex) {\n                          return tab2;\n                        }\n                        return __assign$2(__assign$2({}, tab2), { response: response_1 });\n                      }) }), isWaitingForResponse: false, response: response_1 });\n                    }, _this2.persistTabsState);\n                  }\n                }\n              })];\n            case 2:\n              subscription = _a3.sent();\n              this.setState({ subscription });\n              return [3, 4];\n            case 3:\n              error_1 = _a3.sent();\n              this.setState({\n                isWaitingForResponse: false,\n                response: error_1.message\n              });\n              return [3, 4];\n            case 4:\n              return [2];\n          }\n        });\n      });\n    };\n    _this.handleStopQuery = function() {\n      var subscription = _this.state.subscription;\n      _this.setState({\n        isWaitingForResponse: false,\n        subscription: null\n      });\n      if (subscription) {\n        subscription.unsubscribe();\n      }\n    };\n    _this.handlePrettifyQuery = function() {\n      var _a3, _b2, _c2;\n      var editor = _this.getQueryEditor();\n      var editorContent = (_a3 = editor === null || editor === void 0 ? void 0 : editor.getValue()) !== null && _a3 !== void 0 ? _a3 : \"\";\n      var prettifiedEditorContent = print(parse$1(editorContent));\n      if (prettifiedEditorContent !== editorContent) {\n        editor === null || editor === void 0 ? void 0 : editor.setValue(prettifiedEditorContent);\n      }\n      var variableEditor = _this.getVariableEditor();\n      var variableEditorContent = (_b2 = variableEditor === null || variableEditor === void 0 ? void 0 : variableEditor.getValue()) !== null && _b2 !== void 0 ? _b2 : \"\";\n      try {\n        var prettifiedVariableEditorContent = JSON.stringify(JSON.parse(variableEditorContent), null, 2);\n        if (prettifiedVariableEditorContent !== variableEditorContent) {\n          variableEditor === null || variableEditor === void 0 ? void 0 : variableEditor.setValue(prettifiedVariableEditorContent);\n        }\n      } catch (_d2) {\n      }\n      var headerEditor = _this.getHeaderEditor();\n      var headerEditorContent = (_c2 = headerEditor === null || headerEditor === void 0 ? void 0 : headerEditor.getValue()) !== null && _c2 !== void 0 ? _c2 : \"\";\n      try {\n        var prettifiedHeaderEditorContent = JSON.stringify(JSON.parse(headerEditorContent), null, 2);\n        if (prettifiedHeaderEditorContent !== headerEditorContent) {\n          headerEditor === null || headerEditor === void 0 ? void 0 : headerEditor.setValue(prettifiedHeaderEditorContent);\n        }\n      } catch (_e2) {\n      }\n    };\n    _this.handleMergeQuery = function() {\n      var editor = _this.getQueryEditor();\n      var query2 = editor.getValue();\n      if (!query2) {\n        return;\n      }\n      var ast2 = _this.state.documentAST;\n      editor.setValue(print(mergeAST(ast2, _this.state.schema)));\n    };\n    _this.handleEditQuery = debounce(100, function(value) {\n      var queryFacts2 = _this._updateQueryFacts(value, _this.state.operationName, _this.state.operations, _this.state.schema);\n      _this.setState(function(state) {\n        return __assign$2(__assign$2(__assign$2(__assign$2({}, state), { query: value }), queryFacts2), { tabs: tabsStateEditQueryReducer(value, state.tabs, queryFacts2 === null || queryFacts2 === void 0 ? void 0 : queryFacts2.operationName) });\n      }, _this.persistTabsState);\n      _this._storage.set(\"query\", value);\n      if (_this.props.onEditQuery) {\n        return _this.props.onEditQuery(value, queryFacts2 === null || queryFacts2 === void 0 ? void 0 : queryFacts2.documentAST);\n      }\n    });\n    _this.handleCopyQuery = function() {\n      var editor = _this.getQueryEditor();\n      var query2 = editor && editor.getValue();\n      if (!query2) {\n        return;\n      }\n      copyToClipboard(query2);\n      if (_this.props.onCopyQuery) {\n        return _this.props.onCopyQuery(query2);\n      }\n    };\n    _this._updateQueryFacts = function(query2, operationName2, prevOperations, schema2) {\n      var queryFacts2 = getOperationFacts(schema2, query2);\n      if (queryFacts2) {\n        var updatedOperationName = getSelectedOperationName(prevOperations, operationName2, queryFacts2.operations);\n        var onEditOperationName = _this.props.onEditOperationName;\n        if (onEditOperationName && updatedOperationName && operationName2 !== updatedOperationName) {\n          onEditOperationName(updatedOperationName);\n        }\n        return __assign$2({ operationName: updatedOperationName }, queryFacts2);\n      }\n    };\n    _this.handleEditVariables = function(value) {\n      _this.setState(function(state) {\n        return __assign$2(__assign$2({}, state), { variables: value, tabs: tabsStateEditVariablesReducer(value, state.tabs) });\n      }, _this.persistTabsState);\n      debounce(500, function() {\n        return _this._storage.set(\"variables\", value);\n      })();\n      if (_this.props.onEditVariables) {\n        _this.props.onEditVariables(value);\n      }\n    };\n    _this.handleEditHeaders = function(value) {\n      _this.setState(function(state) {\n        return __assign$2(__assign$2({}, state), { headers: value, tabs: tabsStateEditHeadersReducer(value, state.tabs) });\n      }, _this.persistTabsState);\n      _this.props.shouldPersistHeaders && debounce(500, function() {\n        return _this._storage.set(\"headers\", value);\n      })();\n      if (_this.props.onEditHeaders) {\n        _this.props.onEditHeaders(value);\n      }\n    };\n    _this.handleEditOperationName = function(operationName2) {\n      var onEditOperationName = _this.props.onEditOperationName;\n      if (onEditOperationName) {\n        onEditOperationName(operationName2);\n      }\n    };\n    _this.handleHintInformationRender = function(elem) {\n      elem.addEventListener(\"click\", _this._onClickHintInformation);\n      var onRemoveFn;\n      elem.addEventListener(\"DOMNodeRemoved\", onRemoveFn = function() {\n        elem.removeEventListener(\"DOMNodeRemoved\", onRemoveFn);\n        elem.removeEventListener(\"click\", _this._onClickHintInformation);\n      });\n    };\n    _this.handleEditorRunQuery = function() {\n      _this._runQueryAtCursor();\n    };\n    _this._onClickHintInformation = function(event) {\n      if ((event === null || event === void 0 ? void 0 : event.currentTarget) && \"className\" in event.currentTarget && event.currentTarget.className === \"typeName\") {\n        var typeName = event.currentTarget.innerHTML;\n        var schema2 = _this.state.schema;\n        if (schema2) {\n          var type_1 = schema2.getType(typeName);\n          if (type_1) {\n            _this.setState({ docExplorerOpen: true }, function() {\n              if (_this.docExplorerComponent) {\n                _this.docExplorerComponent.showDoc(type_1);\n              }\n            });\n            debounce(500, function() {\n              return _this._storage.set(\"docExplorerOpen\", JSON.stringify(_this.state.docExplorerOpen));\n            })();\n          }\n        }\n      }\n    };\n    _this.handleToggleDocs = function() {\n      if (typeof _this.props.onToggleDocs === \"function\") {\n        _this.props.onToggleDocs(!_this.state.docExplorerOpen);\n      }\n      _this._storage.set(\"docExplorerOpen\", JSON.stringify(!_this.state.docExplorerOpen));\n      _this.setState({ docExplorerOpen: !_this.state.docExplorerOpen });\n    };\n    _this.handleToggleHistory = function() {\n      if (typeof _this.props.onToggleHistory === \"function\") {\n        _this.props.onToggleHistory(!_this.state.historyPaneOpen);\n      }\n      _this._storage.set(\"historyPaneOpen\", JSON.stringify(!_this.state.historyPaneOpen));\n      _this.setState({ historyPaneOpen: !_this.state.historyPaneOpen });\n    };\n    _this.handleSelectHistoryQuery = function(query2, variables2, headers2, operationName2) {\n      if (query2) {\n        _this.handleEditQuery(query2);\n      }\n      if (variables2) {\n        _this.handleEditVariables(variables2);\n      }\n      if (headers2) {\n        _this.handleEditHeaders(headers2);\n      }\n      if (operationName2) {\n        _this.handleEditOperationName(operationName2);\n      }\n    };\n    _this.handleResizeStart = function(downEvent) {\n      if (!_this._didClickDragBar(downEvent)) {\n        return;\n      }\n      downEvent.preventDefault();\n      var offset = downEvent.clientX - getLeft(downEvent.target);\n      var onMouseMove = function(moveEvent) {\n        if (moveEvent.buttons === 0) {\n          return onMouseUp();\n        }\n        var editorBar = _this.editorBarComponent;\n        var leftSize = moveEvent.clientX - getLeft(editorBar) - offset;\n        var rightSize = editorBar.clientWidth - leftSize;\n        _this.setState({ editorFlex: leftSize / rightSize });\n        debounce(500, function() {\n          return _this._storage.set(\"editorFlex\", JSON.stringify(_this.state.editorFlex));\n        })();\n      };\n      var onMouseUp = function() {\n        document.removeEventListener(\"mousemove\", onMouseMove);\n        document.removeEventListener(\"mouseup\", onMouseUp);\n        onMouseMove = null;\n        onMouseUp = null;\n      };\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", onMouseUp);\n    };\n    _this.handleResetResize = function() {\n      _this.setState({ editorFlex: 1 });\n      _this._storage.set(\"editorFlex\", JSON.stringify(_this.state.editorFlex));\n    };\n    _this.handleDocsResizeStart = function(downEvent) {\n      downEvent.preventDefault();\n      var hadWidth = _this.state.docExplorerWidth;\n      var offset = downEvent.clientX - getLeft(downEvent.target);\n      var onMouseMove = function(moveEvent) {\n        if (moveEvent.buttons === 0) {\n          return onMouseUp();\n        }\n        var app = _this.graphiqlContainer;\n        var cursorPos = moveEvent.clientX - getLeft(app) - offset;\n        var docsSize = app.clientWidth - cursorPos;\n        if (docsSize < 100) {\n          if (typeof _this.props.onToggleDocs === \"function\") {\n            _this.props.onToggleDocs(!_this.state.docExplorerOpen);\n          }\n          _this._storage.set(\"docExplorerOpen\", JSON.stringify(_this.state.docExplorerOpen));\n          _this.setState({ docExplorerOpen: false });\n        } else {\n          _this.setState({\n            docExplorerOpen: true,\n            docExplorerWidth: Math.min(docsSize, 650)\n          });\n          debounce(500, function() {\n            return _this._storage.set(\"docExplorerWidth\", JSON.stringify(_this.state.docExplorerWidth));\n          })();\n        }\n        _this._storage.set(\"docExplorerOpen\", JSON.stringify(_this.state.docExplorerOpen));\n      };\n      var onMouseUp = function() {\n        if (!_this.state.docExplorerOpen) {\n          _this.setState({ docExplorerWidth: hadWidth });\n          debounce(500, function() {\n            return _this._storage.set(\"docExplorerWidth\", JSON.stringify(_this.state.docExplorerWidth));\n          })();\n        }\n        document.removeEventListener(\"mousemove\", onMouseMove);\n        document.removeEventListener(\"mouseup\", onMouseUp);\n        onMouseMove = null;\n        onMouseUp = null;\n      };\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", onMouseUp);\n    };\n    _this.handleDocsResetResize = function() {\n      _this.setState({\n        docExplorerWidth: DEFAULT_DOC_EXPLORER_WIDTH\n      });\n      debounce(500, function() {\n        return _this._storage.set(\"docExplorerWidth\", JSON.stringify(_this.state.docExplorerWidth));\n      })();\n    };\n    _this.handleTabClickPropogation = function(downEvent) {\n      downEvent.preventDefault();\n      downEvent.stopPropagation();\n    };\n    _this.handleOpenHeaderEditorTab = function(_clickEvent) {\n      _this.setState({\n        headerEditorActive: true,\n        variableEditorActive: false,\n        secondaryEditorOpen: true\n      });\n    };\n    _this.handleOpenVariableEditorTab = function(_clickEvent) {\n      _this.setState({\n        headerEditorActive: false,\n        variableEditorActive: true,\n        secondaryEditorOpen: true\n      });\n    };\n    _this.handleSecondaryEditorResizeStart = function(downEvent) {\n      downEvent.preventDefault();\n      var didMove = false;\n      var wasOpen = _this.state.secondaryEditorOpen;\n      var hadHeight = _this.state.secondaryEditorHeight;\n      var offset = downEvent.clientY - getTop(downEvent.target);\n      var onMouseMove = function(moveEvent) {\n        if (moveEvent.buttons === 0) {\n          return onMouseUp();\n        }\n        didMove = true;\n        var editorBar = _this.editorBarComponent;\n        var topSize = moveEvent.clientY - getTop(editorBar) - offset;\n        var bottomSize = editorBar.clientHeight - topSize;\n        if (bottomSize < 60) {\n          _this.setState({\n            secondaryEditorOpen: false,\n            secondaryEditorHeight: hadHeight\n          });\n        } else {\n          _this.setState({\n            secondaryEditorOpen: true,\n            secondaryEditorHeight: bottomSize\n          });\n        }\n        debounce(500, function() {\n          return _this._storage.set(\"secondaryEditorHeight\", JSON.stringify(_this.state.secondaryEditorHeight));\n        })();\n      };\n      var onMouseUp = function() {\n        if (!didMove) {\n          _this.setState({ secondaryEditorOpen: !wasOpen });\n        }\n        document.removeEventListener(\"mousemove\", onMouseMove);\n        document.removeEventListener(\"mouseup\", onMouseUp);\n        onMouseMove = null;\n        onMouseUp = null;\n      };\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mouseup\", onMouseUp);\n    };\n    if (typeof props.fetcher !== \"function\") {\n      throw new TypeError(\"GraphiQL requires a fetcher function.\");\n    }\n    _this._storage = new StorageAPI(props.storage);\n    var maxHistoryLength = (_c = props.maxHistoryLength) !== null && _c !== void 0 ? _c : 20;\n    _this._historyStore = new HistoryStore(_this._storage, maxHistoryLength);\n    _this.componentIsMounted = false;\n    var query = props.query !== void 0 ? props.query : _this._storage.get(\"query\") ? _this._storage.get(\"query\") : props.defaultQuery !== void 0 ? props.defaultQuery : defaultQuery;\n    var queryFacts = getOperationFacts(props.schema, query);\n    var variables = props.variables !== void 0 ? props.variables : _this._storage.get(\"variables\");\n    var headers = props.headers !== void 0 ? props.headers : _this._storage.get(\"headers\");\n    var operationName = props.operationName !== void 0 ? props.operationName : getSelectedOperationName(void 0, _this._storage.get(\"operationName\"), queryFacts && queryFacts.operations);\n    var docExplorerOpen = props.docExplorerOpen || false;\n    if (_this._storage.get(\"docExplorerOpen\")) {\n      docExplorerOpen = _this._storage.get(\"docExplorerOpen\") === \"true\";\n    }\n    var secondaryEditorOpen;\n    if (props.defaultVariableEditorOpen !== void 0) {\n      secondaryEditorOpen = props.defaultVariableEditorOpen;\n    } else if (props.defaultSecondaryEditorOpen !== void 0) {\n      secondaryEditorOpen = props.defaultSecondaryEditorOpen;\n    } else {\n      secondaryEditorOpen = Boolean(variables || headers);\n    }\n    var headerEditorEnabled = (_d = props.headerEditorEnabled) !== null && _d !== void 0 ? _d : true;\n    var shouldPersistHeaders = (_e = props.shouldPersistHeaders) !== null && _e !== void 0 ? _e : false;\n    var schema = props.schema;\n    var response = props.response;\n    var schemaErrors = void 0;\n    if (schema && !_this.props.dangerouslyAssumeSchemaIsValid) {\n      var validationErrors = validateSchema(schema);\n      if (validationErrors && validationErrors.length > 0) {\n        response = GraphiQL2.formatError(validationErrors);\n        schema = void 0;\n        schemaErrors = validationErrors;\n      }\n    }\n    _this._introspectionQuery = getIntrospectionQuery({\n      schemaDescription: (_f = props.schemaDescription) !== null && _f !== void 0 ? _f : void 0,\n      inputValueDeprecation: (_g = props.inputValueDeprecation) !== null && _g !== void 0 ? _g : void 0\n    });\n    _this._introspectionQueryName = (_h = props.introspectionQueryName) !== null && _h !== void 0 ? _h : introspectionQueryName;\n    _this._introspectionQuerySansSubscriptions = _this._introspectionQuery.replace(\"subscriptionType { name }\", \"\");\n    var initialTabHash = idFromTabContents({\n      query,\n      variables,\n      headers\n    });\n    var initialTab = {\n      id: guid(),\n      hash: initialTabHash,\n      title: operationName !== null && operationName !== void 0 ? operationName : \"<untitled>\",\n      query,\n      variables,\n      headers,\n      operationName,\n      response: void 0\n    };\n    var rawTabState = null;\n    if (_this.props.tabs) {\n      rawTabState = _this._storage.get(\"tabState\");\n    }\n    var tabsState;\n    if (rawTabState === null) {\n      tabsState = {\n        activeTabIndex: 0,\n        tabs: [initialTab]\n      };\n    } else {\n      tabsState = JSON.parse(rawTabState);\n      var queryParameterOperationIsWithinTabs = false;\n      try {\n        for (var _k = __values$1(tabsState.tabs), _l = _k.next(); !_l.done; _l = _k.next()) {\n          var tab = _l.value;\n          tab.query = tab.query;\n          tab.variables = tab.variables;\n          tab.headers = shouldPersistHeaders ? tab.headers : void 0;\n          tab.response = void 0;\n          tab.operationName = void 0;\n          tab.id = guid();\n          tab.hash = idFromTabContents(tab);\n          if (tab.hash === initialTabHash) {\n            queryParameterOperationIsWithinTabs = true;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n      } finally {\n        try {\n          if (_l && !_l.done && (_a2 = _k.return))\n            _a2.call(_k);\n        } finally {\n          if (e_1)\n            throw e_1.error;\n        }\n      }\n      if (queryParameterOperationIsWithinTabs === false) {\n        tabsState.tabs.push(initialTab);\n        tabsState.activeTabIndex = tabsState.tabs.length - 1;\n      }\n    }\n    var activeTab = tabsState.tabs[0];\n    var index = 0;\n    try {\n      for (var _m = __values$1(tabsState.tabs), _o = _m.next(); !_o.done; _o = _m.next()) {\n        var tab = _o.value;\n        if (tab.hash === initialTabHash) {\n          tabsState.activeTabIndex = index;\n          activeTab = tab;\n          break;\n        }\n        index++;\n      }\n    } catch (e_2_1) {\n      e_2 = { error: e_2_1 };\n    } finally {\n      try {\n        if (_o && !_o.done && (_b = _m.return))\n          _b.call(_m);\n      } finally {\n        if (e_2)\n          throw e_2.error;\n      }\n    }\n    _this.state = __assign$2({\n      tabs: tabsState,\n      schema,\n      query: activeTab === null || activeTab === void 0 ? void 0 : activeTab.query,\n      variables: activeTab === null || activeTab === void 0 ? void 0 : activeTab.variables,\n      headers: activeTab === null || activeTab === void 0 ? void 0 : activeTab.headers,\n      operationName: activeTab === null || activeTab === void 0 ? void 0 : activeTab.operationName,\n      response: (_j = activeTab === null || activeTab === void 0 ? void 0 : activeTab.response) !== null && _j !== void 0 ? _j : response,\n      docExplorerOpen,\n      schemaErrors,\n      editorFlex: Number(_this._storage.get(\"editorFlex\")) || 1,\n      secondaryEditorOpen,\n      secondaryEditorHeight: Number(_this._storage.get(\"secondaryEditorHeight\")) || 200,\n      variableEditorActive: _this._storage.get(\"variableEditorActive\") === \"true\" || props.headerEditorEnabled ? _this._storage.get(\"headerEditorActive\") !== \"true\" : true,\n      headerEditorActive: _this._storage.get(\"headerEditorActive\") === \"true\",\n      headerEditorEnabled,\n      shouldPersistHeaders,\n      historyPaneOpen: _this._storage.get(\"historyPaneOpen\") === \"true\" || false,\n      docExplorerWidth: Number(_this._storage.get(\"docExplorerWidth\")) || DEFAULT_DOC_EXPLORER_WIDTH,\n      isWaitingForResponse: false,\n      subscription: null,\n      maxHistoryLength\n    }, queryFacts);\n    return _this;\n  }\n  GraphiQL2.formatResult = function(result2) {\n    return JSON.stringify(result2, null, 2);\n  };\n  GraphiQL2.prototype.componentDidMount = function() {\n    this.componentIsMounted = true;\n    if (this.state.schema === void 0) {\n      this.fetchSchema();\n    }\n    this.codeMirrorSizer = new CodeMirrorSizer();\n    if (global !== void 0) {\n      global.g = this;\n    }\n  };\n  GraphiQL2.prototype.UNSAFE_componentWillMount = function() {\n    this.componentIsMounted = false;\n  };\n  GraphiQL2.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {\n    var _this = this;\n    var nextSchema = this.state.schema;\n    var nextQuery = this.state.query;\n    var nextVariables = this.state.variables;\n    var nextHeaders = this.state.headers;\n    var nextOperationName = this.state.operationName;\n    var nextResponse = this.state.response;\n    if (nextProps.schema !== void 0) {\n      nextSchema = nextProps.schema;\n    }\n    if (nextProps.query !== void 0 && this.props.query !== nextProps.query) {\n      nextQuery = nextProps.query;\n    }\n    if (nextProps.variables !== void 0 && this.props.variables !== nextProps.variables) {\n      nextVariables = nextProps.variables;\n    }\n    if (nextProps.headers !== void 0 && this.props.headers !== nextProps.headers) {\n      nextHeaders = nextProps.headers;\n    }\n    if (nextProps.operationName !== void 0) {\n      nextOperationName = nextProps.operationName;\n    }\n    if (nextProps.response !== void 0) {\n      nextResponse = nextProps.response;\n    }\n    if (nextQuery && nextSchema && (nextSchema !== this.state.schema || nextQuery !== this.state.query || nextOperationName !== this.state.operationName)) {\n      if (!this.props.dangerouslyAssumeSchemaIsValid) {\n        var validationErrors = validateSchema(nextSchema);\n        if (validationErrors && validationErrors.length > 0) {\n          this.handleSchemaErrors(validationErrors);\n          nextSchema = void 0;\n        }\n      }\n      var updatedQueryAttributes = this._updateQueryFacts(nextQuery, nextOperationName, this.state.operations, nextSchema);\n      if (updatedQueryAttributes !== void 0) {\n        nextOperationName = updatedQueryAttributes.operationName;\n        this.setState(updatedQueryAttributes);\n      }\n    }\n    if (nextProps.schema === void 0 && nextProps.fetcher !== this.props.fetcher) {\n      nextSchema = void 0;\n    }\n    this._storage.set(\"operationName\", nextOperationName);\n    this.setState({\n      schema: nextSchema,\n      query: nextQuery,\n      variables: nextVariables,\n      headers: nextHeaders,\n      operationName: nextOperationName,\n      response: nextResponse\n    }, function() {\n      if (_this.state.schema === void 0) {\n        if (_this.docExplorerComponent) {\n          _this.docExplorerComponent.reset();\n        }\n        _this.fetchSchema();\n      }\n    });\n  };\n  GraphiQL2.prototype.componentDidUpdate = function() {\n    this.codeMirrorSizer.updateSizes([\n      this.queryEditorComponent,\n      this.variableEditorComponent,\n      this.headerEditorComponent,\n      this.resultComponent\n    ]);\n  };\n  GraphiQL2.prototype.render = function() {\n    var _this = this;\n    var _a2;\n    var children = React$1.Children.toArray(this.props.children);\n    var logo = find$1(children, function(child) {\n      return isChildComponentType(child, GraphiQL2.Logo);\n    }) || React$1.createElement(GraphiQL2.Logo, null);\n    var toolbar = find$1(children, function(child) {\n      return isChildComponentType(child, GraphiQL2.Toolbar);\n    }) || React$1.createElement(GraphiQL2.Toolbar, null, React$1.createElement(ToolbarButton, { onClick: this.handlePrettifyQuery, title: \"Prettify Query (Shift-Ctrl-P)\", label: \"Prettify\" }), React$1.createElement(ToolbarButton, { onClick: this.handleMergeQuery, title: \"Merge Query (Shift-Ctrl-M)\", label: \"Merge\" }), React$1.createElement(ToolbarButton, { onClick: this.handleCopyQuery, title: \"Copy Query (Shift-Ctrl-C)\", label: \"Copy\" }), React$1.createElement(ToolbarButton, { onClick: this.handleToggleHistory, title: \"Show History\", label: \"History\" }), ((_a2 = this.props.toolbar) === null || _a2 === void 0 ? void 0 : _a2.additionalContent) ? this.props.toolbar.additionalContent : null);\n    var footer = find$1(children, function(child) {\n      return isChildComponentType(child, GraphiQL2.Footer);\n    });\n    var queryWrapStyle = {\n      WebkitFlex: this.state.editorFlex,\n      flex: this.state.editorFlex\n    };\n    var docWrapStyle = {\n      display: \"block\",\n      width: this.state.docExplorerWidth\n    };\n    var docExplorerWrapClasses = \"docExplorerWrap\" + (this.state.docExplorerWidth < 200 ? \" doc-explorer-narrow\" : \"\");\n    var historyPaneStyle = {\n      display: this.state.historyPaneOpen ? \"block\" : \"none\",\n      width: \"230px\",\n      zIndex: 7\n    };\n    var secondaryEditorOpen = this.state.secondaryEditorOpen;\n    var secondaryEditorStyle = {\n      height: secondaryEditorOpen ? this.state.secondaryEditorHeight : void 0\n    };\n    var tabsState = this.state.tabs;\n    return React$1.createElement(\"div\", { ref: function(n2) {\n      _this.graphiqlContainer = n2;\n    }, \"data-testid\": \"graphiql-container\", className: \"graphiql-container\" }, this.state.historyPaneOpen && React$1.createElement(\"div\", { className: \"historyPaneWrap\", style: historyPaneStyle }, React$1.createElement(QueryHistory, { ref: function(node) {\n      _this._queryHistory = node;\n    }, operationName: this.state.operationName, query: this.state.query, variables: this.state.variables, onSelectQuery: this.handleSelectHistoryQuery, storage: this._storage, maxHistoryLength: this.state.maxHistoryLength, queryID: this._editorQueryID }, React$1.createElement(\"button\", { className: \"docExplorerHide\", onClick: this.handleToggleHistory, \"aria-label\": \"Close History\" }, \"\\u2715\"))), React$1.createElement(\"div\", { className: \"editorWrap\" }, React$1.createElement(\"div\", { className: \"topBarWrap\" }, this.props.beforeTopBarContent, React$1.createElement(\"div\", { className: \"topBar\" }, logo, React$1.createElement(ExecuteButton, { isRunning: Boolean(this.state.subscription), onRun: this.handleRunQuery, onStop: this.handleStopQuery, operations: this.state.operations }), toolbar), !this.state.docExplorerOpen && React$1.createElement(\"button\", { className: \"docExplorerShow\", onClick: this.handleToggleDocs, \"aria-label\": \"Open Documentation Explorer\" }, \"Docs\")), this.props.tabs ? React$1.createElement(Tabs, { tabsProps: {\n      \"aria-label\": \"Select active operation\"\n    } }, tabsState.tabs.map(function(tab, index) {\n      return React$1.createElement(Tab, { key: tab.id, isActive: index === tabsState.activeTabIndex, title: tab.title, isCloseable: tabsState.tabs.length > 1, onSelect: _this.makeHandleOnSelectTab(index), onClose: _this.makeHandleOnCloseTab(index), tabProps: {\n        \"aria-controls\": \"sessionWrap\",\n        id: \"session-tab-\" + index\n      } });\n    }), React$1.createElement(TabAddButton, { onClick: this.handleOnAddTab })) : null, React$1.createElement(\"div\", { ref: function(n2) {\n      _this.editorBarComponent = n2;\n    }, role: \"tabpanel\", id: \"sessionWrap\", className: \"editorBar\", \"aria-labelledby\": \"session-tab-\" + tabsState.activeTabIndex, onDoubleClick: this.handleResetResize, onMouseDown: this.handleResizeStart }, React$1.createElement(\"div\", { className: \"queryWrap\", style: queryWrapStyle }, React$1.createElement(QueryEditor, { ref: function(n2) {\n      _this.queryEditorComponent = n2;\n    }, schema: this.state.schema, validationRules: this.props.validationRules, value: this.state.query, onEdit: this.handleEditQuery, onHintInformationRender: this.handleHintInformationRender, onClickReference: this.handleClickReference, onCopyQuery: this.handleCopyQuery, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, externalFragments: this.props.externalFragments }), React$1.createElement(\"section\", { className: \"variable-editor secondary-editor\", style: secondaryEditorStyle, \"aria-label\": this.state.variableEditorActive ? \"Query Variables\" : \"Request Headers\" }, React$1.createElement(\"div\", { className: \"secondary-editor-title variable-editor-title\", id: \"secondary-editor-title\", style: {\n      cursor: secondaryEditorOpen ? \"row-resize\" : \"n-resize\"\n    }, onMouseDown: this.handleSecondaryEditorResizeStart }, React$1.createElement(\"div\", { className: \"variable-editor-title-text\" + (this.state.variableEditorActive ? \" active\" : \"\"), onClick: this.handleOpenVariableEditorTab, onMouseDown: this.handleTabClickPropogation }, \"Query Variables\"), this.state.headerEditorEnabled && React$1.createElement(\"div\", { style: {\n      marginLeft: \"20px\"\n    }, className: \"variable-editor-title-text\" + (this.state.headerEditorActive ? \" active\" : \"\"), onClick: this.handleOpenHeaderEditorTab, onMouseDown: this.handleTabClickPropogation }, \"Request Headers\")), React$1.createElement(VariableEditor, { ref: function(n2) {\n      _this.variableEditorComponent = n2;\n    }, value: this.state.variables, variableToType: this.state.variableToType, onEdit: this.handleEditVariables, onHintInformationRender: this.handleHintInformationRender, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, active: this.state.variableEditorActive }), this.state.headerEditorEnabled && React$1.createElement(HeaderEditor, { ref: function(n2) {\n      _this.headerEditorComponent = n2;\n    }, value: this.state.headers, onEdit: this.handleEditHeaders, onHintInformationRender: this.handleHintInformationRender, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, active: this.state.headerEditorActive }))), React$1.createElement(\"div\", { className: \"resultWrap\" }, this.state.isWaitingForResponse && React$1.createElement(\"div\", { className: \"spinner-container\" }, React$1.createElement(\"div\", { className: \"spinner\" })), React$1.createElement(ResultViewer, { registerRef: function(n2) {\n      _this.resultViewerElement = n2;\n    }, ref: function(c) {\n      _this.resultComponent = c;\n    }, value: this.state.response, editorTheme: this.props.editorTheme, ResultsTooltip: this.props.ResultsTooltip, ImagePreview }), footer))), this.state.docExplorerOpen && React$1.createElement(\"div\", { className: docExplorerWrapClasses, style: docWrapStyle }, React$1.createElement(\"div\", { className: \"docExplorerResizer\", onDoubleClick: this.handleDocsResetResize, onMouseDown: this.handleDocsResizeStart }), React$1.createElement(DocExplorer, { ref: function(c) {\n      _this.docExplorerComponent = c;\n    }, schemaErrors: this.state.schemaErrors, schema: this.state.schema }, React$1.createElement(\"button\", { className: \"docExplorerHide\", onClick: this.handleToggleDocs, \"aria-label\": \"Close Documentation Explorer\" }, \"\\u2715\"))));\n  };\n  GraphiQL2.prototype.getQueryEditor = function() {\n    if (this.queryEditorComponent) {\n      return this.queryEditorComponent.getCodeMirror();\n    }\n  };\n  GraphiQL2.prototype.getVariableEditor = function() {\n    if (this.variableEditorComponent) {\n      return this.variableEditorComponent.getCodeMirror();\n    }\n    return null;\n  };\n  GraphiQL2.prototype.getHeaderEditor = function() {\n    if (this.headerEditorComponent) {\n      return this.headerEditorComponent.getCodeMirror();\n    }\n    return null;\n  };\n  GraphiQL2.prototype.refresh = function() {\n    if (this.queryEditorComponent) {\n      this.queryEditorComponent.getCodeMirror().refresh();\n    }\n    if (this.variableEditorComponent) {\n      this.variableEditorComponent.getCodeMirror().refresh();\n    }\n    if (this.headerEditorComponent) {\n      this.headerEditorComponent.getCodeMirror().refresh();\n    }\n    if (this.resultComponent) {\n      this.resultComponent.getCodeMirror().refresh();\n    }\n  };\n  GraphiQL2.prototype.autoCompleteLeafs = function() {\n    var _a2 = fillLeafs(this.state.schema, this.state.query, this.props.getDefaultFieldNames), insertions = _a2.insertions, result2 = _a2.result;\n    if (insertions && insertions.length > 0) {\n      var editor_1 = this.getQueryEditor();\n      if (editor_1) {\n        editor_1.operation(function() {\n          var cursor = editor_1.getCursor();\n          var cursorIndex = editor_1.indexFromPos(cursor);\n          editor_1.setValue(result2 || \"\");\n          var added = 0;\n          var markers = insertions.map(function(_a3) {\n            var index = _a3.index, string2 = _a3.string;\n            return editor_1.markText(editor_1.posFromIndex(index + added), editor_1.posFromIndex(index + (added += string2.length)), {\n              className: \"autoInsertedLeaf\",\n              clearOnEnter: true,\n              title: \"Automatically added leaf fields\"\n            });\n          });\n          setTimeout(function() {\n            return markers.forEach(function(marker2) {\n              return marker2.clear();\n            });\n          }, 7e3);\n          var newCursorIndex = cursorIndex;\n          insertions.forEach(function(_a3) {\n            var index = _a3.index, string2 = _a3.string;\n            if (index < cursorIndex) {\n              newCursorIndex += string2.length;\n            }\n          });\n          editor_1.setCursor(editor_1.posFromIndex(newCursorIndex));\n        });\n      }\n    }\n    return result2;\n  };\n  GraphiQL2.prototype.fetchSchema = function() {\n    var _this = this;\n    var fetcher = this.props.fetcher;\n    var fetcherOpts = {\n      shouldPersistHeaders: Boolean(this.props.shouldPersistHeaders),\n      documentAST: this.state.documentAST\n    };\n    try {\n      if (this.state.headers && this.state.headers.trim().length > 2) {\n        fetcherOpts.headers = JSON.parse(this.state.headers);\n      } else if (this.props.headers) {\n        fetcherOpts.headers = JSON.parse(this.props.headers);\n      }\n    } catch (err) {\n      this.setState({\n        response: \"Introspection failed as headers are invalid.\"\n      });\n      return;\n    }\n    var fetch2 = fetcherReturnToPromise(fetcher({\n      query: this._introspectionQuery,\n      operationName: this._introspectionQueryName\n    }, fetcherOpts));\n    if (!isPromise$1(fetch2)) {\n      this.setState({\n        response: \"Fetcher did not return a Promise for introspection.\"\n      });\n      return;\n    }\n    fetch2.then(function(result2) {\n      if (typeof result2 !== \"string\" && \"data\" in result2) {\n        return result2;\n      }\n      var fetch22 = fetcherReturnToPromise(fetcher({\n        query: _this._introspectionQuerySansSubscriptions,\n        operationName: _this._introspectionQueryName\n      }, fetcherOpts));\n      if (!isPromise$1(fetch2)) {\n        throw new Error(\"Fetcher did not return a Promise for introspection.\");\n      }\n      return fetch22;\n    }).then(function(result2) {\n      var _a2, _b;\n      if (_this.state.schema !== void 0) {\n        return;\n      }\n      if (result2 && result2.data && \"__schema\" in (result2 === null || result2 === void 0 ? void 0 : result2.data)) {\n        var schema = buildClientSchema(result2.data);\n        if (!_this.props.dangerouslyAssumeSchemaIsValid) {\n          var errors2 = validateSchema(schema);\n          if (errors2 && errors2.length > 0) {\n            schema = void 0;\n            _this.handleSchemaErrors(errors2);\n          }\n        }\n        if (schema) {\n          var queryFacts = getOperationFacts(schema, _this.state.query);\n          _this.safeSetState(__assign$2(__assign$2({ schema }, queryFacts), { schemaErrors: void 0 }));\n          (_b = (_a2 = _this.props).onSchemaChange) === null || _b === void 0 ? void 0 : _b.call(_a2, schema);\n        }\n      } else {\n        var responseString = typeof result2 === \"string\" ? result2 : GraphiQL2.formatResult(result2);\n        _this.handleSchemaErrors([responseString]);\n      }\n    }).catch(function(error2) {\n      _this.handleSchemaErrors([error2]);\n    });\n  };\n  GraphiQL2.prototype.handleSchemaErrors = function(schemaErrors) {\n    this.safeSetState({\n      response: schemaErrors ? GraphiQL2.formatError(schemaErrors) : void 0,\n      schema: void 0,\n      schemaErrors\n    });\n  };\n  GraphiQL2.prototype._fetchQuery = function(query, variables, headers, operationName, shouldPersistHeaders, cb2) {\n    return __awaiter$1(this, void 0, void 0, function() {\n      var fetcher, jsonVariables, jsonHeaders, externalFragments_1, fragmentDependencies, fetch2;\n      var _this = this;\n      return __generator$1(this, function(_a2) {\n        fetcher = this.props.fetcher;\n        jsonVariables = null;\n        jsonHeaders = null;\n        try {\n          jsonVariables = variables && variables.trim() !== \"\" ? JSON.parse(variables) : null;\n        } catch (error2) {\n          throw new Error(\"Variables are invalid JSON: \" + error2.message + \".\");\n        }\n        if (typeof jsonVariables !== \"object\") {\n          throw new Error(\"Variables are not a JSON object.\");\n        }\n        try {\n          jsonHeaders = headers && headers.trim() !== \"\" ? JSON.parse(headers) : null;\n        } catch (error2) {\n          throw new Error(\"Headers are invalid JSON: \" + error2.message + \".\");\n        }\n        if (typeof jsonHeaders !== \"object\") {\n          throw new Error(\"Headers are not a JSON object.\");\n        }\n        if (this.props.externalFragments) {\n          externalFragments_1 = /* @__PURE__ */ new Map();\n          if (Array.isArray(this.props.externalFragments)) {\n            this.props.externalFragments.forEach(function(def) {\n              externalFragments_1.set(def.name.value, def);\n            });\n          } else {\n            visit(parse$1(this.props.externalFragments, {}), {\n              FragmentDefinition: function(def) {\n                externalFragments_1.set(def.name.value, def);\n              }\n            });\n          }\n          fragmentDependencies = getFragmentDependenciesForAST(this.state.documentAST, externalFragments_1);\n          if (fragmentDependencies.length > 0) {\n            query += \"\\n\" + fragmentDependencies.map(function(node) {\n              return print(node);\n            }).join(\"\\n\");\n          }\n        }\n        fetch2 = fetcher({\n          query,\n          variables: jsonVariables,\n          operationName\n        }, {\n          headers: jsonHeaders,\n          shouldPersistHeaders,\n          documentAST: this.state.documentAST\n        });\n        return [2, Promise.resolve(fetch2).then(function(value) {\n          if (isObservable(value)) {\n            var subscription = value.subscribe({\n              next: cb2,\n              error: function(error2) {\n                _this.safeSetState({\n                  isWaitingForResponse: false,\n                  response: error2 ? GraphiQL2.formatError(error2) : void 0,\n                  subscription: null\n                });\n              },\n              complete: function() {\n                _this.safeSetState({\n                  isWaitingForResponse: false,\n                  subscription: null\n                });\n              }\n            });\n            return subscription;\n          } else if (isAsyncIterable$2(value)) {\n            (function() {\n              return __awaiter$1(_this, void 0, void 0, function() {\n                var value_1, value_1_1, result2, e_4_1, error_2;\n                var e_4, _a3;\n                return __generator$1(this, function(_b) {\n                  switch (_b.label) {\n                    case 0:\n                      _b.trys.push([0, 13, , 14]);\n                      _b.label = 1;\n                    case 1:\n                      _b.trys.push([1, 6, 7, 12]);\n                      value_1 = __asyncValues$1(value);\n                      _b.label = 2;\n                    case 2:\n                      return [4, value_1.next()];\n                    case 3:\n                      if (!(value_1_1 = _b.sent(), !value_1_1.done))\n                        return [3, 5];\n                      result2 = value_1_1.value;\n                      cb2(result2);\n                      _b.label = 4;\n                    case 4:\n                      return [3, 2];\n                    case 5:\n                      return [3, 12];\n                    case 6:\n                      e_4_1 = _b.sent();\n                      e_4 = { error: e_4_1 };\n                      return [3, 12];\n                    case 7:\n                      _b.trys.push([7, , 10, 11]);\n                      if (!(value_1_1 && !value_1_1.done && (_a3 = value_1.return)))\n                        return [3, 9];\n                      return [4, _a3.call(value_1)];\n                    case 8:\n                      _b.sent();\n                      _b.label = 9;\n                    case 9:\n                      return [3, 11];\n                    case 10:\n                      if (e_4)\n                        throw e_4.error;\n                      return [7];\n                    case 11:\n                      return [7];\n                    case 12:\n                      this.safeSetState({\n                        isWaitingForResponse: false,\n                        subscription: null\n                      });\n                      return [3, 14];\n                    case 13:\n                      error_2 = _b.sent();\n                      this.safeSetState({\n                        isWaitingForResponse: false,\n                        response: error_2 ? GraphiQL2.formatError(error_2) : void 0,\n                        subscription: null\n                      });\n                      return [3, 14];\n                    case 14:\n                      return [2];\n                  }\n                });\n              });\n            })();\n            return {\n              unsubscribe: function() {\n                var _a3, _b;\n                return (_b = (_a3 = value[Symbol.asyncIterator]()).return) === null || _b === void 0 ? void 0 : _b.call(_a3);\n              }\n            };\n          } else {\n            cb2(value);\n            return null;\n          }\n        }).catch(function(error2) {\n          _this.safeSetState({\n            isWaitingForResponse: false,\n            response: error2 ? GraphiQL2.formatError(error2) : void 0\n          });\n          return null;\n        })];\n      });\n    });\n  };\n  GraphiQL2.prototype._runQueryAtCursor = function() {\n    if (this.state.subscription) {\n      this.handleStopQuery();\n      return;\n    }\n    var operationName;\n    var operations = this.state.operations;\n    if (operations) {\n      var editor = this.getQueryEditor();\n      if (editor && editor.hasFocus()) {\n        var cursor = editor.getCursor();\n        var cursorIndex = editor.indexFromPos(cursor);\n        for (var i = 0; i < operations.length; i++) {\n          var operation = operations[i];\n          if (operation.loc && operation.loc.start <= cursorIndex && operation.loc.end >= cursorIndex) {\n            operationName = operation.name && operation.name.value;\n            break;\n          }\n        }\n      }\n    }\n    this.handleRunQuery(operationName);\n  };\n  GraphiQL2.prototype._didClickDragBar = function(event) {\n    if (event.button !== 0 || event.ctrlKey) {\n      return false;\n    }\n    var target2 = event.target;\n    if (target2.className.indexOf(\"CodeMirror-gutter\") !== 0) {\n      return false;\n    }\n    var resultWindow = this.resultViewerElement;\n    while (target2) {\n      if (target2 === resultWindow) {\n        return true;\n      }\n      target2 = target2.parentNode;\n    }\n    return false;\n  };\n  GraphiQL2.formatError = function(error2) {\n    if (Array.isArray(error2)) {\n      return stringify({\n        errors: error2.map(function(e) {\n          return handleSingleError(e);\n        })\n      });\n    }\n    return stringify({ errors: handleSingleError(error2) });\n  };\n  GraphiQL2.Logo = GraphiQLLogo;\n  GraphiQL2.Toolbar = GraphiQLToolbar;\n  GraphiQL2.Footer = GraphiQLFooter;\n  GraphiQL2.QueryEditor = QueryEditor;\n  GraphiQL2.VariableEditor = VariableEditor;\n  GraphiQL2.HeaderEditor = HeaderEditor;\n  GraphiQL2.ResultViewer = ResultViewer;\n  GraphiQL2.Button = ToolbarButton;\n  GraphiQL2.ToolbarButton = ToolbarButton;\n  GraphiQL2.Group = ToolbarGroup;\n  GraphiQL2.Menu = ToolbarMenu;\n  GraphiQL2.MenuItem = ToolbarMenuItem;\n  return GraphiQL2;\n}(React$1.Component);\nfunction GraphiQLLogo(props) {\n  return React$1.createElement(\"div\", { className: \"title\" }, props.children || React$1.createElement(\"span\", null, \"Graph\", React$1.createElement(\"em\", null, \"i\"), \"QL\"));\n}\nGraphiQLLogo.displayName = \"GraphiQLLogo\";\nfunction GraphiQLToolbar(props) {\n  return React$1.createElement(\"div\", { className: \"toolbar\", role: \"toolbar\", \"aria-label\": \"Editor Commands\" }, props.children);\n}\nGraphiQLToolbar.displayName = \"GraphiQLToolbar\";\nfunction GraphiQLFooter(props) {\n  return React$1.createElement(\"div\", { className: \"footer\" }, props.children);\n}\nGraphiQLFooter.displayName = \"GraphiQLFooter\";\nvar defaultQuery = '# Welcome to GraphiQL\\n#\\n# GraphiQL is an in-browser tool for writing, validating, and\\n# testing GraphQL queries.\\n#\\n# Type queries into this side of the screen, and you will see intelligent\\n# typeaheads aware of the current GraphQL type schema and live syntax and\\n# validation errors highlighted within the text.\\n#\\n# GraphQL queries typically start with a \"{\" character. Lines that start\\n# with a # are ignored.\\n#\\n# An example GraphQL query might look like:\\n#\\n#     {\\n#       field(arg: \"value\") {\\n#         subField\\n#       }\\n#     }\\n#\\n# Keyboard shortcuts:\\n#\\n#  Prettify Query:  Shift-Ctrl-P (or press the prettify button above)\\n#\\n#     Merge Query:  Shift-Ctrl-M (or press the merge button above)\\n#\\n#       Run Query:  Ctrl-Enter (or press the play button above)\\n#\\n#   Auto Complete:  Ctrl-Space (or just start typing)\\n#\\n\\n';\nfunction isPromise$1(value) {\n  return typeof value === \"object\" && typeof value.then === \"function\";\n}\nfunction observableToPromise(observable) {\n  return new Promise(function(resolve, reject2) {\n    var subscription = observable.subscribe({\n      next: function(v2) {\n        resolve(v2);\n        subscription.unsubscribe();\n      },\n      error: reject2,\n      complete: function() {\n        reject2(new Error(\"no value resolved\"));\n      }\n    });\n  });\n}\nfunction isObservable(value) {\n  return typeof value === \"object\" && \"subscribe\" in value && typeof value.subscribe === \"function\";\n}\nfunction isAsyncIterable$2(input) {\n  return typeof input === \"object\" && input !== null && (input[Symbol.toStringTag] === \"AsyncGenerator\" || Symbol.asyncIterator in input);\n}\nfunction asyncIterableToPromise(input) {\n  return new Promise(function(resolve, reject2) {\n    var _a2;\n    var iteratorReturn = (_a2 = (\"return\" in input ? input : input[Symbol.asyncIterator]()).return) === null || _a2 === void 0 ? void 0 : _a2.bind(input);\n    var iteratorNext = (\"next\" in input ? input : input[Symbol.asyncIterator]()).next.bind(input);\n    iteratorNext().then(function(result2) {\n      resolve(result2.value);\n      iteratorReturn === null || iteratorReturn === void 0 ? void 0 : iteratorReturn();\n    }).catch(function(err) {\n      reject2(err);\n    });\n  });\n}\nfunction fetcherReturnToPromise(fetcherResult) {\n  return Promise.resolve(fetcherResult).then(function(fetcherResult2) {\n    if (isAsyncIterable$2(fetcherResult2)) {\n      return asyncIterableToPromise(fetcherResult2);\n    } else if (isObservable(fetcherResult2)) {\n      return observableToPromise(fetcherResult2);\n    }\n    return fetcherResult2;\n  });\n}\nfunction isChildComponentType(child, component) {\n  var _a2;\n  if (((_a2 = child === null || child === void 0 ? void 0 : child.type) === null || _a2 === void 0 ? void 0 : _a2.displayName) && child.type.displayName === component.displayName) {\n    return true;\n  }\n  return child.type === component;\n}\nfunction tabsStateEditHeadersReducer(value, state) {\n  return __assign$2(__assign$2({}, state), { tabs: state.tabs.map(function(tab, index) {\n    if (index !== state.activeTabIndex) {\n      return tab;\n    }\n    return __assign$2(__assign$2({}, tab), { headers: value, hash: idFromTabContents({\n      query: tab.query,\n      headers: value,\n      variables: tab.variables\n    }) });\n  }) });\n}\nfunction tabsStateEditVariablesReducer(value, state) {\n  return __assign$2(__assign$2({}, state), { tabs: state.tabs.map(function(tab, index) {\n    if (index !== state.activeTabIndex) {\n      return tab;\n    }\n    return __assign$2(__assign$2({}, tab), { variables: value, hash: idFromTabContents({\n      query: tab.query,\n      headers: tab.headers,\n      variables: value\n    }) });\n  }) });\n}\nfunction tabsStateEditQueryReducer(value, state, operationName) {\n  return __assign$2(__assign$2({}, state), { tabs: state.tabs.map(function(tab, index) {\n    if (index !== state.activeTabIndex) {\n      return tab;\n    }\n    return __assign$2(__assign$2({}, tab), { title: operationName !== null && operationName !== void 0 ? operationName : fuzzyExtractOperationTitle(value), query: value, hash: idFromTabContents({\n      query: value,\n      headers: tab.headers,\n      variables: tab.variables\n    }) });\n  }) });\n}\nfunction stateOnSelectTabReducer(index, state) {\n  var oldActiveTabIndex = state.tabs.activeTabIndex;\n  var tabs = state.tabs.tabs.map(function(currentTab, tabIndex) {\n    if (tabIndex !== oldActiveTabIndex) {\n      return currentTab;\n    }\n    return __assign$2(__assign$2({}, currentTab), { query: state.query, variables: state.variables, operationName: state.operationName, headers: state.headers, response: state.response, hash: idFromTabContents({\n      query: state.query,\n      variables: state.variables,\n      headers: state.headers\n    }) });\n  });\n  var newActiveTab = state.tabs.tabs[index];\n  return __assign$2(__assign$2({}, state), { query: newActiveTab.query, variables: newActiveTab.variables, operationName: newActiveTab.operationName, headers: newActiveTab.headers, response: newActiveTab.response, tabs: __assign$2(__assign$2({}, state.tabs), { tabs, activeTabIndex: index }) });\n}\nfunction stateOnCloseTabReducer(index, state) {\n  var newActiveTabIndex = state.tabs.activeTabIndex > 0 ? state.tabs.activeTabIndex - 1 : 0;\n  var newTabsState = __assign$2(__assign$2({}, state.tabs), { activeTabIndex: newActiveTabIndex, tabs: state.tabs.tabs.filter(function(_tab, i) {\n    return index !== i;\n  }) });\n  var activeTab = newTabsState.tabs[newActiveTabIndex];\n  return __assign$2(__assign$2({}, state), { query: activeTab.query, variables: activeTab.variables, operationName: activeTab.operationName, headers: activeTab.headers, response: activeTab.response, tabs: newTabsState });\n}\nfunction stateOnTabAddReducer(state) {\n  var oldActiveTabIndex = state.tabs.activeTabIndex;\n  var newTab = {\n    id: guid(),\n    title: \"<untitled>\",\n    headers: \"\",\n    variables: \"\",\n    query: \"\",\n    operationName: \"\",\n    response: \"\",\n    hash: idFromTabContents({\n      query: \"\",\n      variables: \"\",\n      headers: \"\"\n    })\n  };\n  var tabs = state.tabs.tabs.map(function(tab, index) {\n    if (index !== oldActiveTabIndex) {\n      return tab;\n    }\n    return __assign$2(__assign$2({}, tab), { headers: state.headers, variables: state.variables, query: state.query, operationName: state.operationName, response: state.response });\n  });\n  return __assign$2(__assign$2({}, state), { headers: newTab.headers, variables: newTab.variables, query: newTab.query, operationName: newTab.operationName, response: newTab.response, tabs: __assign$2(__assign$2({}, state.tabs), { activeTabIndex: state.tabs.tabs.length, tabs: __spread(tabs, [newTab]) }) });\n}\nvar __extends = globalThis && globalThis.__extends || function() {\n  var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n      d2.__proto__ = b2;\n    } || function(d2, b2) {\n      for (var p2 in b2)\n        if (Object.prototype.hasOwnProperty.call(b2, p2))\n          d2[p2] = b2[p2];\n    };\n    return extendStatics(d, b);\n  };\n  return function(d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign$1 = globalThis && globalThis.__assign || function() {\n  __assign$1 = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign$1.apply(this, arguments);\n};\nfunction hasProps(child) {\n  if (!child || typeof child !== \"object\" || !(\"props\" in child)) {\n    return false;\n  }\n  return true;\n}\n(function(_super2) {\n  __extends(ToolbarSelect, _super2);\n  function ToolbarSelect(props) {\n    var _this = _super2.call(this, props) || this;\n    _this._node = null;\n    _this._listener = null;\n    _this.handleOpen = function(e) {\n      preventDefault(e);\n      _this.setState({ visible: true });\n      _this._subscribe();\n    };\n    _this.state = { visible: false };\n    return _this;\n  }\n  ToolbarSelect.prototype.componentWillUnmount = function() {\n    this._release();\n  };\n  ToolbarSelect.prototype.render = function() {\n    var _this = this;\n    var selectedChild;\n    var visible = this.state.visible;\n    var optionChildren = React$1.Children.map(this.props.children, function(child, i) {\n      if (!hasProps(child)) {\n        return null;\n      }\n      if (!selectedChild || child.props.selected) {\n        selectedChild = child;\n      }\n      var onChildSelect = child.props.onSelect || _this.props.onSelect && _this.props.onSelect.bind(null, child.props.value, i);\n      return React$1.createElement(ToolbarSelectOption, __assign$1({}, child.props, { onSelect: onChildSelect }));\n    });\n    return React$1.createElement(\"a\", { className: \"toolbar-select toolbar-button\", onClick: this.handleOpen.bind(this), onMouseDown: preventDefault, ref: function(node) {\n      _this._node = node;\n    }, title: this.props.title }, selectedChild === null || selectedChild === void 0 ? void 0 : selectedChild.props.label, React$1.createElement(\"svg\", { width: \"13\", height: \"10\" }, React$1.createElement(\"path\", { fill: \"#666\", d: \"M 5 5 L 13 5 L 9 1 z\" }), React$1.createElement(\"path\", { fill: \"#666\", d: \"M 5 6 L 13 6 L 9 10 z\" })), React$1.createElement(\"ul\", { className: \"toolbar-select-options\" + (visible ? \" open\" : \"\") }, optionChildren));\n  };\n  ToolbarSelect.prototype._subscribe = function() {\n    if (!this._listener) {\n      this._listener = this.handleClick.bind(this);\n      document.addEventListener(\"click\", this._listener);\n    }\n  };\n  ToolbarSelect.prototype._release = function() {\n    if (this._listener) {\n      document.removeEventListener(\"click\", this._listener);\n      this._listener = null;\n    }\n  };\n  ToolbarSelect.prototype.handleClick = function(e) {\n    if (this._node !== e.target) {\n      preventDefault(e);\n      this.setState({ visible: false });\n      this._release();\n    }\n  };\n  return ToolbarSelect;\n})(React$1.Component);\nfunction ToolbarSelectOption(_a2) {\n  var onSelect = _a2.onSelect, label = _a2.label, selected = _a2.selected;\n  return React$1.createElement(\"li\", { onMouseOver: function(e) {\n    e.currentTarget.className = \"hover\";\n  }, onMouseOut: function(e) {\n    e.currentTarget.className = \"\";\n  }, onMouseDown: preventDefault, onMouseUp: onSelect }, label, selected && React$1.createElement(\"svg\", { width: \"13\", height: \"13\" }, React$1.createElement(\"polygon\", { points: \"4.851,10.462 0,5.611 2.314,3.297 4.851,5.835\\n    10.686,0 13,2.314 4.851,10.462\" })));\n}\nfunction preventDefault(e) {\n  e.preventDefault();\n}\nlet AggregateErrorImpl;\nif (typeof AggregateError === \"undefined\") {\n  class AggregateErrorClass extends Error {\n    constructor(errors2, message = \"\") {\n      super(message);\n      this.errors = errors2;\n      this.name = \"AggregateError\";\n      Error.captureStackTrace(this, AggregateErrorClass);\n    }\n  }\n  AggregateErrorImpl = function(errors2, message) {\n    return new AggregateErrorClass(errors2, message);\n  };\n} else {\n  AggregateErrorImpl = AggregateError;\n}\nfunction isAggregateError(error2) {\n  return \"errors\" in error2 && Array.isArray(error2[\"errors\"]);\n}\nconst MAX_RECURSIVE_DEPTH$1 = 3;\nfunction inspect$1(value) {\n  return formatValue$1(value, []);\n}\nfunction formatValue$1(value, seenValues) {\n  switch (typeof value) {\n    case \"string\":\n      return JSON.stringify(value);\n    case \"function\":\n      return value.name ? `[function ${value.name}]` : \"[function]\";\n    case \"object\":\n      return formatObjectValue$1(value, seenValues);\n    default:\n      return String(value);\n  }\n}\nfunction formatError(value) {\n  if (value instanceof GraphQLError) {\n    return value.toString();\n  }\n  return `${value.name}: ${value.message};\n ${value.stack}`;\n}\nfunction formatObjectValue$1(value, previouslySeenValues) {\n  if (value === null) {\n    return \"null\";\n  }\n  if (value instanceof Error) {\n    if (isAggregateError(value)) {\n      return formatError(value) + \"\\n\" + formatArray$1(value.errors, previouslySeenValues);\n    }\n    return formatError(value);\n  }\n  if (previouslySeenValues.includes(value)) {\n    return \"[Circular]\";\n  }\n  const seenValues = [...previouslySeenValues, value];\n  if (isJSONable$1(value)) {\n    const jsonValue = value.toJSON();\n    if (jsonValue !== value) {\n      return typeof jsonValue === \"string\" ? jsonValue : formatValue$1(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray$1(value, seenValues);\n  }\n  return formatObject$1(value, seenValues);\n}\nfunction isJSONable$1(value) {\n  return typeof value.toJSON === \"function\";\n}\nfunction formatObject$1(object, seenValues) {\n  const entries = Object.entries(object);\n  if (entries.length === 0) {\n    return \"{}\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {\n    return \"[\" + getObjectTag$1(object) + \"]\";\n  }\n  const properties = entries.map(([key, value]) => key + \": \" + formatValue$1(value, seenValues));\n  return \"{ \" + properties.join(\", \") + \" }\";\n}\nfunction formatArray$1(array, seenValues) {\n  if (array.length === 0) {\n    return \"[]\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {\n    return \"[Array]\";\n  }\n  const len = array.length;\n  const remaining = array.length;\n  const items = [];\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue$1(array[i], seenValues));\n  }\n  if (remaining === 1) {\n    items.push(\"... 1 more item\");\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n  return \"[\" + items.join(\", \") + \"]\";\n}\nfunction getObjectTag$1(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, \"\").replace(/]$/, \"\");\n  if (tag === \"Object\" && typeof object.constructor === \"function\") {\n    const name2 = object.constructor.name;\n    if (typeof name2 === \"string\" && name2 !== \"\") {\n      return name2;\n    }\n  }\n  return tag;\n}\nfunction astFromType(type2) {\n  if (isNonNullType(type2)) {\n    const innerType = astFromType(type2.ofType);\n    if (innerType.kind === Kind.NON_NULL_TYPE) {\n      throw new Error(`Invalid type node ${inspect$1(type2)}. Inner type of non-null type cannot be a non-null type.`);\n    }\n    return {\n      kind: Kind.NON_NULL_TYPE,\n      type: innerType\n    };\n  } else if (isListType(type2)) {\n    return {\n      kind: Kind.LIST_TYPE,\n      type: astFromType(type2.ofType)\n    };\n  }\n  return {\n    kind: Kind.NAMED_TYPE,\n    name: {\n      kind: Kind.NAME,\n      value: type2.name\n    }\n  };\n}\nfunction memoize1$1(fn) {\n  const memoize1cache = /* @__PURE__ */ new WeakMap();\n  return function memoized(a1) {\n    const cachedValue = memoize1cache.get(a1);\n    if (cachedValue === void 0) {\n      const newValue = fn(a1);\n      memoize1cache.set(a1, newValue);\n      return newValue;\n    }\n    return cachedValue;\n  };\n}\nfunction memoize2$1(fn) {\n  const memoize2cache = /* @__PURE__ */ new WeakMap();\n  return function memoized(a1, a2) {\n    let cache2 = memoize2cache.get(a1);\n    if (!cache2) {\n      cache2 = /* @__PURE__ */ new WeakMap();\n      memoize2cache.set(a1, cache2);\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n    const cachedValue = cache2.get(a2);\n    if (cachedValue === void 0) {\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n    return cachedValue;\n  };\n}\nconst memoize2of4cache = /* @__PURE__ */ new WeakMap();\nfunction memoize2of4(fn) {\n  return function memoized(a1, a2, a3, a4) {\n    let cache2 = memoize2of4cache.get(a1);\n    if (!cache2) {\n      cache2 = /* @__PURE__ */ new WeakMap();\n      memoize2of4cache.set(a1, cache2);\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n    const cachedValue = cache2.get(a2);\n    if (cachedValue === void 0) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n    return cachedValue;\n  };\n}\nfunction getDefinedRootType(schema, operation) {\n  const rootTypeMap = getRootTypeMap(schema);\n  const rootType = rootTypeMap.get(operation);\n  if (rootType == null) {\n    throw new Error(`Root type for operation \"${operation}\" not defined by the given schema.`);\n  }\n  return rootType;\n}\nconst getRootTypeNames = memoize1$1(function getRootTypeNames2(schema) {\n  const rootTypes = getRootTypes(schema);\n  return new Set([...rootTypes].map((type2) => type2.name));\n});\nconst getRootTypes = memoize1$1(function getRootTypes2(schema) {\n  const rootTypeMap = getRootTypeMap(schema);\n  return new Set(rootTypeMap.values());\n});\nconst getRootTypeMap = memoize1$1(function getRootTypeMap2(schema) {\n  const rootTypeMap = /* @__PURE__ */ new Map();\n  const queryType = schema.getQueryType();\n  if (queryType) {\n    rootTypeMap.set(\"query\", queryType);\n  }\n  const mutationType = schema.getMutationType();\n  if (mutationType) {\n    rootTypeMap.set(\"mutation\", mutationType);\n  }\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType) {\n    rootTypeMap.set(\"subscription\", subscriptionType);\n  }\n  return rootTypeMap;\n});\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction printComment(comment2) {\n  return \"\\n# \" + comment2.replace(/\\n/g, \"\\n# \");\n}\nfunction join(maybeArray, separator2) {\n  return maybeArray ? maybeArray.filter((x2) => x2).join(separator2 || \"\") : \"\";\n}\nfunction hasMultilineItems(maybeArray) {\n  var _a2;\n  return (_a2 = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes(\"\\n\"))) !== null && _a2 !== void 0 ? _a2 : false;\n}\nfunction addDescription(cb2) {\n  return (node, _key, _parent, path, ancestors) => {\n    var _a2;\n    const keys = [];\n    const parent = path.reduce((prev, key2) => {\n      if ([\"fields\", \"arguments\", \"values\"].includes(key2) && prev.name) {\n        keys.push(prev.name.value);\n      }\n      return prev[key2];\n    }, ancestors[0]);\n    const key = [...keys, (_a2 = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a2 === void 0 ? void 0 : _a2.value].filter(Boolean).join(\".\");\n    const items = [];\n    if (node.kind.includes(\"Definition\") && commentsRegistry[key]) {\n      items.push(...commentsRegistry[key]);\n    }\n    return join([...items.map(printComment), node.description, cb2(node, _key, _parent, path, ancestors)], \"\\n\");\n  };\n}\nfunction indent$3(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, \"\\n  \")}`;\n}\nfunction block2(array) {\n  return array && array.length !== 0 ? `{\n${indent$3(join(array, \"\\n\"))}\n}` : \"\";\n}\nfunction wrap(start2, maybeString, end2) {\n  return maybeString ? start2 + maybeString + (end2 || \"\") : \"\";\n}\nfunction printBlockString(value, isDescription = false) {\n  const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === \" \" || value[0] === \"\t\") && value.indexOf(\"\\n\") === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\n${isDescription ? escaped : indent$3(escaped)}\n\"\"\"`;\n}\nconst printDocASTReducer = {\n  Name: { leave: (node) => node.value },\n  Variable: { leave: (node) => \"$\" + node.name },\n  Document: {\n    leave: (node) => join(node.definitions, \"\\n\\n\")\n  },\n  OperationDefinition: {\n    leave: (node) => {\n      const varDefs = wrap(\"(\", join(node.variableDefinitions, \", \"), \")\");\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, \" \")], \" \");\n      return prefix + \" \" + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: ({ variable, type: type2, defaultValue: defaultValue2, directives }) => variable + \": \" + type2 + wrap(\" = \", defaultValue2) + wrap(\" \", join(directives, \" \"))\n  },\n  SelectionSet: { leave: ({ selections }) => block2(selections) },\n  Field: {\n    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {\n      const prefix = wrap(\"\", alias, \": \") + name2;\n      let argsLine = prefix + wrap(\"(\", join(args, \", \"), \")\");\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap(\"(\\n\", indent$3(join(args, \"\\n\")), \"\\n)\");\n      }\n      return join([argsLine, join(directives, \" \"), selectionSet], \" \");\n    }\n  },\n  Argument: { leave: ({ name: name2, value }) => name2 + \": \" + value },\n  FragmentSpread: {\n    leave: ({ name: name2, directives }) => \"...\" + name2 + wrap(\" \", join(directives, \" \"))\n  },\n  InlineFragment: {\n    leave: ({ typeCondition, directives, selectionSet }) => join([\"...\", wrap(\"on \", typeCondition), join(directives, \" \"), selectionSet], \" \")\n  },\n  FragmentDefinition: {\n    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name2}${wrap(\"(\", join(variableDefinitions, \", \"), \")\")} on ${typeCondition} ${wrap(\"\", join(directives, \" \"), \" \")}` + selectionSet\n  },\n  IntValue: { leave: ({ value }) => value },\n  FloatValue: { leave: ({ value }) => value },\n  StringValue: {\n    leave: ({ value, block: isBlockString }) => {\n      if (isBlockString) {\n        return printBlockString(value);\n      }\n      return JSON.stringify(value);\n    }\n  },\n  BooleanValue: { leave: ({ value }) => value ? \"true\" : \"false\" },\n  NullValue: { leave: () => \"null\" },\n  EnumValue: { leave: ({ value }) => value },\n  ListValue: { leave: ({ values }) => \"[\" + join(values, \", \") + \"]\" },\n  ObjectValue: { leave: ({ fields }) => \"{\" + join(fields, \", \") + \"}\" },\n  ObjectField: { leave: ({ name: name2, value }) => name2 + \": \" + value },\n  Directive: {\n    leave: ({ name: name2, arguments: args }) => \"@\" + name2 + wrap(\"(\", join(args, \", \"), \")\")\n  },\n  NamedType: { leave: ({ name: name2 }) => name2 },\n  ListType: { leave: ({ type: type2 }) => \"[\" + type2 + \"]\" },\n  NonNullType: { leave: ({ type: type2 }) => type2 + \"!\" },\n  SchemaDefinition: {\n    leave: ({ directives, operationTypes }) => join([\"schema\", join(directives, \" \"), block2(operationTypes)], \" \")\n  },\n  OperationTypeDefinition: {\n    leave: ({ operation, type: type2 }) => operation + \": \" + type2\n  },\n  ScalarTypeDefinition: {\n    leave: ({ name: name2, directives }) => join([\"scalar\", name2, join(directives, \" \")], \" \")\n  },\n  ObjectTypeDefinition: {\n    leave: ({ name: name2, interfaces, directives, fields }) => join([\"type\", name2, wrap(\"implements \", join(interfaces, \" & \")), join(directives, \" \"), block2(fields)], \" \")\n  },\n  FieldDefinition: {\n    leave: ({ name: name2, arguments: args, type: type2, directives }) => name2 + (hasMultilineItems(args) ? wrap(\"(\\n\", indent$3(join(args, \"\\n\")), \"\\n)\") : wrap(\"(\", join(args, \", \"), \")\")) + \": \" + type2 + wrap(\" \", join(directives, \" \"))\n  },\n  InputValueDefinition: {\n    leave: ({ name: name2, type: type2, defaultValue: defaultValue2, directives }) => join([name2 + \": \" + type2, wrap(\"= \", defaultValue2), join(directives, \" \")], \" \")\n  },\n  InterfaceTypeDefinition: {\n    leave: ({ name: name2, interfaces, directives, fields }) => join([\"interface\", name2, wrap(\"implements \", join(interfaces, \" & \")), join(directives, \" \"), block2(fields)], \" \")\n  },\n  UnionTypeDefinition: {\n    leave: ({ name: name2, directives, types }) => join([\"union\", name2, join(directives, \" \"), wrap(\"= \", join(types, \" | \"))], \" \")\n  },\n  EnumTypeDefinition: {\n    leave: ({ name: name2, directives, values }) => join([\"enum\", name2, join(directives, \" \"), block2(values)], \" \")\n  },\n  EnumValueDefinition: {\n    leave: ({ name: name2, directives }) => join([name2, join(directives, \" \")], \" \")\n  },\n  InputObjectTypeDefinition: {\n    leave: ({ name: name2, directives, fields }) => join([\"input\", name2, join(directives, \" \"), block2(fields)], \" \")\n  },\n  DirectiveDefinition: {\n    leave: ({ name: name2, arguments: args, repeatable, locations }) => \"directive @\" + name2 + (hasMultilineItems(args) ? wrap(\"(\\n\", indent$3(join(args, \"\\n\")), \"\\n)\") : wrap(\"(\", join(args, \", \"), \")\")) + (repeatable ? \" repeatable\" : \"\") + \" on \" + join(locations, \" | \")\n  },\n  SchemaExtension: {\n    leave: ({ directives, operationTypes }) => join([\"extend schema\", join(directives, \" \"), block2(operationTypes)], \" \")\n  },\n  ScalarTypeExtension: {\n    leave: ({ name: name2, directives }) => join([\"extend scalar\", name2, join(directives, \" \")], \" \")\n  },\n  ObjectTypeExtension: {\n    leave: ({ name: name2, interfaces, directives, fields }) => join([\"extend type\", name2, wrap(\"implements \", join(interfaces, \" & \")), join(directives, \" \"), block2(fields)], \" \")\n  },\n  InterfaceTypeExtension: {\n    leave: ({ name: name2, interfaces, directives, fields }) => join([\"extend interface\", name2, wrap(\"implements \", join(interfaces, \" & \")), join(directives, \" \"), block2(fields)], \" \")\n  },\n  UnionTypeExtension: {\n    leave: ({ name: name2, directives, types }) => join([\"extend union\", name2, join(directives, \" \"), wrap(\"= \", join(types, \" | \"))], \" \")\n  },\n  EnumTypeExtension: {\n    leave: ({ name: name2, directives, values }) => join([\"extend enum\", name2, join(directives, \" \"), block2(values)], \" \")\n  },\n  InputObjectTypeExtension: {\n    leave: ({ name: name2, directives, fields }) => join([\"extend input\", name2, join(directives, \" \"), block2(fields)], \" \")\n  }\n};\nObject.keys(printDocASTReducer).reduce((prev, key) => __spreadProps(__spreadValues({}, prev), {\n  [key]: {\n    leave: addDescription(printDocASTReducer[key].leave)\n  }\n}), {});\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  const comments = [];\n  let token2 = loc.startToken.prev;\n  while (token2 != null && token2.kind === TokenKind.COMMENT && token2.next != null && token2.prev != null && token2.line + 1 === token2.next.line && token2.line !== token2.prev.line) {\n    const value = String(token2.value);\n    comments.push(value);\n    token2 = token2.prev;\n  }\n  return comments.length > 0 ? comments.reverse().join(\"\\n\") : void 0;\n}\nfunction dedentBlockStringValue(rawString) {\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n  const commonIndent = getBlockStringIndentation(lines);\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  }\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n  return lines.join(\"\\n\");\n}\nfunction getBlockStringIndentation(lines) {\n  let commonIndent = null;\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent2 = leadingWhitespace(line);\n    if (indent2 === line.length) {\n      continue;\n    }\n    if (commonIndent === null || indent2 < commonIndent) {\n      commonIndent = indent2;\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n  return commonIndent === null ? 0 : commonIndent;\n}\nfunction leadingWhitespace(str) {\n  let i = 0;\n  while (i < str.length && (str[i] === \" \" || str[i] === \"\t\")) {\n    i++;\n  }\n  return i;\n}\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\nfunction parseGraphQLSDL(location, rawSDL, options = {}) {\n  let document2;\n  try {\n    if (options.commentDescriptions && rawSDL.includes(\"#\")) {\n      document2 = transformCommentsToDescriptions(rawSDL, options);\n      if (options.noLocation) {\n        document2 = parse$1(print(document2), options);\n      }\n    } else {\n      document2 = parse$1(new Source(rawSDL, location), options);\n    }\n  } catch (e) {\n    if (e.message.includes(\"EOF\") && rawSDL.replace(/(\\#[^*]*)/g, \"\").trim() === \"\") {\n      document2 = {\n        kind: Kind.DOCUMENT,\n        definitions: []\n      };\n    } else {\n      throw e;\n    }\n  }\n  return {\n    location,\n    document: document2\n  };\n}\nfunction transformCommentsToDescriptions(sourceSdl, options = {}) {\n  const parsedDoc = parse$1(sourceSdl, __spreadProps(__spreadValues({}, options), {\n    noLocation: false\n  }));\n  const modifiedDoc = visit(parsedDoc, {\n    leave: (node) => {\n      if (isDescribable(node)) {\n        const rawValue = getLeadingCommentBlock(node);\n        if (rawValue !== void 0) {\n          const commentsBlock = dedentBlockStringValue(\"\\n\" + rawValue);\n          const isBlock = commentsBlock.includes(\"\\n\");\n          if (!node.description) {\n            return __spreadProps(__spreadValues({}, node), {\n              description: {\n                kind: Kind.STRING,\n                value: commentsBlock,\n                block: isBlock\n              }\n            });\n          } else {\n            return __spreadProps(__spreadValues({}, node), {\n              description: __spreadProps(__spreadValues({}, node.description), {\n                value: node.description.value + \"\\n\" + commentsBlock,\n                block: true\n              })\n            });\n          }\n        }\n      }\n    }\n  });\n  return modifiedDoc;\n}\nfunction isDescribable(node) {\n  return isTypeSystemDefinitionNode(node) || node.kind === Kind.FIELD_DEFINITION || node.kind === Kind.INPUT_VALUE_DEFINITION || node.kind === Kind.ENUM_VALUE_DEFINITION;\n}\nvar MapperKind;\n(function(MapperKind2) {\n  MapperKind2[\"TYPE\"] = \"MapperKind.TYPE\";\n  MapperKind2[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n  MapperKind2[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n  MapperKind2[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n  MapperKind2[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n  MapperKind2[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n  MapperKind2[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n  MapperKind2[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n  MapperKind2[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n  MapperKind2[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n  MapperKind2[\"QUERY\"] = \"MapperKind.QUERY\";\n  MapperKind2[\"MUTATION\"] = \"MapperKind.MUTATION\";\n  MapperKind2[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n  MapperKind2[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n  MapperKind2[\"FIELD\"] = \"MapperKind.FIELD\";\n  MapperKind2[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n  MapperKind2[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n  MapperKind2[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n  MapperKind2[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n  MapperKind2[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n  MapperKind2[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n  MapperKind2[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n  MapperKind2[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n  MapperKind2[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n  MapperKind2[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\nfunction getObjectTypeFromTypeMap(typeMap, type2) {\n  if (type2) {\n    const maybeObjectType = typeMap[type2.name];\n    if (isObjectType(maybeObjectType)) {\n      return maybeObjectType;\n    }\n  }\n}\nfunction isNamedStub(type2) {\n  if (\"getFields\" in type2) {\n    const fields = type2.getFields();\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      return field.name === \"_fake\";\n    }\n  }\n  return false;\n}\nfunction getBuiltInForStub(type2) {\n  switch (type2.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n    case GraphQLString.name:\n      return GraphQLString;\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n    case GraphQLID.name:\n      return GraphQLID;\n    default:\n      return type2;\n  }\n}\nfunction rewireTypes(originalTypeMap, directives) {\n  const referenceTypeMap = /* @__PURE__ */ Object.create(null);\n  for (const typeName in originalTypeMap) {\n    referenceTypeMap[typeName] = originalTypeMap[typeName];\n  }\n  const newTypeMap = /* @__PURE__ */ Object.create(null);\n  for (const typeName in referenceTypeMap) {\n    const namedType = referenceTypeMap[typeName];\n    if (namedType == null || typeName.startsWith(\"__\")) {\n      continue;\n    }\n    const newName = namedType.name;\n    if (newName.startsWith(\"__\")) {\n      continue;\n    }\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n    newTypeMap[newName] = namedType;\n  }\n  for (const typeName in newTypeMap) {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  }\n  const newDirectives = directives.map((directive) => rewireDirective(directive));\n  return {\n    typeMap: newTypeMap,\n    directives: newDirectives\n  };\n  function rewireDirective(directive) {\n    if (isSpecifiedDirective(directive)) {\n      return directive;\n    }\n    const directiveConfig = directive.toConfig();\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n  function rewireArgs(args) {\n    const rewiredArgs = {};\n    for (const argName in args) {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    }\n    return rewiredArgs;\n  }\n  function rewireNamedType(type2) {\n    if (isObjectType(type2)) {\n      const config2 = type2.toConfig();\n      const newConfig = __spreadProps(__spreadValues({}, config2), {\n        fields: () => rewireFields(config2.fields),\n        interfaces: () => rewireNamedTypes(config2.interfaces)\n      });\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type2)) {\n      const config2 = type2.toConfig();\n      const newConfig = __spreadProps(__spreadValues({}, config2), {\n        fields: () => rewireFields(config2.fields)\n      });\n      if (\"interfaces\" in newConfig) {\n        newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);\n      }\n      return new GraphQLInterfaceType(newConfig);\n    } else if (isUnionType(type2)) {\n      const config2 = type2.toConfig();\n      const newConfig = __spreadProps(__spreadValues({}, config2), {\n        types: () => rewireNamedTypes(config2.types)\n      });\n      return new GraphQLUnionType(newConfig);\n    } else if (isInputObjectType(type2)) {\n      const config2 = type2.toConfig();\n      const newConfig = __spreadProps(__spreadValues({}, config2), {\n        fields: () => rewireInputFields(config2.fields)\n      });\n      return new GraphQLInputObjectType(newConfig);\n    } else if (isEnumType(type2)) {\n      const enumConfig = type2.toConfig();\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type2)) {\n      if (isSpecifiedScalarType(type2)) {\n        return type2;\n      }\n      const scalarConfig = type2.toConfig();\n      return new GraphQLScalarType(scalarConfig);\n    }\n    throw new Error(`Unexpected schema type: ${type2}`);\n  }\n  function rewireFields(fields) {\n    const rewiredFields = {};\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null && field.args) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    }\n    return rewiredFields;\n  }\n  function rewireInputFields(fields) {\n    const rewiredFields = {};\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    }\n    return rewiredFields;\n  }\n  function rewireNamedTypes(namedTypes) {\n    const rewiredTypes = [];\n    for (const namedType of namedTypes) {\n      const rewiredType = rewireType(namedType);\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    }\n    return rewiredTypes;\n  }\n  function rewireType(type2) {\n    if (isListType(type2)) {\n      const rewiredType = rewireType(type2.ofType);\n      return rewiredType != null ? new GraphQLList(rewiredType) : null;\n    } else if (isNonNullType(type2)) {\n      const rewiredType = rewireType(type2.ofType);\n      return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n    } else if (isNamedType(type2)) {\n      let rewiredType = referenceTypeMap[type2.name];\n      if (rewiredType === void 0) {\n        rewiredType = isNamedStub(type2) ? getBuiltInForStub(type2) : rewireNamedType(type2);\n        newTypeMap[rewiredType.name] = referenceTypeMap[type2.name] = rewiredType;\n      }\n      return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n    }\n    return null;\n  }\n}\nfunction transformInputValue(type2, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {\n  if (value == null) {\n    return value;\n  }\n  const nullableType = getNullableType(type2);\n  if (isLeafType(nullableType)) {\n    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;\n  } else if (isListType(nullableType)) {\n    return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n  } else if (isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    const newValue = {};\n    for (const key in value) {\n      const field = fields[key];\n      if (field != null) {\n        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n      }\n    }\n    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;\n  }\n}\nfunction serializeInputValue(type2, value) {\n  return transformInputValue(type2, value, (t2, v2) => {\n    try {\n      return t2.serialize(v2);\n    } catch (_a2) {\n      return v2;\n    }\n  });\n}\nfunction parseInputValue(type2, value) {\n  return transformInputValue(type2, value, (t2, v2) => {\n    try {\n      return t2.parseValue(v2);\n    } catch (_a2) {\n      return v2;\n    }\n  });\n}\nfunction mapSchema(schema, schemaMapper = {}) {\n  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type2) => isLeafType(type2)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type2) => !isLeafType(type2)), schema, schemaMapper), schema, schemaMapper);\n  const originalDirectives = schema.getDirectives();\n  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n  return new GraphQLSchema(__spreadProps(__spreadValues({}, schema.toConfig()), {\n    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n    types: Object.values(typeMap),\n    directives\n  }));\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith(\"__\")) {\n      const originalType = originalTypeMap[typeName];\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const maybeNewType = typeMapper(originalType, schema);\n      if (maybeNewType === void 0) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      newTypeMap[typeName] = maybeNewType;\n    }\n  }\n  return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  const enumValueMapper = getEnumValueMapper(schemaMapper);\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n  return mapTypes(originalTypeMap, schema, {\n    [MapperKind.ENUM_TYPE]: (type2) => {\n      const config2 = type2.toConfig();\n      const originalEnumValueConfigMap = config2.values;\n      const newEnumValueConfigMap = {};\n      for (const externalValue in originalEnumValueConfigMap) {\n        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type2.name, schema, externalValue);\n        if (mappedEnumValue === void 0) {\n          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n        } else if (Array.isArray(mappedEnumValue)) {\n          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;\n        } else if (mappedEnumValue !== null) {\n          newEnumValueConfigMap[externalValue] = mappedEnumValue;\n        }\n      }\n      return correctASTNodes(new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {\n        values: newEnumValueConfigMap\n      })));\n    }\n  }, (type2) => isEnumType(type2));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  const newTypeMap = mapArguments(originalTypeMap, schema, {\n    [MapperKind.ARGUMENT]: (argumentConfig) => {\n      if (argumentConfig.defaultValue === void 0) {\n        return argumentConfig;\n      }\n      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n      if (maybeNewType != null) {\n        return __spreadProps(__spreadValues({}, argumentConfig), {\n          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n        });\n      }\n    }\n  });\n  return mapFields(newTypeMap, schema, {\n    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {\n      if (inputFieldConfig.defaultValue === void 0) {\n        return inputFieldConfig;\n      }\n      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n      if (maybeNewType != null) {\n        return __spreadProps(__spreadValues({}, inputFieldConfig), {\n          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n        });\n      }\n    }\n  });\n}\nfunction getNewType(newTypeMap, type2) {\n  if (isListType(type2)) {\n    const newType = getNewType(newTypeMap, type2.ofType);\n    return newType != null ? new GraphQLList(newType) : null;\n  } else if (isNonNullType(type2)) {\n    const newType = getNewType(newTypeMap, type2.ofType);\n    return newType != null ? new GraphQLNonNull(newType) : null;\n  } else if (isNamedType(type2)) {\n    const newType = newTypeMap[type2.name];\n    return newType != null ? newType : null;\n  }\n  return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith(\"__\")) {\n      const originalType = originalTypeMap[typeName];\n      if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const config2 = originalType.toConfig();\n      const originalFieldConfigMap = config2.fields;\n      const newFieldConfigMap = {};\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n        if (mappedField === void 0) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          const [newFieldName, newFieldConfig] = mappedField;\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = __spreadProps(__spreadValues({}, newFieldConfig.astNode), {\n              name: __spreadProps(__spreadValues({}, newFieldConfig.astNode.name), {\n                value: newFieldName\n              })\n            });\n          }\n          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      }\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {\n          fields: newFieldConfigMap\n        })));\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {\n          fields: newFieldConfigMap\n        })));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {\n          fields: newFieldConfigMap\n        })));\n      }\n    }\n  }\n  return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith(\"__\")) {\n      const originalType = originalTypeMap[typeName];\n      if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const argumentMapper = getArgumentMapper(schemaMapper);\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const config2 = originalType.toConfig();\n      const originalFieldConfigMap = config2.fields;\n      const newFieldConfigMap = {};\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const originalArgumentConfigMap = originalFieldConfig.args;\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n        const argumentNames = Object.keys(originalArgumentConfigMap);\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n        const newArgumentConfigMap = {};\n        for (const argumentName of argumentNames) {\n          const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n          if (mappedArgument === void 0) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            const [newArgumentName, newArgumentConfig] = mappedArgument;\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        }\n        newFieldConfigMap[fieldName] = __spreadProps(__spreadValues({}, originalFieldConfig), {\n          args: newArgumentConfigMap\n        });\n      }\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {\n          fields: newFieldConfigMap\n        }));\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  }\n  return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  const directiveMapper = getDirectiveMapper(schemaMapper);\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n  const newDirectives = [];\n  for (const directive of originalDirectives) {\n    const mappedDirective = directiveMapper(directive, schema);\n    if (mappedDirective === void 0) {\n      newDirectives.push(directive);\n    } else if (mappedDirective !== null) {\n      newDirectives.push(mappedDirective);\n    }\n  }\n  return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n  var _a2, _b, _c;\n  const type2 = schema.getType(typeName);\n  const specifiers = [MapperKind.TYPE];\n  if (isObjectType(type2)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n    if (typeName === ((_a2 = schema.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputObjectType(type2)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type2)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n  } else if (isUnionType(type2)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n  } else if (isEnumType(type2)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type2)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n  return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  const specifiers = getTypeSpecifiers(schema, typeName);\n  let typeMapper;\n  const stack = [...specifiers];\n  while (!typeMapper && stack.length > 0) {\n    const next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n  return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n  var _a2, _b, _c;\n  const type2 = schema.getType(typeName);\n  const specifiers = [MapperKind.FIELD];\n  if (isObjectType(type2)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n    if (typeName === ((_a2 = schema.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if (isInterfaceType(type2)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n  } else if (isInputObjectType(type2)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n  }\n  return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  const specifiers = getFieldSpecifiers(schema, typeName);\n  let fieldMapper;\n  const stack = [...specifiers];\n  while (!fieldMapper && stack.length > 0) {\n    const next = stack.pop();\n    fieldMapper = schemaMapper[next];\n  }\n  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type2) {\n  if (isObjectType(type2)) {\n    const config2 = type2.toConfig();\n    if (config2.astNode != null) {\n      const fields = [];\n      for (const fieldName in config2.fields) {\n        const fieldConfig = config2.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        fields\n      });\n    }\n    if (config2.extensionASTNodes != null) {\n      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {\n        kind: Kind.OBJECT_TYPE_EXTENSION,\n        fields: void 0\n      }));\n    }\n    return new GraphQLObjectType(config2);\n  } else if (isInterfaceType(type2)) {\n    const config2 = type2.toConfig();\n    if (config2.astNode != null) {\n      const fields = [];\n      for (const fieldName in config2.fields) {\n        const fieldConfig = config2.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        fields\n      });\n    }\n    if (config2.extensionASTNodes != null) {\n      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {\n        kind: Kind.INTERFACE_TYPE_EXTENSION,\n        fields: void 0\n      }));\n    }\n    return new GraphQLInterfaceType(config2);\n  } else if (isInputObjectType(type2)) {\n    const config2 = type2.toConfig();\n    if (config2.astNode != null) {\n      const fields = [];\n      for (const fieldName in config2.fields) {\n        const fieldConfig = config2.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields\n      });\n    }\n    if (config2.extensionASTNodes != null) {\n      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {\n        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        fields: void 0\n      }));\n    }\n    return new GraphQLInputObjectType(config2);\n  } else if (isEnumType(type2)) {\n    const config2 = type2.toConfig();\n    if (config2.astNode != null) {\n      const values = [];\n      for (const enumKey in config2.values) {\n        const enumValueConfig = config2.values[enumKey];\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      }\n      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {\n        values\n      });\n    }\n    if (config2.extensionASTNodes != null) {\n      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {\n        values: void 0\n      }));\n    }\n    return new GraphQLEnumType(config2);\n  } else {\n    return type2;\n  }\n}\nfunction getResponseKeyFromInfo(info2) {\n  return info2.fieldNodes[0].alias != null ? info2.fieldNodes[0].alias.value : info2.fieldName;\n}\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  let $return;\n  let abruptClose;\n  if (typeof iterator.return === \"function\") {\n    $return = iterator.return;\n    abruptClose = (error2) => {\n      const rethrow = () => Promise.reject(error2);\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n  function mapResult(result2) {\n    return result2.done ? result2 : asyncMapValue(result2.value, callback).then(iteratorResult, abruptClose);\n  }\n  let mapReject;\n  if (rejectCallback) {\n    const reject2 = rejectCallback;\n    mapReject = (error2) => asyncMapValue(error2, reject2).then(iteratorResult, abruptClose);\n  }\n  return {\n    next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });\n    },\n    throw(error2) {\n      if (typeof iterator.throw === \"function\") {\n        return iterator.throw(error2).then(mapResult, mapReject);\n      }\n      return Promise.reject(error2).catch(abruptClose);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\nfunction asyncMapValue(value, callback) {\n  return new Promise((resolve) => resolve(callback(value)));\n}\nfunction iteratorResult(value) {\n  return { value, done: false };\n}\nfunction updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type2, value) {\n  argumentNodes[argName] = {\n    kind: Kind.ARGUMENT,\n    name: {\n      kind: Kind.NAME,\n      value: argName\n    },\n    value: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    }\n  };\n  variableDefinitionsMap[varName] = {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    },\n    type: astFromType(type2)\n  };\n  if (value !== void 0) {\n    variableValues[varName] = value;\n    return;\n  }\n  if (varName in variableValues) {\n    delete variableValues[varName];\n  }\n}\nfunction createVariableNameGenerator(variableDefinitionMap) {\n  let varCounter = 0;\n  return (argName) => {\n    let varName;\n    do {\n      varName = `_v${(varCounter++).toString()}_${argName}`;\n    } while (varName in variableDefinitionMap);\n    return varName;\n  };\n}\nfunction implementsAbstractType(schema, typeA, typeB) {\n  if (typeB == null || typeA == null) {\n    return false;\n  } else if (typeA === typeB) {\n    return true;\n  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n    return doTypesOverlap(schema, typeA, typeB);\n  }\n  return false;\n}\nfunction relocatedError(originalError, path) {\n  return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? void 0 : path === void 0 ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\nfunction observableToAsyncIterable(observable) {\n  const pullQueue = [];\n  const pushQueue = [];\n  let listening = true;\n  const pushValue = (value) => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value, done: false });\n    } else {\n      pushQueue.push({ value, done: false });\n    }\n  };\n  const pushError = (error2) => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value: { errors: [error2] }, done: false });\n    } else {\n      pushQueue.push({ value: { errors: [error2] }, done: false });\n    }\n  };\n  const pushDone = () => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ done: true });\n    } else {\n      pushQueue.push({ done: true });\n    }\n  };\n  const pullValue = () => new Promise((resolve) => {\n    if (pushQueue.length !== 0) {\n      const element = pushQueue.shift();\n      resolve(element);\n    } else {\n      pullQueue.push(resolve);\n    }\n  });\n  const subscription = observable.subscribe({\n    next(value) {\n      pushValue(value);\n    },\n    error(err) {\n      pushError(err);\n    },\n    complete() {\n      pushDone();\n    }\n  });\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n      for (const resolve of pullQueue) {\n        resolve({ value: void 0, done: true });\n      }\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n  return {\n    next() {\n      return listening ? pullValue() : this.return();\n    },\n    return() {\n      emptyQueue();\n      return Promise.resolve({ value: void 0, done: true });\n    },\n    throw(error2) {\n      emptyQueue();\n      return Promise.reject(error2);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\nfunction getOperationASTFromDocument(documentNode, operationName) {\n  const doc = getOperationAST(documentNode, operationName);\n  if (!doc) {\n    throw new Error(`Cannot infer operation ${operationName || \"\"}`);\n  }\n  return doc;\n}\nconst getOperationASTFromRequest = memoize1$1(function getOperationASTFromRequest2(request) {\n  return getOperationASTFromDocument(request.document, request.operationName);\n});\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n        const name2 = getFieldEntryKey(selection);\n        const fieldList = fields.get(name2);\n        if (fieldList !== void 0) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name2, [selection]);\n        }\n        break;\n      }\n      case Kind.INLINE_FRAGMENT: {\n        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n          continue;\n        }\n        collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n        break;\n      }\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n          continue;\n        }\n        collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n        break;\n      }\n    }\n  }\n  return fields;\n}\nfunction shouldIncludeNode(variableValues, node) {\n  const skip2 = getDirectiveValues$1(GraphQLSkipDirective, node, variableValues);\n  if ((skip2 === null || skip2 === void 0 ? void 0 : skip2[\"if\"]) === true) {\n    return false;\n  }\n  const include = getDirectiveValues$1(GraphQLIncludeDirective, node, variableValues);\n  if ((include === null || include === void 0 ? void 0 : include[\"if\"]) === false) {\n    return false;\n  }\n  return true;\n}\nfunction doesFragmentConditionMatch(schema, fragment, type2) {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n  if (conditionalType === type2) {\n    return true;\n  }\n  if (isAbstractType(conditionalType)) {\n    const possibleTypes = schema.getPossibleTypes(conditionalType);\n    return possibleTypes.includes(type2);\n  }\n  return false;\n}\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\nfunction isAsyncIterable$1(value) {\n  return typeof value === \"object\" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === \"function\";\n}\nasync function defaultAsyncIteratorReturn(value) {\n  return { value, done: true };\n}\nconst proxyMethodFactory = memoize2$1(function proxyMethodFactory2(target2, targetMethod) {\n  return function proxyMethod(...args) {\n    return Reflect.apply(targetMethod, target2, args);\n  };\n});\nfunction getAsyncIteratorWithCancel(asyncIterator, onCancel) {\n  return new Proxy(asyncIterator, {\n    has(asyncIterator2, prop2) {\n      if (prop2 === \"return\") {\n        return true;\n      }\n      return Reflect.has(asyncIterator2, prop2);\n    },\n    get(asyncIterator2, prop2, receiver) {\n      const existingPropValue = Reflect.get(asyncIterator2, prop2, receiver);\n      if (prop2 === \"return\") {\n        const existingReturn = existingPropValue || defaultAsyncIteratorReturn;\n        return async function returnWithCancel(value) {\n          const returnValue = await onCancel(value);\n          return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);\n        };\n      } else if (typeof existingPropValue === \"function\") {\n        return proxyMethodFactory(asyncIterator2, existingPropValue);\n      }\n      return existingPropValue;\n    }\n  });\n}\nfunction getAsyncIterableWithCancel(asyncIterable, onCancel) {\n  return new Proxy(asyncIterable, {\n    get(asyncIterable2, prop2, receiver) {\n      const existingPropValue = Reflect.get(asyncIterable2, prop2, receiver);\n      if (Symbol.asyncIterator === prop2) {\n        return function asyncIteratorFactory() {\n          const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);\n          return getAsyncIteratorWithCancel(asyncIterator, onCancel);\n        };\n      } else if (typeof existingPropValue === \"function\") {\n        return proxyMethodFactory(asyncIterable2, existingPropValue);\n      }\n      return existingPropValue;\n    }\n  });\n}\nconst GraphQLDeferDirective = new GraphQLDirective({\n  name: \"defer\",\n  description: \"Directs the executor to defer this fragment when the `if` argument is true or undefined.\",\n  locations: [\n    DirectiveLocation.FRAGMENT_SPREAD,\n    DirectiveLocation.INLINE_FRAGMENT\n  ],\n  args: {\n    if: {\n      type: GraphQLBoolean,\n      description: \"Deferred when true or undefined.\"\n    },\n    label: {\n      type: GraphQLString,\n      description: \"Unique name\"\n    }\n  }\n});\nconst GraphQLStreamDirective = new GraphQLDirective({\n  name: \"stream\",\n  description: \"Directs the executor to stream plural fields when the `if` argument is true or undefined.\",\n  locations: [DirectiveLocation.FIELD],\n  args: {\n    if: {\n      type: GraphQLBoolean,\n      description: \"Stream when true or undefined.\"\n    },\n    label: {\n      type: GraphQLString,\n      description: \"Unique name\"\n    },\n    initialCount: {\n      defaultValue: 0,\n      type: GraphQLInt,\n      description: \"Number of items to return immediately\"\n    },\n    maxChunkSize: {\n      defaultValue: 1,\n      type: GraphQLInt,\n      description: \"Maximum number of items to return within each payload\"\n    },\n    maxInterval: {\n      type: GraphQLInt,\n      description: \"Maximum time in ms to wait to collect items for each payload, will wait indefinitely if undefined\"\n    },\n    inParallel: {\n      defaultValue: false,\n      type: GraphQLBoolean,\n      description: \"Stream items non-sequentially on completion if true\"\n    }\n  }\n});\nfunction addPath(prev, key, typename) {\n  return {\n    prev,\n    key,\n    typename\n  };\n}\nfunction pathToArray(path) {\n  const flattened = [];\n  let curr = path;\n  while (curr) {\n    flattened.push(curr.key);\n    curr = curr.prev;\n  }\n  return flattened.reverse();\n}\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\nfunction inspect(value) {\n  return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case \"string\":\n      return JSON.stringify(value);\n    case \"function\":\n      return value.name ? `[function ${value.name}]` : \"[function]\";\n    case \"object\":\n      return formatObjectValue(value, seenValues);\n    default:\n      return String(value);\n  }\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (value === null) {\n    return \"null\";\n  }\n  if (previouslySeenValues.includes(value)) {\n    return \"[Circular]\";\n  }\n  const seenValues = [...previouslySeenValues, value];\n  if (isJSONable(value)) {\n    const jsonValue = value.toJSON();\n    if (jsonValue !== value) {\n      return typeof jsonValue === \"string\" ? jsonValue : formatValue(jsonValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n  return formatObject(value, seenValues);\n}\nfunction isJSONable(value) {\n  return typeof value.toJSON === \"function\";\n}\nfunction formatObject(object, seenValues) {\n  const entries = Object.entries(object);\n  if (entries.length === 0) {\n    return \"{}\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return \"[\" + getObjectTag(object) + \"]\";\n  }\n  const properties = entries.map(([key, value]) => key + \": \" + formatValue(value, seenValues));\n  return \"{ \" + properties.join(\", \") + \" }\";\n}\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return \"[]\";\n  }\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return \"[Array]\";\n  }\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n  if (remaining === 1) {\n    items.push(\"... 1 more item\");\n  } else if (remaining > 1) {\n    items.push(`... ${remaining} more items`);\n  }\n  return \"[\" + items.join(\", \") + \"]\";\n}\nfunction getObjectTag(object) {\n  const tag = Object.prototype.toString.call(object).replace(/^\\[object /, \"\").replace(/]$/, \"\");\n  if (tag === \"Object\" && typeof object.constructor === \"function\") {\n    const name2 = object.constructor.name;\n    if (typeof name2 === \"string\" && name2 !== \"\") {\n      return name2;\n    }\n  }\n  return tag;\n}\nfunction invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(message != null ? message : \"Unexpected invariant triggered.\");\n  }\n}\nfunction memoize1(fn) {\n  let cache0;\n  return function memoized(a1) {\n    if (cache0 === void 0) {\n      cache0 = /* @__PURE__ */ new WeakMap();\n    }\n    let fnResult = cache0.get(a1);\n    if (fnResult === void 0) {\n      fnResult = fn(a1);\n      cache0.set(a1, fnResult);\n    }\n    return fnResult;\n  };\n}\nfunction is(x2, type2) {\n  if (Object.prototype.toString.call(x2) === `[object ${type2}]`) {\n    return true;\n  }\n  const prototype = Object.getPrototypeOf(x2);\n  if (prototype == null) {\n    return false;\n  }\n  return is(prototype, type2);\n}\nfunction _isScalarType(type2) {\n  return is(type2, \"GraphQLScalarType\");\n}\nfunction _isObjectType(type2) {\n  return is(type2, \"GraphQLObjectType\");\n}\nfunction _isInterfaceType(type2) {\n  return is(type2, \"GraphQLInterfaceType\");\n}\nfunction _isUnionType(type2) {\n  return is(type2, \"GraphQLUnionType\");\n}\nfunction _isEnumType(type2) {\n  return is(type2, \"GraphQLEnumType\");\n}\nfunction _isInputObjectType(type2) {\n  return is(type2, \"GraphQLInputObjectType\");\n}\nfunction _isListType(type2) {\n  return Object.prototype.toString.call(type2) === \"[object GraphQLList]\";\n}\nfunction _isNonNullType(type2) {\n  return Object.prototype.toString.call(type2) === \"[object GraphQLNonNull]\";\n}\nclass TypeTree {\n  constructor() {\n    this._rootNode = {\n      [Kind.NAMED_TYPE]: /* @__PURE__ */ new Map()\n    };\n    this.typeStrings = /* @__PURE__ */ new Set();\n  }\n  add(type2) {\n    this._add(type2, this._rootNode);\n    this.typeStrings.add(type2.toString());\n  }\n  get(typeNode) {\n    return this._get(typeNode, this._rootNode);\n  }\n  has(typeString) {\n    return this.typeStrings.has(typeString);\n  }\n  _get(typeNode, node) {\n    switch (typeNode.kind) {\n      case Kind.LIST_TYPE: {\n        const listNode = node[Kind.LIST_TYPE];\n        if (!listNode) {\n          return;\n        }\n        return this._get(typeNode.type, listNode);\n      }\n      case Kind.NON_NULL_TYPE: {\n        const nonNullNode = node[Kind.NON_NULL_TYPE];\n        if (!nonNullNode) {\n          return;\n        }\n        return this._get(typeNode.type, nonNullNode);\n      }\n      case Kind.NAMED_TYPE:\n        return node[Kind.NAMED_TYPE].get(typeNode.name.value);\n    }\n  }\n  _add(originalType, node, type2 = originalType) {\n    if (_isListType(type2)) {\n      let listTypeNode = node[Kind.LIST_TYPE];\n      if (!listTypeNode) {\n        listTypeNode = node[Kind.LIST_TYPE] = {\n          [Kind.NAMED_TYPE]: /* @__PURE__ */ new Map()\n        };\n      }\n      this._add(originalType, listTypeNode, type2.ofType);\n    } else if (_isNonNullType(type2)) {\n      let nonNullTypeNode = node[Kind.NON_NULL_TYPE];\n      if (!nonNullTypeNode) {\n        nonNullTypeNode = node[Kind.NON_NULL_TYPE] = {\n          [Kind.NAMED_TYPE]: /* @__PURE__ */ new Map()\n        };\n      }\n      this._add(originalType, nonNullTypeNode, type2.ofType);\n    } else {\n      node[Kind.NAMED_TYPE].set(type2.name, originalType);\n    }\n  }\n}\nfunction getInputTypeInfo(type2, wrapper) {\n  if (!_isNonNullType(type2) && !_isListType(type2)) {\n    return {\n      nonNullListWrappers: [],\n      nonNull: _isNonNullType(wrapper),\n      namedType: type2\n    };\n  }\n  const inputTypeInfo = getInputTypeInfo(type2.ofType, type2);\n  if (_isNonNullType(type2)) {\n    return inputTypeInfo;\n  }\n  inputTypeInfo.nonNullListWrappers.push(_isNonNullType(wrapper));\n  return inputTypeInfo;\n}\nfunction getPossibleSequences(nonNullListWrappers) {\n  if (!nonNullListWrappers.length) {\n    return [[]];\n  }\n  const nonNull = nonNullListWrappers.pop();\n  if (nonNull) {\n    return getPossibleSequences(nonNullListWrappers).map((sequence) => [\n      true,\n      ...sequence\n    ]);\n  }\n  return [\n    ...getPossibleSequences(nonNullListWrappers).map((sequence) => [\n      true,\n      ...sequence\n    ]),\n    ...getPossibleSequences(nonNullListWrappers).map((sequence) => [\n      false,\n      ...sequence\n    ])\n  ];\n}\nfunction inputTypesFromSequences(sequences, inputType) {\n  return sequences.map((sequence) => sequence.reduce((acc, nonNull) => {\n    let wrapped = new GraphQLList(acc);\n    if (nonNull) {\n      wrapped = new GraphQLNonNull(wrapped);\n    }\n    return wrapped;\n  }, inputType));\n}\nfunction getPossibleInputTypes(type2) {\n  const { nonNullListWrappers, nonNull, namedType } = getInputTypeInfo(type2);\n  const sequences = getPossibleSequences(nonNullListWrappers);\n  const wrapped = new GraphQLNonNull(namedType);\n  if (nonNull) {\n    return inputTypesFromSequences(sequences, wrapped);\n  }\n  return [\n    ...inputTypesFromSequences(sequences, namedType),\n    ...inputTypesFromSequences(sequences, wrapped)\n  ];\n}\nfunction _toExecutorSchema(schema) {\n  const listTypes = /* @__PURE__ */ new Set();\n  const nonNullTypes = /* @__PURE__ */ new Set();\n  const namedTypes = /* @__PURE__ */ new Set();\n  const inputTypes = /* @__PURE__ */ new Set();\n  const leafTypes = /* @__PURE__ */ new Set();\n  const abstractTypes = /* @__PURE__ */ new Set();\n  const objectTypes = /* @__PURE__ */ new Set();\n  const inputObjectTypes = /* @__PURE__ */ new Set();\n  const typeTree = new TypeTree();\n  const subTypesMap = /* @__PURE__ */ new Map();\n  const possibleTypesMap = /* @__PURE__ */ new Map();\n  function addOutputType(type2) {\n    typeTree.add(type2);\n  }\n  function addInputType(type2) {\n    inputTypes.add(type2);\n    typeTree.add(type2);\n  }\n  function processType(type2) {\n    if (_isListType(type2) && !listTypes.has(type2)) {\n      listTypes.add(type2);\n      processType(type2.ofType);\n    } else if (_isNonNullType(type2) && !nonNullTypes.has(type2)) {\n      nonNullTypes.add(type2);\n      processType(type2.ofType);\n    } else if (_isScalarType(type2) && !namedTypes.has(type2)) {\n      namedTypes.add(type2);\n      leafTypes.add(type2);\n    } else if (_isObjectType(type2) && !namedTypes.has(type2)) {\n      namedTypes.add(type2);\n      objectTypes.add(type2);\n      addOutputType(type2);\n      for (const field of Object.values(type2.getFields())) {\n        processType(field.type);\n        for (const arg of field.args) {\n          addInputType(arg.type);\n          processType(arg.type);\n        }\n      }\n      for (const iface of Object.values(type2.getInterfaces())) {\n        processType(iface);\n        let subTypes = subTypesMap.get(iface);\n        if (!subTypes) {\n          subTypes = /* @__PURE__ */ new Set();\n          subTypesMap.set(iface, subTypes);\n        }\n        subTypes.add(type2);\n        let possibleTypes = possibleTypesMap.get(iface);\n        if (!possibleTypes) {\n          possibleTypes = [];\n          possibleTypesMap.set(iface, possibleTypes);\n        }\n        possibleTypes.push(type2);\n      }\n    } else if (_isInterfaceType(type2) && !namedTypes.has(type2)) {\n      namedTypes.add(type2);\n      abstractTypes.add(type2);\n      addOutputType(type2);\n      for (const field of Object.values(type2.getFields())) {\n        processType(field.type);\n        for (const arg of field.args) {\n          addInputType(arg.type);\n          processType(arg.type);\n        }\n      }\n      if (\"getInterfaces\" in type2) {\n        for (const iface of Object.values(type2.getInterfaces())) {\n          processType(iface);\n          let subTypes = subTypesMap.get(iface);\n          if (!subTypes) {\n            subTypes = /* @__PURE__ */ new Set();\n            subTypesMap.set(iface, subTypes);\n          }\n          subTypes.add(type2);\n        }\n      }\n    } else if (_isUnionType(type2) && !namedTypes.has(type2)) {\n      namedTypes.add(type2);\n      abstractTypes.add(type2);\n      addOutputType(type2);\n      let subTypes = subTypesMap.get(type2);\n      if (!subTypes) {\n        subTypes = /* @__PURE__ */ new Set();\n        subTypesMap.set(type2, subTypes);\n      }\n      let possibleTypes = possibleTypesMap.get(type2);\n      if (!possibleTypes) {\n        possibleTypes = [];\n        possibleTypesMap.set(type2, possibleTypes);\n      }\n      for (const possibleType of type2.getTypes()) {\n        processType(possibleType);\n        subTypes.add(possibleType);\n        possibleTypes.push(possibleType);\n      }\n    } else if (_isEnumType(type2) && !namedTypes.has(type2)) {\n      namedTypes.add(type2);\n      leafTypes.add(type2);\n    } else if (_isInputObjectType(type2) && !namedTypes.has(type2)) {\n      namedTypes.add(type2);\n      inputObjectTypes.add(type2);\n      for (const field of Object.values(type2.getFields())) {\n        addInputType(field.type);\n        processType(field.type);\n      }\n    }\n  }\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n  for (const type2 of Object.values(schema.getTypeMap())) {\n    processType(type2);\n  }\n  for (const fieldDef of [\n    SchemaMetaFieldDef,\n    TypeMetaFieldDef,\n    TypeNameMetaFieldDef\n  ]) {\n    processType(fieldDef.type);\n    for (const arg of fieldDef.args) {\n      addInputType(arg.type);\n      processType(arg.type);\n    }\n  }\n  for (const directive of [...schema.getDirectives()]) {\n    for (const arg of directive.args) {\n      addInputType(arg.type);\n      processType(arg.type);\n    }\n  }\n  for (const inputType of inputTypes.values()) {\n    const possibleInputTypes = getPossibleInputTypes(inputType);\n    for (const possibleInputType of possibleInputTypes) {\n      const typeString = possibleInputType.toString();\n      if (!typeTree.has(typeString)) {\n        addInputType(possibleInputType);\n        processType(possibleInputType);\n      }\n    }\n  }\n  function isListType2(type2) {\n    return listTypes.has(type2);\n  }\n  function isNonNullType2(type2) {\n    return nonNullTypes.has(type2);\n  }\n  function isNamedType2(type2) {\n    return namedTypes.has(type2);\n  }\n  function isInputType2(type2) {\n    return inputTypes.has(type2);\n  }\n  function isLeafType2(type2) {\n    return leafTypes.has(type2);\n  }\n  function isAbstractType2(type2) {\n    return abstractTypes.has(type2);\n  }\n  function isObjectType2(type2) {\n    return objectTypes.has(type2);\n  }\n  function isInputObjectType2(type2) {\n    return inputObjectTypes.has(type2);\n  }\n  function getNamedType2(typeName) {\n    var _schema$getType;\n    return (_schema$getType = schema.getType(typeName)) !== null && _schema$getType !== void 0 ? _schema$getType : void 0;\n  }\n  function getType(typeNode) {\n    return typeTree.get(typeNode);\n  }\n  function getRootType(operation) {\n    if (operation === \"query\") {\n      return queryType !== null && queryType !== void 0 ? queryType : void 0;\n    } else if (operation === \"mutation\") {\n      return mutationType !== null && mutationType !== void 0 ? mutationType : void 0;\n    } else if (operation === \"subscription\") {\n      return subscriptionType !== null && subscriptionType !== void 0 ? subscriptionType : void 0;\n    }\n    invariant(false, \"Unexpected operation type: \" + inspect(operation));\n  }\n  function getPossibleTypes(abstractType) {\n    var _possibleTypesMap$get;\n    return (_possibleTypesMap$get = possibleTypesMap.get(abstractType)) !== null && _possibleTypesMap$get !== void 0 ? _possibleTypesMap$get : [];\n  }\n  function isSubType(abstractType, maybeSubType) {\n    var _subTypesMap$get$has, _subTypesMap$get;\n    return (_subTypesMap$get$has = (_subTypesMap$get = subTypesMap.get(abstractType)) === null || _subTypesMap$get === void 0 ? void 0 : _subTypesMap$get.has(maybeSubType)) !== null && _subTypesMap$get$has !== void 0 ? _subTypesMap$get$has : false;\n  }\n  return {\n    isListType: isListType2,\n    isNonNullType: isNonNullType2,\n    isNamedType: isNamedType2,\n    isInputType: isInputType2,\n    isLeafType: isLeafType2,\n    isAbstractType: isAbstractType2,\n    isObjectType: isObjectType2,\n    isInputObjectType: isInputObjectType2,\n    getNamedType: getNamedType2,\n    getType,\n    getRootType,\n    getPossibleTypes,\n    isSubType\n  };\n}\nconst toExecutorSchema = memoize1(_toExecutorSchema);\nfunction memoize1and1(fn) {\n  let cache0;\n  return function memoized(a1, a2) {\n    if (cache0 === void 0) {\n      cache0 = /* @__PURE__ */ new WeakMap();\n    }\n    let cache1 = cache0.get(a1);\n    if (cache1 === void 0) {\n      cache1 = /* @__PURE__ */ new Map();\n      cache0.set(a1, cache1);\n    }\n    let fnResult = cache1.get(a2);\n    if (fnResult === void 0) {\n      fnResult = fn(a1, a2);\n      cache1.set(a2, fnResult);\n    }\n    return fnResult;\n  };\n}\nfunction memoize2(fn) {\n  let cache0;\n  return function memoized(a1, a2) {\n    if (cache0 === void 0) {\n      cache0 = /* @__PURE__ */ new WeakMap();\n    }\n    let cache1 = cache0.get(a1);\n    if (cache1 === void 0) {\n      cache1 = /* @__PURE__ */ new WeakMap();\n      cache0.set(a1, cache1);\n    }\n    let fnResult = cache1.get(a2);\n    if (fnResult === void 0) {\n      fnResult = fn(a1, a2);\n      cache1.set(a2, fnResult);\n    }\n    return fnResult;\n  };\n}\nfunction devAssert(condition, message) {\n  const booleanCondition = Boolean(condition);\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\nfunction isPromise(value) {\n  return typeof (value === null || value === void 0 ? void 0 : value.then) === \"function\";\n}\nfunction isObjectLike(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction promiseReduce(values, callbackFn, initialValue) {\n  let accumulator = initialValue;\n  for (const value of values) {\n    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);\n  }\n  return accumulator;\n}\nfunction isAsyncIterable(maybeAsyncIterable) {\n  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === \"function\";\n}\nfunction isIterableObject(maybeIterable) {\n  return typeof maybeIterable === \"object\" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === \"function\";\n}\nfunction resolveAfterAll(result2, promises) {\n  return new Promise((resolve, reject2) => {\n    let rejected = false;\n    let reason;\n    let numPromises = promises.length;\n    const onFulfilled = () => {\n      numPromises--;\n      if (!numPromises) {\n        if (rejected) {\n          reject2(reason);\n        }\n        resolve(result2);\n      }\n    };\n    const onRejected = (_reason) => {\n      if (!rejected) {\n        rejected = true;\n        reason = _reason;\n      }\n      numPromises--;\n      if (!numPromises) {\n        reject2(reason);\n      }\n    };\n    for (const promise of promises) {\n      promise.then(onFulfilled, onRejected);\n    }\n  });\n}\nclass RepeaterOverflowError extends Error {\n  constructor(message) {\n    super(message);\n    Object.defineProperty(this, \"name\", {\n      value: \"RepeaterOverflowError\",\n      enumerable: false\n    });\n    Object.setPrototypeOf(this, this.constructor.prototype);\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\nfunction swallow(value) {\n  if (value != null && typeof value.then === \"function\") {\n    value.then(NOOP, NOOP);\n  }\n}\nconst Initial = 0;\nconst Started = 1;\nconst Stopped = 2;\nconst Done = 3;\nconst Rejected = 4;\nconst MAX_QUEUE_LENGTH = 1024;\nconst NOOP = () => void 0;\nfunction consumeExecution(r2) {\n  const err = r2.err;\n  const execution = Promise.resolve(r2.execution).then((value) => {\n    if (err != null) {\n      throw err;\n    }\n    return value;\n  });\n  r2.err = void 0;\n  r2.execution = execution.then(() => void 0, () => void 0);\n  return r2.pending === void 0 ? execution : r2.pending.then(() => execution);\n}\nfunction createIteration(r2, value) {\n  const done = r2.state >= Done;\n  return Promise.resolve(value).then((resolvedValue) => {\n    if (!done && r2.state >= Rejected) {\n      return consumeExecution(r2).then((finalValue) => ({\n        value: finalValue,\n        done: true\n      }));\n    }\n    return {\n      value: resolvedValue,\n      done\n    };\n  });\n}\nfunction stop(r2, err) {\n  if (r2.state >= Stopped) {\n    return;\n  }\n  r2.state = Stopped;\n  r2.onnext();\n  r2.onstop();\n  if (r2.err == null) {\n    r2.err = err;\n  }\n  if (r2.pushes.length === 0 && (typeof r2.buffer === \"undefined\" || r2.buffer.empty)) {\n    finish(r2);\n  } else {\n    for (const p2 of r2.pushes) {\n      p2.resolve();\n    }\n  }\n}\nfunction finish(r2) {\n  if (r2.state >= Done) {\n    return;\n  }\n  if (r2.state < Stopped) {\n    stop(r2);\n  }\n  r2.state = Done;\n  r2.buffer = void 0;\n  for (const next of r2.nexts) {\n    const execution = r2.pending === void 0 ? consumeExecution(r2) : r2.pending.then(() => consumeExecution(r2));\n    next.resolve(createIteration(r2, execution));\n  }\n  r2.pushes = [];\n  r2.nexts = [];\n}\nfunction reject(r2) {\n  if (r2.state >= Rejected) {\n    return;\n  }\n  if (r2.state < Done) {\n    finish(r2);\n  }\n  r2.state = Rejected;\n}\nfunction push(r2, value) {\n  swallow(value);\n  if (r2.pushes.length >= MAX_QUEUE_LENGTH) {\n    throw new RepeaterOverflowError(`No more than ${MAX_QUEUE_LENGTH} pending calls to push are allowed on a single repeater.`);\n  } else if (r2.state >= Stopped) {\n    return Promise.resolve(void 0);\n  }\n  let valueP = r2.pending === void 0 ? Promise.resolve(value) : r2.pending.then(() => value);\n  valueP = valueP.catch((err) => {\n    if (r2.state < Stopped) {\n      r2.err = err;\n    }\n    reject(r2);\n    return void 0;\n  });\n  let nextP;\n  if (r2.nexts.length) {\n    const next2 = r2.nexts.shift();\n    next2.resolve(createIteration(r2, valueP));\n    if (r2.nexts.length) {\n      nextP = Promise.resolve(r2.nexts[0].value);\n    } else {\n      nextP = new Promise((resolve) => r2.onnext = resolve);\n    }\n  } else if (typeof r2.buffer !== \"undefined\" && !r2.buffer.full) {\n    r2.buffer.add(valueP);\n    nextP = Promise.resolve(void 0);\n  } else {\n    nextP = new Promise((resolve) => r2.pushes.push({\n      resolve,\n      value: valueP\n    }));\n  }\n  let floating = true;\n  const next = {};\n  const unhandled = nextP.catch((err) => {\n    if (floating) {\n      throw err;\n    }\n    return void 0;\n  });\n  next.then = (onfulfilled, onrejected) => {\n    floating = false;\n    return Promise.prototype.then.call(nextP, onfulfilled, onrejected);\n  };\n  next.catch = (onrejected) => {\n    floating = false;\n    return Promise.prototype.catch.call(nextP, onrejected);\n  };\n  next.finally = nextP.finally.bind(nextP);\n  r2.pending = valueP.then(() => unhandled).catch((err) => {\n    r2.err = err;\n    reject(r2);\n  });\n  return next;\n}\nfunction createStop(r2) {\n  const stop1 = stop.bind(null, r2);\n  const stopP = new Promise((resolve) => r2.onstop = resolve);\n  stop1.then = stopP.then.bind(stopP);\n  stop1.catch = stopP.catch.bind(stopP);\n  stop1.finally = stopP.finally.bind(stopP);\n  return stop1;\n}\nfunction execute(r2) {\n  r2.state = Started;\n  const push1 = push.bind(null, r2);\n  const stop1 = createStop(r2);\n  r2.execution = new Promise((resolve) => resolve(r2.executor(push1, stop1)));\n  r2.execution.catch(() => stop(r2));\n}\nconst records = /* @__PURE__ */ new WeakMap();\nclass Repeater {\n  constructor(executor, buffer2) {\n    records.set(this, {\n      executor,\n      buffer: buffer2,\n      err: void 0,\n      state: Initial,\n      pushes: [],\n      nexts: [],\n      pending: void 0,\n      execution: void 0,\n      onnext: NOOP,\n      onstop: NOOP\n    });\n  }\n  next(value) {\n    swallow(value);\n    const r2 = records.get(this);\n    if (r2 === void 0) {\n      throw new Error(\"WeakMap error\");\n    }\n    if (r2.nexts.length >= MAX_QUEUE_LENGTH) {\n      throw new RepeaterOverflowError(`No more than ${MAX_QUEUE_LENGTH} pending calls to next are allowed on a single repeater.`);\n    }\n    if (r2.state <= Initial) {\n      execute(r2);\n    }\n    r2.onnext(value);\n    if (typeof r2.buffer !== \"undefined\" && !r2.buffer.empty) {\n      const result2 = createIteration(r2, r2.buffer.remove());\n      if (r2.pushes.length) {\n        const p2 = r2.pushes.shift();\n        r2.buffer.add(p2.value);\n        r2.onnext = p2.resolve;\n      }\n      return result2;\n    } else if (r2.pushes.length) {\n      const p2 = r2.pushes.shift();\n      r2.onnext = p2.resolve;\n      return createIteration(r2, p2.value);\n    } else if (r2.state >= Stopped) {\n      finish(r2);\n      return createIteration(r2, consumeExecution(r2));\n    }\n    return new Promise((resolve) => r2.nexts.push({\n      resolve,\n      value\n    }));\n  }\n  return(value) {\n    swallow(value);\n    const r2 = records.get(this);\n    if (r2 === void 0) {\n      throw new Error(\"WeakMap error\");\n    }\n    finish(r2);\n    r2.execution = Promise.resolve(r2.execution).then(() => value);\n    return createIteration(r2, consumeExecution(r2));\n  }\n  throw(err) {\n    const r2 = records.get(this);\n    if (r2 === void 0) {\n      throw new Error(\"WeakMap error\");\n    }\n    if (r2.state <= Initial || r2.state >= Stopped || typeof r2.buffer !== \"undefined\" && !r2.buffer.empty) {\n      finish(r2);\n      if (r2.err == null) {\n        r2.err = err;\n      }\n      return createIteration(r2, consumeExecution(r2));\n    }\n    return this.next(Promise.reject(err));\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\nclass Publisher {\n  constructor({\n    payloadFromSource = (source) => source,\n    onReady,\n    hasNext = () => true,\n    onStop\n  } = {}) {\n    this._payloadFromSource = payloadFromSource;\n    this._onReady = onReady;\n    this._hasNext = hasNext;\n    this._buffer = [];\n    this._stopped = false;\n    this._trigger = new Promise((resolve) => {\n      this._resolve = resolve;\n    });\n    this._pushed = /* @__PURE__ */ new WeakMap();\n    this._pending = /* @__PURE__ */ new WeakMap();\n    this._repeater = new Repeater(async (push2, stop2) => {\n      if (onStop) {\n        stop2.then(onStop);\n      }\n      while (true) {\n        await this._trigger;\n        while (this._buffer.length) {\n          const payload = this._buffer.shift();\n          await push2(payload);\n        }\n        if (this._stopped) {\n          stop2();\n          break;\n        }\n        this._trigger = new Promise((resolve) => {\n          this._resolve = resolve;\n        });\n      }\n    });\n  }\n  emit(keys, payload) {\n    for (const key of keys) {\n      this._pushed.set(key, true);\n    }\n    this._buffer.push(payload);\n    for (const key of keys) {\n      const dependents = this._pending.get(key);\n      if (dependents) {\n        this._pushMany(dependents);\n      }\n      this._pending.delete(key);\n    }\n    this._resolve();\n  }\n  stop(finalPayload) {\n    if (finalPayload !== void 0) {\n      this._buffer.push(finalPayload);\n    }\n    this._stopped = true;\n    this._resolve();\n  }\n  queue(keys, source, parentKey) {\n    if (this._pushed.get(parentKey)) {\n      this._pushOne({\n        keys,\n        source\n      });\n      return;\n    }\n    const dependents = this._pending.get(parentKey);\n    if (dependents) {\n      dependents.push({\n        keys,\n        source\n      });\n      return;\n    }\n    this._pending.set(parentKey, [\n      {\n        keys,\n        source\n      }\n    ]);\n  }\n  _pushOne(context) {\n    const hasNext = this._pushOneImpl(context);\n    if (!hasNext) {\n      this.stop();\n    }\n  }\n  _pushOneImpl({ keys, source }) {\n    var _this$_onReady;\n    (_this$_onReady = this._onReady) === null || _this$_onReady === void 0 ? void 0 : _this$_onReady.call(this);\n    const hasNext = this._hasNext();\n    const payload = this._payloadFromSource(source, hasNext);\n    this.emit(keys, payload);\n    return hasNext;\n  }\n  _pushMany(contexts) {\n    let hasNext = false;\n    for (const context of contexts) {\n      hasNext = this._pushOneImpl(context);\n    }\n    if (!hasNext) {\n      this.stop();\n    }\n  }\n  subscribe() {\n    return this._repeater;\n  }\n}\nclass Bundler {\n  constructor({\n    initialIndex,\n    maxBundleSize,\n    maxInterval,\n    createDataBundleContext,\n    createErrorBundleContext,\n    onSubsequentData,\n    onSubsequentError,\n    onDataBundle,\n    onErrorBundle\n  }) {\n    this._maxBundleSize = maxBundleSize;\n    this._maxInterval = maxInterval;\n    this._createDataBundleContext = createDataBundleContext;\n    this._createErrorBundleContext = createErrorBundleContext;\n    this._onSubsequentData = onSubsequentData;\n    this._onSubsequentError = onSubsequentError;\n    this._onDataBundle = onDataBundle;\n    this._onErrorBundle = onErrorBundle;\n    if (maxInterval != null) {\n      this._timingContext = {\n        maxInterval,\n        timeout: void 0,\n        lastTime: Date.now()\n      };\n    }\n    this._currentBundleSize = 0;\n    this._count = initialIndex;\n  }\n  queueData(index, result2) {\n    const context = this._updateDataContext(index, result2);\n    this._currentBundleSize++;\n    this._count++;\n    if (this._count === this._total) {\n      this._onDataBundle(context);\n      if (this._timingContext) {\n        this._clearCurrentTimer(this._timingContext);\n      }\n      return;\n    }\n    if (this._currentBundleSize === this._maxBundleSize) {\n      this._onDataBundle(context);\n      this._currentContext = void 0;\n      if (this._timingContext) {\n        this._restartTimer(this._timingContext);\n      }\n      return;\n    }\n    if (this._timingContext && Date.now() - this._timingContext.lastTime > this._timingContext.maxInterval) {\n      this._onDataBundle(context);\n      this._currentContext = void 0;\n      this._startNewTimer(this._timingContext);\n    }\n  }\n  queueError(index, result2) {\n    const context = this._updateErrorContext(index, result2);\n    this._currentBundleSize++;\n    this._count++;\n    if (this._count === this._total) {\n      this._onErrorBundle(context);\n      if (this._timingContext) {\n        this._clearCurrentTimer(this._timingContext);\n      }\n      return;\n    }\n    if (this._currentBundleSize === this._maxBundleSize) {\n      this._onErrorBundle(context);\n      this._currentContext = void 0;\n      if (this._timingContext) {\n        this._restartTimer(this._timingContext);\n      }\n    }\n    if (this._timingContext && Date.now() - this._timingContext.lastTime > this._timingContext.maxInterval) {\n      this._onErrorBundle(context);\n      this._currentContext = void 0;\n      this._startNewTimer(this._timingContext);\n    }\n  }\n  setTotal(total) {\n    if (this._count < total) {\n      this._total = total;\n      return;\n    }\n    if (this._currentContext) {\n      this._onBundle(this._currentContext);\n      if (this._timingContext) {\n        this._clearCurrentTimer(this._timingContext);\n      }\n    }\n  }\n  _clearCurrentTimer(timingContext) {\n    const timeout = timingContext.timeout;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n  }\n  _startNewTimer(timingContext) {\n    timingContext.timeout = setTimeout(() => this._flushCurrentBundle(timingContext), timingContext.maxInterval);\n    timingContext.lastTime = Date.now();\n  }\n  _flushCurrentBundle(timingContext) {\n    if (this._currentContext) {\n      this._onBundle(this._currentContext);\n      this._currentContext = void 0;\n      this._restartTimer(timingContext);\n      this._startNewTimer(timingContext);\n    }\n  }\n  _restartTimer(timingContext) {\n    this._clearCurrentTimer(timingContext);\n    this._startNewTimer(timingContext);\n  }\n  _updateDataContext(index, result2) {\n    if (this._currentContext === void 0) {\n      return this._getNewDataContext(index, result2);\n    } else if (!this._currentContext.isData) {\n      this._onErrorBundle(this._currentContext.context);\n      return this._getNewDataContext(index, result2);\n    }\n    this._onSubsequentData(index, result2, this._currentContext.context);\n    return this._currentContext.context;\n  }\n  _getNewDataContext(index, result2) {\n    this._currentBundleSize = 0;\n    const context = this._createDataBundleContext(index, result2);\n    this._currentContext = {\n      isData: true,\n      context\n    };\n    if (this._timingContext) {\n      const timingContext = this._timingContext;\n      timingContext.timeout = setTimeout(() => this._flushCurrentBundle(timingContext), timingContext.maxInterval);\n    }\n    return context;\n  }\n  _updateErrorContext(index, result2) {\n    if (this._currentContext === void 0) {\n      return this._getNewErrorContext(index, result2);\n    } else if (this._currentContext.isData) {\n      this._onDataBundle(this._currentContext.context);\n      return this._getNewErrorContext(index, result2);\n    }\n    this._onSubsequentError(index, result2, this._currentContext.context);\n    return this._currentContext.context;\n  }\n  _getNewErrorContext(index, result2) {\n    this._currentBundleSize = 0;\n    const context = this._createErrorBundleContext(index, result2);\n    this._currentContext = {\n      isData: false,\n      context\n    };\n    if (this._timingContext) {\n      const timingContext = this._timingContext;\n      timingContext.timeout = setTimeout(() => this._flushCurrentBundle(timingContext), timingContext.maxInterval);\n    }\n    return context;\n  }\n  _onBundle(bundleContext) {\n    if (bundleContext.isData) {\n      this._onDataBundle(bundleContext.context);\n      return;\n    }\n    this._onErrorBundle(bundleContext.context);\n  }\n}\nfunction getSequentialBundler(initialIndex, bundler) {\n  const dataResultMap = /* @__PURE__ */ new Map();\n  const errorResultMap = /* @__PURE__ */ new Map();\n  let count = initialIndex;\n  return {\n    queueData: (index, result2) => {\n      if (count !== index) {\n        dataResultMap.set(index, result2);\n        return;\n      }\n      bundler.queueData(index, result2);\n      count++;\n      processPending();\n    },\n    queueError: (index, result2) => {\n      if (count !== index) {\n        errorResultMap.set(index, result2);\n        return;\n      }\n      bundler.queueError(index, result2);\n      count++;\n      processPending();\n    },\n    setTotal: (total) => bundler.setTotal(total)\n  };\n  function processPending() {\n    while (true) {\n      const dataResult = dataResultMap.get(count);\n      if (dataResult !== void 0) {\n        dataResultMap.delete(count);\n        bundler.queueData(count, dataResult);\n        count++;\n        continue;\n      }\n      const errorResult = errorResultMap.get(count);\n      if (errorResult !== void 0) {\n        errorResultMap.delete(count);\n        bundler.queueError(count, errorResult);\n        count++;\n        continue;\n      }\n      break;\n    }\n  }\n}\nfunction toError(thrownValue) {\n  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);\n}\nclass NonErrorThrown extends Error {\n  constructor(thrownValue) {\n    super(\"Unexpected error value: \" + inspect(thrownValue));\n    this.name = \"NonErrorThrown\";\n    this.thrownValue = thrownValue;\n  }\n}\nfunction keyMap(list3, keyFn) {\n  const result2 = /* @__PURE__ */ Object.create(null);\n  for (const item of list3) {\n    result2[keyFn(item)] = item;\n  }\n  return result2;\n}\nfunction printPathArray(path) {\n  return path.map((key) => typeof key === \"number\" ? \"[\" + key.toString() + \"]\" : \".\" + key).join(\"\");\n}\nconst MAX_SUGGESTIONS = 5;\nfunction didYouMean(firstArg, secondArg) {\n  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];\n  let message = \" Did you mean \";\n  if (subMessage) {\n    message += subMessage + \" \";\n  }\n  const suggestions = suggestionsArg.map((x2) => `\"${x2}\"`);\n  switch (suggestions.length) {\n    case 0:\n      return \"\";\n    case 1:\n      return message + suggestions[0] + \"?\";\n    case 2:\n      return message + suggestions[0] + \" or \" + suggestions[1] + \"?\";\n  }\n  const selected = suggestions.slice(0, MAX_SUGGESTIONS);\n  const lastItem = selected.pop();\n  return message + selected.join(\", \") + \", or \" + lastItem + \"?\";\n}\nfunction naturalCompare(aStr, bStr) {\n  let aIndex = 0;\n  let bIndex = 0;\n  while (aIndex < aStr.length && bIndex < bStr.length) {\n    let aChar = aStr.charCodeAt(aIndex);\n    let bChar = bStr.charCodeAt(bIndex);\n    if (isDigit(aChar) && isDigit(bChar)) {\n      let aNum = 0;\n      do {\n        ++aIndex;\n        aNum = aNum * 10 + aChar - DIGIT_0;\n        aChar = aStr.charCodeAt(aIndex);\n      } while (isDigit(aChar) && aNum > 0);\n      let bNum = 0;\n      do {\n        ++bIndex;\n        bNum = bNum * 10 + bChar - DIGIT_0;\n        bChar = bStr.charCodeAt(bIndex);\n      } while (isDigit(bChar) && bNum > 0);\n      if (aNum < bNum) {\n        return -1;\n      }\n      if (aNum > bNum) {\n        return 1;\n      }\n    } else {\n      if (aChar < bChar) {\n        return -1;\n      }\n      if (aChar > bChar) {\n        return 1;\n      }\n      ++aIndex;\n      ++bIndex;\n    }\n  }\n  return aStr.length - bStr.length;\n}\nconst DIGIT_0 = 48;\nconst DIGIT_9 = 57;\nfunction isDigit(code3) {\n  return !isNaN(code3) && DIGIT_0 <= code3 && code3 <= DIGIT_9;\n}\nfunction suggestionList(input, options) {\n  const optionsByDistance = /* @__PURE__ */ Object.create(null);\n  const lexicalDistance2 = new LexicalDistance(input);\n  const threshold = Math.floor(input.length * 0.4) + 1;\n  for (const option of options) {\n    const distance = lexicalDistance2.measure(option, threshold);\n    if (distance !== void 0) {\n      optionsByDistance[option] = distance;\n    }\n  }\n  return Object.keys(optionsByDistance).sort((a, b) => {\n    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\n  });\n}\nclass LexicalDistance {\n  constructor(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0),\n      new Array(input.length + 1).fill(0)\n    ];\n  }\n  measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n    const optionLowerCase = option.toLowerCase();\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n    let a = stringToArray(optionLowerCase);\n    let b = this._inputArray;\n    if (a.length < b.length) {\n      const tmp = a;\n      a = b;\n      b = tmp;\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength - bLength > threshold) {\n      return void 0;\n    }\n    const rows = this._rows;\n    for (let j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n    for (let i = 1; i <= aLength; i++) {\n      const upRow = rows[(i - 1) % 3];\n      const currentRow = rows[i % 3];\n      let smallestCell = currentRow[0] = i;\n      for (let j = 1; j <= bLength; j++) {\n        const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);\n        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n        currentRow[j] = currentCell;\n      }\n      if (smallestCell > threshold) {\n        return void 0;\n      }\n    }\n    const distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : void 0;\n  }\n}\nfunction stringToArray(str) {\n  const strLength = str.length;\n  const array = new Array(strLength);\n  for (let i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n}\nfunction isGraphQLError(error2) {\n  return error2.name === \"GraphQLError\";\n}\nfunction coerceInputValue(executorSchema, inputValue, type2, onError = defaultOnError) {\n  return coerceInputValueImpl(executorSchema, inputValue, type2, onError, void 0);\n}\nfunction defaultOnError(path, invalidValue, error2) {\n  let errorPrefix = \"Invalid value \" + inspect(invalidValue);\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${printPathArray(path)}\"`;\n  }\n  error2.message = errorPrefix + \": \" + error2.message;\n  throw error2;\n}\nfunction coerceInputValueImpl(executorSchema, inputValue, type2, onError, path) {\n  if (executorSchema.isNonNullType(type2)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(executorSchema, inputValue, type2.ofType, onError, path);\n    }\n    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type \"${inspect(type2)}\" not to be null.`));\n    return;\n  }\n  if (inputValue == null) {\n    return null;\n  }\n  if (executorSchema.isListType(type2)) {\n    const itemType = type2.ofType;\n    if (isIterableObject(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = addPath(path, index, void 0);\n        return coerceInputValueImpl(executorSchema, itemValue, itemType, onError, itemPath);\n      });\n    }\n    return [\n      coerceInputValueImpl(executorSchema, inputValue, itemType, onError, path)\n    ];\n  }\n  if (executorSchema.isInputObjectType(type2)) {\n    if (!isObjectLike(inputValue)) {\n      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type2.name}\" to be an object.`));\n      return;\n    }\n    const coercedValue = {};\n    const fieldDefs = type2.getFields();\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n      if (fieldValue === void 0) {\n        if (field.defaultValue !== void 0) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if (executorSchema.isNonNullType(field.type)) {\n          const typeStr = inspect(field.type);\n          onError(pathToArray(path), inputValue, new GraphQLError(`Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`));\n        }\n        continue;\n      }\n      coercedValue[field.name] = coerceInputValueImpl(executorSchema, fieldValue, field.type, onError, addPath(path, field.name, type2.name));\n    }\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = suggestionList(fieldName, Object.keys(type2.getFields()));\n        onError(pathToArray(path), inputValue, new GraphQLError(`Field \"${fieldName}\" is not defined by type \"${type2.name}\".` + didYouMean(suggestions)));\n      }\n    }\n    return coercedValue;\n  }\n  if (executorSchema.isLeafType(type2)) {\n    let parseResult;\n    try {\n      parseResult = type2.parseValue(inputValue);\n    } catch (error2) {\n      if (isGraphQLError(error2)) {\n        onError(pathToArray(path), inputValue, error2);\n      } else {\n        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type2.name}\". ` + error2.message, void 0, void 0, void 0, void 0, error2));\n      }\n      return;\n    }\n    if (parseResult === void 0) {\n      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type \"${type2.name}\".`));\n    }\n    return parseResult;\n  }\n  invariant(false, \"Unexpected input type: \" + inspect(type2));\n}\nfunction valueFromAST(executorSchema, valueNode, type2, variables) {\n  if (!valueNode) {\n    return;\n  }\n  if (valueNode.kind === Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n    if (variables == null || variables[variableName] === void 0) {\n      return;\n    }\n    const variableValue = variables[variableName];\n    if (variableValue === null && executorSchema.isNonNullType(type2)) {\n      return;\n    }\n    return variableValue;\n  }\n  if (executorSchema.isNonNullType(type2)) {\n    if (valueNode.kind === Kind.NULL) {\n      return;\n    }\n    return valueFromAST(executorSchema, valueNode, type2.ofType, variables);\n  }\n  if (valueNode.kind === Kind.NULL) {\n    return null;\n  }\n  if (executorSchema.isListType(type2)) {\n    const itemType = type2.ofType;\n    if (valueNode.kind === Kind.LIST) {\n      const coercedValues = [];\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          if (executorSchema.isNonNullType(itemType)) {\n            return;\n          }\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(executorSchema, itemNode, itemType, variables);\n          if (itemValue === void 0) {\n            return;\n          }\n          coercedValues.push(itemValue);\n        }\n      }\n      return coercedValues;\n    }\n    const coercedValue = valueFromAST(executorSchema, valueNode, itemType, variables);\n    if (coercedValue === void 0) {\n      return;\n    }\n    return [coercedValue];\n  }\n  if (executorSchema.isInputObjectType(type2)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return;\n    }\n    const coercedObj = /* @__PURE__ */ Object.create(null);\n    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);\n    for (const field of Object.values(type2.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== void 0) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (executorSchema.isNonNullType(field.type)) {\n          return;\n        }\n        continue;\n      }\n      const fieldValue = valueFromAST(executorSchema, fieldNode.value, field.type, variables);\n      if (fieldValue === void 0) {\n        return;\n      }\n      coercedObj[field.name] = fieldValue;\n    }\n    return coercedObj;\n  }\n  if (executorSchema.isLeafType(type2)) {\n    let result2;\n    try {\n      result2 = type2.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return;\n    }\n    if (result2 === void 0) {\n      return;\n    }\n    return result2;\n  }\n  invariant(false, \"Unexpected input type: \" + inspect(type2));\n}\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);\n}\nfunction getVariableValues(executorSchema, varDefNodes, inputs, options) {\n  const errors2 = [];\n  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;\n  try {\n    const coerced = coerceVariableValues(executorSchema, varDefNodes, inputs, (error2) => {\n      if (maxErrors != null && errors2.length >= maxErrors) {\n        throw new GraphQLError(\"Too many errors processing variables, error limit reached. Execution aborted.\");\n      }\n      errors2.push(error2);\n    });\n    if (errors2.length === 0) {\n      return {\n        coerced\n      };\n    }\n  } catch (error2) {\n    errors2.push(error2);\n  }\n  return {\n    errors: errors2\n  };\n}\nfunction coerceVariableValues(executorSchema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = executorSchema.getType(varDefNode.type);\n    if (!varType || !executorSchema.isInputType(varType)) {\n      const varTypeStr = print(varDefNode.type);\n      onError(new GraphQLError(`Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`, varDefNode.type));\n      continue;\n    }\n    if (!hasOwnProperty$1(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(executorSchema, varDefNode.defaultValue, varType);\n      } else if (executorSchema.isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(new GraphQLError(`Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`, varDefNode));\n      }\n      continue;\n    }\n    const value = inputs[varName];\n    if (value === null && executorSchema.isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(new GraphQLError(`Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`, varDefNode));\n      continue;\n    }\n    coercedValues[varName] = coerceInputValue(executorSchema, value, varType, (path, invalidValue, error2) => {\n      let prefix = `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n      if (path.length > 0) {\n        prefix += ` at \"${varName}${printPathArray(path)}\"`;\n      }\n      onError(new GraphQLError(prefix + \"; \" + error2.message, varDefNode, void 0, void 0, void 0, error2.originalError));\n    });\n  }\n  return coercedValues;\n}\nfunction getArgumentValues(executorSchema, def, node, variableValues) {\n  var _node$arguments;\n  const coercedValues = {};\n  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n  for (const argDef of def.args) {\n    const name2 = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name2];\n    if (!argumentNode) {\n      if (argDef.defaultValue !== void 0) {\n        coercedValues[name2] = argDef.defaultValue;\n      } else if (executorSchema.isNonNullType(argType)) {\n        throw new GraphQLError(`Argument \"${name2}\" of required type \"${inspect(argType)}\" was not provided.`, node);\n      }\n      continue;\n    }\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n      if (variableValues == null || !hasOwnProperty$1(variableValues, variableName)) {\n        if (argDef.defaultValue !== void 0) {\n          coercedValues[name2] = argDef.defaultValue;\n        } else if (executorSchema.isNonNullType(argType)) {\n          throw new GraphQLError(`Argument \"${name2}\" of required type \"${inspect(argType)}\" was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n        }\n        continue;\n      }\n      isNull = variableValues[variableName] == null;\n    }\n    if (isNull && executorSchema.isNonNullType(argType)) {\n      throw new GraphQLError(`Argument \"${name2}\" of non-null type \"${inspect(argType)}\" must not be null.`, valueNode);\n    }\n    const coercedValue = valueFromAST(executorSchema, valueNode, argType, variableValues);\n    if (coercedValue === void 0) {\n      throw new GraphQLError(`Argument \"${name2}\" has invalid value ${print(valueNode)}.`, valueNode);\n    }\n    coercedValues[name2] = coercedValue;\n  }\n  return coercedValues;\n}\nfunction getDirectiveValues(executorSchema, directiveDef, node, variableValues) {\n  var _node$directives;\n  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive) => directive.name.value === directiveDef.name);\n  if (directiveNode) {\n    return getArgumentValues(executorSchema, directiveDef, directiveNode, variableValues);\n  }\n}\nfunction hasOwnProperty$1(obj, prop2) {\n  return Object.prototype.hasOwnProperty.call(obj, prop2);\n}\nfunction mapAsyncIterable(iterable, fn) {\n  return new Repeater(async (push2, stop2) => {\n    const iter = iterable[Symbol.asyncIterator]();\n    let finalIteration;\n    stop2.then(() => {\n      finalIteration = typeof iter.return === \"function\" ? iter.return() : true;\n    });\n    while (!finalIteration) {\n      const iteration = await iter.next();\n      if (iteration.done) {\n        stop2();\n        break;\n      }\n      await push2(fn(iteration.value));\n    }\n    if (isPromise(finalIteration)) {\n      await finalIteration;\n    }\n  });\n}\nfunction flattenAsyncIterable(iterable) {\n  return new Repeater(async (push2, stop2) => {\n    const iter = iterable[Symbol.asyncIterator]();\n    let childIterator;\n    let finalIteration;\n    stop2.then(() => {\n      const childReturned = childIterator && typeof childIterator.return === \"function\" && childIterator.return();\n      const returned = typeof iter.return === \"function\" && iter.return();\n      if (isPromise(childReturned)) {\n        finalIteration = isPromise(returned) ? Promise.all([childReturned, returned]) : true;\n      } else if (isPromise(returned)) {\n        finalIteration = returned;\n      } else {\n        finalIteration = true;\n      }\n    });\n    while (!finalIteration) {\n      const iteration = await iter.next();\n      if (iteration.done) {\n        stop2();\n        break;\n      }\n      const value = iteration.value;\n      if (isAsyncIterable(value)) {\n        childIterator = value[Symbol.asyncIterator]();\n        await pushChildIterations(childIterator, push2, finalIteration);\n        childIterator = void 0;\n        continue;\n      }\n      await push2(value);\n    }\n    if (isPromise(finalIteration)) {\n      await finalIteration;\n    }\n  });\n}\nasync function pushChildIterations(iter, push2, finalIteration) {\n  while (!finalIteration) {\n    const iteration = await iter.next();\n    if (iteration.done) {\n      return;\n    }\n    await push2(iteration.value);\n  }\n}\nfunction _defineProperty$1(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nclass Executor {\n  constructor(executorArgs) {\n    _defineProperty$1(this, \"splitDefinitions\", memoize1((document2) => this._splitDefinitions(document2)));\n    _defineProperty$1(this, \"selectOperation\", memoize1and1((operations, operationName) => this._selectOperation(operations, operationName)));\n    _defineProperty$1(this, \"getFieldContext\", memoize2((parentType, fieldNodes) => this._getFieldContext(parentType, fieldNodes)));\n    _defineProperty$1(this, \"getValueCompleter\", memoize1((returnType) => this._getValueCompleter(returnType)));\n    _defineProperty$1(this, \"createFieldList\", memoize1((node) => [node]));\n    _defineProperty$1(this, \"updateFieldList\", memoize2((fieldList, node) => [...fieldList, node]));\n    _defineProperty$1(this, \"buildFieldResolver\", (resolverKey, defaultResolver) => (exeContext, fieldContext, source, info2) => {\n      var _fieldDef$resolverKey;\n      const { fieldDef, initialFieldNode } = fieldContext;\n      const resolveFn = (_fieldDef$resolverKey = fieldDef[resolverKey]) !== null && _fieldDef$resolverKey !== void 0 ? _fieldDef$resolverKey : defaultResolver;\n      const { contextValue, variableValues } = exeContext;\n      const args = exeContext.getArgumentValues(fieldDef, initialFieldNode, variableValues);\n      return resolveFn(source, args, contextValue, info2);\n    });\n    _defineProperty$1(this, \"buildRootFieldCollector\", (fragments, variableValues, getDeferValues) => (runtimeType, operation) => {\n      const fields = /* @__PURE__ */ new Map();\n      const patches = [];\n      this.collectFieldsImpl(fragments, variableValues, getDeferValues, runtimeType, operation.selectionSet, fields, patches, /* @__PURE__ */ new Set());\n      return {\n        fields,\n        patches\n      };\n    });\n    _defineProperty$1(this, \"buildSubFieldCollector\", (fragments, variableValues, getDeferValues) => memoize2((returnType, fieldNodes) => {\n      const subFieldNodes = /* @__PURE__ */ new Map();\n      const visitedFragmentNames = /* @__PURE__ */ new Set();\n      const subPatches = [];\n      const subFieldsAndPatches = {\n        fields: subFieldNodes,\n        patches: subPatches\n      };\n      for (const node of fieldNodes) {\n        if (node.selectionSet) {\n          this.collectFieldsImpl(fragments, variableValues, getDeferValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);\n        }\n      }\n      return subFieldsAndPatches;\n    }));\n    const { schema, executorSchema } = executorArgs;\n    schema || devAssert(false, \"Must provide schema.\");\n    this._schema = schema;\n    this._executorSchema = executorSchema !== null && executorSchema !== void 0 ? executorSchema : toExecutorSchema(schema);\n  }\n  execute(args) {\n    const exeContext = this.buildExecutionContext(args);\n    if (!(\"fragments\" in exeContext)) {\n      return {\n        errors: exeContext\n      };\n    }\n    const { operation, forceQueryAlgorithm } = exeContext;\n    if (forceQueryAlgorithm) {\n      return this.executeQueryImpl(exeContext);\n    }\n    switch (operation.operation) {\n      case \"query\":\n        return this.executeQueryImpl(exeContext);\n      case \"mutation\":\n        return this.executeMutationImpl(exeContext);\n      default:\n        return this.executeSubscriptionImpl(exeContext);\n    }\n  }\n  async createSourceEventStream(args) {\n    const exeContext = this.buildExecutionContext(args);\n    if (!(\"fragments\" in exeContext)) {\n      return {\n        errors: exeContext\n      };\n    }\n    return this.createSourceEventStreamImpl(exeContext);\n  }\n  executeQueryImpl(exeContext) {\n    return this.executeOperationImpl(exeContext, this.executeFields.bind(this), this.buildResponse.bind(this));\n  }\n  executeMutationImpl(exeContext) {\n    return this.executeOperationImpl(exeContext, this.executeFieldsSerially.bind(this), this.buildResponse.bind(this));\n  }\n  executeOperationImpl(exeContext, rootFieldsExecutor, responseBuilder) {\n    let data;\n    try {\n      const { rootValue, rootResponseNode } = exeContext;\n      const {\n        rootType,\n        fieldsAndPatches: { fields, patches }\n      } = this.getRootContext(exeContext);\n      const path = void 0;\n      data = rootFieldsExecutor(exeContext, rootType, rootValue, path, fields, rootResponseNode);\n      this.addPatches(exeContext, patches, rootType, rootValue, path, rootResponseNode);\n    } catch (error2) {\n      exeContext.rootResponseNode.errors.push(error2);\n      data = null;\n    }\n    if (isPromise(data)) {\n      return data.then((resolvedData) => responseBuilder(exeContext, resolvedData), (error2) => {\n        exeContext.rootResponseNode.errors.push(error2);\n        return responseBuilder(exeContext, null);\n      });\n    }\n    return responseBuilder(exeContext, data);\n  }\n  buildResponse(exeContext, data) {\n    const rootResponseNode = exeContext.rootResponseNode;\n    const errors2 = rootResponseNode.errors;\n    const initialResult = errors2.length === 0 ? {\n      data\n    } : {\n      errors: errors2,\n      data\n    };\n    if (this.hasNext(exeContext.state)) {\n      const publisher = exeContext.publisher;\n      publisher.emit([rootResponseNode], __spreadProps(__spreadValues({}, initialResult), { hasNext: true }));\n      return publisher.subscribe();\n    }\n    return initialResult;\n  }\n  assertValidExecutionArguments(document2, rawVariableValues) {\n    document2 || devAssert(false, \"Must provide document.\");\n    rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(false, \"Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.\");\n  }\n  _splitDefinitions(document2) {\n    const operations = [];\n    const fragments = /* @__PURE__ */ Object.create(null);\n    for (const definition of document2.definitions) {\n      switch (definition.kind) {\n        case Kind.OPERATION_DEFINITION:\n          operations.push(definition);\n          break;\n        case Kind.FRAGMENT_DEFINITION:\n          fragments[definition.name.value] = definition;\n          break;\n      }\n    }\n    return {\n      operations,\n      fragments\n    };\n  }\n  _selectOperation(operations, operationName) {\n    let operation;\n    for (const possibleOperation of operations) {\n      var _possibleOperation$na;\n      if (operationName == null) {\n        if (operation !== void 0) {\n          return [\n            new GraphQLError(\"Must provide operation name if query contains multiple operations.\")\n          ];\n        }\n        operation = possibleOperation;\n      } else if (((_possibleOperation$na = possibleOperation.name) === null || _possibleOperation$na === void 0 ? void 0 : _possibleOperation$na.value) === operationName) {\n        operation = possibleOperation;\n      }\n    }\n    if (!operation) {\n      if (operationName != null) {\n        return [\n          new GraphQLError(`Unknown operation named \"${operationName}\".`)\n        ];\n      }\n      return [new GraphQLError(\"Must provide an operation.\")];\n    }\n    return operation;\n  }\n  createPublisher(state) {\n    return new Publisher({\n      payloadFromSource: (result2, hasNext) => {\n        const { responseContext, data, path, atIndex, atIndices, label } = result2;\n        const errors2 = [];\n        for (const responseNode of responseContext.responseNodes) {\n          errors2.push(...responseNode.errors);\n        }\n        const value = {\n          data,\n          path: path ? pathToArray(path) : [],\n          hasNext\n        };\n        if (atIndex != null) {\n          value.atIndex = atIndex;\n        } else if (atIndices != null) {\n          value.atIndices = atIndices;\n        }\n        if (label != null) {\n          value.label = label;\n        }\n        if (errors2.length > 0) {\n          value.errors = errors2;\n        }\n        return value;\n      },\n      onReady: () => state.pendingPushes--,\n      hasNext: () => this.hasNext(state),\n      onStop: () => Promise.all(Array.from(state.iterators.values()).map((iterator) => {\n        var _iterator$return;\n        return (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator);\n      }))\n    });\n  }\n  buildExecutionContext(args) {\n    var _operation$variableDe;\n    const {\n      document: document2,\n      rootValue,\n      contextValue,\n      variableValues: rawVariableValues,\n      operationName,\n      fieldResolver,\n      typeResolver,\n      subscribeFieldResolver,\n      forceQueryAlgorithm,\n      enableIncremental\n    } = args;\n    this.assertValidExecutionArguments(document2, rawVariableValues);\n    const { operations, fragments } = this.splitDefinitions(document2);\n    const operation = this.selectOperation(operations, operationName);\n    if (\"length\" in operation) {\n      return operation;\n    }\n    const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];\n    const coercedVariableValues = getVariableValues(this._executorSchema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {\n      maxErrors: 50\n    });\n    if (coercedVariableValues.errors) {\n      return coercedVariableValues.errors;\n    }\n    const enableIncrementalFlagValue = enableIncremental !== null && enableIncremental !== void 0 ? enableIncremental : true;\n    const defaultResolveFieldValueFn = fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver;\n    const getDeferValues = enableIncrementalFlagValue ? this.getDeferValues.bind(this) : () => void 0;\n    const coercedVariableValuesValues = coercedVariableValues.coerced;\n    const state = {\n      pendingPushes: 0,\n      pendingStreamResults: 0,\n      iterators: /* @__PURE__ */ new Set()\n    };\n    return {\n      fragments,\n      rootValue,\n      contextValue,\n      operation,\n      variableValues: coercedVariableValues.coerced,\n      fieldResolver: defaultResolveFieldValueFn,\n      typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,\n      forceQueryAlgorithm: forceQueryAlgorithm !== null && forceQueryAlgorithm !== void 0 ? forceQueryAlgorithm : false,\n      enableIncremental: enableIncrementalFlagValue,\n      getArgumentValues: memoize2((def, node) => getArgumentValues(this._executorSchema, def, node, coercedVariableValuesValues)),\n      getDeferValues,\n      getStreamValues: enableIncrementalFlagValue ? this.getStreamValues.bind(this) : () => void 0,\n      rootFieldCollector: this.buildRootFieldCollector(fragments, coercedVariableValuesValues, getDeferValues),\n      subFieldCollector: this.buildSubFieldCollector(fragments, coercedVariableValuesValues, getDeferValues),\n      resolveField: operation.operation === \"subscription\" && !forceQueryAlgorithm ? this.buildFieldResolver(\"subscribe\", subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver) : this.buildFieldResolver(\"resolve\", defaultResolveFieldValueFn),\n      rootResponseNode: {\n        errors: []\n      },\n      state,\n      publisher: this.createPublisher(state)\n    };\n  }\n  buildPerPayloadExecutionContext(exeContext, payload) {\n    const state = {\n      pendingPushes: 0,\n      pendingStreamResults: 0,\n      iterators: /* @__PURE__ */ new Set()\n    };\n    return __spreadProps(__spreadValues({}, exeContext), {\n      rootValue: payload,\n      forceQueryAlgorithm: true,\n      resolveField: this.buildFieldResolver(\"resolve\", exeContext.fieldResolver),\n      rootResponseNode: {\n        errors: []\n      },\n      state,\n      publisher: this.createPublisher(state)\n    });\n  }\n  getRootContext(exeContext) {\n    const { operation, rootFieldCollector } = exeContext;\n    const rootType = this._executorSchema.getRootType(operation.operation);\n    if (rootType == null) {\n      throw new GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, operation);\n    }\n    const fieldsAndPatches = rootFieldCollector(rootType, operation);\n    return {\n      rootType,\n      fieldsAndPatches\n    };\n  }\n  executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n    const parentTypeName = parentType.name;\n    return promiseReduce(fields.entries(), (results, [responseName, fieldNodes]) => {\n      const fieldPath = addPath(path, responseName, parentTypeName);\n      const result2 = this.executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, exeContext.rootResponseNode);\n      if (result2 === void 0) {\n        return results;\n      }\n      if (isPromise(result2)) {\n        return result2.then((resolvedResult) => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n      results[responseName] = result2;\n      return results;\n    }, /* @__PURE__ */ Object.create(null));\n  }\n  executeFields(exeContext, parentType, sourceValue, path, fields, responseNode) {\n    const results = /* @__PURE__ */ Object.create(null);\n    const promises = [];\n    const parentTypeName = parentType.name;\n    for (const [responseName, fieldNodes] of fields.entries()) {\n      const fieldPath = addPath(path, responseName, parentTypeName);\n      const result2 = this.executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, responseNode);\n      if (result2 !== void 0) {\n        if (isPromise(result2)) {\n          results[responseName] = void 0;\n          const promise = result2.then((resolved) => {\n            results[responseName] = resolved;\n          });\n          promises.push(promise);\n        } else {\n          results[responseName] = result2;\n        }\n      }\n    }\n    if (!promises.length) {\n      return results;\n    }\n    return resolveAfterAll(results, promises);\n  }\n  executeField(exeContext, parentType, source, fieldNodes, path, responseNode) {\n    const fieldContext = this.getFieldContext(parentType, fieldNodes);\n    if (!fieldContext) {\n      return;\n    }\n    const returnType = fieldContext.returnType;\n    const info2 = this.buildResolveInfo(exeContext, fieldContext, path);\n    try {\n      const result2 = exeContext.resolveField(exeContext, fieldContext, source, info2);\n      let completed;\n      const valueCompleter = this.getValueCompleter(returnType);\n      if (isPromise(result2)) {\n        completed = result2.then((resolved) => valueCompleter(exeContext, fieldContext, info2, path, resolved, responseNode));\n      } else {\n        completed = valueCompleter(exeContext, fieldContext, info2, path, result2, responseNode);\n      }\n      if (isPromise(completed)) {\n        return completed.then(void 0, (rawError) => this.handleRawError(rawError, fieldNodes, path, returnType, responseNode.errors));\n      }\n      return completed;\n    } catch (rawError) {\n      return this.handleRawError(rawError, fieldNodes, path, returnType, responseNode.errors);\n    }\n  }\n  buildResolveInfo(exeContext, fieldContext, path) {\n    const { fieldName, fieldNodes, returnType, parentType } = fieldContext;\n    const { _schema: schema, _executorSchema: executorSchema } = this;\n    const { fragments, rootValue, operation, variableValues } = exeContext;\n    return {\n      fieldName,\n      fieldNodes,\n      returnType,\n      parentType,\n      path,\n      schema,\n      executorSchema,\n      fragments,\n      rootValue,\n      operation,\n      variableValues\n    };\n  }\n  toLocatedError(rawError, fieldNodes, path) {\n    return locatedError(toError(rawError), fieldNodes, pathToArray(path));\n  }\n  handleRawError(rawError, fieldNodes, path, returnType, errors2) {\n    const error2 = this.toLocatedError(rawError, fieldNodes, path);\n    if (this._executorSchema.isNonNullType(returnType)) {\n      throw error2;\n    }\n    errors2.push(error2);\n    return null;\n  }\n  buildNullableValueCompleter(valueCompleter) {\n    return (exeContext, fieldContext, info2, path, result2, responseNode) => {\n      if (result2 instanceof Error) {\n        throw result2;\n      }\n      if (result2 == null) {\n        return null;\n      }\n      return valueCompleter(exeContext, fieldContext, info2, path, result2, responseNode);\n    };\n  }\n  _getValueCompleter(returnType) {\n    if (this._executorSchema.isNonNullType(returnType)) {\n      return (exeContext, fieldContext, info2, path, result2, responseNode) => {\n        const innerValueCompleter = this.getValueCompleter(returnType.ofType);\n        const completed = innerValueCompleter(exeContext, fieldContext, info2, path, result2, responseNode);\n        if (completed === null) {\n          throw new Error(`Cannot return null for non-nullable field ${info2.parentType.name}.${info2.fieldName}.`);\n        }\n        return completed;\n      };\n    }\n    if (this._executorSchema.isListType(returnType)) {\n      return this.buildNullableValueCompleter((exeContext, fieldContext, info2, path, result2, responseNode) => this.completeListValue(exeContext, returnType, fieldContext, info2, path, result2, responseNode));\n    }\n    if (this._executorSchema.isLeafType(returnType)) {\n      return this.buildNullableValueCompleter((_exeContext, _fieldContext, _info, _path, result2, _responseNode) => this.completeLeafValue(returnType, result2));\n    }\n    if (this._executorSchema.isAbstractType(returnType)) {\n      return this.buildNullableValueCompleter((exeContext, fieldContext, info2, path, result2, responseNode) => this.completeAbstractValue(exeContext, returnType, fieldContext, info2, path, result2, responseNode));\n    }\n    if (this._executorSchema.isObjectType(returnType)) {\n      return this.buildNullableValueCompleter((exeContext, fieldContext, info2, path, result2, responseNode) => this.completeObjectValue(exeContext, returnType, fieldContext, info2, path, result2, responseNode));\n    }\n    invariant(false, \"Cannot complete value of unexpected output type: \" + inspect(returnType));\n  }\n  completeListValue(exeContext, returnType, fieldContext, info2, path, result2, responseNode) {\n    const itemType = returnType.ofType;\n    const valueCompleter = this.getValueCompleter(itemType);\n    const completedResults = [];\n    const promises = [];\n    const stream = exeContext.getStreamValues(exeContext.variableValues, fieldContext);\n    if (isAsyncIterable(result2)) {\n      const iterator2 = result2[Symbol.asyncIterator]();\n      return this.completeAsyncIteratorValue(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator2, responseNode, stream, completedResults, promises);\n    }\n    if (!isIterableObject(result2)) {\n      throw new GraphQLError(`Expected Iterable, but did not find one for field \"${info2.parentType.name}.${info2.fieldName}\".`);\n    }\n    const iterator = result2[Symbol.iterator]();\n    this.completeIteratorValue(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, stream, completedResults, promises);\n    return promises.length ? resolveAfterAll(completedResults, promises) : completedResults;\n  }\n  getStreamValues(variableValues, fieldContext) {\n    const stream = getDirectiveValues(this._executorSchema, GraphQLStreamDirective, fieldContext.initialFieldNode, variableValues);\n    if (!stream) {\n      return;\n    }\n    if (stream.if === false) {\n      return;\n    }\n    const { initialCount, maxChunkSize, maxInterval, inParallel, label } = stream;\n    typeof initialCount === \"number\" || invariant(false, \"initialCount must be a number\");\n    initialCount >= 0 || invariant(false, \"initialCount must be an integer greater than or equal to zero\");\n    typeof maxChunkSize === \"number\" || invariant(false, \"maxChunkSize must be a number\");\n    maxChunkSize >= 1 || invariant(false, \"maxChunkSize must be an integer greater than or equal to one\");\n    if (maxInterval != null) {\n      typeof maxInterval === \"number\" || invariant(false, \"maxInterval must be a number\");\n      maxInterval >= 0 || invariant(false, \"maxInterval must be an integer greater than or equal to zero\");\n    }\n    return {\n      initialCount,\n      maxChunkSize,\n      maxInterval,\n      inParallel: inParallel === true,\n      label: typeof label === \"string\" ? label : void 0\n    };\n  }\n  completeIteratorValue(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, stream, completedResults, promises) {\n    if (stream) {\n      this.completeIteratorValueWithStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, stream, completedResults, 0, promises);\n      return;\n    }\n    this.completeIteratorValueWithoutStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, completedResults, 0, promises);\n  }\n  onNewBundleContext(state, context, responseNode) {\n    state.pendingPushes++;\n    state.pendingStreamResults--;\n    context.responseNodes.push(responseNode);\n    return context;\n  }\n  onSubsequentResponseNode(state, context, responseNode) {\n    state.pendingStreamResults--;\n    context.responseNodes.push(responseNode);\n  }\n  createStreamContext(exeContext, initialCount, maxChunkSize, maxInterval, inParallel, path, label, parentResponseNode) {\n    if (maxChunkSize === 1) {\n      const bundler = new Bundler({\n        initialIndex: initialCount,\n        maxBundleSize: maxChunkSize,\n        maxInterval,\n        createDataBundleContext: (index, result2) => this.onNewBundleContext(exeContext.state, {\n          responseNodes: [],\n          parentResponseNode,\n          result: result2.data,\n          atIndex: index\n        }, result2.responseNode),\n        createErrorBundleContext: (index, responseNode) => this.onNewBundleContext(exeContext.state, {\n          responseNodes: [],\n          parentResponseNode,\n          atIndex: index\n        }, responseNode),\n        onSubsequentData: () => {\n        },\n        onSubsequentError: () => {\n        },\n        onDataBundle: (context) => exeContext.publisher.queue(context.responseNodes, {\n          responseContext: context,\n          data: context.result,\n          path: addPath(path, context.atIndex, void 0),\n          label\n        }, parentResponseNode),\n        onErrorBundle: (context) => exeContext.publisher.queue(context.responseNodes, {\n          responseContext: context,\n          data: null,\n          path: addPath(path, context.atIndex, void 0),\n          label\n        }, parentResponseNode)\n      });\n      return {\n        initialCount,\n        path,\n        bundler: inParallel ? bundler : getSequentialBundler(initialCount, bundler)\n      };\n    }\n    if (inParallel) {\n      return {\n        initialCount,\n        path,\n        bundler: new Bundler({\n          initialIndex: initialCount,\n          maxBundleSize: maxChunkSize,\n          maxInterval,\n          createDataBundleContext: (index, result2) => this.onNewBundleContext(exeContext.state, {\n            responseNodes: [],\n            parentResponseNode,\n            atIndices: [index],\n            results: [result2.data]\n          }, result2.responseNode),\n          createErrorBundleContext: (index, responseNode) => this.onNewBundleContext(exeContext.state, {\n            responseNodes: [],\n            parentResponseNode,\n            atIndices: [index]\n          }, responseNode),\n          onSubsequentData: (index, result2, context) => {\n            this.onSubsequentResponseNode(exeContext.state, context, result2.responseNode);\n            context.results.push(result2.data);\n            context.atIndices.push(index);\n          },\n          onSubsequentError: (index, responseNode, context) => {\n            this.onSubsequentResponseNode(exeContext.state, context, responseNode);\n            context.atIndices.push(index);\n          },\n          onDataBundle: (context) => exeContext.publisher.queue(context.responseNodes, {\n            responseContext: context,\n            data: context.results,\n            path,\n            atIndices: context.atIndices,\n            label\n          }, parentResponseNode),\n          onErrorBundle: (context) => exeContext.publisher.queue(context.responseNodes, {\n            responseContext: context,\n            data: null,\n            path,\n            atIndices: context.atIndices,\n            label\n          }, parentResponseNode)\n        })\n      };\n    }\n    return {\n      initialCount,\n      path,\n      bundler: getSequentialBundler(initialCount, new Bundler({\n        initialIndex: initialCount,\n        maxBundleSize: maxChunkSize,\n        maxInterval,\n        createDataBundleContext: (index, result2) => this.onNewBundleContext(exeContext.state, {\n          responseNodes: [],\n          parentResponseNode,\n          atIndex: index,\n          results: [result2.data]\n        }, result2.responseNode),\n        createErrorBundleContext: (index, responseNode) => this.onNewBundleContext(exeContext.state, {\n          responseNodes: [],\n          parentResponseNode,\n          atIndex: index\n        }, responseNode),\n        onSubsequentData: (_index, result2, context) => {\n          this.onSubsequentResponseNode(exeContext.state, context, result2.responseNode);\n          context.results.push(result2.data);\n        },\n        onSubsequentError: (_index, responseNode, context) => this.onSubsequentResponseNode(exeContext.state, context, responseNode),\n        onDataBundle: (context) => exeContext.publisher.queue(context.responseNodes, {\n          responseContext: context,\n          data: context.results,\n          path,\n          atIndex: context.atIndex,\n          label\n        }, parentResponseNode),\n        onErrorBundle: (context) => exeContext.publisher.queue(context.responseNodes, {\n          responseContext: context,\n          data: null,\n          path,\n          atIndex: context.atIndex,\n          label\n        }, parentResponseNode)\n      }))\n    };\n  }\n  completeIteratorValueWithStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, stream, completedResults, _index, promises) {\n    const initialCount = stream.initialCount;\n    let index = _index;\n    while (true) {\n      if (index >= initialCount) {\n        const { maxChunkSize, maxInterval, inParallel, label } = stream;\n        const streamContext = this.createStreamContext(exeContext, initialCount, maxChunkSize, maxInterval, inParallel, path, label, responseNode);\n        const nextIndex = this.addIteratorValue(index, iterator, exeContext, itemType, fieldContext, info2, valueCompleter, streamContext);\n        streamContext.bundler.setTotal(nextIndex);\n        break;\n      }\n      const iteration = iterator.next();\n      if (iteration.done) {\n        return;\n      }\n      const itemPath = addPath(path, index, void 0);\n      this.completeListItemValue(completedResults, index, promises, iteration.value, exeContext, itemType, valueCompleter, fieldContext, info2, itemPath, responseNode);\n      index++;\n    }\n  }\n  completeIteratorValueWithoutStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, completedResults, _index, promises) {\n    let index = _index;\n    while (true) {\n      const iteration = iterator.next();\n      if (iteration.done) {\n        return index;\n      }\n      const itemPath = addPath(path, index, void 0);\n      this.completeListItemValue(completedResults, index, promises, iteration.value, exeContext, itemType, valueCompleter, fieldContext, info2, itemPath, responseNode);\n      index++;\n    }\n  }\n  async completeAsyncIteratorValue(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, stream, completedResults, promises) {\n    if (stream) {\n      await this.completeAsyncIteratorValueWithStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, stream, completedResults, promises);\n    } else {\n      await this.completeAsyncIteratorValueWithoutStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, completedResults, promises);\n    }\n    return promises.length ? resolveAfterAll(completedResults, promises) : completedResults;\n  }\n  async completeAsyncIteratorValueWithStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, stream, completedResults, promises) {\n    const initialCount = stream.initialCount;\n    let index = 0;\n    try {\n      while (true) {\n        if (index >= initialCount) {\n          const { maxChunkSize, maxInterval, inParallel, label } = stream;\n          const streamContext = this.createStreamContext(exeContext, initialCount, maxChunkSize, maxInterval, inParallel, path, label, responseNode);\n          this.addAsyncIteratorValue(index, iterator, exeContext, itemType, fieldContext, info2, valueCompleter, streamContext);\n          return;\n        }\n        const iteration = await iterator.next();\n        if (iteration.done) {\n          break;\n        }\n        const itemPath = addPath(path, index, void 0);\n        this.completeListItemValue(completedResults, index, promises, iteration.value, exeContext, itemType, valueCompleter, fieldContext, info2, itemPath, responseNode);\n        index++;\n      }\n    } catch (rawError) {\n      const itemPath = addPath(path, index, void 0);\n      completedResults.push(this.handleRawError(rawError, fieldContext.fieldNodes, itemPath, itemType, responseNode.errors));\n    }\n  }\n  async completeAsyncIteratorValueWithoutStream(exeContext, itemType, fieldContext, info2, valueCompleter, path, iterator, responseNode, completedResults, promises) {\n    let index = 0;\n    try {\n      while (true) {\n        const iteration = await iterator.next();\n        if (iteration.done) {\n          break;\n        }\n        const itemPath = addPath(path, index, void 0);\n        this.completeListItemValue(completedResults, index, promises, iteration.value, exeContext, itemType, valueCompleter, fieldContext, info2, itemPath, responseNode);\n        index++;\n      }\n    } catch (rawError) {\n      const itemPath = addPath(path, index, void 0);\n      completedResults.push(this.handleRawError(rawError, fieldContext.fieldNodes, itemPath, itemType, responseNode.errors));\n    }\n  }\n  completeListItemValue(completedResults, index, promises, item, exeContext, itemType, valueCompleter, fieldContext, info2, itemPath, responseNode) {\n    try {\n      let completedItem;\n      if (isPromise(item)) {\n        completedItem = item.then((resolved) => valueCompleter(exeContext, fieldContext, info2, itemPath, resolved, responseNode));\n      } else {\n        completedItem = valueCompleter(exeContext, fieldContext, info2, itemPath, item, responseNode);\n      }\n      completedResults[index] = completedItem;\n      if (!isPromise(completedItem)) {\n        return;\n      }\n      const promise = completedItem.then(void 0, (rawError) => this.handleRawError(rawError, fieldContext.fieldNodes, itemPath, itemType, responseNode.errors)).then((resolved) => {\n        completedResults[index] = resolved;\n      });\n      promises.push(promise);\n    } catch (rawError) {\n      completedResults[index] = this.handleRawError(rawError, fieldContext.fieldNodes, itemPath, itemType, responseNode.errors);\n    }\n  }\n  completeLeafValue(returnType, result2) {\n    const serializedResult = returnType.serialize(result2);\n    if (serializedResult == null) {\n      throw new Error(`Expected \\`${inspect(returnType)}.serialize(${inspect(result2)})\\` to return non-nullable value, returned: ${inspect(serializedResult)}`);\n    }\n    return serializedResult;\n  }\n  completeAbstractValue(exeContext, returnType, fieldContext, info2, path, result2, responseNode) {\n    var _returnType$resolveTy;\n    const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;\n    const contextValue = exeContext.contextValue;\n    const runtimeType = resolveTypeFn(result2, contextValue, info2, returnType);\n    if (isPromise(runtimeType)) {\n      return runtimeType.then((resolvedRuntimeType) => this.completeObjectValue(exeContext, this.ensureValidRuntimeType(resolvedRuntimeType, returnType, fieldContext, result2), fieldContext, info2, path, result2, responseNode));\n    }\n    return this.completeObjectValue(exeContext, this.ensureValidRuntimeType(runtimeType, returnType, fieldContext, result2), fieldContext, info2, path, result2, responseNode);\n  }\n  ensureValidRuntimeType(runtimeTypeOrName, returnType, fieldContext, result2) {\n    if (runtimeTypeOrName == null) {\n      throw new GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${fieldContext.parentType.name}.${fieldContext.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`, fieldContext.fieldNodes);\n    }\n    const runtimeTypeName = typeof runtimeTypeOrName === \"object\" && this._executorSchema.isNamedType(runtimeTypeOrName) ? runtimeTypeOrName.name : runtimeTypeOrName;\n    if (typeof runtimeTypeName !== \"string\") {\n      throw new GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${fieldContext.parentType.name}.${fieldContext.fieldName}\" with value ${inspect(result2)}, received \"${inspect(runtimeTypeName)}\".`);\n    }\n    const runtimeType = this._executorSchema.getNamedType(runtimeTypeName);\n    if (runtimeType == null) {\n      throw new GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`, fieldContext.fieldNodes);\n    }\n    if (!this._executorSchema.isObjectType(runtimeType)) {\n      throw new GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`, fieldContext.fieldNodes);\n    }\n    if (!this._executorSchema.isSubType(returnType, runtimeType)) {\n      throw new GraphQLError(`Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`, fieldContext.fieldNodes);\n    }\n    return runtimeType;\n  }\n  completeObjectValue(exeContext, returnType, fieldContext, info2, path, result2, responseNode) {\n    if (returnType.isTypeOf) {\n      const isTypeOf = returnType.isTypeOf(result2, exeContext.contextValue, info2);\n      if (isPromise(isTypeOf)) {\n        return isTypeOf.then((resolvedIsTypeOf) => {\n          if (!resolvedIsTypeOf) {\n            throw this.invalidReturnTypeError(returnType, result2, fieldContext.fieldNodes);\n          }\n          return this.collectAndExecuteSubfields(exeContext, returnType, fieldContext, path, result2, responseNode);\n        });\n      }\n      if (!isTypeOf) {\n        throw this.invalidReturnTypeError(returnType, result2, fieldContext.fieldNodes);\n      }\n    }\n    return this.collectAndExecuteSubfields(exeContext, returnType, fieldContext, path, result2, responseNode);\n  }\n  invalidReturnTypeError(returnType, result2, fieldNodes) {\n    return new GraphQLError(`Expected value of type \"${returnType.name}\" but got: ${inspect(result2)}.`, fieldNodes);\n  }\n  collectAndExecuteSubfields(exeContext, returnType, fieldContext, path, result2, responseNode) {\n    const { subFieldCollector } = exeContext;\n    const { fields: subFieldNodes, patches: subPatches } = subFieldCollector(returnType, fieldContext.fieldNodes);\n    const subFields = this.executeFields(exeContext, returnType, result2, path, subFieldNodes, responseNode);\n    this.addPatches(exeContext, subPatches, returnType, result2, path, responseNode);\n    return subFields;\n  }\n  _getFieldContext(parentType, fieldNodes) {\n    const initialFieldNode = fieldNodes[0];\n    const fieldName = initialFieldNode.name.value;\n    let fieldDef;\n    if (fieldName === SchemaMetaFieldDef.name && this._executorSchema.getRootType(\"query\") === parentType) {\n      fieldDef = SchemaMetaFieldDef;\n    } else if (fieldName === TypeMetaFieldDef.name && this._executorSchema.getRootType(\"query\") === parentType) {\n      fieldDef = TypeMetaFieldDef;\n    } else if (fieldName === TypeNameMetaFieldDef.name) {\n      fieldDef = TypeNameMetaFieldDef;\n    } else {\n      fieldDef = parentType.getFields()[fieldName];\n    }\n    if (!fieldDef) {\n      return;\n    }\n    return {\n      fieldDef,\n      initialFieldNode,\n      fieldName: fieldDef.name,\n      fieldNodes,\n      returnType: fieldDef.type,\n      parentType\n    };\n  }\n  async executeSubscriptionImpl(exeContext) {\n    return this.executeOperationImpl(exeContext, this.executeRootSubscriptionFields.bind(this), this.buildSubscribeResponse.bind(this));\n  }\n  async executeRootSubscriptionFields(exeContext, parentType, sourceValue, path, fields, responseNode) {\n    const [responseName, fieldNodes] = [...fields.entries()][0];\n    const fieldPath = addPath(path, responseName, parentType.name);\n    return this.executeRootSubscriptionField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, responseNode);\n  }\n  buildCreateSourceEventStreamResponse(exeContext, eventStream) {\n    const { rootResponseNode } = exeContext;\n    const errors2 = rootResponseNode.errors;\n    if (errors2.length) {\n      return {\n        errors: errors2\n      };\n    }\n    if (!isAsyncIterable(eventStream)) {\n      throw new Error(`Subscription field must return Async Iterable. Received: ${inspect(eventStream)}.`);\n    }\n    return eventStream;\n  }\n  buildSubscribeResponse(exeContext, _eventStream) {\n    const eventStream = this.buildCreateSourceEventStreamResponse(exeContext, _eventStream);\n    if (!isAsyncIterable(eventStream)) {\n      return eventStream;\n    }\n    const mapSourceToResponse = (payload) => {\n      const perPayloadExecutionContext = this.buildPerPayloadExecutionContext(exeContext, payload);\n      return this.executeQueryImpl(perPayloadExecutionContext);\n    };\n    return flattenAsyncIterable(mapAsyncIterable(eventStream, mapSourceToResponse));\n  }\n  async createSourceEventStreamImpl(exeContext) {\n    return this.executeOperationImpl(exeContext, this.executeRootSubscriptionFields.bind(this), this.buildCreateSourceEventStreamResponse.bind(this));\n  }\n  async executeRootSubscriptionField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, responseNode) {\n    const fieldContext = this.getFieldContext(parentType, fieldNodes);\n    if (!fieldContext) {\n      const fieldName = fieldNodes[0].name.value;\n      responseNode.errors.push(new GraphQLError(`The subscription field \"${fieldName}\" is not defined.`, fieldNodes));\n      return null;\n    }\n    const info2 = this.buildResolveInfo(exeContext, fieldContext, fieldPath);\n    try {\n      const eventStream = await exeContext.resolveField(exeContext, fieldContext, sourceValue, info2);\n      if (eventStream instanceof Error) {\n        throw eventStream;\n      }\n      return eventStream;\n    } catch (rawError) {\n      responseNode.errors.push(this.toLocatedError(rawError, fieldNodes, fieldPath));\n      return null;\n    }\n  }\n  addPatches(exeContext, patches, parentType, source, path, parentResponseNode) {\n    const { state, publisher } = exeContext;\n    for (const patch of patches) {\n      state.pendingPushes++;\n      const { label, fields: patchFields } = patch;\n      const errors2 = [];\n      const responseNode = {\n        errors: errors2\n      };\n      const responseContext = {\n        responseNodes: [responseNode],\n        parentResponseNode\n      };\n      Promise.resolve(source).then(() => this.executeFields(exeContext, parentType, source, path, patchFields, responseNode)).then((data) => publisher.queue(responseContext.responseNodes, {\n        responseContext,\n        data,\n        path,\n        label\n      }, responseContext.parentResponseNode), (error2) => {\n        errors2.push(error2);\n        publisher.queue(responseContext.responseNodes, {\n          responseContext,\n          data: null,\n          path,\n          label\n        }, responseContext.parentResponseNode);\n      });\n    }\n  }\n  addIteratorValue(initialIndex, iterator, exeContext, itemType, fieldContext, info2, valueCompleter, streamContext) {\n    let index = initialIndex;\n    let iteration = iterator.next();\n    while (!iteration.done) {\n      this.addValue(iteration.value, exeContext, itemType, fieldContext, info2, valueCompleter, index, streamContext);\n      index++;\n      iteration = iterator.next();\n    }\n    return index;\n  }\n  async addAsyncIteratorValue(initialIndex, iterator, exeContext, itemType, fieldContext, info2, valueCompleter, streamContext) {\n    exeContext.state.iterators.add(iterator);\n    let index = initialIndex;\n    try {\n      let iteration = await iterator.next();\n      while (!iteration.done) {\n        this.addValue(iteration.value, exeContext, itemType, fieldContext, info2, valueCompleter, index, streamContext);\n        index++;\n        iteration = await iterator.next();\n      }\n      streamContext.bundler.setTotal(index);\n    } catch (rawError) {\n      exeContext.state.pendingStreamResults++;\n      this.handleRawStreamError(fieldContext, itemType, streamContext, rawError, index);\n      streamContext.bundler.setTotal(index + 1);\n    }\n    this.closeAsyncIterator(exeContext, iterator);\n  }\n  handleRawStreamError(fieldContext, itemType, streamContext, rawError, index) {\n    const { path } = streamContext;\n    const itemPath = addPath(path, index, void 0);\n    const error2 = this.toLocatedError(rawError, fieldContext.fieldNodes, itemPath);\n    if (this._executorSchema.isNonNullType(itemType)) {\n      streamContext.bundler.queueError(index, {\n        errors: [error2]\n      });\n    } else {\n      streamContext.bundler.queueData(index, {\n        responseNode: {\n          errors: [error2]\n        },\n        data: null\n      });\n    }\n  }\n  addValue(value, exeContext, itemType, fieldContext, info2, valueCompleter, index, streamContext) {\n    const itemPath = addPath(streamContext.path, index, void 0);\n    const responseNode = {\n      errors: []\n    };\n    exeContext.state.pendingStreamResults++;\n    Promise.resolve(value).then((resolved) => valueCompleter(exeContext, fieldContext, info2, itemPath, resolved, responseNode)).then((data) => streamContext.bundler.queueData(index, {\n      responseNode,\n      data\n    }), (rawError) => this.handleRawStreamError(fieldContext, itemType, streamContext, rawError, index));\n  }\n  closeAsyncIterator(exeContext, iterator) {\n    const { state, publisher } = exeContext;\n    state.iterators.delete(iterator);\n    if (!this.hasNext(exeContext.state)) {\n      publisher.stop({\n        hasNext: false\n      });\n    }\n  }\n  hasNext(state) {\n    return state.pendingPushes > 0 || state.pendingStreamResults > 0 || state.iterators.size > 0;\n  }\n  collectFieldsImpl(fragments, variableValues, getDeferValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n      switch (selection.kind) {\n        case Kind.FIELD: {\n          if (!this.shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          const name2 = this.getFieldEntryKey(selection);\n          const fieldList = fields.get(name2);\n          if (fieldList !== void 0) {\n            fields.set(name2, this.updateFieldList(fieldList, selection));\n          } else {\n            fields.set(name2, this.createFieldList(selection));\n          }\n          break;\n        }\n        case Kind.INLINE_FRAGMENT: {\n          if (!this.shouldIncludeNode(variableValues, selection) || !this.doesFragmentConditionMatch(selection, runtimeType)) {\n            continue;\n          }\n          const defer = getDeferValues(variableValues, selection);\n          if (defer) {\n            const patchFields = /* @__PURE__ */ new Map();\n            this.collectFieldsImpl(fragments, variableValues, getDeferValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);\n            patches.push({\n              label: defer.label,\n              fields: patchFields\n            });\n          } else {\n            this.collectFieldsImpl(fragments, variableValues, getDeferValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);\n          }\n          break;\n        }\n        case Kind.FRAGMENT_SPREAD: {\n          const fragName = selection.name.value;\n          if (!this.shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          const defer = getDeferValues(variableValues, selection);\n          if (visitedFragmentNames.has(fragName) && !defer) {\n            continue;\n          }\n          const fragment = fragments[fragName];\n          if (!fragment || !this.doesFragmentConditionMatch(fragment, runtimeType)) {\n            continue;\n          }\n          if (defer) {\n            const patchFields = /* @__PURE__ */ new Map();\n            this.collectFieldsImpl(fragments, variableValues, getDeferValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);\n            patches.push({\n              label: defer.label,\n              fields: patchFields\n            });\n          } else {\n            visitedFragmentNames.add(fragName);\n            this.collectFieldsImpl(fragments, variableValues, getDeferValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);\n          }\n          break;\n        }\n      }\n    }\n  }\n  getDeferValues(variableValues, node) {\n    const defer = getDirectiveValues(this._executorSchema, GraphQLDeferDirective, node, variableValues);\n    if (!defer) {\n      return;\n    }\n    if (defer.if === false) {\n      return;\n    }\n    return {\n      label: typeof defer.label === \"string\" ? defer.label : void 0\n    };\n  }\n  shouldIncludeNode(variableValues, node) {\n    const skip2 = getDirectiveValues(this._executorSchema, GraphQLSkipDirective, node, variableValues);\n    if ((skip2 === null || skip2 === void 0 ? void 0 : skip2.if) === true) {\n      return false;\n    }\n    const include = getDirectiveValues(this._executorSchema, GraphQLIncludeDirective, node, variableValues);\n    if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n      return false;\n    }\n    return true;\n  }\n  doesFragmentConditionMatch(fragment, type2) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n      return true;\n    }\n    const conditionalType = this._executorSchema.getType(typeConditionNode);\n    if (conditionalType === type2) {\n      return true;\n    }\n    if (conditionalType && this._executorSchema.isAbstractType(conditionalType)) {\n      return this._executorSchema.isSubType(conditionalType, type2);\n    }\n    return false;\n  }\n  getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n  }\n}\nconst defaultFieldResolver = function(source, args, contextValue, info2) {\n  if (isObjectLike(source) || typeof source === \"function\") {\n    const property = source[info2.fieldName];\n    if (typeof property === \"function\") {\n      return source[info2.fieldName](args, contextValue, info2);\n    }\n    return property;\n  }\n};\nconst defaultTypeResolver = function(value, contextValue, info2, abstractType) {\n  if (isObjectLike(value) && typeof value.__typename === \"string\") {\n    return value.__typename;\n  }\n  const possibleTypes = info2.executorSchema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type2 = possibleTypes[i];\n    if (type2.isTypeOf) {\n      const isTypeOfResult = type2.isTypeOf(value, contextValue, info2);\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type2.name;\n      }\n    }\n  }\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\nfunction isPromiseLike$1(object) {\n  return object != null && typeof object.then === \"function\";\n}\nconst defaultOnRejectedFn = (reason) => {\n  throw reason;\n};\nclass ValueOrPromise {\n  constructor(executor) {\n    let value;\n    try {\n      value = executor();\n    } catch (reason) {\n      this.state = { status: \"rejected\", value: reason };\n      return;\n    }\n    if (isPromiseLike$1(value)) {\n      this.state = { status: \"pending\", value };\n      return;\n    }\n    this.state = { status: \"fulfilled\", value };\n  }\n  then(onFulfilled, onRejected) {\n    const state = this.state;\n    if (state.status === \"pending\") {\n      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));\n    }\n    const onRejectedFn = typeof onRejected === \"function\" ? onRejected : defaultOnRejectedFn;\n    if (state.status === \"rejected\") {\n      return new ValueOrPromise(() => onRejectedFn(state.value));\n    }\n    try {\n      const onFulfilledFn = typeof onFulfilled === \"function\" ? onFulfilled : void 0;\n      return onFulfilledFn === void 0 ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));\n    } catch (e) {\n      return new ValueOrPromise(() => onRejectedFn(e));\n    }\n  }\n  catch(onRejected) {\n    return this.then(void 0, onRejected);\n  }\n  resolve() {\n    const state = this.state;\n    if (state.status === \"pending\") {\n      return Promise.resolve(state.value);\n    }\n    if (state.status === \"rejected\") {\n      throw state.value;\n    }\n    return state.value;\n  }\n  static all(valueOrPromises) {\n    let containsPromise = false;\n    const values = [];\n    for (const valueOrPromise of valueOrPromises) {\n      const state = valueOrPromise.state;\n      if (state.status === \"rejected\") {\n        return new ValueOrPromise(() => {\n          throw state.value;\n        });\n      }\n      if (state.status === \"pending\") {\n        containsPromise = true;\n      }\n      values.push(state.value);\n    }\n    if (containsPromise) {\n      return new ValueOrPromise(() => Promise.all(values));\n    }\n    return new ValueOrPromise(() => values);\n  }\n}\nvar DataLoader = /* @__PURE__ */ function() {\n  function DataLoader2(batchLoadFn, options) {\n    if (typeof batchLoadFn !== \"function\") {\n      throw new TypeError(\"DataLoader must be constructed with a function which accepts \" + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n    }\n    this._batchLoadFn = batchLoadFn;\n    this._maxBatchSize = getValidMaxBatchSize(options);\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\n    this._cacheKeyFn = getValidCacheKeyFn(options);\n    this._cacheMap = getValidCacheMap(options);\n    this._batch = null;\n  }\n  var _proto = DataLoader2.prototype;\n  _proto.load = function load(key) {\n    if (key === null || key === void 0) {\n      throw new TypeError(\"The loader.load() function must be called with a value,\" + (\"but got: \" + String(key) + \".\"));\n    }\n    var batch = getCurrentBatch(this);\n    var cacheMap = this._cacheMap;\n    var cacheKey = this._cacheKeyFn(key);\n    if (cacheMap) {\n      var cachedPromise = cacheMap.get(cacheKey);\n      if (cachedPromise) {\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n        return new Promise(function(resolve) {\n          cacheHits.push(function() {\n            return resolve(cachedPromise);\n          });\n        });\n      }\n    }\n    batch.keys.push(key);\n    var promise = new Promise(function(resolve, reject2) {\n      batch.callbacks.push({\n        resolve,\n        reject: reject2\n      });\n    });\n    if (cacheMap) {\n      cacheMap.set(cacheKey, promise);\n    }\n    return promise;\n  };\n  _proto.loadMany = function loadMany(keys) {\n    if (!isArrayLike(keys)) {\n      throw new TypeError(\"The loader.loadMany() function must be called with Array<key> \" + (\"but got: \" + keys + \".\"));\n    }\n    var loadPromises = [];\n    for (var i = 0; i < keys.length; i++) {\n      loadPromises.push(this.load(keys[i])[\"catch\"](function(error2) {\n        return error2;\n      }));\n    }\n    return Promise.all(loadPromises);\n  };\n  _proto.clear = function clear(key) {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n      cacheMap[\"delete\"](cacheKey);\n    }\n    return this;\n  };\n  _proto.clearAll = function clearAll() {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      cacheMap.clear();\n    }\n    return this;\n  };\n  _proto.prime = function prime2(key, value) {\n    var cacheMap = this._cacheMap;\n    if (cacheMap) {\n      var cacheKey = this._cacheKeyFn(key);\n      if (cacheMap.get(cacheKey) === void 0) {\n        var promise;\n        if (value instanceof Error) {\n          promise = Promise.reject(value);\n          promise[\"catch\"](function() {\n          });\n        } else {\n          promise = Promise.resolve(value);\n        }\n        cacheMap.set(cacheKey, promise);\n      }\n    }\n    return this;\n  };\n  return DataLoader2;\n}();\nvar enqueuePostPromiseJob = typeof process === \"object\" && typeof process.nextTick === \"function\" ? function(fn) {\n  if (!resolvedPromise) {\n    resolvedPromise = Promise.resolve();\n  }\n  resolvedPromise.then(function() {\n    return process.nextTick(fn);\n  });\n} : setImmediate || setTimeout;\nvar resolvedPromise;\nfunction getCurrentBatch(loader) {\n  var existingBatch = loader._batch;\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {\n    return existingBatch;\n  }\n  var newBatch = {\n    hasDispatched: false,\n    keys: [],\n    callbacks: []\n  };\n  loader._batch = newBatch;\n  loader._batchScheduleFn(function() {\n    return dispatchBatch(loader, newBatch);\n  });\n  return newBatch;\n}\nfunction dispatchBatch(loader, batch) {\n  batch.hasDispatched = true;\n  if (batch.keys.length === 0) {\n    resolveCacheHits(batch);\n    return;\n  }\n  var batchPromise = loader._batchLoadFn(batch.keys);\n  if (!batchPromise || typeof batchPromise.then !== \"function\") {\n    return failedDispatch(loader, batch, new TypeError(\"DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did \" + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n  }\n  batchPromise.then(function(values) {\n    if (!isArrayLike(values)) {\n      throw new TypeError(\"DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did \" + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n    }\n    if (values.length !== batch.keys.length) {\n      throw new TypeError(\"DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.\" + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n    }\n    resolveCacheHits(batch);\n    for (var i = 0; i < batch.callbacks.length; i++) {\n      var value = values[i];\n      if (value instanceof Error) {\n        batch.callbacks[i].reject(value);\n      } else {\n        batch.callbacks[i].resolve(value);\n      }\n    }\n  })[\"catch\"](function(error2) {\n    return failedDispatch(loader, batch, error2);\n  });\n}\nfunction failedDispatch(loader, batch, error2) {\n  resolveCacheHits(batch);\n  for (var i = 0; i < batch.keys.length; i++) {\n    loader.clear(batch.keys[i]);\n    batch.callbacks[i].reject(error2);\n  }\n}\nfunction resolveCacheHits(batch) {\n  if (batch.cacheHits) {\n    for (var i = 0; i < batch.cacheHits.length; i++) {\n      batch.cacheHits[i]();\n    }\n  }\n}\nfunction getValidMaxBatchSize(options) {\n  var shouldBatch = !options || options.batch !== false;\n  if (!shouldBatch) {\n    return 1;\n  }\n  var maxBatchSize = options && options.maxBatchSize;\n  if (maxBatchSize === void 0) {\n    return Infinity;\n  }\n  if (typeof maxBatchSize !== \"number\" || maxBatchSize < 1) {\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n  }\n  return maxBatchSize;\n}\nfunction getValidBatchScheduleFn(options) {\n  var batchScheduleFn = options && options.batchScheduleFn;\n  if (batchScheduleFn === void 0) {\n    return enqueuePostPromiseJob;\n  }\n  if (typeof batchScheduleFn !== \"function\") {\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n  }\n  return batchScheduleFn;\n}\nfunction getValidCacheKeyFn(options) {\n  var cacheKeyFn = options && options.cacheKeyFn;\n  if (cacheKeyFn === void 0) {\n    return function(key) {\n      return key;\n    };\n  }\n  if (typeof cacheKeyFn !== \"function\") {\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n  }\n  return cacheKeyFn;\n}\nfunction getValidCacheMap(options) {\n  var shouldCache = !options || options.cache !== false;\n  if (!shouldCache) {\n    return null;\n  }\n  var cacheMap = options && options.cacheMap;\n  if (cacheMap === void 0) {\n    return /* @__PURE__ */ new Map();\n  }\n  if (cacheMap !== null) {\n    var cacheFunctions = [\"get\", \"set\", \"delete\", \"clear\"];\n    var missingFunctions = cacheFunctions.filter(function(fnName) {\n      return cacheMap && typeof cacheMap[fnName] !== \"function\";\n    });\n    if (missingFunctions.length !== 0) {\n      throw new TypeError(\"Custom cacheMap missing methods: \" + missingFunctions.join(\", \"));\n    }\n  }\n  return cacheMap;\n}\nfunction isArrayLike(x2) {\n  return typeof x2 === \"object\" && x2 !== null && typeof x2.length === \"number\" && (x2.length === 0 || x2.length > 0 && Object.prototype.hasOwnProperty.call(x2, x2.length - 1));\n}\nvar dataloader = DataLoader;\nfunction createPrefix(index) {\n  return `_${index}_`;\n}\nfunction parseKey(prefixedKey) {\n  const match2 = /^_([\\d]+)_(.*)$/.exec(prefixedKey);\n  if (match2 && match2.length === 3 && !isNaN(Number(match2[1])) && match2[2]) {\n    return { index: Number(match2[1]), originalKey: match2[2] };\n  }\n  throw new Error(`Key ${prefixedKey} is not correctly prefixed`);\n}\nfunction mergeRequests(requests, extensionsReducer) {\n  var _a2, _b, _c, _d, _e;\n  const mergedVariables = /* @__PURE__ */ Object.create(null);\n  const mergedVariableDefinitions = [];\n  const mergedSelections = [];\n  const mergedFragmentDefinitions = [];\n  let mergedExtensions = /* @__PURE__ */ Object.create(null);\n  for (const index in requests) {\n    const request = requests[index];\n    const prefixedRequests = prefixRequest(createPrefix(index), request);\n    for (const def of prefixedRequests.document.definitions) {\n      if (isOperationDefinition(def)) {\n        mergedSelections.push(...def.selectionSet.selections);\n        if (def.variableDefinitions) {\n          mergedVariableDefinitions.push(...def.variableDefinitions);\n        }\n      }\n      if (isFragmentDefinition(def)) {\n        mergedFragmentDefinitions.push(def);\n      }\n    }\n    Object.assign(mergedVariables, prefixedRequests.variables);\n    mergedExtensions = extensionsReducer(mergedExtensions, request);\n  }\n  const firstRequest = requests[0];\n  const operationType = (_a2 = firstRequest.operationType) !== null && _a2 !== void 0 ? _a2 : getOperationASTFromRequest(firstRequest).operation;\n  const mergedOperationDefinition = {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: operationType,\n    variableDefinitions: mergedVariableDefinitions,\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: mergedSelections\n    }\n  };\n  const operationName = (_b = firstRequest.operationName) !== null && _b !== void 0 ? _b : (_e = (_d = (_c = firstRequest.info) === null || _c === void 0 ? void 0 : _c.operation) === null || _d === void 0 ? void 0 : _d.name) === null || _e === void 0 ? void 0 : _e.value;\n  if (operationName) {\n    mergedOperationDefinition.name = {\n      kind: Kind.NAME,\n      value: operationName\n    };\n  }\n  return {\n    document: {\n      kind: Kind.DOCUMENT,\n      definitions: [mergedOperationDefinition, ...mergedFragmentDefinitions]\n    },\n    variables: mergedVariables,\n    extensions: mergedExtensions,\n    context: requests[0].context,\n    info: requests[0].info,\n    operationType\n  };\n}\nfunction prefixRequest(prefix, request) {\n  var _a2;\n  const executionVariables = (_a2 = request.variables) !== null && _a2 !== void 0 ? _a2 : {};\n  function prefixNode(node) {\n    return prefixNodeName(node, prefix);\n  }\n  let prefixedDocument = aliasTopLevelFields(prefix, request.document);\n  const executionVariableNames = Object.keys(executionVariables);\n  const hasFragmentDefinitions = request.document.definitions.some((def) => isFragmentDefinition(def));\n  const fragmentSpreadImpl = {};\n  if (executionVariableNames.length > 0 || hasFragmentDefinitions) {\n    prefixedDocument = visit(prefixedDocument, {\n      [Kind.VARIABLE]: prefixNode,\n      [Kind.FRAGMENT_DEFINITION]: prefixNode,\n      [Kind.FRAGMENT_SPREAD]: (node) => {\n        node = prefixNodeName(node, prefix);\n        fragmentSpreadImpl[node.name.value] = true;\n        return node;\n      }\n    });\n  }\n  const prefixedVariables = {};\n  for (const variableName of executionVariableNames) {\n    prefixedVariables[prefix + variableName] = executionVariables[variableName];\n  }\n  if (hasFragmentDefinitions) {\n    prefixedDocument = __spreadProps(__spreadValues({}, prefixedDocument), {\n      definitions: prefixedDocument.definitions.filter((def) => {\n        return !isFragmentDefinition(def) || fragmentSpreadImpl[def.name.value];\n      })\n    });\n  }\n  return {\n    document: prefixedDocument,\n    variables: prefixedVariables\n  };\n}\nfunction aliasTopLevelFields(prefix, document2) {\n  const transformer = {\n    [Kind.OPERATION_DEFINITION]: (def) => {\n      const { selections } = def.selectionSet;\n      return __spreadProps(__spreadValues({}, def), {\n        selectionSet: __spreadProps(__spreadValues({}, def.selectionSet), {\n          selections: aliasFieldsInSelection(prefix, selections, document2)\n        })\n      });\n    }\n  };\n  return visit(document2, transformer, {\n    [Kind.DOCUMENT]: [`definitions`]\n  });\n}\nfunction aliasFieldsInSelection(prefix, selections, document2) {\n  return selections.map((selection) => {\n    switch (selection.kind) {\n      case Kind.INLINE_FRAGMENT:\n        return aliasFieldsInInlineFragment(prefix, selection, document2);\n      case Kind.FRAGMENT_SPREAD: {\n        const inlineFragment = inlineFragmentSpread(selection, document2);\n        return aliasFieldsInInlineFragment(prefix, inlineFragment, document2);\n      }\n      case Kind.FIELD:\n      default:\n        return aliasField(selection, prefix);\n    }\n  });\n}\nfunction aliasFieldsInInlineFragment(prefix, fragment, document2) {\n  const { selections } = fragment.selectionSet;\n  return __spreadProps(__spreadValues({}, fragment), {\n    selectionSet: __spreadProps(__spreadValues({}, fragment.selectionSet), {\n      selections: aliasFieldsInSelection(prefix, selections, document2)\n    })\n  });\n}\nfunction inlineFragmentSpread(spread, document2) {\n  const fragment = document2.definitions.find((def) => isFragmentDefinition(def) && def.name.value === spread.name.value);\n  if (!fragment) {\n    throw new Error(`Fragment ${spread.name.value} does not exist`);\n  }\n  const { typeCondition, selectionSet } = fragment;\n  return {\n    kind: Kind.INLINE_FRAGMENT,\n    typeCondition,\n    selectionSet,\n    directives: spread.directives\n  };\n}\nfunction prefixNodeName(namedNode, prefix) {\n  return __spreadProps(__spreadValues({}, namedNode), {\n    name: __spreadProps(__spreadValues({}, namedNode.name), {\n      value: prefix + namedNode.name.value\n    })\n  });\n}\nfunction aliasField(field, aliasPrefix) {\n  const aliasNode = field.alias ? field.alias : field.name;\n  return __spreadProps(__spreadValues({}, field), {\n    alias: __spreadProps(__spreadValues({}, aliasNode), {\n      value: aliasPrefix + aliasNode.value\n    })\n  });\n}\nfunction isOperationDefinition(def) {\n  return def.kind === Kind.OPERATION_DEFINITION;\n}\nfunction isFragmentDefinition(def) {\n  return def.kind === Kind.FRAGMENT_DEFINITION;\n}\nfunction splitResult({ data, errors: errors2 }, numResults) {\n  const splitResults = [];\n  for (let i = 0; i < numResults; i++) {\n    splitResults.push({});\n  }\n  if (data) {\n    for (const prefixedKey in data) {\n      const { index, originalKey } = parseKey(prefixedKey);\n      const result2 = splitResults[index];\n      if (result2 == null) {\n        continue;\n      }\n      if (result2.data == null) {\n        result2.data = { [originalKey]: data[prefixedKey] };\n      } else {\n        result2.data[originalKey] = data[prefixedKey];\n      }\n    }\n  }\n  if (errors2) {\n    for (const error2 of errors2) {\n      if (error2.path) {\n        const parsedKey = parseKey(error2.path[0]);\n        const { index, originalKey } = parsedKey;\n        const newError = relocatedError(error2, [originalKey, ...error2.path.slice(1)]);\n        const resultErrors = splitResults[index].errors = splitResults[index].errors || [];\n        resultErrors.push(newError);\n      } else {\n        splitResults.forEach((result2) => {\n          const resultErrors = result2.errors = result2.errors || [];\n          resultErrors.push(new GraphQLError(error2.message));\n        });\n      }\n    }\n  }\n  return splitResults;\n}\nfunction createBatchingExecutor(executor, dataLoaderOptions, extensionsReducer = defaultExtensionsReducer) {\n  const loadFn = createLoadFn(executor, extensionsReducer);\n  const loader = new dataloader(loadFn, dataLoaderOptions);\n  return function batchingExecutor(request) {\n    const operationAst = getOperationASTFromRequest(request);\n    return operationAst.operation === \"subscription\" ? executor(request) : loader.load(request);\n  };\n}\nfunction createLoadFn(executor, extensionsReducer) {\n  return async function batchExecuteLoadFn(requests) {\n    const execBatches = [];\n    let index = 0;\n    const request = requests[index];\n    let currentBatch = [request];\n    execBatches.push(currentBatch);\n    const operationAst = getOperationASTFromRequest(request);\n    const operationType = operationAst.operation;\n    if (operationType == null) {\n      throw new Error(\"could not identify operation type of document\");\n    }\n    while (++index < requests.length) {\n      const currentRequest = requests[index];\n      const currentOperationAST = getOperationASTFromRequest(currentRequest);\n      const currentOperationType = currentOperationAST.operation;\n      if (operationType === currentOperationType) {\n        currentBatch.push(currentRequest);\n      } else {\n        currentBatch = [currentRequest];\n        execBatches.push(currentBatch);\n      }\n    }\n    const results = await Promise.all(execBatches.map(async (execBatch) => {\n      const mergedRequests = mergeRequests(execBatch, extensionsReducer);\n      const resultBatches = await executor(mergedRequests);\n      return splitResult(resultBatches, execBatch.length);\n    }));\n    return results.flat();\n  };\n}\nfunction defaultExtensionsReducer(mergedExtensions, request) {\n  const newExtensions = request.extensions;\n  if (newExtensions != null) {\n    Object.assign(mergedExtensions, newExtensions);\n  }\n  return mergedExtensions;\n}\nconst getBatchingExecutor = memoize2of4(function getBatchingExecutor2(_context, executor, dataLoaderOptions, extensionsReducer) {\n  return createBatchingExecutor(executor, dataLoaderOptions, extensionsReducer);\n});\nfunction applySchemaTransforms(originalWrappingSchema, subschemaConfig, transformedSchema) {\n  const schemaTransforms = subschemaConfig.transforms;\n  if (schemaTransforms == null) {\n    return originalWrappingSchema;\n  }\n  return schemaTransforms.reduce((schema, transform) => transform.transformSchema != null ? transform.transformSchema(schema, subschemaConfig, transformedSchema) : schema, originalWrappingSchema);\n}\nclass Subschema {\n  constructor(config2) {\n    var _a2;\n    this.schema = config2.schema;\n    this.executor = config2.executor;\n    this.batch = config2.batch;\n    this.batchingOptions = config2.batchingOptions;\n    this.createProxyingResolver = config2.createProxyingResolver;\n    this.transforms = (_a2 = config2.transforms) !== null && _a2 !== void 0 ? _a2 : [];\n    this.transformedSchema = applySchemaTransforms(this.schema, config2);\n    this.merge = config2.merge;\n  }\n}\nfunction getDocumentMetadata(document2) {\n  const operations = [];\n  const fragments = [];\n  const fragmentNames = /* @__PURE__ */ new Set();\n  for (let i = 0; i < document2.definitions.length; i++) {\n    const def = document2.definitions[i];\n    if (def.kind === Kind.FRAGMENT_DEFINITION) {\n      fragments.push(def);\n      fragmentNames.add(def.name.value);\n    } else if (def.kind === Kind.OPERATION_DEFINITION) {\n      operations.push(def);\n    }\n  }\n  return {\n    operations,\n    fragments,\n    fragmentNames\n  };\n}\nfunction prepareGatewayDocument(originalDocument, transformedSchema, returnType, infoSchema) {\n  const wrappedConcreteTypesDocument = wrapConcreteTypes(returnType, transformedSchema, originalDocument);\n  if (infoSchema == null) {\n    return wrappedConcreteTypesDocument;\n  }\n  const { possibleTypesMap, reversePossibleTypesMap: reversePossibleTypesMap2, interfaceExtensionsMap, fieldNodesByType, fieldNodesByField, dynamicSelectionSetsByField } = getSchemaMetaData(infoSchema, transformedSchema);\n  const { operations, fragments, fragmentNames } = getDocumentMetadata(wrappedConcreteTypesDocument);\n  const { expandedFragments, fragmentReplacements } = getExpandedFragments(fragments, fragmentNames, possibleTypesMap);\n  const typeInfo = new TypeInfo(transformedSchema);\n  const expandedDocument = {\n    kind: Kind.DOCUMENT,\n    definitions: [...operations, ...fragments, ...expandedFragments]\n  };\n  const visitorKeyMap = {\n    Document: [\"definitions\"],\n    OperationDefinition: [\"selectionSet\"],\n    SelectionSet: [\"selections\"],\n    Field: [\"selectionSet\"],\n    InlineFragment: [\"selectionSet\"],\n    FragmentDefinition: [\"selectionSet\"]\n  };\n  return visit(expandedDocument, visitWithTypeInfo(typeInfo, {\n    [Kind.SELECTION_SET]: (node) => visitSelectionSet(node, fragmentReplacements, transformedSchema, typeInfo, possibleTypesMap, reversePossibleTypesMap2, interfaceExtensionsMap, fieldNodesByType, fieldNodesByField, dynamicSelectionSetsByField)\n  }), visitorKeyMap);\n}\nfunction visitSelectionSet(node, fragmentReplacements, schema, typeInfo, possibleTypesMap, reversePossibleTypesMap2, interfaceExtensionsMap, fieldNodesByType, fieldNodesByField, dynamicSelectionSetsByField) {\n  var _a2, _b;\n  const newSelections = /* @__PURE__ */ new Set();\n  const maybeType = typeInfo.getParentType();\n  if (maybeType != null) {\n    const parentType = getNamedType(maybeType);\n    const parentTypeName = parentType.name;\n    const fieldNodes = fieldNodesByType[parentTypeName];\n    if (fieldNodes) {\n      for (const fieldNode of fieldNodes) {\n        newSelections.add(fieldNode);\n      }\n    }\n    const interfaceExtensions = interfaceExtensionsMap[parentType.name];\n    const interfaceExtensionFields = [];\n    for (const selection of node.selections) {\n      if (selection.kind === Kind.INLINE_FRAGMENT) {\n        if (selection.typeCondition != null) {\n          const possibleTypes = possibleTypesMap[selection.typeCondition.name.value];\n          if (possibleTypes == null) {\n            newSelections.add(selection);\n            continue;\n          }\n          for (const possibleTypeName of possibleTypes) {\n            const maybePossibleType = schema.getType(possibleTypeName);\n            if (maybePossibleType != null && implementsAbstractType(schema, parentType, maybePossibleType)) {\n              newSelections.add(generateInlineFragment(possibleTypeName, selection.selectionSet));\n            }\n          }\n        }\n      } else if (selection.kind === Kind.FRAGMENT_SPREAD) {\n        const fragmentName = selection.name.value;\n        if (!fragmentReplacements[fragmentName]) {\n          newSelections.add(selection);\n          continue;\n        }\n        for (const replacement of fragmentReplacements[fragmentName]) {\n          const typeName = replacement.typeName;\n          const maybeReplacementType = schema.getType(typeName);\n          if (maybeReplacementType != null && implementsAbstractType(schema, parentType, maybeType)) {\n            newSelections.add({\n              kind: Kind.FRAGMENT_SPREAD,\n              name: {\n                kind: Kind.NAME,\n                value: replacement.fragmentName\n              }\n            });\n          }\n        }\n      } else {\n        const fieldName = selection.name.value;\n        const fieldNodes2 = (_a2 = fieldNodesByField[parentTypeName]) === null || _a2 === void 0 ? void 0 : _a2[fieldName];\n        if (fieldNodes2 != null) {\n          for (const fieldNode of fieldNodes2) {\n            newSelections.add(fieldNode);\n          }\n        }\n        const dynamicSelectionSets = (_b = dynamicSelectionSetsByField[parentTypeName]) === null || _b === void 0 ? void 0 : _b[fieldName];\n        if (dynamicSelectionSets != null) {\n          for (const selectionSetFn of dynamicSelectionSets) {\n            const selectionSet = selectionSetFn(selection);\n            if (selectionSet != null) {\n              for (const selection2 of selectionSet.selections) {\n                newSelections.add(selection2);\n              }\n            }\n          }\n        }\n        if (interfaceExtensions === null || interfaceExtensions === void 0 ? void 0 : interfaceExtensions[fieldName]) {\n          interfaceExtensionFields.push(selection);\n        } else {\n          newSelections.add(selection);\n        }\n      }\n    }\n    if (reversePossibleTypesMap2[parentType.name]) {\n      newSelections.add({\n        kind: Kind.FIELD,\n        name: {\n          kind: Kind.NAME,\n          value: \"__typename\"\n        }\n      });\n    }\n    if (interfaceExtensionFields.length) {\n      const possibleTypes = possibleTypesMap[parentType.name];\n      if (possibleTypes != null) {\n        for (const possibleType of possibleTypes) {\n          newSelections.add(generateInlineFragment(possibleType, {\n            kind: Kind.SELECTION_SET,\n            selections: interfaceExtensionFields\n          }));\n        }\n      }\n    }\n    return __spreadProps(__spreadValues({}, node), {\n      selections: Array.from(newSelections)\n    });\n  }\n  return node;\n}\nfunction generateInlineFragment(typeName, selectionSet) {\n  return {\n    kind: Kind.INLINE_FRAGMENT,\n    typeCondition: {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: typeName\n      }\n    },\n    selectionSet\n  };\n}\nconst getSchemaMetaData = memoize2$1((sourceSchema, targetSchema) => {\n  var _a2, _b, _c, _d;\n  const typeMap = sourceSchema.getTypeMap();\n  const targetTypeMap = targetSchema.getTypeMap();\n  const possibleTypesMap = /* @__PURE__ */ Object.create(null);\n  const interfaceExtensionsMap = /* @__PURE__ */ Object.create(null);\n  for (const typeName in typeMap) {\n    const type2 = typeMap[typeName];\n    if (isAbstractType(type2)) {\n      const targetType = targetTypeMap[typeName];\n      if (isInterfaceType(type2) && isInterfaceType(targetType)) {\n        const targetTypeFields = targetType.getFields();\n        const sourceTypeFields = type2.getFields();\n        const extensionFields = /* @__PURE__ */ Object.create(null);\n        let isExtensionFieldsEmpty = true;\n        for (const fieldName in sourceTypeFields) {\n          if (!targetTypeFields[fieldName]) {\n            extensionFields[fieldName] = true;\n            isExtensionFieldsEmpty = false;\n          }\n        }\n        if (!isExtensionFieldsEmpty) {\n          interfaceExtensionsMap[typeName] = extensionFields;\n        }\n      }\n      if (interfaceExtensionsMap[typeName] || !isAbstractType(targetType)) {\n        const implementations = sourceSchema.getPossibleTypes(type2);\n        possibleTypesMap[typeName] = [];\n        for (const impl of implementations) {\n          if (targetTypeMap[impl.name]) {\n            possibleTypesMap[typeName].push(impl.name);\n          }\n        }\n      }\n    }\n  }\n  const stitchingInfo = (_a2 = sourceSchema.extensions) === null || _a2 === void 0 ? void 0 : _a2[\"stitchingInfo\"];\n  return {\n    possibleTypesMap,\n    reversePossibleTypesMap: reversePossibleTypesMap(possibleTypesMap),\n    interfaceExtensionsMap,\n    fieldNodesByType: (_b = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.fieldNodesByType) !== null && _b !== void 0 ? _b : {},\n    fieldNodesByField: (_c = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.fieldNodesByField) !== null && _c !== void 0 ? _c : {},\n    dynamicSelectionSetsByField: (_d = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.dynamicSelectionSetsByField) !== null && _d !== void 0 ? _d : {}\n  };\n});\nfunction reversePossibleTypesMap(possibleTypesMap) {\n  const result2 = /* @__PURE__ */ Object.create(null);\n  for (const typeName in possibleTypesMap) {\n    const toTypeNames = possibleTypesMap[typeName];\n    for (const toTypeName of toTypeNames) {\n      if (!result2[toTypeName]) {\n        result2[toTypeName] = [];\n      }\n      result2[toTypeName].push(typeName);\n    }\n  }\n  return result2;\n}\nfunction getExpandedFragments(fragments, fragmentNames, possibleTypesMap) {\n  let fragmentCounter = 0;\n  function generateFragmentName(typeName) {\n    let fragmentName;\n    do {\n      fragmentName = `_${typeName}_Fragment${fragmentCounter.toString()}`;\n      fragmentCounter++;\n    } while (fragmentNames.has(fragmentName));\n    return fragmentName;\n  }\n  const expandedFragments = [];\n  const fragmentReplacements = /* @__PURE__ */ Object.create(null);\n  for (const fragment of fragments) {\n    const possibleTypes = possibleTypesMap[fragment.typeCondition.name.value];\n    if (possibleTypes != null) {\n      const fragmentName = fragment.name.value;\n      fragmentReplacements[fragmentName] = [];\n      for (const possibleTypeName of possibleTypes) {\n        const name2 = generateFragmentName(possibleTypeName);\n        fragmentNames.add(name2);\n        expandedFragments.push({\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name2\n          },\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: possibleTypeName\n            }\n          },\n          selectionSet: fragment.selectionSet\n        });\n        fragmentReplacements[fragmentName].push({\n          fragmentName: name2,\n          typeName: possibleTypeName\n        });\n      }\n    }\n  }\n  return {\n    expandedFragments,\n    fragmentReplacements\n  };\n}\nfunction wrapConcreteTypes(returnType, targetSchema, document2) {\n  const namedType = getNamedType(returnType);\n  if (!isObjectType(namedType)) {\n    return document2;\n  }\n  const rootTypeNames = getRootTypeNames(targetSchema);\n  const typeInfo = new TypeInfo(targetSchema);\n  const visitorKeys = {\n    Document: [\"definitions\"],\n    OperationDefinition: [\"selectionSet\"],\n    SelectionSet: [\"selections\"],\n    InlineFragment: [\"selectionSet\"],\n    FragmentDefinition: [\"selectionSet\"]\n  };\n  return visit(document2, visitWithTypeInfo(typeInfo, {\n    [Kind.FRAGMENT_DEFINITION]: (node) => {\n      const typeName = node.typeCondition.name.value;\n      if (!rootTypeNames.has(typeName)) {\n        return false;\n      }\n    },\n    [Kind.FIELD]: (node) => {\n      const type2 = typeInfo.getType();\n      if (type2 != null && isAbstractType(getNamedType(type2))) {\n        return __spreadProps(__spreadValues({}, node), {\n          selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: [\n              {\n                kind: Kind.INLINE_FRAGMENT,\n                typeCondition: {\n                  kind: Kind.NAMED_TYPE,\n                  name: {\n                    kind: Kind.NAME,\n                    value: namedType.name\n                  }\n                },\n                selectionSet: node.selectionSet\n              }\n            ]\n          }\n        });\n      }\n    }\n  }), visitorKeys);\n}\nfunction finalizeGatewayDocument(targetSchema, fragments, operations) {\n  var _a2;\n  let usedVariables = [];\n  let usedFragments = [];\n  const newOperations = [];\n  let newFragments = [];\n  const validFragments = [];\n  const validFragmentsWithType = /* @__PURE__ */ Object.create(null);\n  for (const fragment of fragments) {\n    const typeName = fragment.typeCondition.name.value;\n    const type2 = targetSchema.getType(typeName);\n    if (type2 != null) {\n      validFragments.push(fragment);\n      validFragmentsWithType[fragment.name.value] = type2;\n    }\n  }\n  let fragmentSet = /* @__PURE__ */ Object.create(null);\n  for (const operation of operations) {\n    const type2 = getDefinedRootType(targetSchema, operation.operation);\n    const { selectionSet, usedFragments: operationUsedFragments, usedVariables: operationUsedVariables } = finalizeSelectionSet(targetSchema, type2, validFragmentsWithType, operation.selectionSet);\n    usedFragments = union(usedFragments, operationUsedFragments);\n    const { usedVariables: collectedUsedVariables, newFragments: collectedNewFragments, fragmentSet: collectedFragmentSet } = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments);\n    const operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);\n    usedVariables = union(usedVariables, operationOrFragmentVariables);\n    newFragments = collectedNewFragments;\n    fragmentSet = collectedFragmentSet;\n    const variableDefinitions = ((_a2 = operation.variableDefinitions) !== null && _a2 !== void 0 ? _a2 : []).filter((variable) => operationOrFragmentVariables.indexOf(variable.variable.name.value) !== -1);\n    newOperations.push({\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation.operation,\n      name: operation.name,\n      directives: operation.directives,\n      variableDefinitions,\n      selectionSet\n    });\n  }\n  const newDocument = {\n    kind: Kind.DOCUMENT,\n    definitions: [...newOperations, ...newFragments]\n  };\n  return {\n    usedVariables,\n    newDocument\n  };\n}\nfunction finalizeGatewayRequest(originalRequest, delegationContext) {\n  let { document: document2, variables } = originalRequest;\n  let { operations, fragments } = getDocumentMetadata(document2);\n  const { targetSchema, args } = delegationContext;\n  if (args) {\n    const requestWithNewVariables = addVariablesToRootFields(targetSchema, operations, args);\n    operations = requestWithNewVariables.newOperations;\n    variables = Object.assign({}, variables !== null && variables !== void 0 ? variables : {}, requestWithNewVariables.newVariables);\n  }\n  const { usedVariables, newDocument } = finalizeGatewayDocument(targetSchema, fragments, operations);\n  const newVariables = {};\n  if (variables != null) {\n    for (const variableName of usedVariables) {\n      const variableValue = variables[variableName];\n      if (variableValue !== void 0) {\n        newVariables[variableName] = variableValue;\n      }\n    }\n  }\n  return __spreadProps(__spreadValues({}, originalRequest), {\n    document: newDocument,\n    variables: newVariables\n  });\n}\nfunction addVariablesToRootFields(targetSchema, operations, args) {\n  const newVariables = /* @__PURE__ */ Object.create(null);\n  const newOperations = operations.map((operation) => {\n    var _a2, _b;\n    const variableDefinitionMap = ((_a2 = operation.variableDefinitions) !== null && _a2 !== void 0 ? _a2 : []).reduce((prev, def) => __spreadProps(__spreadValues({}, prev), {\n      [def.variable.name.value]: def\n    }), {});\n    const type2 = getDefinedRootType(targetSchema, operation.operation);\n    const newSelections = [];\n    for (const selection of operation.selectionSet.selections) {\n      if (selection.kind === Kind.FIELD) {\n        const argumentNodes = (_b = selection.arguments) !== null && _b !== void 0 ? _b : [];\n        const argumentNodeMap = argumentNodes.reduce((prev, argument) => __spreadProps(__spreadValues({}, prev), {\n          [argument.name.value]: argument\n        }), {});\n        const targetField = type2.getFields()[selection.name.value];\n        if (targetField != null) {\n          updateArguments(targetField, argumentNodeMap, variableDefinitionMap, newVariables, args);\n        }\n        newSelections.push(__spreadProps(__spreadValues({}, selection), {\n          arguments: Object.values(argumentNodeMap)\n        }));\n      } else {\n        newSelections.push(selection);\n      }\n    }\n    const newSelectionSet = {\n      kind: Kind.SELECTION_SET,\n      selections: newSelections\n    };\n    return __spreadProps(__spreadValues({}, operation), {\n      variableDefinitions: Object.values(variableDefinitionMap),\n      selectionSet: newSelectionSet\n    });\n  });\n  return {\n    newOperations,\n    newVariables\n  };\n}\nfunction updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {\n  const generateVariableName = createVariableNameGenerator(variableDefinitionMap);\n  for (const argument of targetField.args) {\n    const argName = argument.name;\n    const argType = argument.type;\n    if (argName in newArgs) {\n      updateArgument(argumentNodeMap, variableDefinitionMap, variableValues, argName, generateVariableName(argName), argType, serializeInputValue(argType, newArgs[argName]));\n    }\n  }\n}\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\n  let remainingFragments = usedFragments.slice();\n  let usedVariables = [];\n  const newFragments = [];\n  while (remainingFragments.length !== 0) {\n    const nextFragmentName = remainingFragments.pop();\n    const fragment = validFragments.find((fr) => fr.name.value === nextFragmentName);\n    if (fragment != null) {\n      const name2 = nextFragmentName;\n      const typeName = fragment.typeCondition.name.value;\n      const type2 = targetSchema.getType(typeName);\n      if (type2 == null) {\n        throw new Error(`Fragment reference type \"${typeName}\", but the type is not contained within the target schema.`);\n      }\n      const { selectionSet, usedFragments: fragmentUsedFragments, usedVariables: fragmentUsedVariables } = finalizeSelectionSet(targetSchema, type2, validFragmentsWithType, fragment.selectionSet);\n      remainingFragments = union(remainingFragments, fragmentUsedFragments);\n      usedVariables = union(usedVariables, fragmentUsedVariables);\n      if (name2 && !(name2 in fragmentSet)) {\n        fragmentSet[name2] = true;\n        newFragments.push({\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name2\n          },\n          typeCondition: fragment.typeCondition,\n          selectionSet\n        });\n      }\n    }\n  }\n  return {\n    usedVariables,\n    newFragments,\n    fragmentSet\n  };\n}\nconst filteredSelectionSetVisitorKeys = {\n  SelectionSet: [\"selections\"],\n  Field: [\"selectionSet\"],\n  InlineFragment: [\"selectionSet\"],\n  FragmentDefinition: [\"selectionSet\"]\n};\nconst variablesVisitorKeys = {\n  SelectionSet: [\"selections\"],\n  Field: [\"arguments\", \"directives\", \"selectionSet\"],\n  Argument: [\"value\"],\n  InlineFragment: [\"directives\", \"selectionSet\"],\n  FragmentSpread: [\"directives\"],\n  FragmentDefinition: [\"selectionSet\"],\n  ObjectValue: [\"fields\"],\n  ObjectField: [\"name\", \"value\"],\n  Directive: [\"arguments\"],\n  ListValue: [\"values\"]\n};\nfunction finalizeSelectionSet(schema, type2, validFragments, selectionSet) {\n  const usedFragments = [];\n  const usedVariables = [];\n  const typeInfo = versionInfo.major < 16 ? new TypeInfo(schema, void 0, type2) : new TypeInfo(schema, type2);\n  const filteredSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, {\n    [Kind.FIELD]: {\n      enter: (node) => {\n        const parentType = typeInfo.getParentType();\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          const fields = parentType.getFields();\n          const field = node.name.value === \"__typename\" ? TypeNameMetaFieldDef : fields[node.name.value];\n          if (!field) {\n            return null;\n          }\n          const args = field.args != null ? field.args : [];\n          const argsMap = /* @__PURE__ */ Object.create(null);\n          for (const arg of args) {\n            argsMap[arg.name] = arg;\n          }\n          if (node.arguments != null) {\n            const newArgs = [];\n            for (const arg of node.arguments) {\n              if (arg.name.value in argsMap) {\n                newArgs.push(arg);\n              }\n            }\n            if (newArgs.length !== node.arguments.length) {\n              return __spreadProps(__spreadValues({}, node), {\n                arguments: newArgs\n              });\n            }\n          }\n        }\n      },\n      leave: (node) => {\n        const type3 = typeInfo.getType();\n        if (type3 == null) {\n          throw new Error(`No type was found for field node ${inspect$1(node)}.`);\n        }\n        const namedType = getNamedType(type3);\n        if (!schema.getType(namedType.name) == null) {\n          return null;\n        }\n        if (isObjectType(namedType) || isInterfaceType(namedType)) {\n          const selections = node.selectionSet != null ? node.selectionSet.selections : null;\n          if (selections == null || selections.length === 0) {\n            return null;\n          }\n        }\n      }\n    },\n    [Kind.FRAGMENT_SPREAD]: {\n      enter: (node) => {\n        if (!(node.name.value in validFragments)) {\n          return null;\n        }\n        const parentType = typeInfo.getParentType();\n        const innerType = validFragments[node.name.value];\n        if (!implementsAbstractType(schema, parentType, innerType)) {\n          return null;\n        }\n        usedFragments.push(node.name.value);\n      }\n    },\n    [Kind.INLINE_FRAGMENT]: {\n      enter: (node) => {\n        if (node.typeCondition != null) {\n          const parentType = typeInfo.getParentType();\n          const innerType = schema.getType(node.typeCondition.name.value);\n          if (!implementsAbstractType(schema, parentType, innerType)) {\n            return null;\n          }\n        }\n      }\n    },\n    [Kind.SELECTION_SET]: {\n      leave: (node) => {\n        const parentType = typeInfo.getParentType();\n        if (parentType != null && isAbstractType(parentType)) {\n          const selections = node.selections.concat([\n            {\n              kind: Kind.FIELD,\n              name: {\n                kind: Kind.NAME,\n                value: \"__typename\"\n              }\n            }\n          ]);\n          return __spreadProps(__spreadValues({}, node), {\n            selections\n          });\n        }\n      }\n    }\n  }), filteredSelectionSetVisitorKeys);\n  visit(filteredSelectionSet, {\n    [Kind.VARIABLE]: (variableNode) => {\n      usedVariables.push(variableNode.name.value);\n    }\n  }, variablesVisitorKeys);\n  return {\n    selectionSet: filteredSelectionSet,\n    usedFragments,\n    usedVariables\n  };\n}\nfunction union(...arrays) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  const result2 = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      if (!(item in cache)) {\n        cache[item] = true;\n        result2.push(item);\n      }\n    }\n  }\n  return result2;\n}\nconst UNPATHED_ERRORS_SYMBOL = Symbol(\"subschemaErrors\");\nconst OBJECT_SUBSCHEMA_SYMBOL = Symbol(\"initialSubschema\");\nconst FIELD_SUBSCHEMA_MAP_SYMBOL = Symbol(\"subschemaMap\");\nfunction isExternalObject(data) {\n  return data[UNPATHED_ERRORS_SYMBOL] !== void 0;\n}\nfunction annotateExternalObject(object, errors2, subschema, subschemaMap) {\n  Object.defineProperties(object, {\n    [OBJECT_SUBSCHEMA_SYMBOL]: { value: subschema },\n    [FIELD_SUBSCHEMA_MAP_SYMBOL]: { value: subschemaMap },\n    [UNPATHED_ERRORS_SYMBOL]: { value: errors2 }\n  });\n  return object;\n}\nfunction getSubschema(object, responseKey) {\n  var _a2;\n  return (_a2 = object[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey]) !== null && _a2 !== void 0 ? _a2 : object[OBJECT_SUBSCHEMA_SYMBOL];\n}\nfunction getUnpathedErrors(object) {\n  return object[UNPATHED_ERRORS_SYMBOL];\n}\nconst EMPTY_ARRAY = [];\nconst EMPTY_OBJECT = /* @__PURE__ */ Object.create(null);\nasync function mergeFields(mergedTypeInfo, object, sourceSubschema, context, info2) {\n  var _a2;\n  const delegationMaps = mergedTypeInfo.delegationPlanBuilder(info2.schema, sourceSubschema, info2.variableValues != null && Object.keys(info2.variableValues).length > 0 ? info2.variableValues : EMPTY_OBJECT, info2.fragments != null && Object.keys(info2.fragments).length > 0 ? info2.fragments : EMPTY_OBJECT, ((_a2 = info2.fieldNodes) === null || _a2 === void 0 ? void 0 : _a2.length) ? info2.fieldNodes : EMPTY_ARRAY);\n  for (const delegationMap of delegationMaps) {\n    await executeDelegationStage(mergedTypeInfo, delegationMap, object, context, info2);\n  }\n  return object;\n}\nasync function executeDelegationStage(mergedTypeInfo, delegationMap, object, context, info2) {\n  const combinedErrors = object[UNPATHED_ERRORS_SYMBOL];\n  const path = pathToArray$1(info2.path);\n  const combinedFieldSubschemaMap = object[FIELD_SUBSCHEMA_MAP_SYMBOL];\n  await Promise.all([...delegationMap.entries()].map(async ([subschema, selectionSet]) => {\n    var _a2;\n    const schema = subschema.transformedSchema || info2.schema;\n    const type2 = schema.getType(object.__typename);\n    const resolver = mergedTypeInfo.resolvers.get(subschema);\n    if (resolver) {\n      let source;\n      try {\n        source = await resolver(object, context, info2, subschema, selectionSet, void 0, type2);\n      } catch (error2) {\n        source = error2;\n      }\n      if (source instanceof Error || source == null) {\n        const fieldNodeResponseKeyMap = collectFields(schema, EMPTY_OBJECT, EMPTY_OBJECT, type2, selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());\n        const nullResult = {};\n        for (const [responseKey, fieldNodes] of fieldNodeResponseKeyMap) {\n          const combinedPath = [...path, responseKey];\n          if (source instanceof GraphQLError) {\n            nullResult[responseKey] = relocatedError(source, combinedPath);\n          } else if (source instanceof Error) {\n            nullResult[responseKey] = locatedError(source, fieldNodes, combinedPath);\n          } else {\n            nullResult[responseKey] = null;\n          }\n        }\n        source = nullResult;\n      } else {\n        if (source[UNPATHED_ERRORS_SYMBOL]) {\n          combinedErrors.push(...source[UNPATHED_ERRORS_SYMBOL]);\n        }\n      }\n      const objectSubschema = source[OBJECT_SUBSCHEMA_SYMBOL];\n      const fieldSubschemaMap = source[FIELD_SUBSCHEMA_MAP_SYMBOL];\n      for (const responseKey in source) {\n        object[responseKey] = source[responseKey];\n        combinedFieldSubschemaMap[responseKey] = (_a2 = fieldSubschemaMap === null || fieldSubschemaMap === void 0 ? void 0 : fieldSubschemaMap[responseKey]) !== null && _a2 !== void 0 ? _a2 : objectSubschema;\n      }\n    }\n  }));\n}\nfunction resolveExternalValue(result2, unpathedErrors, subschema, context, info2, returnType = getReturnType(info2), skipTypeMerging) {\n  const type2 = getNullableType(returnType);\n  if (result2 instanceof Error) {\n    return result2;\n  }\n  if (result2 == null) {\n    return reportUnpathedErrorsViaNull(unpathedErrors);\n  }\n  if (\"parseValue\" in type2) {\n    return type2.parseValue(result2);\n  } else if (isCompositeType(type2)) {\n    return resolveExternalObject(type2, result2, unpathedErrors, subschema, context, info2, skipTypeMerging);\n  } else if (isListType(type2)) {\n    return resolveExternalList(type2, result2, unpathedErrors, subschema, context, info2, skipTypeMerging);\n  }\n}\nfunction resolveExternalObject(type2, object, unpathedErrors, subschema, context, info2, skipTypeMerging) {\n  var _a2;\n  if (!isExternalObject(object)) {\n    annotateExternalObject(object, unpathedErrors, subschema, /* @__PURE__ */ Object.create(null));\n  }\n  if (skipTypeMerging || info2 == null) {\n    return object;\n  }\n  const stitchingInfo = (_a2 = info2.schema.extensions) === null || _a2 === void 0 ? void 0 : _a2[\"stitchingInfo\"];\n  if (stitchingInfo == null) {\n    return object;\n  }\n  const typeName = isAbstractType(type2) ? object.__typename : type2.name;\n  const mergedTypeInfo = stitchingInfo.mergedTypes[typeName];\n  let targetSubschemas;\n  if (mergedTypeInfo != null) {\n    targetSubschemas = mergedTypeInfo.targetSubschemas.get(subschema);\n  }\n  if (!targetSubschemas || !targetSubschemas.length) {\n    return object;\n  }\n  return mergeFields(mergedTypeInfo, object, subschema, context, info2);\n}\nfunction resolveExternalList(type2, list3, unpathedErrors, subschema, context, info2, skipTypeMerging) {\n  return list3.map((listMember) => resolveExternalListMember(getNullableType(type2.ofType), listMember, unpathedErrors, subschema, context, info2, skipTypeMerging));\n}\nfunction resolveExternalListMember(type2, listMember, unpathedErrors, subschema, context, info2, skipTypeMerging) {\n  if (listMember instanceof Error) {\n    return listMember;\n  }\n  if (listMember == null) {\n    return reportUnpathedErrorsViaNull(unpathedErrors);\n  }\n  if (\"parseValue\" in type2) {\n    return type2.parseValue(listMember);\n  } else if (isCompositeType(type2)) {\n    return resolveExternalObject(type2, listMember, unpathedErrors, subschema, context, info2, skipTypeMerging);\n  } else if (isListType(type2)) {\n    return resolveExternalList(type2, listMember, unpathedErrors, subschema, context, info2, skipTypeMerging);\n  }\n}\nconst reportedErrors = /* @__PURE__ */ new WeakMap();\nfunction reportUnpathedErrorsViaNull(unpathedErrors) {\n  if (unpathedErrors.length) {\n    const unreportedErrors = [];\n    for (const error2 of unpathedErrors) {\n      if (!reportedErrors.has(error2)) {\n        unreportedErrors.push(error2);\n        reportedErrors.set(error2, true);\n      }\n    }\n    if (unreportedErrors.length) {\n      if (unreportedErrors.length === 1) {\n        return unreportedErrors[0];\n      }\n      const combinedError = new AggregateErrorImpl(unreportedErrors, unreportedErrors.map((error2) => error2.message).join(\", \\n\"));\n      return locatedError(combinedError, void 0, unreportedErrors[0].path);\n    }\n  }\n  return null;\n}\nfunction getReturnType(info2) {\n  if (info2 == null) {\n    throw new Error(`Return type cannot be inferred without a source schema.`);\n  }\n  return info2.returnType;\n}\nfunction checkResultAndHandleErrors(result2, delegationContext) {\n  const { context, info: info2, fieldName: responseKey = getResponseKey(info2), subschema, returnType = getReturnType$1(info2), skipTypeMerging, onLocatedError } = delegationContext;\n  const { data, unpathedErrors } = mergeDataAndErrors(result2.data == null ? void 0 : result2.data[responseKey], result2.errors == null ? [] : result2.errors, info2 != null && info2.path ? pathToArray$1(info2.path) : void 0, onLocatedError);\n  return resolveExternalValue(data, unpathedErrors, subschema, context, info2, returnType, skipTypeMerging);\n}\nfunction mergeDataAndErrors(data, errors2, path, onLocatedError, index = 1) {\n  var _a2;\n  if (data == null) {\n    if (!errors2.length) {\n      return { data: null, unpathedErrors: [] };\n    }\n    if (errors2.length === 1) {\n      const error2 = onLocatedError ? onLocatedError(errors2[0]) : errors2[0];\n      const newPath = path === void 0 ? error2.path : error2.path === void 0 ? path : path.concat(error2.path.slice(1));\n      return { data: relocatedError(errors2[0], newPath), unpathedErrors: [] };\n    }\n    const combinedError = new AggregateErrorImpl(errors2, errors2.map((error2) => error2.message).join(\", \\n\"));\n    const newError = locatedError(combinedError, void 0, path);\n    return { data: newError, unpathedErrors: [] };\n  }\n  if (!errors2.length) {\n    return { data, unpathedErrors: [] };\n  }\n  const unpathedErrors = [];\n  const errorMap = /* @__PURE__ */ new Map();\n  for (const error2 of errors2) {\n    const pathSegment = (_a2 = error2.path) === null || _a2 === void 0 ? void 0 : _a2[index];\n    if (pathSegment != null) {\n      let pathSegmentErrors = errorMap.get(pathSegment);\n      if (pathSegmentErrors === void 0) {\n        pathSegmentErrors = [error2];\n        errorMap.set(pathSegment, pathSegmentErrors);\n      } else {\n        pathSegmentErrors.push(error2);\n      }\n    } else {\n      unpathedErrors.push(error2);\n    }\n  }\n  for (const [pathSegment, pathSegmentErrors] of errorMap) {\n    if (data[pathSegment] !== void 0) {\n      const { data: newData, unpathedErrors: newErrors } = mergeDataAndErrors(data[pathSegment], pathSegmentErrors, path, onLocatedError, index + 1);\n      data[pathSegment] = newData;\n      unpathedErrors.push(...newErrors);\n    } else {\n      unpathedErrors.push(...pathSegmentErrors);\n    }\n  }\n  return { data, unpathedErrors };\n}\nfunction getResponseKey(info2) {\n  if (info2 == null) {\n    throw new Error(`Data cannot be extracted from result without an explicit key or source schema.`);\n  }\n  return getResponseKeyFromInfo(info2);\n}\nfunction getReturnType$1(info2) {\n  if (info2 == null) {\n    throw new Error(`Return type cannot be inferred without a source schema.`);\n  }\n  return info2.returnType;\n}\nclass Transformer {\n  constructor(context) {\n    this.transformations = [];\n    this.delegationContext = context;\n    const transforms = context.transforms;\n    const delegationTransforms = transforms.slice().reverse();\n    for (const transform of delegationTransforms) {\n      this.addTransform(transform, {});\n    }\n  }\n  addTransform(transform, context = {}) {\n    this.transformations.push({ transform, context });\n  }\n  transformRequest(originalRequest) {\n    var _a2;\n    let request = __spreadProps(__spreadValues({}, originalRequest), {\n      document: prepareGatewayDocument(originalRequest.document, this.delegationContext.transformedSchema, this.delegationContext.returnType, (_a2 = this.delegationContext.info) === null || _a2 === void 0 ? void 0 : _a2.schema)\n    });\n    for (const transformation of this.transformations) {\n      if (transformation.transform.transformRequest) {\n        request = transformation.transform.transformRequest(request, this.delegationContext, transformation.context);\n      }\n    }\n    return finalizeGatewayRequest(request, this.delegationContext);\n  }\n  transformResult(originalResult) {\n    let result2 = originalResult;\n    for (let i = this.transformations.length - 1; i >= 0; i--) {\n      const transformation = this.transformations[i];\n      if (transformation.transform.transformResult) {\n        result2 = transformation.transform.transformResult(result2, this.delegationContext, transformation.context);\n      }\n    }\n    return checkResultAndHandleErrors(result2, this.delegationContext);\n  }\n}\nfunction getDelegatingOperation(parentType, schema) {\n  if (parentType === schema.getMutationType()) {\n    return \"mutation\";\n  } else if (parentType === schema.getSubscriptionType()) {\n    return \"subscription\";\n  }\n  return \"query\";\n}\nfunction createRequest({ sourceSchema, sourceParentType, sourceFieldName, fragments, variableDefinitions, variableValues, targetRootValue, targetOperationName, targetOperation, targetFieldName, selectionSet, fieldNodes, context, info: info2 }) {\n  var _a2, _b;\n  let newSelectionSet;\n  const argumentNodeMap = /* @__PURE__ */ Object.create(null);\n  if (selectionSet != null) {\n    newSelectionSet = selectionSet;\n  } else {\n    const selections = [];\n    for (const fieldNode of fieldNodes || []) {\n      if (fieldNode.selectionSet) {\n        for (const selection of fieldNode.selectionSet.selections) {\n          selections.push(selection);\n        }\n      }\n    }\n    newSelectionSet = selections.length ? {\n      kind: Kind.SELECTION_SET,\n      selections\n    } : void 0;\n    const args = (_a2 = fieldNodes === null || fieldNodes === void 0 ? void 0 : fieldNodes[0]) === null || _a2 === void 0 ? void 0 : _a2.arguments;\n    if (args) {\n      for (const argNode of args) {\n        argumentNodeMap[argNode.name.value] = argNode;\n      }\n    }\n  }\n  const newVariables = /* @__PURE__ */ Object.create(null);\n  const variableDefinitionMap = /* @__PURE__ */ Object.create(null);\n  if (sourceSchema != null && variableDefinitions != null) {\n    for (const def of variableDefinitions) {\n      const varName = def.variable.name.value;\n      variableDefinitionMap[varName] = def;\n      const varType = typeFromAST(sourceSchema, def.type);\n      const serializedValue = serializeInputValue(varType, variableValues === null || variableValues === void 0 ? void 0 : variableValues[varName]);\n      if (serializedValue !== void 0) {\n        newVariables[varName] = serializedValue;\n      }\n    }\n  }\n  if (sourceParentType != null && sourceFieldName != null) {\n    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);\n  }\n  const rootFieldName = targetFieldName !== null && targetFieldName !== void 0 ? targetFieldName : (_b = fieldNodes === null || fieldNodes === void 0 ? void 0 : fieldNodes[0]) === null || _b === void 0 ? void 0 : _b.name.value;\n  if (rootFieldName === void 0) {\n    throw new Error(`Either \"targetFieldName\" or a non empty \"fieldNodes\" array must be provided.`);\n  }\n  const rootfieldNode = {\n    kind: Kind.FIELD,\n    arguments: Object.values(argumentNodeMap),\n    name: {\n      kind: Kind.NAME,\n      value: rootFieldName\n    },\n    selectionSet: newSelectionSet\n  };\n  const operationName = targetOperationName ? {\n    kind: Kind.NAME,\n    value: targetOperationName\n  } : void 0;\n  const operationDefinition = {\n    kind: Kind.OPERATION_DEFINITION,\n    name: operationName,\n    operation: targetOperation,\n    variableDefinitions: Object.values(variableDefinitionMap),\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [rootfieldNode]\n    }\n  };\n  const definitions = [operationDefinition];\n  if (fragments != null) {\n    for (const fragmentName in fragments) {\n      const fragment = fragments[fragmentName];\n      definitions.push(fragment);\n    }\n  }\n  const document2 = {\n    kind: Kind.DOCUMENT,\n    definitions\n  };\n  return {\n    document: document2,\n    variables: newVariables,\n    rootValue: targetRootValue,\n    operationName: targetOperationName,\n    context,\n    info: info2,\n    operationType: targetOperation\n  };\n}\nfunction updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {\n  const generateVariableName = createVariableNameGenerator(variableDefinitionMap);\n  const sourceField = sourceParentType.getFields()[sourceFieldName];\n  for (const argument of sourceField.args) {\n    const argName = argument.name;\n    const sourceArgType = argument.type;\n    if (argumentNodeMap[argName] === void 0) {\n      const defaultValue2 = argument.defaultValue;\n      if (defaultValue2 !== void 0) {\n        updateArgument(argumentNodeMap, variableDefinitionMap, variableValues, argName, generateVariableName(argName), sourceArgType, serializeInputValue(sourceArgType, defaultValue2));\n      }\n    }\n  }\n}\nfunction defaultMergedResolver(parent, args, context, info2) {\n  if (!parent) {\n    return null;\n  }\n  const responseKey = getResponseKeyFromInfo(info2);\n  if (!isExternalObject(parent)) {\n    return defaultFieldResolver$1(parent, args, context, info2);\n  }\n  const data = parent[responseKey];\n  const unpathedErrors = getUnpathedErrors(parent);\n  const subschema = getSubschema(parent, responseKey);\n  return resolveExternalValue(data, unpathedErrors, subschema, context, info2);\n}\nfunction isSubschemaConfig(value) {\n  return Boolean(value === null || value === void 0 ? void 0 : value.schema);\n}\nfunction delegateToSchema(options) {\n  var _a2, _b;\n  const { info: info2, schema, rootValue = (_a2 = schema.rootValue) !== null && _a2 !== void 0 ? _a2 : info2.rootValue, operationName = (_b = info2.operation.name) === null || _b === void 0 ? void 0 : _b.value, operation = getDelegatingOperation(info2.parentType, info2.schema), fieldName = info2.fieldName, selectionSet, fieldNodes = info2.fieldNodes, context } = options;\n  const request = createRequest({\n    sourceSchema: info2.schema,\n    sourceParentType: info2.parentType,\n    sourceFieldName: info2.fieldName,\n    fragments: info2.fragments,\n    variableDefinitions: info2.operation.variableDefinitions,\n    variableValues: info2.variableValues,\n    targetRootValue: rootValue,\n    targetOperationName: operationName,\n    targetOperation: operation,\n    targetFieldName: fieldName,\n    selectionSet,\n    fieldNodes,\n    context,\n    info: info2\n  });\n  return delegateRequest(__spreadProps(__spreadValues({}, options), {\n    request\n  }));\n}\nfunction getDelegationReturnType(targetSchema, operation, fieldName) {\n  const rootType = getDefinedRootType(targetSchema, operation);\n  return rootType.getFields()[fieldName].type;\n}\nfunction delegateRequest(options) {\n  const delegationContext = getDelegationContext(options);\n  const transformer = new Transformer(delegationContext);\n  const processedRequest = transformer.transformRequest(options.request);\n  if (options.validateRequest) {\n    validateRequest(delegationContext, processedRequest.document);\n  }\n  const executor = getExecutor(delegationContext);\n  return new ValueOrPromise(() => executor(processedRequest)).then((originalResult) => {\n    if (isAsyncIterable$1(originalResult)) {\n      const iterator = originalResult[Symbol.asyncIterator]();\n      return mapAsyncIterator(iterator, (result2) => transformer.transformResult(result2));\n    }\n    return transformer.transformResult(originalResult);\n  }).resolve();\n}\nfunction getDelegationContext({ request, schema, fieldName, returnType, args, info: info2, transforms = [], transformedSchema, skipTypeMerging = false }) {\n  var _a2, _b, _c, _d;\n  const operationDefinition = getOperationASTFromRequest(request);\n  let targetFieldName;\n  if (fieldName == null) {\n    targetFieldName = operationDefinition.selectionSet.selections[0].name.value;\n  } else {\n    targetFieldName = fieldName;\n  }\n  const stitchingInfo = (_a2 = info2 === null || info2 === void 0 ? void 0 : info2.schema.extensions) === null || _a2 === void 0 ? void 0 : _a2[\"stitchingInfo\"];\n  const subschemaOrSubschemaConfig = (_b = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.subschemaMap.get(schema)) !== null && _b !== void 0 ? _b : schema;\n  const operation = operationDefinition.operation;\n  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n    const targetSchema = subschemaOrSubschemaConfig.schema;\n    return {\n      subschema: schema,\n      subschemaConfig: subschemaOrSubschemaConfig,\n      targetSchema,\n      operation,\n      fieldName: targetFieldName,\n      args,\n      context: request.context,\n      info: info2,\n      returnType: (_c = returnType !== null && returnType !== void 0 ? returnType : info2 === null || info2 === void 0 ? void 0 : info2.returnType) !== null && _c !== void 0 ? _c : getDelegationReturnType(targetSchema, operation, targetFieldName),\n      transforms: subschemaOrSubschemaConfig.transforms != null ? subschemaOrSubschemaConfig.transforms.concat(transforms) : transforms,\n      transformedSchema: transformedSchema !== null && transformedSchema !== void 0 ? transformedSchema : subschemaOrSubschemaConfig instanceof Subschema ? subschemaOrSubschemaConfig.transformedSchema : targetSchema,\n      skipTypeMerging\n    };\n  }\n  return {\n    subschema: schema,\n    subschemaConfig: void 0,\n    targetSchema: subschemaOrSubschemaConfig,\n    operation,\n    fieldName: targetFieldName,\n    args,\n    context: request.context,\n    info: info2,\n    returnType: (_d = returnType !== null && returnType !== void 0 ? returnType : info2 === null || info2 === void 0 ? void 0 : info2.returnType) !== null && _d !== void 0 ? _d : getDelegationReturnType(subschemaOrSubschemaConfig, operation, targetFieldName),\n    transforms,\n    transformedSchema: transformedSchema !== null && transformedSchema !== void 0 ? transformedSchema : subschemaOrSubschemaConfig,\n    skipTypeMerging\n  };\n}\nfunction validateRequest(delegationContext, document2) {\n  const errors2 = validate(delegationContext.targetSchema, document2);\n  if (errors2.length > 0) {\n    if (errors2.length > 1) {\n      const combinedError = new AggregateErrorImpl(errors2, errors2.map((error3) => error3.message).join(\", \\n\"));\n      throw combinedError;\n    }\n    const error2 = errors2[0];\n    throw error2.originalError || error2;\n  }\n}\nconst GLOBAL_CONTEXT = {};\nfunction getExecutor(delegationContext) {\n  const { subschemaConfig, targetSchema, context } = delegationContext;\n  let executor = (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.executor) || createDefaultExecutor(targetSchema);\n  if (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.batch) {\n    const batchingOptions = subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.batchingOptions;\n    executor = getBatchingExecutor(context !== null && context !== void 0 ? context : GLOBAL_CONTEXT, executor, batchingOptions === null || batchingOptions === void 0 ? void 0 : batchingOptions.dataLoaderOptions, batchingOptions === null || batchingOptions === void 0 ? void 0 : batchingOptions.extensionsReducer);\n  }\n  return executor;\n}\nconst createDefaultExecutor = memoize1$1(function createDefaultExecutor2(schema) {\n  const executor = new Executor({ schema });\n  return function defaultExecutor(request) {\n    const operationAst = getOperationASTFromRequest(request);\n    const executionArgs = {\n      schema,\n      document: request.document,\n      contextValue: request.context,\n      variableValues: request.variables,\n      rootValue: request.rootValue,\n      operationName: request.operationName\n    };\n    if (operationAst.operation === \"subscription\") {\n      return subscribe(executionArgs);\n    }\n    return executor.execute(executionArgs);\n  };\n});\nfunction generateProxyingResolvers(subschemaConfig) {\n  var _a2;\n  const targetSchema = subschemaConfig.schema;\n  const createProxyingResolver = (_a2 = subschemaConfig.createProxyingResolver) !== null && _a2 !== void 0 ? _a2 : defaultCreateProxyingResolver;\n  const transformedSchema = applySchemaTransforms(targetSchema, subschemaConfig);\n  const rootTypeMap = getRootTypeMap(targetSchema);\n  const resolvers = {};\n  for (const [operation, rootType] of rootTypeMap.entries()) {\n    const typeName = rootType.name;\n    const fields = rootType.getFields();\n    resolvers[typeName] = {};\n    for (const fieldName in fields) {\n      const proxyingResolver = createProxyingResolver({\n        subschemaConfig,\n        transformedSchema,\n        operation,\n        fieldName\n      });\n      const finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);\n      if (operation === \"subscription\") {\n        resolvers[typeName][fieldName] = {\n          subscribe: finalResolver,\n          resolve: identical\n        };\n      } else {\n        resolvers[typeName][fieldName] = {\n          resolve: finalResolver\n        };\n      }\n    }\n  }\n  return resolvers;\n}\nfunction identical(value) {\n  return value;\n}\nfunction createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {\n  return function possiblyNestedProxyingResolver(parent, args, context, info2) {\n    if (parent != null) {\n      const responseKey = getResponseKeyFromInfo(info2);\n      if (isExternalObject(parent)) {\n        const unpathedErrors = getUnpathedErrors(parent);\n        const subschema = getSubschema(parent, responseKey);\n        if (subschemaConfig === subschema && parent[responseKey] !== void 0) {\n          return resolveExternalValue(parent[responseKey], unpathedErrors, subschema, context, info2);\n        }\n      }\n    }\n    return proxyingResolver(parent, args, context, info2);\n  };\n}\nfunction defaultCreateProxyingResolver({ subschemaConfig, operation, transformedSchema }) {\n  return function proxyingResolver(_parent, _args, context, info2) {\n    return delegateToSchema({\n      schema: subschemaConfig,\n      operation,\n      context,\n      info: info2,\n      transformedSchema\n    });\n  };\n}\nfunction wrapSchema(subschemaConfig) {\n  const targetSchema = subschemaConfig.schema;\n  const proxyingResolvers = generateProxyingResolvers(subschemaConfig);\n  const schema = createWrappingSchema(targetSchema, proxyingResolvers);\n  const transformedSchema = applySchemaTransforms(schema, subschemaConfig);\n  return applySchemaTransforms(schema, subschemaConfig, transformedSchema);\n}\nfunction createWrappingSchema(schema, proxyingResolvers) {\n  return mapSchema(schema, {\n    [MapperKind.ROOT_OBJECT]: (type2) => {\n      var _a2;\n      const config2 = type2.toConfig();\n      const fieldConfigMap = config2.fields;\n      for (const fieldName in fieldConfigMap) {\n        const field = fieldConfigMap[fieldName];\n        if (field == null) {\n          continue;\n        }\n        fieldConfigMap[fieldName] = __spreadValues(__spreadValues({}, field), (_a2 = proxyingResolvers[type2.name]) === null || _a2 === void 0 ? void 0 : _a2[fieldName]);\n      }\n      return new GraphQLObjectType(config2);\n    },\n    [MapperKind.OBJECT_TYPE]: (type2) => {\n      const config2 = type2.toConfig();\n      config2.isTypeOf = void 0;\n      for (const fieldName in config2.fields) {\n        const field = config2.fields[fieldName];\n        if (field == null) {\n          continue;\n        }\n        field.resolve = defaultMergedResolver;\n        field.subscribe = void 0;\n      }\n      return new GraphQLObjectType(config2);\n    },\n    [MapperKind.INTERFACE_TYPE]: (type2) => {\n      const config2 = type2.toConfig();\n      delete config2.resolveType;\n      return new GraphQLInterfaceType(config2);\n    },\n    [MapperKind.UNION_TYPE]: (type2) => {\n      const config2 = type2.toConfig();\n      delete config2.resolveType;\n      return new GraphQLUnionType(config2);\n    }\n  });\n}\nfunction getSchemaFromIntrospection(introspectionResult, options) {\n  var _a2;\n  if ((_a2 = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.data) === null || _a2 === void 0 ? void 0 : _a2.__schema) {\n    return buildClientSchema(introspectionResult.data, options);\n  }\n  throw new Error(\"Could not obtain introspection result, received: \" + JSON.stringify(introspectionResult));\n}\nfunction introspectSchema(executor, context, options) {\n  const parsedIntrospectionQuery = parse$1(getIntrospectionQuery(options), options);\n  return new ValueOrPromise(() => executor({\n    document: parsedIntrospectionQuery,\n    context,\n    operationType: \"query\"\n  })).then((introspection2) => {\n    if (isAsyncIterable$1(introspection2)) {\n      const iterator = introspection2[Symbol.asyncIterator]();\n      return iterator.next().then(({ value }) => value);\n    }\n    return introspection2;\n  }).then((introspection2) => getSchemaFromIntrospection(introspection2, options)).resolve();\n}\nconst baseHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isObject$3(val) {\n  return typeof val === \"object\" && val !== null;\n}\nfunction areGraphQLErrors(obj) {\n  return Array.isArray(obj) && obj.length > 0 && obj.every((ob2) => \"message\" in ob2);\n}\nfunction hasOwnProperty(obj, prop2) {\n  return baseHasOwnProperty.call(obj, prop2);\n}\nfunction hasOwnObjectProperty(obj, prop2) {\n  return baseHasOwnProperty.call(obj, prop2) && isObject$3(obj[prop2]);\n}\nfunction hasOwnStringProperty(obj, prop2) {\n  return baseHasOwnProperty.call(obj, prop2) && typeof obj[prop2] === \"string\";\n}\nfunction limitCloseReason(reason, whenTooLong) {\n  return reason.length < 124 ? reason : whenTooLong;\n}\nconst GRAPHQL_TRANSPORT_WS_PROTOCOL = \"graphql-transport-ws\";\nvar CloseCode;\n(function(CloseCode2) {\n  CloseCode2[CloseCode2[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n  CloseCode2[CloseCode2[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n  CloseCode2[CloseCode2[\"BadRequest\"] = 4400] = \"BadRequest\";\n  CloseCode2[CloseCode2[\"BadResponse\"] = 4004] = \"BadResponse\";\n  CloseCode2[CloseCode2[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n  CloseCode2[CloseCode2[\"Forbidden\"] = 4403] = \"Forbidden\";\n  CloseCode2[CloseCode2[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n  CloseCode2[CloseCode2[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n  CloseCode2[CloseCode2[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n  CloseCode2[CloseCode2[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n  CloseCode2[CloseCode2[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\nvar MessageType;\n(function(MessageType2) {\n  MessageType2[\"ConnectionInit\"] = \"connection_init\";\n  MessageType2[\"ConnectionAck\"] = \"connection_ack\";\n  MessageType2[\"Ping\"] = \"ping\";\n  MessageType2[\"Pong\"] = \"pong\";\n  MessageType2[\"Subscribe\"] = \"subscribe\";\n  MessageType2[\"Next\"] = \"next\";\n  MessageType2[\"Error\"] = \"error\";\n  MessageType2[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\nfunction isMessage(val) {\n  if (isObject$3(val)) {\n    if (!hasOwnStringProperty(val, \"type\")) {\n      return false;\n    }\n    switch (val.type) {\n      case MessageType.ConnectionInit:\n        return !hasOwnProperty(val, \"payload\") || val.payload === void 0 || isObject$3(val.payload);\n      case MessageType.ConnectionAck:\n      case MessageType.Ping:\n      case MessageType.Pong:\n        return !hasOwnProperty(val, \"payload\") || val.payload === void 0 || isObject$3(val.payload);\n      case MessageType.Subscribe:\n        return hasOwnStringProperty(val, \"id\") && hasOwnObjectProperty(val, \"payload\") && (!hasOwnProperty(val.payload, \"operationName\") || val.payload.operationName === void 0 || val.payload.operationName === null || typeof val.payload.operationName === \"string\") && hasOwnStringProperty(val.payload, \"query\") && (!hasOwnProperty(val.payload, \"variables\") || val.payload.variables === void 0 || val.payload.variables === null || hasOwnObjectProperty(val.payload, \"variables\")) && (!hasOwnProperty(val.payload, \"extensions\") || val.payload.extensions === void 0 || val.payload.extensions === null || hasOwnObjectProperty(val.payload, \"extensions\"));\n      case MessageType.Next:\n        return hasOwnStringProperty(val, \"id\") && hasOwnObjectProperty(val, \"payload\");\n      case MessageType.Error:\n        return hasOwnStringProperty(val, \"id\") && areGraphQLErrors(val.payload);\n      case MessageType.Complete:\n        return hasOwnStringProperty(val, \"id\");\n      default:\n        return false;\n    }\n  }\n  return false;\n}\nfunction parseMessage(data, reviver) {\n  if (isMessage(data)) {\n    return data;\n  }\n  if (typeof data !== \"string\") {\n    throw new Error(\"Message not parsable\");\n  }\n  const message = JSON.parse(data, reviver);\n  if (!isMessage(message)) {\n    throw new Error(\"Invalid message\");\n  }\n  return message;\n}\nfunction stringifyMessage(msg, replacer) {\n  if (!isMessage(msg)) {\n    throw new Error(\"Cannot stringify invalid message\");\n  }\n  return JSON.stringify(msg, replacer);\n}\nfunction createClient$1(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = async function randomisedExponentialBackoff(retries2) {\n      let retryDelay = 1e3;\n      for (let i = 0; i < retries2; i++) {\n        retryDelay *= 2;\n      }\n      await new Promise((resolve) => setTimeout(resolve, retryDelay + Math.floor(Math.random() * (3e3 - 300) + 300)));\n    },\n    isFatalConnectionProblem = (errOrCloseEvent) => !isLikeCloseEvent(errOrCloseEvent),\n    on,\n    webSocketImpl,\n    generateID = function generateUUID() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r2 = Math.random() * 16 | 0, v2 = c == \"x\" ? r2 : r2 & 3 | 8;\n        return v2.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws2;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error(\"Invalid WebSocket implementation provided\");\n    }\n    ws2 = webSocketImpl;\n  } else if (typeof WebSocket !== \"undefined\") {\n    ws2 = WebSocket;\n  } else if (typeof global !== \"undefined\") {\n    ws2 = global.WebSocket || global.MozWebSocket;\n  } else if (typeof window !== \"undefined\") {\n    ws2 = window.WebSocket || window.MozWebSocket;\n  }\n  if (!ws2)\n    throw new Error(\"WebSocket implementation missing\");\n  const WebSocketImpl = ws2;\n  const emitter = (() => {\n    const message = (() => {\n      const listeners3 = {};\n      return {\n        on(id2, listener) {\n          listeners3[id2] = listener;\n          return () => {\n            delete listeners3[id2];\n          };\n        },\n        emit(message2) {\n          var _a2;\n          if (\"id\" in message2)\n            (_a2 = listeners3[message2.id]) === null || _a2 === void 0 ? void 0 : _a2.call(listeners3, message2);\n        }\n      };\n    })();\n    const listeners2 = {\n      connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n      opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n      connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n      ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n      pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n      message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n      closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n      error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l2 = listeners2[event];\n        l2.push(listener);\n        return () => {\n          l2.splice(l2.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        for (const listener of [...listeners2[event]]) {\n          listener(...args);\n        }\n      }\n    };\n  })();\n  function errorOrClosed(cb2) {\n    const listening = [\n      emitter.on(\"error\", (err) => {\n        listening.forEach((unlisten) => unlisten());\n        cb2(err);\n      }),\n      emitter.on(\"closed\", (event) => {\n        listening.forEach((unlisten) => unlisten());\n        cb2(event);\n      })\n    ];\n  }\n  let connecting, locks = 0, retrying = false, retries = 0, disposed = false;\n  async function connect2() {\n    const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {\n      if (retrying) {\n        await retryWait(retries);\n        if (!locks) {\n          connecting = void 0;\n          return denied({ code: 1e3, reason: \"All Subscriptions Gone\" });\n        }\n        retries++;\n      }\n      emitter.emit(\"connecting\");\n      const socket2 = new WebSocketImpl(typeof url === \"function\" ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n      let connectionAckTimeout, queuedPing;\n      function enqueuePing() {\n        if (isFinite(keepAlive) && keepAlive > 0) {\n          clearTimeout(queuedPing);\n          queuedPing = setTimeout(() => {\n            if (socket2.readyState === WebSocketImpl.OPEN) {\n              socket2.send(stringifyMessage({ type: MessageType.Ping }));\n              emitter.emit(\"ping\", false, void 0);\n            }\n          }, keepAlive);\n        }\n      }\n      errorOrClosed((errOrEvent) => {\n        connecting = void 0;\n        clearTimeout(connectionAckTimeout);\n        clearTimeout(queuedPing);\n        denied(errOrEvent);\n      });\n      socket2.onerror = (err) => emitter.emit(\"error\", err);\n      socket2.onclose = (event) => emitter.emit(\"closed\", event);\n      socket2.onopen = async () => {\n        try {\n          emitter.emit(\"opened\", socket2);\n          const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n          socket2.send(stringifyMessage(payload ? {\n            type: MessageType.ConnectionInit,\n            payload\n          } : {\n            type: MessageType.ConnectionInit\n          }, replacer));\n          if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n            connectionAckTimeout = setTimeout(() => {\n              socket2.close(CloseCode.ConnectionAcknowledgementTimeout, \"Connection acknowledgement timeout\");\n            }, connectionAckWaitTimeout);\n          }\n          enqueuePing();\n        } catch (err) {\n          emitter.emit(\"error\", err);\n          socket2.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, \"Internal client error\"));\n        }\n      };\n      let acknowledged = false;\n      socket2.onmessage = ({ data }) => {\n        try {\n          const message = parseMessage(data, reviver);\n          emitter.emit(\"message\", message);\n          if (message.type === \"ping\" || message.type === \"pong\") {\n            emitter.emit(message.type, true, message.payload);\n            if (message.type === \"pong\") {\n              enqueuePing();\n            } else if (!disablePong) {\n              socket2.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong\n              }));\n              emitter.emit(\"pong\", false, message.payload);\n            }\n            return;\n          }\n          if (acknowledged)\n            return;\n          if (message.type !== MessageType.ConnectionAck)\n            throw new Error(`First message cannot be of type ${message.type}`);\n          clearTimeout(connectionAckTimeout);\n          acknowledged = true;\n          emitter.emit(\"connected\", socket2, message.payload);\n          retrying = false;\n          retries = 0;\n          connected([\n            socket2,\n            new Promise((_, reject2) => errorOrClosed(reject2))\n          ]);\n        } catch (err) {\n          socket2.onmessage = null;\n          emitter.emit(\"error\", err);\n          socket2.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, \"Bad response\"));\n        }\n      };\n    })()));\n    if (socket.readyState === WebSocketImpl.CLOSING)\n      await throwOnClose;\n    let release = () => {\n    };\n    const released = new Promise((resolve) => release = resolve);\n    return [\n      socket,\n      release,\n      Promise.race([\n        released.then(() => {\n          if (!locks) {\n            const complete = () => socket.close(1e3, \"Normal Closure\");\n            if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n              setTimeout(() => {\n                if (!locks && socket.readyState === WebSocketImpl.OPEN)\n                  complete();\n              }, lazyCloseTimeout);\n            } else {\n              complete();\n            }\n          }\n        }),\n        throwOnClose\n      ])\n    ];\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [\n      CloseCode.InternalServerError,\n      CloseCode.InternalClientError,\n      CloseCode.BadRequest,\n      CloseCode.BadResponse,\n      CloseCode.Unauthorized,\n      CloseCode.SubprotocolNotAcceptable,\n      CloseCode.SubscriberAlreadyExists,\n      CloseCode.TooManyInitialisationRequests\n    ].includes(errOrCloseEvent.code)))\n      throw errOrCloseEvent;\n    if (disposed)\n      return false;\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)\n      return locks > 0;\n    if (!retryAttempts || retries >= retryAttempts)\n      throw errOrCloseEvent;\n    if (isFatalConnectionProblem(errOrCloseEvent))\n      throw errOrCloseEvent;\n    return retrying = true;\n  }\n  if (!lazy) {\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const [, , throwOnClose] = await connect2();\n          await throwOnClose;\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n              return;\n          } catch (errOrCloseEvent2) {\n            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent2);\n          }\n        }\n      }\n    })();\n  }\n  return {\n    on: emitter.on,\n    subscribe(payload, sink) {\n      const id2 = generateID();\n      let done = false, errored = false, releaser = () => {\n        locks--;\n        done = true;\n      };\n      (async () => {\n        locks++;\n        for (; ; ) {\n          try {\n            const [socket, release, waitForReleaseOrThrowOnClose] = await connect2();\n            if (done)\n              return release();\n            const unlisten = emitter.onMessage(id2, (message) => {\n              switch (message.type) {\n                case MessageType.Next: {\n                  sink.next(message.payload);\n                  return;\n                }\n                case MessageType.Error: {\n                  errored = true, done = true;\n                  sink.error(message.payload);\n                  releaser();\n                  return;\n                }\n                case MessageType.Complete: {\n                  done = true;\n                  releaser();\n                  return;\n                }\n              }\n            });\n            socket.send(stringifyMessage({\n              id: id2,\n              type: MessageType.Subscribe,\n              payload\n            }, replacer));\n            releaser = () => {\n              if (!done && socket.readyState === WebSocketImpl.OPEN)\n                socket.send(stringifyMessage({\n                  id: id2,\n                  type: MessageType.Complete\n                }, replacer));\n              locks--;\n              done = true;\n              release();\n            };\n            await waitForReleaseOrThrowOnClose.finally(unlisten);\n            return;\n          } catch (errOrCloseEvent) {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n              return;\n          }\n        }\n      })().then(() => {\n        if (!errored)\n          sink.complete();\n      }).catch((err) => {\n        sink.error(err);\n      });\n      return () => {\n        if (!done)\n          releaser();\n      };\n    },\n    async dispose() {\n      disposed = true;\n      if (connecting) {\n        const [socket] = await connecting;\n        socket.close(1e3, \"Normal Closure\");\n      }\n    }\n  };\n}\nfunction isLikeCloseEvent(val) {\n  return isObject$3(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code3) {\n  if ([\n    1e3,\n    1001,\n    1006,\n    1005,\n    1012,\n    1013,\n    1013\n  ].includes(code3))\n    return false;\n  return code3 >= 1e3 && code3 <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\nconst TOKEN_HEADER_KEY = \"x-graphql-event-stream-token\";\nfunction validateStreamEvent(e) {\n  e = e;\n  if (e !== \"next\" && e !== \"complete\")\n    throw new Error(`Invalid stream event \"${e}\"`);\n  return e;\n}\nfunction parseStreamData(e, data) {\n  if (data) {\n    try {\n      data = JSON.parse(data);\n    } catch (_a2) {\n      throw new Error(\"Invalid stream data\");\n    }\n  }\n  if (e === \"next\" && !data)\n    throw new Error('Stream data must be an object for \"next\" events');\n  return data || null;\n}\nfunction isObject$2(val) {\n  return typeof val === \"object\" && val !== null;\n}\nvar ControlChars;\n(function(ControlChars2) {\n  ControlChars2[ControlChars2[\"NewLine\"] = 10] = \"NewLine\";\n  ControlChars2[ControlChars2[\"CchunkiageReturn\"] = 13] = \"CchunkiageReturn\";\n  ControlChars2[ControlChars2[\"Space\"] = 32] = \"Space\";\n  ControlChars2[ControlChars2[\"Colon\"] = 58] = \"Colon\";\n})(ControlChars || (ControlChars = {}));\nfunction createParser() {\n  let buffer2;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  let message = { event: \"\", data: \"\" };\n  let pending = [];\n  const decoder2 = new TextDecoder();\n  return function parse2(chunk) {\n    if (buffer2 === void 0) {\n      buffer2 = chunk;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      const concat2 = new Uint8Array(buffer2.length + chunk.length);\n      concat2.set(buffer2);\n      concat2.set(chunk, buffer2.length);\n      buffer2 = concat2;\n    }\n    const bufLength = buffer2.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer2[position] === ControlChars.NewLine) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer2[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case ControlChars.CchunkiageReturn:\n            discardTrailingNewline = true;\n          case ControlChars.NewLine:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      } else if (lineStart === lineEnd) {\n        if (message.event || message.data) {\n          if (!message.event)\n            throw new Error(\"Missing message event\");\n          const event = validateStreamEvent(message.event);\n          const data = parseStreamData(event, message.data);\n          pending.push({\n            event,\n            data\n          });\n          message = { event: \"\", data: \"\" };\n        }\n      } else if (fieldLength > 0) {\n        const line = buffer2.subarray(lineStart, lineEnd);\n        const field = decoder2.decode(line.subarray(0, fieldLength));\n        const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n        const value = decoder2.decode(line.subarray(valueOffset));\n        switch (field) {\n          case \"event\":\n            message.event = value;\n            break;\n          case \"data\":\n            message.data = message.data ? message.data + \"\\n\" + value : value;\n            break;\n        }\n      }\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer2 = void 0;\n      const messages = [...pending];\n      pending = [];\n      return messages;\n    } else if (lineStart !== 0) {\n      buffer2 = buffer2.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nvar __asyncValues = globalThis && globalThis.__asyncValues || function(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m2 = o[Symbol.asyncIterator], i;\n  return m2 ? m2.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n2) {\n    i[n2] = o[n2] && function(v2) {\n      return new Promise(function(resolve, reject2) {\n        v2 = o[n2](v2), settle(resolve, reject2, v2.done, v2.value);\n      });\n    };\n  }\n  function settle(resolve, reject2, d, v2) {\n    Promise.resolve(v2).then(function(v3) {\n      resolve({ value: v3, done: d });\n    }, reject2);\n  }\n};\nvar __await = globalThis && globalThis.__await || function(v2) {\n  return this instanceof __await ? (this.v = v2, this) : new __await(v2);\n};\nvar __asyncGenerator = globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q2 = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n2) {\n    if (g[n2])\n      i[n2] = function(v2) {\n        return new Promise(function(a, b) {\n          q2.push([n2, v2, a, b]) > 1 || resume(n2, v2);\n        });\n      };\n  }\n  function resume(n2, v2) {\n    try {\n      step(g[n2](v2));\n    } catch (e) {\n      settle(q2[0][3], e);\n    }\n  }\n  function step(r2) {\n    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q2[0][2], r2);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject2(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v2) {\n    if (f(v2), q2.shift(), q2.length)\n      resume(q2[0][0], q2[0][1]);\n  }\n};\nfunction createClient(options) {\n  const {\n    singleConnection = false,\n    lazy = true,\n    onNonLazyError = console.error,\n    generateID = function generateUUID() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r2 = Math.random() * 16 | 0, v2 = c == \"x\" ? r2 : r2 & 3 | 8;\n        return v2.toString(16);\n      });\n    },\n    retryAttempts = 5,\n    retry = async function randomisedExponentialBackoff(retries2) {\n      let retryDelay = 1e3;\n      for (let i = 0; i < retries2; i++) {\n        retryDelay *= 2;\n      }\n      await new Promise((resolve) => setTimeout(resolve, retryDelay + Math.floor(Math.random() * (3e3 - 300) + 300)));\n    }\n  } = options;\n  const fetchFn = options.fetchFn || fetch;\n  const AbortControllerImpl = options.abortControllerImpl || AbortController;\n  const client2 = (() => {\n    let disposed = false;\n    const listeners2 = [];\n    return {\n      get disposed() {\n        return disposed;\n      },\n      onDispose(cb2) {\n        if (disposed) {\n          setTimeout(() => cb2(), 0);\n          return () => {\n          };\n        }\n        listeners2.push(cb2);\n        return () => {\n          listeners2.splice(listeners2.indexOf(cb2), 1);\n        };\n      },\n      dispose() {\n        if (disposed)\n          return;\n        disposed = true;\n        for (const listener of [...listeners2]) {\n          listener();\n        }\n      }\n    };\n  })();\n  let connCtrl, conn, locks = 0, retryingErr = null, retries = 0;\n  async function getOrConnect() {\n    try {\n      if (client2.disposed)\n        throw new Error(\"Client has been disposed\");\n      return await (conn !== null && conn !== void 0 ? conn : conn = (async () => {\n        var _a2;\n        if (retryingErr) {\n          await retry(retries);\n          if (connCtrl.signal.aborted)\n            throw new Error(\"Connection aborted by the client\");\n          retries++;\n        }\n        connCtrl = new AbortControllerImpl();\n        const unlistenDispose = client2.onDispose(() => connCtrl.abort());\n        connCtrl.signal.addEventListener(\"abort\", () => {\n          unlistenDispose();\n          conn = void 0;\n        });\n        const url = typeof options.url === \"function\" ? await options.url() : options.url;\n        if (connCtrl.signal.aborted)\n          throw new Error(\"Connection aborted by the client\");\n        const headers = typeof options.headers === \"function\" ? await options.headers() : (_a2 = options.headers) !== null && _a2 !== void 0 ? _a2 : {};\n        if (connCtrl.signal.aborted)\n          throw new Error(\"Connection aborted by the client\");\n        let res;\n        try {\n          res = await fetchFn(url, {\n            signal: connCtrl.signal,\n            method: \"PUT\",\n            headers\n          });\n        } catch (err) {\n          throw new NetworkError(err);\n        }\n        if (res.status !== 201)\n          throw new NetworkError(res);\n        const token2 = await res.text();\n        headers[TOKEN_HEADER_KEY] = token2;\n        const connected = await connect({\n          signal: connCtrl.signal,\n          headers,\n          url,\n          fetchFn\n        });\n        retryingErr = null;\n        retries = 0;\n        connected.waitForThrow().catch(() => conn = void 0);\n        return connected;\n      })());\n    } catch (err) {\n      conn = void 0;\n      throw err;\n    }\n  }\n  if (singleConnection && !lazy) {\n    (async () => {\n      locks++;\n      for (; ; ) {\n        try {\n          const { waitForThrow } = await getOrConnect();\n          await waitForThrow();\n        } catch (err) {\n          if (client2.disposed)\n            return;\n          if (!(err instanceof NetworkError))\n            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);\n          if (!retryAttempts || retries >= retryAttempts)\n            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);\n          retryingErr = err;\n        }\n      }\n    })();\n  }\n  return {\n    subscribe(request, sink) {\n      if (!singleConnection) {\n        const control2 = new AbortControllerImpl();\n        const unlisten2 = client2.onDispose(() => {\n          unlisten2();\n          control2.abort();\n        });\n        (async () => {\n          var e_1, _a2;\n          var _b;\n          let retryingErr2 = null, retries2 = 0;\n          for (; ; ) {\n            try {\n              if (retryingErr2) {\n                await retry(retries2);\n                if (control2.signal.aborted)\n                  throw new Error(\"Connection aborted by the client\");\n                retries2++;\n              }\n              const url = typeof options.url === \"function\" ? await options.url() : options.url;\n              if (control2.signal.aborted)\n                throw new Error(\"Connection aborted by the client\");\n              const headers = typeof options.headers === \"function\" ? await options.headers() : (_b = options.headers) !== null && _b !== void 0 ? _b : {};\n              if (control2.signal.aborted)\n                throw new Error(\"Connection aborted by the client\");\n              const { getResults } = await connect({\n                signal: control2.signal,\n                headers,\n                url,\n                body: JSON.stringify(request),\n                fetchFn\n              });\n              retryingErr2 = null;\n              retries2 = 0;\n              try {\n                for (var _c = (e_1 = void 0, __asyncValues(getResults())), _d; _d = await _c.next(), !_d.done; ) {\n                  const result2 = _d.value;\n                  sink.next(result2);\n                }\n              } catch (e_1_1) {\n                e_1 = { error: e_1_1 };\n              } finally {\n                try {\n                  if (_d && !_d.done && (_a2 = _c.return))\n                    await _a2.call(_c);\n                } finally {\n                  if (e_1)\n                    throw e_1.error;\n                }\n              }\n              return control2.abort();\n            } catch (err) {\n              if (control2.signal.aborted)\n                return;\n              if (!(err instanceof NetworkError))\n                throw err;\n              if (!retryAttempts || retries2 >= retryAttempts)\n                throw err;\n              retryingErr2 = err;\n            }\n          }\n        })().then(() => sink.complete()).catch((err) => sink.error(err));\n        return () => control2.abort();\n      }\n      locks++;\n      const control = new AbortControllerImpl();\n      const unlisten = client2.onDispose(() => {\n        unlisten();\n        control.abort();\n      });\n      (async () => {\n        var e_2, _a2;\n        const operationId = generateID();\n        request = Object.assign(Object.assign({}, request), { extensions: Object.assign(Object.assign({}, request.extensions), { operationId }) });\n        let complete = null;\n        for (; ; ) {\n          complete = null;\n          try {\n            const { url, headers, getResults } = await getOrConnect();\n            let res;\n            try {\n              res = await fetchFn(url, {\n                signal: control.signal,\n                method: \"POST\",\n                headers,\n                body: JSON.stringify(request)\n              });\n            } catch (err) {\n              throw new NetworkError(err);\n            }\n            if (res.status !== 202)\n              throw new NetworkError(res);\n            complete = async () => {\n              let res2;\n              try {\n                const control2 = new AbortControllerImpl();\n                const unlisten2 = client2.onDispose(() => {\n                  unlisten2();\n                  control2.abort();\n                });\n                res2 = await fetchFn(url + \"?operationId=\" + operationId, {\n                  signal: control2.signal,\n                  method: \"DELETE\",\n                  headers\n                });\n              } catch (err) {\n                throw new NetworkError(err);\n              }\n              if (res2.status !== 200)\n                throw new NetworkError(res2);\n            };\n            try {\n              for (var _b = (e_2 = void 0, __asyncValues(getResults({\n                signal: control.signal,\n                operationId\n              }))), _c; _c = await _b.next(), !_c.done; ) {\n                const result2 = _c.value;\n                sink.next(result2);\n              }\n            } catch (e_2_1) {\n              e_2 = { error: e_2_1 };\n            } finally {\n              try {\n                if (_c && !_c.done && (_a2 = _b.return))\n                  await _a2.call(_b);\n              } finally {\n                if (e_2)\n                  throw e_2.error;\n              }\n            }\n            complete = null;\n            return control.abort();\n          } catch (err) {\n            if (control.signal.aborted)\n              return await (complete === null || complete === void 0 ? void 0 : complete());\n            if (!(err instanceof NetworkError))\n              throw err;\n            if (!retryAttempts || retries >= retryAttempts)\n              throw err;\n            retryingErr = err;\n          } finally {\n            if (control.signal.aborted && --locks === 0)\n              connCtrl.abort();\n          }\n        }\n      })().then(() => sink.complete()).catch((err) => sink.error(err));\n      return () => control.abort();\n    },\n    dispose() {\n      client2.dispose();\n    }\n  };\n}\nclass NetworkError extends Error {\n  constructor(msgOrErrOrResponse) {\n    let message, response;\n    if (isResponseLike(msgOrErrOrResponse)) {\n      response = msgOrErrOrResponse;\n      message = \"Server responded with \" + msgOrErrOrResponse.status + \": \" + msgOrErrOrResponse.statusText;\n    } else if (msgOrErrOrResponse instanceof Error)\n      message = msgOrErrOrResponse.message;\n    else\n      message = String(msgOrErrOrResponse);\n    super(message);\n    this.name = this.constructor.name;\n    this.response = response;\n  }\n}\nfunction isResponseLike(val) {\n  return isObject$2(val) && typeof val[\"ok\"] === \"boolean\" && typeof val[\"status\"] === \"number\" && typeof val[\"statusText\"] === \"string\";\n}\nasync function connect(options) {\n  const { signal, url, headers, body, fetchFn } = options;\n  const waiting = {};\n  const queue = {};\n  let res;\n  try {\n    res = await fetchFn(url, {\n      signal,\n      method: body ? \"POST\" : \"GET\",\n      headers: Object.assign(Object.assign({}, headers), { accept: \"text/event-stream\" }),\n      body\n    });\n  } catch (err) {\n    throw new NetworkError(err);\n  }\n  if (!res.ok)\n    throw new NetworkError(res);\n  if (!res.body)\n    throw new Error(\"Missing response body\");\n  let error2 = null;\n  let waitingForThrow = null;\n  (async () => {\n    var e_3, _a2;\n    var _b;\n    try {\n      const parse2 = createParser();\n      try {\n        for (var _c = __asyncValues(toAsyncIterator(res.body)), _d; _d = await _c.next(), !_d.done; ) {\n          const chunk = _d.value;\n          if (typeof chunk === \"string\")\n            throw new Error(`Unexpected string chunk \"${chunk}\"`);\n          const msgs = parse2(chunk);\n          if (!msgs)\n            continue;\n          for (const msg of msgs) {\n            const operationId = msg.data && \"id\" in msg.data ? msg.data.id : \"\";\n            if (!(operationId in queue))\n              queue[operationId] = [];\n            switch (msg.event) {\n              case \"next\":\n                if (operationId)\n                  queue[operationId].push(msg.data.payload);\n                else\n                  queue[operationId].push(msg.data);\n                break;\n              case \"complete\":\n                queue[operationId].push(\"complete\");\n                break;\n              default:\n                throw new Error(`Unexpected message event \"${msg.event}\"`);\n            }\n            (_b = waiting[operationId]) === null || _b === void 0 ? void 0 : _b.proceed();\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = { error: e_3_1 };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a2 = _c.return))\n            await _a2.call(_c);\n        } finally {\n          if (e_3)\n            throw e_3.error;\n        }\n      }\n    } catch (err) {\n      error2 = err;\n      if (waitingForThrow)\n        waitingForThrow(err);\n    } finally {\n      Object.values(waiting).forEach(({ proceed }) => proceed());\n    }\n  })();\n  return {\n    url,\n    headers,\n    waitForThrow: () => new Promise((_, reject2) => {\n      if (error2)\n        return reject2(error2);\n      waitingForThrow = reject2;\n    }),\n    getResults(options2) {\n      var _a2;\n      return __asyncGenerator(this, arguments, function* getResults_1() {\n        const { signal: signal2, operationId = \"\" } = options2 !== null && options2 !== void 0 ? options2 : {};\n        try {\n          for (; ; ) {\n            while ((_a2 = queue[operationId]) === null || _a2 === void 0 ? void 0 : _a2.length) {\n              const result2 = queue[operationId].shift();\n              if (result2 === \"complete\")\n                return yield __await(void 0);\n              yield yield __await(result2);\n            }\n            if (error2)\n              throw error2;\n            if (signal2 === null || signal2 === void 0 ? void 0 : signal2.aborted)\n              throw new Error(\"Getting results aborted by the client\");\n            yield __await(new Promise((resolve) => {\n              const proceed = () => {\n                signal2 === null || signal2 === void 0 ? void 0 : signal2.removeEventListener(\"abort\", proceed);\n                delete waiting[operationId];\n                resolve();\n              };\n              signal2 === null || signal2 === void 0 ? void 0 : signal2.addEventListener(\"abort\", proceed);\n              waiting[operationId] = { proceed };\n            }));\n          }\n        } finally {\n          delete queue[operationId];\n        }\n      });\n    }\n  };\n}\nfunction toAsyncIterator(val) {\n  if (typeof Object(val)[Symbol.asyncIterator] === \"function\") {\n    val = val;\n    return val[Symbol.asyncIterator]();\n  }\n  return function() {\n    return __asyncGenerator(this, arguments, function* () {\n      val = val;\n      const reader = val.getReader();\n      for (; ; ) {\n        const { value, done } = yield __await(reader.read());\n        if (done)\n          return yield __await(value);\n        yield yield __await(value);\n      }\n    });\n  }();\n}\nvar ws = null;\nif (typeof WebSocket !== \"undefined\") {\n  ws = WebSocket;\n} else if (typeof MozWebSocket !== \"undefined\") {\n  ws = MozWebSocket;\n} else if (typeof commonjsGlobal !== \"undefined\") {\n  ws = commonjsGlobal.WebSocket || commonjsGlobal.MozWebSocket;\n} else if (typeof window !== \"undefined\") {\n  ws = window.WebSocket || window.MozWebSocket;\n} else if (typeof self !== \"undefined\") {\n  ws = self.WebSocket || self.MozWebSocket;\n}\nvar browser$1 = ws;\nvar ReactNativeFile_1 = class ReactNativeFile {\n  constructor({ uri, name: name2, type: type2 }) {\n    this.uri = uri;\n    this.name = name2;\n    this.type = type2;\n  }\n};\nconst ReactNativeFile2 = ReactNativeFile_1;\nvar isExtractableFile = function isExtractableFile2(value) {\n  return typeof File !== \"undefined\" && value instanceof File || typeof Blob !== \"undefined\" && value instanceof Blob || value instanceof ReactNativeFile2;\n};\nvar isExtractableFile$1 = isExtractableFile;\nconst defaultIsExtractableFile = isExtractableFile;\nvar extractFiles = function extractFiles2(value, path = \"\", isExtractableFile3 = defaultIsExtractableFile) {\n  const files = /* @__PURE__ */ new Map();\n  const clones = /* @__PURE__ */ new Map();\n  function recurse(value2, path2, recursed) {\n    let clone = value2;\n    if (isExtractableFile3(value2)) {\n      clone = null;\n      const filePaths = files.get(value2);\n      filePaths ? filePaths.push(path2) : files.set(value2, [path2]);\n    } else {\n      const isList2 = Array.isArray(value2) || typeof FileList !== \"undefined\" && value2 instanceof FileList;\n      const isObject2 = value2 && value2.constructor === Object;\n      if (isList2 || isObject2) {\n        const hasClone = clones.has(value2);\n        if (hasClone)\n          clone = clones.get(value2);\n        else {\n          clone = isList2 ? [] : {};\n          clones.set(value2, clone);\n        }\n        if (!recursed.has(value2)) {\n          const pathPrefix = path2 ? `${path2}.` : \"\";\n          const recursedDeeper = new Set(recursed).add(value2);\n          if (isList2) {\n            let index = 0;\n            for (const item of value2) {\n              const itemClone = recurse(item, pathPrefix + index++, recursedDeeper);\n              if (!hasClone)\n                clone.push(itemClone);\n            }\n          } else\n            for (const key in value2) {\n              const propertyClone = recurse(value2[key], pathPrefix + key, recursedDeeper);\n              if (!hasClone)\n                clone[key] = propertyClone;\n            }\n        }\n      }\n    }\n    return clone;\n  }\n  return {\n    clone: recurse(value, path, /* @__PURE__ */ new Set()),\n    files\n  };\n};\nvar extractFiles$1 = extractFiles;\nvar client = {};\nvar backo2 = Backoff$1;\nfunction Backoff$1(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 1e4;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\nBackoff$1.prototype.duration = function() {\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand = Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\nBackoff$1.prototype.reset = function() {\n  this.attempts = 0;\n};\nBackoff$1.prototype.setMin = function(min) {\n  this.ms = min;\n};\nBackoff$1.prototype.setMax = function(max) {\n  this.max = max;\n};\nBackoff$1.prototype.setJitter = function(jitter) {\n  this.jitter = jitter;\n};\nvar eventemitter3 = { exports: {} };\n(function(module2) {\n  var has2 = Object.prototype.hasOwnProperty, prefix = \"~\";\n  function Events() {\n  }\n  if (Object.create) {\n    Events.prototype = /* @__PURE__ */ Object.create(null);\n    if (!new Events().__proto__)\n      prefix = false;\n  }\n  function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n  }\n  function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt])\n      emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn)\n      emitter._events[evt].push(listener);\n    else\n      emitter._events[evt] = [emitter._events[evt], listener];\n    return emitter;\n  }\n  function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0)\n      emitter._events = new Events();\n    else\n      delete emitter._events[evt];\n  }\n  function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n  EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name2;\n    if (this._eventsCount === 0)\n      return names;\n    for (name2 in events = this._events) {\n      if (has2.call(events, name2))\n        names.push(prefix ? name2.slice(1) : name2);\n    }\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n  };\n  EventEmitter.prototype.listeners = function listeners2(event) {\n    var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n    if (!handlers)\n      return [];\n    if (handlers.fn)\n      return [handlers.fn];\n    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {\n      ee2[i] = handlers[i].fn;\n    }\n    return ee2;\n  };\n  EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];\n    if (!listeners2)\n      return 0;\n    if (listeners2.fn)\n      return 1;\n    return listeners2.length;\n  };\n  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt])\n      return false;\n    var listeners2 = this._events[evt], len = arguments.length, args, i;\n    if (listeners2.fn) {\n      if (listeners2.once)\n        this.removeListener(event, listeners2.fn, void 0, true);\n      switch (len) {\n        case 1:\n          return listeners2.fn.call(listeners2.context), true;\n        case 2:\n          return listeners2.fn.call(listeners2.context, a1), true;\n        case 3:\n          return listeners2.fn.call(listeners2.context, a1, a2), true;\n        case 4:\n          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;\n        case 5:\n          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;\n        case 6:\n          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;\n      }\n      for (i = 1, args = new Array(len - 1); i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n      listeners2.fn.apply(listeners2.context, args);\n    } else {\n      var length = listeners2.length, j;\n      for (i = 0; i < length; i++) {\n        if (listeners2[i].once)\n          this.removeListener(event, listeners2[i].fn, void 0, true);\n        switch (len) {\n          case 1:\n            listeners2[i].fn.call(listeners2[i].context);\n            break;\n          case 2:\n            listeners2[i].fn.call(listeners2[i].context, a1);\n            break;\n          case 3:\n            listeners2[i].fn.call(listeners2[i].context, a1, a2);\n            break;\n          case 4:\n            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);\n            break;\n          default:\n            if (!args)\n              for (j = 1, args = new Array(len - 1); j < len; j++) {\n                args[j - 1] = arguments[j];\n              }\n            listeners2[i].fn.apply(listeners2[i].context, args);\n        }\n      }\n    }\n    return true;\n  };\n  EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n  };\n  EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n  };\n  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt])\n      return this;\n    if (!fn) {\n      clearEvent(this, evt);\n      return this;\n    }\n    var listeners2 = this._events[evt];\n    if (listeners2.fn) {\n      if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {\n        clearEvent(this, evt);\n      }\n    } else {\n      for (var i = 0, events = [], length = listeners2.length; i < length; i++) {\n        if (listeners2[i].fn !== fn || once && !listeners2[i].once || context && listeners2[i].context !== context) {\n          events.push(listeners2[i]);\n        }\n      }\n      if (events.length)\n        this._events[evt] = events.length === 1 ? events[0] : events;\n      else\n        clearEvent(this, evt);\n    }\n    return this;\n  };\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n      evt = prefix ? prefix + event : event;\n      if (this._events[evt])\n        clearEvent(this, evt);\n    } else {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n    return this;\n  };\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n  EventEmitter.prefixed = prefix;\n  EventEmitter.EventEmitter = EventEmitter;\n  {\n    module2.exports = EventEmitter;\n  }\n})(eventemitter3);\nvar isString$1 = {};\nObject.defineProperty(isString$1, \"__esModule\", { value: true });\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nisString$1.default = isString;\nvar isObject$1 = {};\nObject.defineProperty(isObject$1, \"__esModule\", { value: true });\nfunction isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nisObject$1.default = isObject;\nvar require$$4 = /* @__PURE__ */ getAugmentedNamespace(printer);\nvar require$$5 = /* @__PURE__ */ getAugmentedNamespace(getOperationAST$1);\nfunction symbolObservablePonyfill(root2) {\n  var result2;\n  var Symbol2 = root2.Symbol;\n  if (typeof Symbol2 === \"function\") {\n    if (Symbol2.observable) {\n      result2 = Symbol2.observable;\n    } else {\n      result2 = Symbol2(\"observable\");\n      Symbol2.observable = result2;\n    }\n  } else {\n    result2 = \"@@observable\";\n  }\n  return result2;\n}\nvar root;\nif (typeof self !== \"undefined\") {\n  root = self;\n} else if (typeof window !== \"undefined\") {\n  root = window;\n} else if (typeof global !== \"undefined\") {\n  root = global;\n} else if (typeof module !== \"undefined\") {\n  root = module;\n} else {\n  root = Function(\"return this\")();\n}\nvar result = symbolObservablePonyfill(root);\nvar es = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": result\n});\nvar require$$6 = /* @__PURE__ */ getAugmentedNamespace(es);\nvar protocol = {};\nObject.defineProperty(protocol, \"__esModule\", { value: true });\nprotocol.GRAPHQL_SUBSCRIPTIONS = protocol.GRAPHQL_WS = void 0;\nvar GRAPHQL_WS = \"graphql-ws\";\nprotocol.GRAPHQL_WS = GRAPHQL_WS;\nvar GRAPHQL_SUBSCRIPTIONS = \"graphql-subscriptions\";\nprotocol.GRAPHQL_SUBSCRIPTIONS = GRAPHQL_SUBSCRIPTIONS;\nvar defaults = {};\nObject.defineProperty(defaults, \"__esModule\", { value: true });\ndefaults.WS_TIMEOUT = defaults.MIN_WS_TIMEOUT = void 0;\nvar MIN_WS_TIMEOUT = 1e3;\ndefaults.MIN_WS_TIMEOUT = MIN_WS_TIMEOUT;\nvar WS_TIMEOUT = 3e4;\ndefaults.WS_TIMEOUT = WS_TIMEOUT;\nvar messageTypes = {};\nObject.defineProperty(messageTypes, \"__esModule\", { value: true });\nvar MessageTypes = function() {\n  function MessageTypes2() {\n    throw new Error(\"Static Class\");\n  }\n  MessageTypes2.GQL_CONNECTION_INIT = \"connection_init\";\n  MessageTypes2.GQL_CONNECTION_ACK = \"connection_ack\";\n  MessageTypes2.GQL_CONNECTION_ERROR = \"connection_error\";\n  MessageTypes2.GQL_CONNECTION_KEEP_ALIVE = \"ka\";\n  MessageTypes2.GQL_CONNECTION_TERMINATE = \"connection_terminate\";\n  MessageTypes2.GQL_START = \"start\";\n  MessageTypes2.GQL_DATA = \"data\";\n  MessageTypes2.GQL_ERROR = \"error\";\n  MessageTypes2.GQL_COMPLETE = \"complete\";\n  MessageTypes2.GQL_STOP = \"stop\";\n  MessageTypes2.SUBSCRIPTION_START = \"subscription_start\";\n  MessageTypes2.SUBSCRIPTION_DATA = \"subscription_data\";\n  MessageTypes2.SUBSCRIPTION_SUCCESS = \"subscription_success\";\n  MessageTypes2.SUBSCRIPTION_FAIL = \"subscription_fail\";\n  MessageTypes2.SUBSCRIPTION_END = \"subscription_end\";\n  MessageTypes2.INIT = \"init\";\n  MessageTypes2.INIT_SUCCESS = \"init_success\";\n  MessageTypes2.INIT_FAIL = \"init_fail\";\n  MessageTypes2.KEEP_ALIVE = \"keepalive\";\n  return MessageTypes2;\n}();\nmessageTypes.default = MessageTypes;\nvar __assign = commonjsGlobal && commonjsGlobal.__assign || function() {\n  __assign = Object.assign || function(t2) {\n    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {\n      s = arguments[i];\n      for (var p2 in s)\n        if (Object.prototype.hasOwnProperty.call(s, p2))\n          t2[p2] = s[p2];\n    }\n    return t2;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {\n  function adopt(value) {\n    return value instanceof P2 ? value : new P2(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P2 || (P2 = Promise))(function(resolve, reject2) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject2(e);\n      }\n    }\n    function step(result2) {\n      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {\n  var _ = { label: 0, sent: function() {\n    if (t2[0] & 1)\n      throw t2[1];\n    return t2[1];\n  }, trys: [], ops: [] }, f, y2, t2, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n2) {\n    return function(v2) {\n      return step([n2, v2]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError(\"Generator is already executing.\");\n    while (_)\n      try {\n        if (f = 1, y2 && (t2 = op[0] & 2 ? y2[\"return\"] : op[0] ? y2[\"throw\"] || ((t2 = y2[\"return\"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)\n          return t2;\n        if (y2 = 0, t2)\n          op = [op[0] & 2, t2.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t2 = op;\n            break;\n          case 4:\n            _.label++;\n            return { value: op[1], done: false };\n          case 5:\n            _.label++;\n            y2 = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t2[1]) {\n              _.label = t2[1];\n              t2 = op;\n              break;\n            }\n            if (t2 && _.label < t2[2]) {\n              _.label = t2[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t2[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y2 = 0;\n      } finally {\n        f = t2 = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return { value: op[0] ? op[1] : void 0, done: true };\n  }\n};\nvar __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {\n  if (pack || arguments.length === 2)\n    for (var i = 0, l2 = from.length, ar; i < l2; i++) {\n      if (ar || !(i in from)) {\n        if (!ar)\n          ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(client, \"__esModule\", { value: true });\nvar SubscriptionClient_1 = client.SubscriptionClient = void 0;\nvar _global = typeof commonjsGlobal !== \"undefined\" ? commonjsGlobal : typeof window !== \"undefined\" ? window : {};\nvar NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\nvar Backoff = backo2;\nvar eventemitter3_1 = eventemitter3.exports;\nvar is_string_1 = isString$1;\nvar is_object_1 = isObject$1;\nvar printer_1 = require$$4;\nvar getOperationAST_1 = require$$5;\nvar symbol_observable_1 = require$$6;\nvar protocol_1 = protocol;\nvar defaults_1 = defaults;\nvar message_types_1 = messageTypes;\nvar SubscriptionClient = function() {\n  function SubscriptionClient2(url, options, webSocketImpl, webSocketProtocols) {\n    var _a2 = options || {}, _b = _a2.connectionCallback, connectionCallback = _b === void 0 ? void 0 : _b, _c = _a2.connectionParams, connectionParams = _c === void 0 ? {} : _c, _d = _a2.minTimeout, minTimeout = _d === void 0 ? defaults_1.MIN_WS_TIMEOUT : _d, _e = _a2.timeout, timeout = _e === void 0 ? defaults_1.WS_TIMEOUT : _e, _f = _a2.reconnect, reconnect = _f === void 0 ? false : _f, _g = _a2.reconnectionAttempts, reconnectionAttempts = _g === void 0 ? Infinity : _g, _h = _a2.lazy, lazy = _h === void 0 ? false : _h, _j = _a2.inactivityTimeout, inactivityTimeout = _j === void 0 ? 0 : _j, _k = _a2.wsOptionArguments, wsOptionArguments = _k === void 0 ? [] : _k;\n    this.wsImpl = webSocketImpl || NativeWebSocket;\n    if (!this.wsImpl) {\n      throw new Error(\"Unable to find native implementation, or alternative implementation for WebSocket!\");\n    }\n    this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.minWsTimeout = minTimeout;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({ jitter: 0.5 });\n    this.eventEmitter = new eventemitter3_1.EventEmitter();\n    this.middlewares = [];\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n    this.wsOptionArguments = wsOptionArguments;\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n  Object.defineProperty(SubscriptionClient2.prototype, \"status\", {\n    get: function() {\n      if (this.client === null) {\n        return this.wsImpl.CLOSED;\n      }\n      return this.client.readyState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SubscriptionClient2.prototype.close = function(isForced, closedByUser) {\n    if (isForced === void 0) {\n      isForced = true;\n    }\n    if (closedByUser === void 0) {\n      closedByUser = true;\n    }\n    this.clearInactivityTimeout();\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_TERMINATE, null);\n      }\n      this.client.close();\n      this.client.onopen = null;\n      this.client.onclose = null;\n      this.client.onerror = null;\n      this.client.onmessage = null;\n      this.client = null;\n      this.eventEmitter.emit(\"disconnected\");\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  };\n  SubscriptionClient2.prototype.request = function(request) {\n    var _a2;\n    var getObserver = this.getObserver.bind(this);\n    var executeOperation2 = this.executeOperation.bind(this);\n    var unsubscribe = this.unsubscribe.bind(this);\n    var opId;\n    this.clearInactivityTimeout();\n    return _a2 = {}, _a2[symbol_observable_1.default] = function() {\n      return this;\n    }, _a2.subscribe = function(observerOrNext, onError, onComplete) {\n      var observer = getObserver(observerOrNext, onError, onComplete);\n      opId = executeOperation2(request, function(error2, result2) {\n        if (error2 === null && result2 === null) {\n          if (observer.complete) {\n            observer.complete();\n          }\n        } else if (error2) {\n          if (observer.error) {\n            observer.error(error2[0]);\n          }\n        } else {\n          if (observer.next) {\n            observer.next(result2);\n          }\n        }\n      });\n      return {\n        unsubscribe: function() {\n          if (opId) {\n            unsubscribe(opId);\n            opId = null;\n          }\n        }\n      };\n    }, _a2;\n  };\n  SubscriptionClient2.prototype.on = function(eventName, callback, context) {\n    var handler = this.eventEmitter.on(eventName, callback, context);\n    return function() {\n      handler.off(eventName, callback, context);\n    };\n  };\n  SubscriptionClient2.prototype.onConnected = function(callback, context) {\n    return this.on(\"connected\", callback, context);\n  };\n  SubscriptionClient2.prototype.onConnecting = function(callback, context) {\n    return this.on(\"connecting\", callback, context);\n  };\n  SubscriptionClient2.prototype.onDisconnected = function(callback, context) {\n    return this.on(\"disconnected\", callback, context);\n  };\n  SubscriptionClient2.prototype.onReconnected = function(callback, context) {\n    return this.on(\"reconnected\", callback, context);\n  };\n  SubscriptionClient2.prototype.onReconnecting = function(callback, context) {\n    return this.on(\"reconnecting\", callback, context);\n  };\n  SubscriptionClient2.prototype.onError = function(callback, context) {\n    return this.on(\"error\", callback, context);\n  };\n  SubscriptionClient2.prototype.unsubscribeAll = function() {\n    var _this = this;\n    Object.keys(this.operations).forEach(function(subId) {\n      _this.unsubscribe(subId);\n    });\n  };\n  SubscriptionClient2.prototype.applyMiddlewares = function(options) {\n    var _this = this;\n    return new Promise(function(resolve, reject2) {\n      var queue = function(funcs, scope) {\n        var next = function(error2) {\n          if (error2) {\n            reject2(error2);\n          } else {\n            if (funcs.length > 0) {\n              var f = funcs.shift();\n              if (f) {\n                f.applyMiddleware.apply(scope, [options, next]);\n              }\n            } else {\n              resolve(options);\n            }\n          }\n        };\n        next();\n      };\n      queue(__spreadArray([], _this.middlewares, true), _this);\n    });\n  };\n  SubscriptionClient2.prototype.use = function(middlewares) {\n    var _this = this;\n    middlewares.map(function(middleware) {\n      if (typeof middleware.applyMiddleware === \"function\") {\n        _this.middlewares.push(middleware);\n      } else {\n        throw new Error(\"Middleware must implement the applyMiddleware function.\");\n      }\n    });\n    return this;\n  };\n  SubscriptionClient2.prototype.getConnectionParams = function(connectionParams) {\n    return function() {\n      return new Promise(function(resolve, reject2) {\n        if (typeof connectionParams === \"function\") {\n          try {\n            return resolve(connectionParams.call(null));\n          } catch (error2) {\n            return reject2(error2);\n          }\n        }\n        resolve(connectionParams);\n      });\n    };\n  };\n  SubscriptionClient2.prototype.executeOperation = function(options, handler) {\n    var _this = this;\n    if (this.client === null) {\n      this.connect();\n    }\n    var opId = this.generateOperationId();\n    this.operations[opId] = { options, handler };\n    this.applyMiddlewares(options).then(function(processedOptions) {\n      _this.checkOperationOptions(processedOptions, handler);\n      if (_this.operations[opId]) {\n        _this.operations[opId] = { options: processedOptions, handler };\n        _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);\n      }\n    }).catch(function(error2) {\n      _this.unsubscribe(opId);\n      handler(_this.formatErrors(error2));\n    });\n    return opId;\n  };\n  SubscriptionClient2.prototype.getObserver = function(observerOrNext, error2, complete) {\n    if (typeof observerOrNext === \"function\") {\n      return {\n        next: function(v2) {\n          return observerOrNext(v2);\n        },\n        error: function(e) {\n          return error2 && error2(e);\n        },\n        complete: function() {\n          return complete && complete();\n        }\n      };\n    }\n    return observerOrNext;\n  };\n  SubscriptionClient2.prototype.createMaxConnectTimeGenerator = function() {\n    var minValue = this.minWsTimeout;\n    var maxValue = this.wsTimeout;\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2\n    });\n  };\n  SubscriptionClient2.prototype.clearCheckConnectionInterval = function() {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  };\n  SubscriptionClient2.prototype.clearMaxConnectTimeout = function() {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n  };\n  SubscriptionClient2.prototype.clearTryReconnectTimeout = function() {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  };\n  SubscriptionClient2.prototype.clearInactivityTimeout = function() {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  };\n  SubscriptionClient2.prototype.setInactivityTimeout = function() {\n    var _this = this;\n    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n      this.inactivityTimeoutId = setTimeout(function() {\n        if (Object.keys(_this.operations).length === 0) {\n          _this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  };\n  SubscriptionClient2.prototype.checkOperationOptions = function(options, handler) {\n    var query = options.query, variables = options.variables, operationName = options.operationName;\n    if (!query) {\n      throw new Error(\"Must provide a query.\");\n    }\n    if (!handler) {\n      throw new Error(\"Must provide an handler.\");\n    }\n    if (!(0, is_string_1.default)(query) && !(0, getOperationAST_1.getOperationAST)(query, operationName) || operationName && !(0, is_string_1.default)(operationName) || variables && !(0, is_object_1.default)(variables)) {\n      throw new Error(\"Incorrect option types. query must be a string or a document,`operationName` must be a string, and `variables` must be an object.\");\n    }\n  };\n  SubscriptionClient2.prototype.buildMessage = function(id2, type2, payload) {\n    var payloadToReturn = payload && payload.query ? __assign(__assign({}, payload), { query: typeof payload.query === \"string\" ? payload.query : (0, printer_1.print)(payload.query) }) : payload;\n    return {\n      id: id2,\n      type: type2,\n      payload: payloadToReturn\n    };\n  };\n  SubscriptionClient2.prototype.formatErrors = function(errors2) {\n    if (Array.isArray(errors2)) {\n      return errors2;\n    }\n    if (errors2 && errors2.errors) {\n      return this.formatErrors(errors2.errors);\n    }\n    if (errors2 && errors2.message) {\n      return [errors2];\n    }\n    return [{\n      name: \"FormatedError\",\n      message: \"Unknown error\",\n      originalError: errors2\n    }];\n  };\n  SubscriptionClient2.prototype.sendMessage = function(id2, type2, payload) {\n    this.sendMessageRaw(this.buildMessage(id2, type2, payload));\n  };\n  SubscriptionClient2.prototype.sendMessageRaw = function(message) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        var serializedMessage = JSON.stringify(message);\n        try {\n          JSON.parse(serializedMessage);\n        } catch (e) {\n          this.eventEmitter.emit(\"error\", new Error(\"Message must be JSON-serializable. Got: \" + message));\n        }\n        this.client.send(serializedMessage);\n        break;\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n        break;\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter.emit(\"error\", new Error(\"A message was not sent because socket is not connected, is closing or is already closed. Message was: \" + JSON.stringify(message)));\n        }\n    }\n  };\n  SubscriptionClient2.prototype.generateOperationId = function() {\n    return String(++this.nextOperationId);\n  };\n  SubscriptionClient2.prototype.tryReconnect = function() {\n    var _this = this;\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach(function(key) {\n        _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));\n      });\n      this.reconnecting = true;\n    }\n    this.clearTryReconnectTimeout();\n    var delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(function() {\n      _this.connect();\n    }, delay);\n  };\n  SubscriptionClient2.prototype.flushUnsentMessagesQueue = function() {\n    var _this = this;\n    this.unsentMessagesQueue.forEach(function(message) {\n      _this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  };\n  SubscriptionClient2.prototype.checkConnection = function() {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  };\n  SubscriptionClient2.prototype.checkMaxConnectTimeout = function() {\n    var _this = this;\n    this.clearMaxConnectTimeout();\n    this.maxConnectTimeoutId = setTimeout(function() {\n      if (_this.status !== _this.wsImpl.OPEN) {\n        _this.reconnecting = true;\n        _this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  };\n  SubscriptionClient2.prototype.connect = function() {\n    var _a2;\n    var _this = this;\n    this.client = new ((_a2 = this.wsImpl).bind.apply(_a2, __spreadArray([void 0, this.url, this.wsProtocols], this.wsOptionArguments, false)))();\n    this.checkMaxConnectTimeout();\n    this.client.onopen = function() {\n      return __awaiter(_this, void 0, void 0, function() {\n        var connectionParams, error_1;\n        return __generator(this, function(_a3) {\n          switch (_a3.label) {\n            case 0:\n              if (!(this.status === this.wsImpl.OPEN))\n                return [3, 4];\n              this.clearMaxConnectTimeout();\n              this.closedByUser = false;\n              this.eventEmitter.emit(this.reconnecting ? \"reconnecting\" : \"connecting\");\n              _a3.label = 1;\n            case 1:\n              _a3.trys.push([1, 3, , 4]);\n              return [4, this.connectionParams()];\n            case 2:\n              connectionParams = _a3.sent();\n              this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n            case 3:\n              error_1 = _a3.sent();\n              this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_ERROR, error_1);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n            case 4:\n              return [2];\n          }\n        });\n      });\n    };\n    this.client.onclose = function() {\n      if (!_this.closedByUser) {\n        _this.close(false, false);\n      }\n    };\n    this.client.onerror = function(err) {\n      _this.eventEmitter.emit(\"error\", err);\n    };\n    this.client.onmessage = function(_a3) {\n      var data = _a3.data;\n      _this.processReceivedData(data);\n    };\n  };\n  SubscriptionClient2.prototype.processReceivedData = function(receivedData) {\n    var parsedMessage;\n    var opId;\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (e) {\n      throw new Error(\"Message must be JSON-parseable. Got: \" + receivedData);\n    }\n    if ([\n      message_types_1.default.GQL_DATA,\n      message_types_1.default.GQL_COMPLETE,\n      message_types_1.default.GQL_ERROR\n    ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {\n      this.unsubscribe(opId);\n      return;\n    }\n    switch (parsedMessage.type) {\n      case message_types_1.default.GQL_CONNECTION_ERROR:\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n        break;\n      case message_types_1.default.GQL_CONNECTION_ACK:\n        this.eventEmitter.emit(this.reconnecting ? \"reconnected\" : \"connected\", parsedMessage.payload);\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n        break;\n      case message_types_1.default.GQL_COMPLETE:\n        var handler = this.operations[opId].handler;\n        delete this.operations[opId];\n        handler.call(this, null, null);\n        break;\n      case message_types_1.default.GQL_ERROR:\n        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n        delete this.operations[opId];\n        break;\n      case message_types_1.default.GQL_DATA:\n        var parsedPayload = !parsedMessage.payload.errors ? parsedMessage.payload : __assign(__assign({}, parsedMessage.payload), { errors: this.formatErrors(parsedMessage.payload.errors) });\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n      case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:\n        var firstKA = typeof this.wasKeepAliveReceived === \"undefined\";\n        this.wasKeepAliveReceived = true;\n        if (firstKA) {\n          this.checkConnection();\n        }\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n        break;\n      default:\n        throw new Error(\"Invalid message type!\");\n    }\n  };\n  SubscriptionClient2.prototype.unsubscribe = function(opId) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, message_types_1.default.GQL_STOP, void 0);\n    }\n  };\n  return SubscriptionClient2;\n}();\nSubscriptionClient_1 = client.SubscriptionClient = SubscriptionClient;\nconst GraphQLLiveDirective = new GraphQLDirective({\n  name: \"live\",\n  description: \"Instruction for establishing a live connection that is updated once the underlying data changes.\",\n  locations: [DirectiveLocation.QUERY],\n  args: {\n    if: {\n      type: GraphQLBoolean,\n      defaultValue: true,\n      description: \"Whether the query should be live or not.\"\n    },\n    throttle: {\n      type: GraphQLInt,\n      description: 'Propose a desired throttle interval ot the server in order to receive updates to at most once per \"throttle\" milliseconds. The server must not accept this value.'\n    }\n  }\n});\nconst isNone = (input) => input == null;\nconst getLiveDirectiveNode = (input) => {\n  var _a2;\n  if (input.kind !== \"OperationDefinition\" || input.operation !== \"query\") {\n    return null;\n  }\n  const liveDirective = (_a2 = input.directives) === null || _a2 === void 0 ? void 0 : _a2.find((d) => d.name.value === \"live\");\n  if (isNone(liveDirective)) {\n    return null;\n  }\n  return liveDirective;\n};\nconst getLiveDirectiveArgumentValues = (node, variableValues) => {\n  var _a2;\n  const values = getDirectiveValues$1(GraphQLLiveDirective, { directives: [node] }, variableValues);\n  return {\n    isLive: (values === null || values === void 0 ? void 0 : values[\"if\"]) === true,\n    throttleValue: (_a2 = values === null || values === void 0 ? void 0 : values[\"throttle\"]) !== null && _a2 !== void 0 ? _a2 : null\n  };\n};\nconst isLiveQueryOperationDefinitionNode = (input, variables) => {\n  const liveDirectiveNode = getLiveDirectiveNode(input);\n  if (isNone(liveDirectiveNode)) {\n    return false;\n  }\n  return getLiveDirectiveArgumentValues(liveDirectiveNode, variables).isLive;\n};\nvar fetch$1 = globalThis.fetch;\nvar FormData = globalThis.FormData;\nvar AbortController$1 = globalThis.AbortController;\nvar File$1 = globalThis.File;\nvar buffer = {};\nvar base64Js = {};\nbase64Js.byteLength = byteLength;\nbase64Js.toByteArray = toByteArray;\nbase64Js.fromByteArray = fromByteArray;\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar code$1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (var i = 0, len = code$1.length; i < len; ++i) {\n  lookup[i] = code$1[i];\n  revLookup[code$1.charCodeAt(i)] = i;\n}\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\nfunction getLens(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1)\n    validLen = len;\n  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n  return [validLen, placeHoldersLen];\n}\nfunction byteLength(b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction _byteLength(b64, validLen, placeHoldersLen) {\n  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction toByteArray(b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n  var curByte = 0;\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = tmp >> 16 & 255;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[curByte++] = tmp & 255;\n  }\n  if (placeHoldersLen === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[curByte++] = tmp >> 8 & 255;\n    arr[curByte++] = tmp & 255;\n  }\n  return arr;\n}\nfunction tripletToBase64(num2) {\n  return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];\n}\nfunction encodeChunk(uint8, start2, end2) {\n  var tmp;\n  var output = [];\n  for (var i = start2; i < end2; i += 3) {\n    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3;\n  var parts = [];\n  var maxChunkLength = 16383;\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n  }\n  return parts.join(\"\");\n}\nvar ieee754 = {};\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {\n  var e, m2;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer2[offset + i];\n  i += d;\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n  }\n  m2 = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n  }\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m2 ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m2 = m2 + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);\n};\nieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {\n  var e, m2, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  value = Math.abs(value);\n  if (isNaN(value) || value === Infinity) {\n    m2 = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m2 = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m2 = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {\n  }\n  e = e << mLen | m2;\n  eLen += mLen;\n  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n  }\n  buffer2[offset + i - d] |= s * 128;\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n(function(exports) {\n  var base64 = base64Js;\n  var ieee754$1 = ieee754;\n  var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n  exports.Buffer = Buffer2;\n  exports.SlowBuffer = SlowBuffer;\n  exports.INSPECT_MAX_BYTES = 50;\n  var K_MAX_LENGTH = 2147483647;\n  exports.kMaxLength = K_MAX_LENGTH;\n  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n  }\n  function typedArraySupport() {\n    try {\n      var arr = new Uint8Array(1);\n      var proto = { foo: function() {\n        return 42;\n      } };\n      Object.setPrototypeOf(proto, Uint8Array.prototype);\n      Object.setPrototypeOf(arr, proto);\n      return arr.foo() === 42;\n    } catch (e) {\n      return false;\n    }\n  }\n  Object.defineProperty(Buffer2.prototype, \"parent\", {\n    enumerable: true,\n    get: function() {\n      if (!Buffer2.isBuffer(this))\n        return void 0;\n      return this.buffer;\n    }\n  });\n  Object.defineProperty(Buffer2.prototype, \"offset\", {\n    enumerable: true,\n    get: function() {\n      if (!Buffer2.isBuffer(this))\n        return void 0;\n      return this.byteOffset;\n    }\n  });\n  function createBuffer(length) {\n    if (length > K_MAX_LENGTH) {\n      throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    }\n    var buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, Buffer2.prototype);\n    return buf;\n  }\n  function Buffer2(arg, encodingOrOffset, length) {\n    if (typeof arg === \"number\") {\n      if (typeof encodingOrOffset === \"string\") {\n        throw new TypeError('The \"string\" argument must be of type string. Received type number');\n      }\n      return allocUnsafe(arg);\n    }\n    return from(arg, encodingOrOffset, length);\n  }\n  Buffer2.poolSize = 8192;\n  function from(value, encodingOrOffset, length) {\n    if (typeof value === \"string\") {\n      return fromString(value, encodingOrOffset);\n    }\n    if (ArrayBuffer.isView(value)) {\n      return fromArrayView(value);\n    }\n    if (value == null) {\n      throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    }\n    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n      return fromArrayBuffer(value, encodingOrOffset, length);\n    }\n    if (typeof value === \"number\") {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    }\n    var valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) {\n      return Buffer2.from(valueOf, encodingOrOffset, length);\n    }\n    var b = fromObject(value);\n    if (b)\n      return b;\n    if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n      return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n    }\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n  }\n  Buffer2.from = function(value, encodingOrOffset, length) {\n    return from(value, encodingOrOffset, length);\n  };\n  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);\n  Object.setPrototypeOf(Buffer2, Uint8Array);\n  function assertSize(size) {\n    if (typeof size !== \"number\") {\n      throw new TypeError('\"size\" argument must be of type number');\n    } else if (size < 0) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n  }\n  function alloc(size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n      return createBuffer(size);\n    }\n    if (fill !== void 0) {\n      return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n    }\n    return createBuffer(size);\n  }\n  Buffer2.alloc = function(size, fill, encoding) {\n    return alloc(size, fill, encoding);\n  };\n  function allocUnsafe(size) {\n    assertSize(size);\n    return createBuffer(size < 0 ? 0 : checked(size) | 0);\n  }\n  Buffer2.allocUnsafe = function(size) {\n    return allocUnsafe(size);\n  };\n  Buffer2.allocUnsafeSlow = function(size) {\n    return allocUnsafe(size);\n  };\n  function fromString(string2, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n      encoding = \"utf8\";\n    }\n    if (!Buffer2.isEncoding(encoding)) {\n      throw new TypeError(\"Unknown encoding: \" + encoding);\n    }\n    var length = byteLength2(string2, encoding) | 0;\n    var buf = createBuffer(length);\n    var actual = buf.write(string2, encoding);\n    if (actual !== length) {\n      buf = buf.slice(0, actual);\n    }\n    return buf;\n  }\n  function fromArrayLike(array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    var buf = createBuffer(length);\n    for (var i = 0; i < length; i += 1) {\n      buf[i] = array[i] & 255;\n    }\n    return buf;\n  }\n  function fromArrayView(arrayView) {\n    if (isInstance(arrayView, Uint8Array)) {\n      var copy2 = new Uint8Array(arrayView);\n      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);\n    }\n    return fromArrayLike(arrayView);\n  }\n  function fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n      throw new RangeError('\"offset\" is outside of buffer bounds');\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n      throw new RangeError('\"length\" is outside of buffer bounds');\n    }\n    var buf;\n    if (byteOffset === void 0 && length === void 0) {\n      buf = new Uint8Array(array);\n    } else if (length === void 0) {\n      buf = new Uint8Array(array, byteOffset);\n    } else {\n      buf = new Uint8Array(array, byteOffset, length);\n    }\n    Object.setPrototypeOf(buf, Buffer2.prototype);\n    return buf;\n  }\n  function fromObject(obj) {\n    if (Buffer2.isBuffer(obj)) {\n      var len = checked(obj.length) | 0;\n      var buf = createBuffer(len);\n      if (buf.length === 0) {\n        return buf;\n      }\n      obj.copy(buf, 0, 0, len);\n      return buf;\n    }\n    if (obj.length !== void 0) {\n      if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n        return createBuffer(0);\n      }\n      return fromArrayLike(obj);\n    }\n    if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data);\n    }\n  }\n  function checked(length) {\n    if (length >= K_MAX_LENGTH) {\n      throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n    }\n    return length | 0;\n  }\n  function SlowBuffer(length) {\n    if (+length != length) {\n      length = 0;\n    }\n    return Buffer2.alloc(+length);\n  }\n  Buffer2.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n  };\n  Buffer2.compare = function compare(a, b) {\n    if (isInstance(a, Uint8Array))\n      a = Buffer2.from(a, a.offset, a.byteLength);\n    if (isInstance(b, Uint8Array))\n      b = Buffer2.from(b, b.offset, b.byteLength);\n    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n      throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    }\n    if (a === b)\n      return 0;\n    var x2 = a.length;\n    var y2 = b.length;\n    for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {\n      if (a[i] !== b[i]) {\n        x2 = a[i];\n        y2 = b[i];\n        break;\n      }\n    }\n    if (x2 < y2)\n      return -1;\n    if (y2 < x2)\n      return 1;\n    return 0;\n  };\n  Buffer2.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  Buffer2.concat = function concat2(list3, length) {\n    if (!Array.isArray(list3)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list3.length === 0) {\n      return Buffer2.alloc(0);\n    }\n    var i;\n    if (length === void 0) {\n      length = 0;\n      for (i = 0; i < list3.length; ++i) {\n        length += list3[i].length;\n      }\n    }\n    var buffer2 = Buffer2.allocUnsafe(length);\n    var pos = 0;\n    for (i = 0; i < list3.length; ++i) {\n      var buf = list3[i];\n      if (isInstance(buf, Uint8Array)) {\n        if (pos + buf.length > buffer2.length) {\n          Buffer2.from(buf).copy(buffer2, pos);\n        } else {\n          Uint8Array.prototype.set.call(buffer2, buf, pos);\n        }\n      } else if (!Buffer2.isBuffer(buf)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      } else {\n        buf.copy(buffer2, pos);\n      }\n      pos += buf.length;\n    }\n    return buffer2;\n  };\n  function byteLength2(string2, encoding) {\n    if (Buffer2.isBuffer(string2)) {\n      return string2.length;\n    }\n    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {\n      return string2.byteLength;\n    }\n    if (typeof string2 !== \"string\") {\n      throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);\n    }\n    var len = string2.length;\n    var mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0)\n      return 0;\n    var loweredCase = false;\n    for (; ; ) {\n      switch (encoding) {\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return len;\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8ToBytes(string2).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return len * 2;\n        case \"hex\":\n          return len >>> 1;\n        case \"base64\":\n          return base64ToBytes(string2).length;\n        default:\n          if (loweredCase) {\n            return mustMatch ? -1 : utf8ToBytes(string2).length;\n          }\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n  Buffer2.byteLength = byteLength2;\n  function slowToString(encoding, start2, end2) {\n    var loweredCase = false;\n    if (start2 === void 0 || start2 < 0) {\n      start2 = 0;\n    }\n    if (start2 > this.length) {\n      return \"\";\n    }\n    if (end2 === void 0 || end2 > this.length) {\n      end2 = this.length;\n    }\n    if (end2 <= 0) {\n      return \"\";\n    }\n    end2 >>>= 0;\n    start2 >>>= 0;\n    if (end2 <= start2) {\n      return \"\";\n    }\n    if (!encoding)\n      encoding = \"utf8\";\n    while (true) {\n      switch (encoding) {\n        case \"hex\":\n          return hexSlice(this, start2, end2);\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Slice(this, start2, end2);\n        case \"ascii\":\n          return asciiSlice(this, start2, end2);\n        case \"latin1\":\n        case \"binary\":\n          return latin1Slice(this, start2, end2);\n        case \"base64\":\n          return base64Slice(this, start2, end2);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return utf16leSlice(this, start2, end2);\n        default:\n          if (loweredCase)\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (encoding + \"\").toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n  Buffer2.prototype._isBuffer = true;\n  function swap(b, n2, m2) {\n    var i = b[n2];\n    b[n2] = b[m2];\n    b[m2] = i;\n  }\n  Buffer2.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for (var i = 0; i < len; i += 2) {\n      swap(this, i, i + 1);\n    }\n    return this;\n  };\n  Buffer2.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for (var i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this;\n  };\n  Buffer2.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n      throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for (var i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this;\n  };\n  Buffer2.prototype.toString = function toString() {\n    var length = this.length;\n    if (length === 0)\n      return \"\";\n    if (arguments.length === 0)\n      return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n  };\n  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n  Buffer2.prototype.equals = function equals2(b) {\n    if (!Buffer2.isBuffer(b))\n      throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b)\n      return true;\n    return Buffer2.compare(this, b) === 0;\n  };\n  Buffer2.prototype.inspect = function inspect2() {\n    var str = \"\";\n    var max = exports.INSPECT_MAX_BYTES;\n    str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n    if (this.length > max)\n      str += \" ... \";\n    return \"<Buffer \" + str + \">\";\n  };\n  if (customInspectSymbol) {\n    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n  }\n  Buffer2.prototype.compare = function compare(target2, start2, end2, thisStart, thisEnd) {\n    if (isInstance(target2, Uint8Array)) {\n      target2 = Buffer2.from(target2, target2.offset, target2.byteLength);\n    }\n    if (!Buffer2.isBuffer(target2)) {\n      throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target2);\n    }\n    if (start2 === void 0) {\n      start2 = 0;\n    }\n    if (end2 === void 0) {\n      end2 = target2 ? target2.length : 0;\n    }\n    if (thisStart === void 0) {\n      thisStart = 0;\n    }\n    if (thisEnd === void 0) {\n      thisEnd = this.length;\n    }\n    if (start2 < 0 || end2 > target2.length || thisStart < 0 || thisEnd > this.length) {\n      throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start2 >= end2) {\n      return 0;\n    }\n    if (thisStart >= thisEnd) {\n      return -1;\n    }\n    if (start2 >= end2) {\n      return 1;\n    }\n    start2 >>>= 0;\n    end2 >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target2)\n      return 0;\n    var x2 = thisEnd - thisStart;\n    var y2 = end2 - start2;\n    var len = Math.min(x2, y2);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target2.slice(start2, end2);\n    for (var i = 0; i < len; ++i) {\n      if (thisCopy[i] !== targetCopy[i]) {\n        x2 = thisCopy[i];\n        y2 = targetCopy[i];\n        break;\n      }\n    }\n    if (x2 < y2)\n      return -1;\n    if (y2 < x2)\n      return 1;\n    return 0;\n  };\n  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {\n    if (buffer2.length === 0)\n      return -1;\n    if (typeof byteOffset === \"string\") {\n      encoding = byteOffset;\n      byteOffset = 0;\n    } else if (byteOffset > 2147483647) {\n      byteOffset = 2147483647;\n    } else if (byteOffset < -2147483648) {\n      byteOffset = -2147483648;\n    }\n    byteOffset = +byteOffset;\n    if (numberIsNaN(byteOffset)) {\n      byteOffset = dir ? 0 : buffer2.length - 1;\n    }\n    if (byteOffset < 0)\n      byteOffset = buffer2.length + byteOffset;\n    if (byteOffset >= buffer2.length) {\n      if (dir)\n        return -1;\n      else\n        byteOffset = buffer2.length - 1;\n    } else if (byteOffset < 0) {\n      if (dir)\n        byteOffset = 0;\n      else\n        return -1;\n    }\n    if (typeof val === \"string\") {\n      val = Buffer2.from(val, encoding);\n    }\n    if (Buffer2.isBuffer(val)) {\n      if (val.length === 0) {\n        return -1;\n      }\n      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n      val = val & 255;\n      if (typeof Uint8Array.prototype.indexOf === \"function\") {\n        if (dir) {\n          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);\n        } else {\n          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);\n        }\n      }\n      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== void 0) {\n      encoding = String(encoding).toLowerCase();\n      if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n        if (arr.length < 2 || val.length < 2) {\n          return -1;\n        }\n        indexSize = 2;\n        arrLength /= 2;\n        valLength /= 2;\n        byteOffset /= 2;\n      }\n    }\n    function read(buf, i2) {\n      if (indexSize === 1) {\n        return buf[i2];\n      } else {\n        return buf.readUInt16BE(i2 * indexSize);\n      }\n    }\n    var i;\n    if (dir) {\n      var foundIndex = -1;\n      for (i = byteOffset; i < arrLength; i++) {\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n          if (foundIndex === -1)\n            foundIndex = i;\n          if (i - foundIndex + 1 === valLength)\n            return foundIndex * indexSize;\n        } else {\n          if (foundIndex !== -1)\n            i -= i - foundIndex;\n          foundIndex = -1;\n        }\n      }\n    } else {\n      if (byteOffset + valLength > arrLength)\n        byteOffset = arrLength - valLength;\n      for (i = byteOffset; i >= 0; i--) {\n        var found = true;\n        for (var j = 0; j < valLength; j++) {\n          if (read(arr, i + j) !== read(val, j)) {\n            found = false;\n            break;\n          }\n        }\n        if (found)\n          return i;\n      }\n    }\n    return -1;\n  }\n  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n  };\n  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n  };\n  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n  };\n  function hexWrite(buf, string2, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n      length = remaining;\n    } else {\n      length = Number(length);\n      if (length > remaining) {\n        length = remaining;\n      }\n    }\n    var strLen2 = string2.length;\n    if (length > strLen2 / 2) {\n      length = strLen2 / 2;\n    }\n    for (var i = 0; i < length; ++i) {\n      var parsed = parseInt(string2.substr(i * 2, 2), 16);\n      if (numberIsNaN(parsed))\n        return i;\n      buf[offset + i] = parsed;\n    }\n    return i;\n  }\n  function utf8Write(buf, string2, offset, length) {\n    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);\n  }\n  function asciiWrite(buf, string2, offset, length) {\n    return blitBuffer(asciiToBytes(string2), buf, offset, length);\n  }\n  function base64Write(buf, string2, offset, length) {\n    return blitBuffer(base64ToBytes(string2), buf, offset, length);\n  }\n  function ucs2Write(buf, string2, offset, length) {\n    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);\n  }\n  Buffer2.prototype.write = function write(string2, offset, length, encoding) {\n    if (offset === void 0) {\n      encoding = \"utf8\";\n      length = this.length;\n      offset = 0;\n    } else if (length === void 0 && typeof offset === \"string\") {\n      encoding = offset;\n      length = this.length;\n      offset = 0;\n    } else if (isFinite(offset)) {\n      offset = offset >>> 0;\n      if (isFinite(length)) {\n        length = length >>> 0;\n        if (encoding === void 0)\n          encoding = \"utf8\";\n      } else {\n        encoding = length;\n        length = void 0;\n      }\n    } else {\n      throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === void 0 || length > remaining)\n      length = remaining;\n    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n      throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding)\n      encoding = \"utf8\";\n    var loweredCase = false;\n    for (; ; ) {\n      switch (encoding) {\n        case \"hex\":\n          return hexWrite(this, string2, offset, length);\n        case \"utf8\":\n        case \"utf-8\":\n          return utf8Write(this, string2, offset, length);\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n          return asciiWrite(this, string2, offset, length);\n        case \"base64\":\n          return base64Write(this, string2, offset, length);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return ucs2Write(this, string2, offset, length);\n        default:\n          if (loweredCase)\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n          encoding = (\"\" + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  };\n  Buffer2.prototype.toJSON = function toJSON() {\n    return {\n      type: \"Buffer\",\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n  };\n  function base64Slice(buf, start2, end2) {\n    if (start2 === 0 && end2 === buf.length) {\n      return base64.fromByteArray(buf);\n    } else {\n      return base64.fromByteArray(buf.slice(start2, end2));\n    }\n  }\n  function utf8Slice(buf, start2, end2) {\n    end2 = Math.min(buf.length, end2);\n    var res = [];\n    var i = start2;\n    while (i < end2) {\n      var firstByte = buf[i];\n      var codePoint = null;\n      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n      if (i + bytesPerSequence <= end2) {\n        var secondByte, thirdByte, fourthByte, tempCodePoint;\n        switch (bytesPerSequence) {\n          case 1:\n            if (firstByte < 128) {\n              codePoint = firstByte;\n            }\n            break;\n          case 2:\n            secondByte = buf[i + 1];\n            if ((secondByte & 192) === 128) {\n              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n              if (tempCodePoint > 127) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break;\n          case 3:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                codePoint = tempCodePoint;\n              }\n            }\n            break;\n          case 4:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            fourthByte = buf[i + 3];\n            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                codePoint = tempCodePoint;\n              }\n            }\n        }\n      }\n      if (codePoint === null) {\n        codePoint = 65533;\n        bytesPerSequence = 1;\n      } else if (codePoint > 65535) {\n        codePoint -= 65536;\n        res.push(codePoint >>> 10 & 1023 | 55296);\n        codePoint = 56320 | codePoint & 1023;\n      }\n      res.push(codePoint);\n      i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n  }\n  var MAX_ARGUMENTS_LENGTH = 4096;\n  function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n      return String.fromCharCode.apply(String, codePoints);\n    }\n    var res = \"\";\n    var i = 0;\n    while (i < len) {\n      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n  }\n  function asciiSlice(buf, start2, end2) {\n    var ret = \"\";\n    end2 = Math.min(buf.length, end2);\n    for (var i = start2; i < end2; ++i) {\n      ret += String.fromCharCode(buf[i] & 127);\n    }\n    return ret;\n  }\n  function latin1Slice(buf, start2, end2) {\n    var ret = \"\";\n    end2 = Math.min(buf.length, end2);\n    for (var i = start2; i < end2; ++i) {\n      ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n  }\n  function hexSlice(buf, start2, end2) {\n    var len = buf.length;\n    if (!start2 || start2 < 0)\n      start2 = 0;\n    if (!end2 || end2 < 0 || end2 > len)\n      end2 = len;\n    var out = \"\";\n    for (var i = start2; i < end2; ++i) {\n      out += hexSliceLookupTable[buf[i]];\n    }\n    return out;\n  }\n  function utf16leSlice(buf, start2, end2) {\n    var bytes = buf.slice(start2, end2);\n    var res = \"\";\n    for (var i = 0; i < bytes.length - 1; i += 2) {\n      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n  }\n  Buffer2.prototype.slice = function slice(start2, end2) {\n    var len = this.length;\n    start2 = ~~start2;\n    end2 = end2 === void 0 ? len : ~~end2;\n    if (start2 < 0) {\n      start2 += len;\n      if (start2 < 0)\n        start2 = 0;\n    } else if (start2 > len) {\n      start2 = len;\n    }\n    if (end2 < 0) {\n      end2 += len;\n      if (end2 < 0)\n        end2 = 0;\n    } else if (end2 > len) {\n      end2 = len;\n    }\n    if (end2 < start2)\n      end2 = start2;\n    var newBuf = this.subarray(start2, end2);\n    Object.setPrototypeOf(newBuf, Buffer2.prototype);\n    return newBuf;\n  };\n  function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0)\n      throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length)\n      throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength3 && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n    return val;\n  };\n  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      checkOffset(offset, byteLength3, this.length);\n    }\n    var val = this[offset + --byteLength3];\n    var mul = 1;\n    while (byteLength3 > 0 && (mul *= 256)) {\n      val += this[offset + --byteLength3] * mul;\n    }\n    return val;\n  };\n  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 1, this.length);\n    return this[offset];\n  };\n  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n  };\n  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n  };\n  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n  };\n  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n  };\n  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while (++i < byteLength3 && (mul *= 256)) {\n      val += this[offset + i] * mul;\n    }\n    mul *= 128;\n    if (val >= mul)\n      val -= Math.pow(2, 8 * byteLength3);\n    return val;\n  };\n  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert)\n      checkOffset(offset, byteLength3, this.length);\n    var i = byteLength3;\n    var mul = 1;\n    var val = this[offset + --i];\n    while (i > 0 && (mul *= 256)) {\n      val += this[offset + --i] * mul;\n    }\n    mul *= 128;\n    if (val >= mul)\n      val -= Math.pow(2, 8 * byteLength3);\n    return val;\n  };\n  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 128))\n      return this[offset];\n    return (255 - this[offset] + 1) * -1;\n  };\n  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 32768 ? val | 4294901760 : val;\n  };\n  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n  };\n  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n  };\n  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return ieee754$1.read(this, offset, true, 23, 4);\n  };\n  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 4, this.length);\n    return ieee754$1.read(this, offset, false, 23, 4);\n  };\n  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 8, this.length);\n    return ieee754$1.read(this, offset, true, 52, 8);\n  };\n  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkOffset(offset, 8, this.length);\n    return ieee754$1.read(this, offset, false, 52, 8);\n  };\n  function checkInt(buf, value, offset, ext, max, min) {\n    if (!Buffer2.isBuffer(buf))\n      throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min)\n      throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length)\n      throw new RangeError(\"Index out of range\");\n  }\n  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;\n      checkInt(this, value, offset, byteLength3, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 255;\n    while (++i < byteLength3 && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength3 = byteLength3 >>> 0;\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;\n      checkInt(this, value, offset, byteLength3, maxBytes, 0);\n    }\n    var i = byteLength3 - 1;\n    var mul = 1;\n    this[offset + i] = value & 255;\n    while (--i >= 0 && (mul *= 256)) {\n      this[offset + i] = value / mul & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 1, 255, 0);\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 65535, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 255;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 4294967295, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength3 - 1);\n      checkInt(this, value, offset, byteLength3, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub2 = 0;\n    this[offset] = value & 255;\n    while (++i < byteLength3 && (mul *= 256)) {\n      if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {\n        sub2 = 1;\n      }\n      this[offset + i] = (value / mul >> 0) - sub2 & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength3 - 1);\n      checkInt(this, value, offset, byteLength3, limit - 1, -limit);\n    }\n    var i = byteLength3 - 1;\n    var mul = 1;\n    var sub2 = 0;\n    this[offset + i] = value & 255;\n    while (--i >= 0 && (mul *= 256)) {\n      if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {\n        sub2 = 1;\n      }\n      this[offset + i] = (value / mul >> 0) - sub2 & 255;\n    }\n    return offset + byteLength3;\n  };\n  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 1, 127, -128);\n    if (value < 0)\n      value = 255 + value + 1;\n    this[offset] = value & 255;\n    return offset + 1;\n  };\n  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 2, 32767, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 255;\n    return offset + 2;\n  };\n  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    this[offset] = value & 255;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n  };\n  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert)\n      checkInt(this, value, offset, 4, 2147483647, -2147483648);\n    if (value < 0)\n      value = 4294967295 + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 255;\n    return offset + 4;\n  };\n  function checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length)\n      throw new RangeError(\"Index out of range\");\n    if (offset < 0)\n      throw new RangeError(\"Index out of range\");\n  }\n  function writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 4);\n    }\n    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n  }\n  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n  };\n  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n  };\n  function writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 8);\n    }\n    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n  }\n  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n  };\n  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n  };\n  Buffer2.prototype.copy = function copy2(target2, targetStart, start2, end2) {\n    if (!Buffer2.isBuffer(target2))\n      throw new TypeError(\"argument should be a Buffer\");\n    if (!start2)\n      start2 = 0;\n    if (!end2 && end2 !== 0)\n      end2 = this.length;\n    if (targetStart >= target2.length)\n      targetStart = target2.length;\n    if (!targetStart)\n      targetStart = 0;\n    if (end2 > 0 && end2 < start2)\n      end2 = start2;\n    if (end2 === start2)\n      return 0;\n    if (target2.length === 0 || this.length === 0)\n      return 0;\n    if (targetStart < 0) {\n      throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start2 < 0 || start2 >= this.length)\n      throw new RangeError(\"Index out of range\");\n    if (end2 < 0)\n      throw new RangeError(\"sourceEnd out of bounds\");\n    if (end2 > this.length)\n      end2 = this.length;\n    if (target2.length - targetStart < end2 - start2) {\n      end2 = target2.length - targetStart + start2;\n    }\n    var len = end2 - start2;\n    if (this === target2 && typeof Uint8Array.prototype.copyWithin === \"function\") {\n      this.copyWithin(targetStart, start2, end2);\n    } else {\n      Uint8Array.prototype.set.call(target2, this.subarray(start2, end2), targetStart);\n    }\n    return len;\n  };\n  Buffer2.prototype.fill = function fill(val, start2, end2, encoding) {\n    if (typeof val === \"string\") {\n      if (typeof start2 === \"string\") {\n        encoding = start2;\n        start2 = 0;\n        end2 = this.length;\n      } else if (typeof end2 === \"string\") {\n        encoding = end2;\n        end2 = this.length;\n      }\n      if (encoding !== void 0 && typeof encoding !== \"string\") {\n        throw new TypeError(\"encoding must be a string\");\n      }\n      if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      if (val.length === 1) {\n        var code3 = val.charCodeAt(0);\n        if (encoding === \"utf8\" && code3 < 128 || encoding === \"latin1\") {\n          val = code3;\n        }\n      }\n    } else if (typeof val === \"number\") {\n      val = val & 255;\n    } else if (typeof val === \"boolean\") {\n      val = Number(val);\n    }\n    if (start2 < 0 || this.length < start2 || this.length < end2) {\n      throw new RangeError(\"Out of range index\");\n    }\n    if (end2 <= start2) {\n      return this;\n    }\n    start2 = start2 >>> 0;\n    end2 = end2 === void 0 ? this.length : end2 >>> 0;\n    if (!val)\n      val = 0;\n    var i;\n    if (typeof val === \"number\") {\n      for (i = start2; i < end2; ++i) {\n        this[i] = val;\n      }\n    } else {\n      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n      var len = bytes.length;\n      if (len === 0) {\n        throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n      }\n      for (i = 0; i < end2 - start2; ++i) {\n        this[i + start2] = bytes[i % len];\n      }\n    }\n    return this;\n  };\n  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n  function base64clean(str) {\n    str = str.split(\"=\")[0];\n    str = str.trim().replace(INVALID_BASE64_RE, \"\");\n    if (str.length < 2)\n      return \"\";\n    while (str.length % 4 !== 0) {\n      str = str + \"=\";\n    }\n    return str;\n  }\n  function utf8ToBytes(string2, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string2.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for (var i = 0; i < length; ++i) {\n      codePoint = string2.charCodeAt(i);\n      if (codePoint > 55295 && codePoint < 57344) {\n        if (!leadSurrogate) {\n          if (codePoint > 56319) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            continue;\n          } else if (i + 1 === length) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            continue;\n          }\n          leadSurrogate = codePoint;\n          continue;\n        }\n        if (codePoint < 56320) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          leadSurrogate = codePoint;\n          continue;\n        }\n        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n      } else if (leadSurrogate) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n      }\n      leadSurrogate = null;\n      if (codePoint < 128) {\n        if ((units -= 1) < 0)\n          break;\n        bytes.push(codePoint);\n      } else if (codePoint < 2048) {\n        if ((units -= 2) < 0)\n          break;\n        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n      } else if (codePoint < 65536) {\n        if ((units -= 3) < 0)\n          break;\n        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else if (codePoint < 1114112) {\n        if ((units -= 4) < 0)\n          break;\n        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n      } else {\n        throw new Error(\"Invalid code point\");\n      }\n    }\n    return bytes;\n  }\n  function asciiToBytes(str) {\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      byteArray.push(str.charCodeAt(i) & 255);\n    }\n    return byteArray;\n  }\n  function utf16leToBytes(str, units) {\n    var c, hi2, lo;\n    var byteArray = [];\n    for (var i = 0; i < str.length; ++i) {\n      if ((units -= 2) < 0)\n        break;\n      c = str.charCodeAt(i);\n      hi2 = c >> 8;\n      lo = c % 256;\n      byteArray.push(lo);\n      byteArray.push(hi2);\n    }\n    return byteArray;\n  }\n  function base64ToBytes(str) {\n    return base64.toByteArray(base64clean(str));\n  }\n  function blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n      if (i + offset >= dst.length || i >= src.length)\n        break;\n      dst[i + offset] = src[i];\n    }\n    return i;\n  }\n  function isInstance(obj, type2) {\n    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;\n  }\n  function numberIsNaN(obj) {\n    return obj !== obj;\n  }\n  var hexSliceLookupTable = function() {\n    var alphabet = \"0123456789abcdef\";\n    var table3 = new Array(256);\n    for (var i = 0; i < 16; ++i) {\n      var i16 = i * 16;\n      for (var j = 0; j < 16; ++j) {\n        table3[i16 + j] = alphabet[i] + alphabet[j];\n      }\n    }\n    return table3;\n  }();\n})(buffer);\nconst { Buffer: Buffer$1 } = buffer;\nfunction syncFetch(...args) {\n  const [url, opts] = parseArgs(...args);\n  const xhr = new XMLHttpRequest();\n  xhr.withCredentials = opts.credentials === \"include\";\n  xhr.timeout = opts.timeout;\n  xhr.open(opts.method || \"GET\", url, false);\n  try {\n    xhr.responseType = \"arraybuffer\";\n  } catch (e) {\n  }\n  for (const header of opts.headers) {\n    xhr.setRequestHeader(...header);\n  }\n  xhr.send(opts.body || null);\n  let headers = xhr.getAllResponseHeaders();\n  headers = headers && headers.split(\"\\r\\n\").filter(Boolean).map((header) => header.split(\": \", 2));\n  return new syncFetch.Response(xhr.response, {\n    url: xhr.responseURL,\n    status: xhr.status,\n    statusText: xhr.statusText,\n    headers,\n    redirected: xhr.responseURL !== url\n  });\n}\nfunction parseArgs(resource, init) {\n  const request = [];\n  if (resource instanceof syncFetch.Request) {\n    request.push(resource.url);\n    request.push({\n      method: resource.method,\n      headers: resource.headers,\n      body: resource.body\n    });\n  } else {\n    request.push(resource, {});\n  }\n  Object.assign(request[1], init);\n  request[1].headers = new syncFetch.Headers(request[1].headers || {});\n  return request;\n}\nconst INTERNALS = Symbol(\"SyncFetch Internals\");\nclass SyncRequest extends Request {\n  constructor(resource, init = {}, body = init.body) {\n    super(resource, init);\n    this[INTERNALS] = {\n      body: body ? Buffer$1.from(body) : null\n    };\n  }\n  clone() {\n    checkBody(this);\n    return new SyncRequest(this.url, this);\n  }\n}\nclass SyncResponse extends Response {\n  constructor(body, init = {}) {\n    body = body ? Buffer$1.from(body) : null;\n    super(createStream(body), init);\n    this[INTERNALS] = {\n      url: init.url,\n      redirected: init.redirected,\n      body\n    };\n  }\n  get url() {\n    return this[INTERNALS].url;\n  }\n  get redirected() {\n    return this[INTERNALS].redirected;\n  }\n  clone() {\n    checkBody(this);\n    return new SyncResponse(this[INTERNALS].body, {\n      url: this.url,\n      headers: this.headers,\n      status: this.status,\n      statusText: this.statusText,\n      redirected: this.redirected\n    });\n  }\n}\nclass Body {\n  constructor(body) {\n    this[INTERNALS] = {\n      body: Buffer$1.from(body)\n    };\n  }\n  static mixin(prototype) {\n    for (const name2 of Object.getOwnPropertyNames(Body.prototype)) {\n      if (name2 === \"constructor\") {\n        continue;\n      }\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name2);\n      Object.defineProperty(prototype, name2, __spreadProps(__spreadValues({}, desc), { enumerable: true }));\n    }\n  }\n  arrayBuffer() {\n    checkBody(this);\n    const buffer2 = consumeBody(this);\n    return buffer2.buffer.slice(buffer2.byteOffset, buffer2.byteOffset + buffer2.byteLength);\n  }\n  blob() {\n    checkBody(this);\n    const type2 = this.headers && this.headers.get(\"content-type\");\n    return new Blob([consumeBody(this)], type2 && { type: type2 });\n  }\n  text() {\n    checkBody(this);\n    return consumeBody(this).toString();\n  }\n  json() {\n    checkBody(this);\n    try {\n      return JSON.parse(consumeBody(this).toString());\n    } catch (err) {\n      throw new TypeError(`invalid json response body at ${this.url} reason: ${err.message}`, \"invalid-json\");\n    }\n  }\n  buffer() {\n    checkBody(this);\n    return consumeBody(this).clone();\n  }\n}\nfunction checkBody(body) {\n  if (body.bodyUsed) {\n    throw new TypeError(`body used already for: ${body.url}`);\n  }\n}\nfunction consumeBody(body) {\n  _super(body, \"arrayBuffer\")();\n  return body[INTERNALS].body || Buffer$1.alloc(0);\n}\nfunction _super(self2, method) {\n  return Object.getPrototypeOf(Object.getPrototypeOf(self2))[method].bind(self2);\n}\nfunction createStream(body) {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(body);\n      controller.close();\n    }\n  });\n}\nBody.mixin(SyncRequest.prototype);\nBody.mixin(SyncResponse.prototype);\nsyncFetch.Headers = self.Headers;\nsyncFetch.Request = SyncRequest;\nsyncFetch.Response = SyncResponse;\nvar browser = syncFetch;\nconst separator$1 = \"\\r\\n\\r\\n\";\nasync function* generate$1(stream, boundary, options) {\n  const len_boundary = Buffer.byteLength(boundary), is_eager = !options || !options.multiple;\n  let buffer2 = Buffer.alloc(0), is_preamble = true, payloads = [];\n  outer:\n    for await (const chunk of stream) {\n      let idx_boundary = buffer2.byteLength;\n      buffer2 = Buffer.concat([buffer2, chunk]);\n      const idx_chunk = chunk.indexOf(boundary);\n      if (!!~idx_chunk) {\n        idx_boundary += idx_chunk;\n      } else {\n        idx_boundary = buffer2.indexOf(boundary);\n      }\n      payloads = [];\n      while (!!~idx_boundary) {\n        const current = buffer2.slice(0, idx_boundary);\n        const next = buffer2.slice(idx_boundary + len_boundary);\n        if (is_preamble) {\n          is_preamble = false;\n        } else {\n          const headers = {};\n          const idx_headers = current.indexOf(separator$1);\n          const arr_headers = buffer2.slice(0, idx_headers).toString().trim().split(/\\r\\n/);\n          let tmp;\n          while (tmp = arr_headers.shift()) {\n            tmp = tmp.split(\": \");\n            headers[tmp.shift().toLowerCase()] = tmp.join(\": \");\n          }\n          let body = current.slice(idx_headers + separator$1.length, current.lastIndexOf(\"\\r\\n\"));\n          let is_json = false;\n          tmp = headers[\"content-type\"];\n          if (tmp && !!~tmp.indexOf(\"application/json\")) {\n            try {\n              body = JSON.parse(body.toString());\n              is_json = true;\n            } catch (_) {\n            }\n          }\n          tmp = { headers, body, json: is_json };\n          is_eager ? yield tmp : payloads.push(tmp);\n          if (next.slice(0, 2).toString() === \"--\")\n            break outer;\n        }\n        buffer2 = next;\n        idx_boundary = buffer2.indexOf(boundary);\n      }\n      if (payloads.length)\n        yield payloads;\n    }\n  if (payloads.length)\n    yield payloads;\n}\nasync function meros$1(response, options) {\n  const ctype = response.headers[\"content-type\"];\n  if (!ctype || !~ctype.indexOf(\"multipart/mixed\"))\n    return response;\n  const idx_boundary = ctype.indexOf(\"boundary=\");\n  return generate$1(response, `--${!!~idx_boundary ? ctype.substring(idx_boundary + 9).trim().replace(/['\"]/g, \"\") : \"-\"}`, options);\n}\nconst separator = \"\\r\\n\\r\\n\";\nconst decoder = new TextDecoder();\nasync function* generate(stream, boundary, options) {\n  const reader = stream.getReader(), is_eager = !options || !options.multiple;\n  let buffer2 = \"\", is_preamble = true, payloads = [];\n  try {\n    let result2;\n    outer:\n      while (!(result2 = await reader.read()).done) {\n        const chunk = decoder.decode(result2.value);\n        const idx_chunk = chunk.indexOf(boundary);\n        let idx_boundary = buffer2.length;\n        buffer2 += chunk;\n        if (!!~idx_chunk) {\n          idx_boundary += idx_chunk;\n        } else {\n          idx_boundary = buffer2.indexOf(boundary);\n        }\n        payloads = [];\n        while (!!~idx_boundary) {\n          const current = buffer2.substring(0, idx_boundary);\n          const next = buffer2.substring(idx_boundary + boundary.length);\n          if (is_preamble) {\n            is_preamble = false;\n          } else {\n            const headers = {};\n            const idx_headers = current.indexOf(separator);\n            const arr_headers = buffer2.slice(0, idx_headers).toString().trim().split(/\\r\\n/);\n            let tmp;\n            while (tmp = arr_headers.shift()) {\n              tmp = tmp.split(\": \");\n              headers[tmp.shift().toLowerCase()] = tmp.join(\": \");\n            }\n            let body = current.substring(idx_headers + separator.length, current.lastIndexOf(\"\\r\\n\"));\n            let is_json = false;\n            tmp = headers[\"content-type\"];\n            if (tmp && !!~tmp.indexOf(\"application/json\")) {\n              try {\n                body = JSON.parse(body);\n                is_json = true;\n              } catch (_) {\n              }\n            }\n            tmp = { headers, body, json: is_json };\n            is_eager ? yield tmp : payloads.push(tmp);\n            if (next.substring(0, 2) === \"--\")\n              break outer;\n          }\n          buffer2 = next;\n          idx_boundary = buffer2.indexOf(boundary);\n        }\n        if (payloads.length)\n          yield payloads;\n      }\n  } finally {\n    if (payloads.length)\n      yield payloads;\n    reader.releaseLock();\n  }\n}\nasync function meros(response, options) {\n  if (!response.ok || !response.body || response.bodyUsed)\n    return response;\n  const ctype = response.headers.get(\"content-type\");\n  if (!ctype || !~ctype.indexOf(\"multipart/mixed\"))\n    return response;\n  const idx_boundary = ctype.indexOf(\"boundary=\");\n  return generate(response.body, `--${!!~idx_boundary ? ctype.substring(idx_boundary + 9).trim().replace(/['\"]/g, \"\") : \"-\"}`, options);\n}\nconst defaultAsyncFetch = async (input, init) => {\n  return fetch$1(input, init);\n};\nconst defaultSyncFetch = (input, init) => {\n  if (typeof input === \"string\") {\n    init === null || init === void 0 ? true : delete init.signal;\n  } else {\n    delete input.signal;\n  }\n  return browser(input, init);\n};\nfunction isIncomingMessage(body) {\n  return body != null && typeof body === \"object\" && \"pipe\" in body;\n}\nasync function handleMultipartMixedResponse(response) {\n  const body = await response.body;\n  const contentType = response.headers.get(\"content-type\") || \"\";\n  let asyncIterator;\n  if (isIncomingMessage(body)) {\n    body.headers = {\n      \"content-type\": contentType\n    };\n    asyncIterator = await meros$1(body);\n  } else {\n    asyncIterator = await meros(response);\n  }\n  const executionResult = {};\n  return mapAsyncIterator(asyncIterator, (part2) => {\n    if (part2.json) {\n      const chunk = part2.body;\n      if (chunk.path) {\n        if (chunk.data) {\n          const path = [\"data\"];\n          dset(executionResult, path.concat(chunk.path), chunk.data);\n        }\n        if (chunk.errors) {\n          executionResult.errors = (executionResult.errors || []).concat(chunk.errors);\n        }\n      } else {\n        if (chunk.data) {\n          executionResult.data = chunk.data;\n        }\n        if (chunk.errors) {\n          executionResult.errors = chunk.errors;\n        }\n      }\n      return executionResult;\n    }\n  });\n}\nasync function* handleReadable(readable) {\n  const decoder2 = new TextDecoder();\n  outer:\n    for await (const chunk of readable) {\n      const chunkStr = typeof chunk === \"string\" ? chunk : decoder2.decode(chunk);\n      for (const part2 of chunkStr.split(\"\\n\\n\")) {\n        if (part2) {\n          const eventStr = part2.split(\"event: \")[1];\n          const dataStr = part2.split(\"data: \")[1];\n          if (eventStr === \"complete\") {\n            break outer;\n          }\n          if (dataStr) {\n            const data = JSON.parse(dataStr);\n            yield data.payload || data;\n          }\n        }\n      }\n    }\n}\nasync function* handleReadableStream(stream) {\n  const decoder2 = new TextDecoder();\n  const reader = stream.getReader();\n  let buffer2;\n  let position = 0;\n  let fieldLength = -1;\n  let discardTrailingNewline = false;\n  try {\n    let result2;\n    let message = {\n      data: \"\",\n      event: \"\",\n      id: \"\",\n      retry: void 0\n    };\n    while (!(result2 = await reader.read()).done) {\n      const arr = result2.value;\n      if (buffer2 === void 0) {\n        buffer2 = arr;\n        position = 0;\n        fieldLength = -1;\n      } else {\n        buffer2 = concat(buffer2, arr);\n      }\n      const bufLength = buffer2.length;\n      let lineStart = 0;\n      while (position < bufLength) {\n        if (discardTrailingNewline) {\n          if (buffer2[position] === 10) {\n            lineStart = ++position;\n          }\n          discardTrailingNewline = false;\n        }\n        let lineEnd = -1;\n        for (; position < bufLength && lineEnd === -1; ++position) {\n          switch (buffer2[position]) {\n            case 58: {\n              if (fieldLength === -1) {\n                fieldLength = position - lineStart;\n              }\n              break;\n            }\n            case 13: {\n              discardTrailingNewline = true;\n              break;\n            }\n            case 10: {\n              lineEnd = position;\n              break;\n            }\n          }\n        }\n        if (lineEnd === -1) {\n          break;\n        }\n        const line = buffer2.subarray(lineStart, lineEnd);\n        if (line.length === 0) {\n          if (message.event || message.data) {\n            yield JSON.parse(message.data);\n            message = {\n              data: \"\",\n              event: \"\",\n              id: \"\",\n              retry: void 0\n            };\n          }\n        } else if (fieldLength > 0) {\n          const field = decoder2.decode(line.subarray(0, fieldLength));\n          const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\n          const value = decoder2.decode(line.subarray(valueOffset));\n          switch (field) {\n            case \"data\":\n              message.data = message.data ? message.data + \"\\n\" + value : value;\n              break;\n            case \"event\":\n              message.event = value;\n              break;\n            case \"id\":\n              message.id = value;\n              break;\n            case \"retry\": {\n              const retry = parseInt(value, 10);\n              message.retry = retry;\n              break;\n            }\n          }\n        }\n        lineStart = position;\n        fieldLength = -1;\n      }\n      if (lineStart === bufLength) {\n        buffer2 = void 0;\n      } else if (lineStart !== 0) {\n        buffer2 = buffer2.subarray(lineStart);\n        position -= lineStart;\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nasync function handleEventStreamResponse(response) {\n  const body = await response.body;\n  if (body) {\n    if (isAsyncIterable$1(body)) {\n      return handleReadable(body);\n    }\n    return handleReadableStream(body);\n  }\n  throw new Error(\"Response body is expected to be a readable stream but got; \" + inspect$1(body));\n}\nfunction addCancelToResponseStream(resultStream, controller) {\n  return getAsyncIterableWithCancel(resultStream, () => {\n    if (!controller.signal.aborted) {\n      controller.abort();\n    }\n  });\n}\nfunction isBlob(obj) {\n  return typeof obj.arrayBuffer === \"function\";\n}\nfunction isGraphQLUpload(upload) {\n  return typeof upload.createReadStream === \"function\";\n}\nfunction isPromiseLike(obj) {\n  return typeof obj.then === \"function\";\n}\nconst asyncImport = (moduleName) => import(moduleName);\nconst syncImport = (moduleName) => require(moduleName);\nvar SubscriptionProtocol;\n(function(SubscriptionProtocol2) {\n  SubscriptionProtocol2[\"WS\"] = \"WS\";\n  SubscriptionProtocol2[\"LEGACY_WS\"] = \"LEGACY_WS\";\n  SubscriptionProtocol2[\"SSE\"] = \"SSE\";\n  SubscriptionProtocol2[\"GRAPHQL_SSE\"] = \"GRAPHQL_SSE\";\n})(SubscriptionProtocol || (SubscriptionProtocol = {}));\nfunction isCompatibleUri(uri) {\n  try {\n    new URL(uri);\n    return true;\n  } catch (_a2) {\n    return false;\n  }\n}\nclass UrlLoader {\n  createFormDataFromVariables({ query, variables, operationName, extensions }) {\n    const vars = Object.assign({}, variables);\n    const { clone, files } = extractFiles$1(vars, \"variables\", (v2) => isExtractableFile$1(v2) || (v2 === null || v2 === void 0 ? void 0 : v2.promise) || isAsyncIterable$1(v2) || (v2 === null || v2 === void 0 ? void 0 : v2.then) || typeof (v2 === null || v2 === void 0 ? void 0 : v2.arrayBuffer) === \"function\");\n    const map2 = {};\n    const uploads = [];\n    let currIndex = 0;\n    for (const [file, curr] of files) {\n      map2[currIndex] = curr;\n      uploads[currIndex] = file;\n      currIndex++;\n    }\n    const form = new FormData();\n    form.append(\"operations\", JSON.stringify({\n      query,\n      variables: clone,\n      operationName,\n      extensions\n    }));\n    form.append(\"map\", JSON.stringify(map2));\n    function handleUpload(upload, i) {\n      const indexStr = i.toString();\n      if (upload != null) {\n        const filename = upload.filename || upload.name || upload.path || `blob-${indexStr}`;\n        if (isPromiseLike(upload)) {\n          return upload.then((resolvedUpload) => handleUpload(resolvedUpload, i));\n        } else if (isBlob(upload)) {\n          return upload.arrayBuffer().then((arrayBuffer) => {\n            form.append(indexStr, new File$1([arrayBuffer], filename, { type: upload.type }), filename);\n          });\n        } else if (isGraphQLUpload(upload)) {\n          const stream = upload.createReadStream();\n          const chunks = [];\n          return Promise.resolve().then(async () => {\n            for await (const chunk of stream) {\n              if (chunk) {\n                chunks.push(...chunk);\n              }\n            }\n            const blobPart = new Uint8Array(chunks);\n            form.append(indexStr, new File$1([blobPart], filename, { type: upload.mimetype }), filename);\n          });\n        } else {\n          form.append(indexStr, new File$1([upload], filename), filename);\n        }\n      }\n    }\n    return ValueOrPromise.all(uploads.map((upload, i) => new ValueOrPromise(() => handleUpload(upload, i)))).then(() => form).resolve();\n  }\n  prepareGETUrl({ baseUrl, query, variables, operationName, extensions }) {\n    const HTTP_URL = switchProtocols(baseUrl, {\n      wss: \"https\",\n      ws: \"http\"\n    });\n    const dummyHostname = \"https://dummyhostname.com\";\n    const validUrl = HTTP_URL.startsWith(\"http\") ? HTTP_URL : HTTP_URL.startsWith(\"/\") ? `${dummyHostname}${HTTP_URL}` : `${dummyHostname}/${HTTP_URL}`;\n    const urlObj = new URL(validUrl);\n    urlObj.searchParams.set(\"query\", query);\n    if (variables && Object.keys(variables).length > 0) {\n      urlObj.searchParams.set(\"variables\", JSON.stringify(variables));\n    }\n    if (operationName) {\n      urlObj.searchParams.set(\"operationName\", operationName);\n    }\n    if (extensions) {\n      urlObj.searchParams.set(\"extensions\", JSON.stringify(extensions));\n    }\n    const finalUrl = urlObj.toString().replace(dummyHostname, \"\");\n    return finalUrl;\n  }\n  buildHTTPExecutor(initialEndpoint, fetch2, options) {\n    const defaultMethod = this.getDefaultMethodFromOptions(options === null || options === void 0 ? void 0 : options.method, \"POST\");\n    const HTTP_URL = switchProtocols(initialEndpoint, {\n      wss: \"https\",\n      ws: \"http\"\n    });\n    const executor = (request) => {\n      var _a2, _b;\n      const controller = new AbortController$1();\n      let method = defaultMethod;\n      if (options === null || options === void 0 ? void 0 : options.useGETForQueries) {\n        const operationAst = getOperationASTFromRequest(request);\n        const operationType = operationAst.operation;\n        if (operationType === \"query\") {\n          method = \"GET\";\n        }\n      }\n      const endpoint = ((_a2 = request.extensions) === null || _a2 === void 0 ? void 0 : _a2.endpoint) || HTTP_URL;\n      const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers, ((_b = request.extensions) === null || _b === void 0 ? void 0 : _b.headers) || {});\n      const acceptedProtocols = [`application/json`];\n      if (method === \"GET\" && (options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.SSE) {\n        acceptedProtocols.push(\"text/event-stream\");\n      } else {\n        acceptedProtocols.push(\"multipart/mixed\");\n      }\n      const accept = acceptedProtocols.join(\", \");\n      const query = print(request.document);\n      const requestBody = {\n        query,\n        variables: request.variables,\n        operationName: request.operationName,\n        extensions: request.extensions\n      };\n      let timeoutId;\n      if (options === null || options === void 0 ? void 0 : options.timeout) {\n        timeoutId = setTimeout(() => {\n          if (!controller.signal.aborted) {\n            controller.abort();\n          }\n        }, options.timeout);\n      }\n      const credentials = (options === null || options === void 0 ? void 0 : options.credentials) || \"same-origin\";\n      return new ValueOrPromise(() => {\n        switch (method) {\n          case \"GET\":\n            const finalUrl = this.prepareGETUrl(__spreadValues({\n              baseUrl: endpoint\n            }, requestBody));\n            return fetch2(finalUrl, {\n              method: \"GET\",\n              credentials,\n              headers: __spreadValues({\n                accept\n              }, headers),\n              signal: controller.signal\n            });\n          case \"POST\":\n            if (options === null || options === void 0 ? void 0 : options.multipart) {\n              return new ValueOrPromise(() => this.createFormDataFromVariables(requestBody)).then((form) => fetch2(endpoint, {\n                method: \"POST\",\n                credentials,\n                body: form,\n                headers: __spreadValues({\n                  accept\n                }, headers),\n                signal: controller.signal\n              })).resolve();\n            } else {\n              return fetch2(endpoint, {\n                method: \"POST\",\n                credentials,\n                body: JSON.stringify(requestBody),\n                headers: __spreadValues({\n                  accept,\n                  \"content-type\": \"application/json\"\n                }, headers),\n                signal: controller.signal\n              });\n            }\n        }\n      }).then((fetchResult) => {\n        if (timeoutId != null) {\n          clearTimeout(timeoutId);\n        }\n        if ((options === null || options === void 0 ? void 0 : options.retry) != null && !fetchResult.status.toString().startsWith(\"2\")) {\n          throw new Error(fetchResult.statusText || `HTTP Error: ${fetchResult.status}`);\n        }\n        const contentType = fetchResult.headers.get(\"content-type\");\n        if (contentType === null || contentType === void 0 ? void 0 : contentType.includes(\"text/event-stream\")) {\n          return handleEventStreamResponse(fetchResult).then((resultStream) => addCancelToResponseStream(resultStream, controller));\n        } else if (contentType === null || contentType === void 0 ? void 0 : contentType.includes(\"multipart/mixed\")) {\n          return handleMultipartMixedResponse(fetchResult).then((resultStream) => addCancelToResponseStream(resultStream, controller));\n        }\n        return fetchResult.text();\n      }).then((result2) => {\n        if (typeof result2 === \"string\") {\n          return JSON.parse(result2);\n        } else {\n          return result2;\n        }\n      }).resolve();\n    };\n    if ((options === null || options === void 0 ? void 0 : options.retry) != null) {\n      return function retryExecutor(request) {\n        let result2;\n        let error2;\n        let attempt = 0;\n        function retryAttempt() {\n          attempt++;\n          if (attempt > options.retry) {\n            if (result2 != null) {\n              return result2;\n            }\n            if (error2 != null) {\n              throw error2;\n            }\n            throw new Error(\"No result\");\n          }\n          return new ValueOrPromise(() => executor(request)).then((res) => {\n            var _a2;\n            result2 = res;\n            if ((_a2 = result2 === null || result2 === void 0 ? void 0 : result2.errors) === null || _a2 === void 0 ? void 0 : _a2.length) {\n              return retryAttempt();\n            }\n            return result2;\n          }).catch((e) => {\n            error2 = e;\n            return retryAttempt();\n          }).resolve();\n        }\n        return retryAttempt();\n      };\n    }\n    return executor;\n  }\n  buildWSExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams) {\n    const WS_URL = switchProtocols(subscriptionsEndpoint, {\n      https: \"wss\",\n      http: \"ws\"\n    });\n    const subscriptionClient = createClient$1({\n      url: WS_URL,\n      webSocketImpl,\n      connectionParams,\n      lazy: true\n    });\n    return ({ document: document2, variables, operationName, extensions }) => {\n      const query = print(document2);\n      return observableToAsyncIterable({\n        subscribe: (observer) => {\n          const unsubscribe = subscriptionClient.subscribe({\n            query,\n            variables,\n            operationName,\n            extensions\n          }, observer);\n          return {\n            unsubscribe\n          };\n        }\n      });\n    };\n  }\n  buildWSLegacyExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams) {\n    const WS_URL = switchProtocols(subscriptionsEndpoint, {\n      https: \"wss\",\n      http: \"ws\"\n    });\n    const subscriptionClient = new SubscriptionClient_1(WS_URL, {\n      connectionParams,\n      lazy: true\n    }, webSocketImpl);\n    return ({ document: document2, variables, operationName }) => {\n      return observableToAsyncIterable(subscriptionClient.request({\n        query: document2,\n        variables,\n        operationName\n      }));\n    };\n  }\n  buildGraphQLSSEExecutor(endpoint, fetch2, options = {}) {\n    const { headers } = options;\n    const client2 = createClient(__spreadProps(__spreadValues({}, options.graphqlSseOptions), {\n      url: endpoint,\n      fetchFn: fetch2,\n      abortControllerImpl: AbortController$1,\n      headers\n    }));\n    return async ({ document: document2, variables, operationName, extensions }) => {\n      return observableToAsyncIterable({\n        subscribe: (observer) => {\n          const unsubscribe = client2.subscribe({\n            query: document2,\n            variables,\n            operationName,\n            extensions\n          }, observer);\n          return {\n            unsubscribe\n          };\n        }\n      });\n    };\n  }\n  getFetch(customFetch, importFn) {\n    if (customFetch) {\n      if (typeof customFetch === \"string\") {\n        const [moduleName, fetchFnName] = customFetch.split(\"#\");\n        return new ValueOrPromise(() => importFn(moduleName)).then((module2) => fetchFnName ? module2[fetchFnName] : module2).resolve();\n      } else if (typeof customFetch === \"function\") {\n        return customFetch;\n      }\n    }\n    if (importFn === asyncImport) {\n      return defaultAsyncFetch;\n    } else {\n      return defaultSyncFetch;\n    }\n  }\n  getDefaultMethodFromOptions(method, defaultMethod) {\n    if (method) {\n      defaultMethod = method;\n    }\n    return defaultMethod;\n  }\n  getWebSocketImpl(importFn, options) {\n    if (typeof (options === null || options === void 0 ? void 0 : options.webSocketImpl) === \"string\") {\n      const [moduleName, webSocketImplName] = options.webSocketImpl.split(\"#\");\n      return new ValueOrPromise(() => importFn(moduleName)).then((importedModule) => webSocketImplName ? importedModule[webSocketImplName] : importedModule).resolve();\n    } else {\n      const websocketImpl = (options === null || options === void 0 ? void 0 : options.webSocketImpl) || browser$1;\n      return websocketImpl;\n    }\n  }\n  buildSubscriptionExecutor(subscriptionsEndpoint, fetch2, importFn, options) {\n    if ((options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.SSE) {\n      return this.buildHTTPExecutor(subscriptionsEndpoint, fetch2, __spreadProps(__spreadValues({}, options), {\n        method: \"GET\"\n      }));\n    } else if ((options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.GRAPHQL_SSE) {\n      if (!(options === null || options === void 0 ? void 0 : options.subscriptionsEndpoint)) {\n        subscriptionsEndpoint += \"/stream\";\n      }\n      return this.buildGraphQLSSEExecutor(subscriptionsEndpoint, fetch2, options);\n    } else {\n      const webSocketImpl$ = new ValueOrPromise(() => this.getWebSocketImpl(importFn, options));\n      const connectionParams = () => ({ headers: options === null || options === void 0 ? void 0 : options.headers });\n      const executor$ = webSocketImpl$.then((webSocketImpl) => {\n        if ((options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.LEGACY_WS) {\n          return this.buildWSLegacyExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams);\n        } else {\n          return this.buildWSExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams);\n        }\n      });\n      return (request) => executor$.then((executor) => executor(request)).resolve();\n    }\n  }\n  getExecutor(endpoint, importFn, options) {\n    const fetch$ = new ValueOrPromise(() => this.getFetch(options === null || options === void 0 ? void 0 : options.customFetch, asyncImport));\n    const httpExecutor$ = fetch$.then((fetch2) => {\n      return this.buildHTTPExecutor(endpoint, fetch2, options);\n    });\n    const subscriptionExecutor$ = fetch$.then((fetch2) => {\n      const subscriptionsEndpoint = (options === null || options === void 0 ? void 0 : options.subscriptionsEndpoint) || endpoint;\n      return this.buildSubscriptionExecutor(subscriptionsEndpoint, fetch2, importFn, options);\n    });\n    function getExecutorByRequest(request) {\n      const operationAst = getOperationASTFromRequest(request);\n      if (operationAst.operation === \"subscription\" || isLiveQueryOperationDefinitionNode(operationAst, request.variables)) {\n        return subscriptionExecutor$;\n      } else {\n        return httpExecutor$;\n      }\n    }\n    return (request) => getExecutorByRequest(request).then((executor) => executor(request)).resolve();\n  }\n  getExecutorAsync(endpoint, options) {\n    return this.getExecutor(endpoint, asyncImport, options);\n  }\n  getExecutorSync(endpoint, options) {\n    return this.getExecutor(endpoint, syncImport, options);\n  }\n  handleSDL(pointer, fetch2, options) {\n    const defaultMethod = this.getDefaultMethodFromOptions(options === null || options === void 0 ? void 0 : options.method, \"GET\");\n    return new ValueOrPromise(() => fetch2(pointer, {\n      method: defaultMethod,\n      headers: options.headers\n    })).then((response) => response.text()).then((schemaString) => parseGraphQLSDL(pointer, schemaString, options)).resolve();\n  }\n  async load(pointer, options) {\n    if (!isCompatibleUri(pointer)) {\n      return [];\n    }\n    let source = {\n      location: pointer\n    };\n    let executor;\n    if ((options === null || options === void 0 ? void 0 : options.handleAsSDL) || pointer.endsWith(\".graphql\") || pointer.endsWith(\".graphqls\")) {\n      const fetch2 = await this.getFetch(options === null || options === void 0 ? void 0 : options.customFetch, asyncImport);\n      source = await this.handleSDL(pointer, fetch2, options);\n      if (!source.schema && !source.document && !source.rawSDL) {\n        throw new Error(`Invalid SDL response`);\n      }\n      source.schema = source.schema || (source.document ? buildASTSchema(source.document, options) : source.rawSDL ? buildSchema(source.rawSDL, options) : void 0);\n    } else {\n      executor = this.getExecutorAsync(pointer, options);\n      source.schema = await introspectSchema(executor, {}, options);\n    }\n    if (!source.schema) {\n      throw new Error(`Invalid introspected schema`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.endpoint) {\n      executor = this.getExecutorAsync(options.endpoint, options);\n    }\n    source.schema = wrapSchema({\n      schema: source.schema,\n      executor\n    });\n    return [source];\n  }\n  loadSync(pointer, options) {\n    if (!isCompatibleUri(pointer)) {\n      return [];\n    }\n    let source = {\n      location: pointer\n    };\n    let executor;\n    if ((options === null || options === void 0 ? void 0 : options.handleAsSDL) || pointer.endsWith(\".graphql\") || pointer.endsWith(\".graphqls\")) {\n      const fetch2 = this.getFetch(options === null || options === void 0 ? void 0 : options.customFetch, syncImport);\n      source = this.handleSDL(pointer, fetch2, options);\n      if (!source.schema && !source.document && !source.rawSDL) {\n        throw new Error(`Invalid SDL response`);\n      }\n      source.schema = source.schema || (source.document ? buildASTSchema(source.document, options) : source.rawSDL ? buildSchema(source.rawSDL, options) : void 0);\n    } else {\n      executor = this.getExecutorSync(pointer, options);\n      source.schema = introspectSchema(executor, {}, options);\n    }\n    if (!source.schema) {\n      throw new Error(`Invalid introspected schema`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.endpoint) {\n      executor = this.getExecutorSync(options.endpoint, options);\n    }\n    source.schema = wrapSchema({\n      schema: source.schema,\n      executor\n    });\n    return [source];\n  }\n}\nfunction switchProtocols(pointer, protocolMap) {\n  return Object.entries(protocolMap).reduce((prev, [source, target2]) => prev.replace(`${source}://`, `${target2}://`).replace(`${source}:\\\\`, `${target2}:\\\\`), pointer);\n}\nvar dist = {};\nvar Explorer$1 = {};\nvar require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(graphql);\nObject.defineProperty(Explorer$1, \"__esModule\", {\n  value: true\n});\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n  return typeof obj;\n} : function(obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _slicedToArray = function() {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = void 0;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i)\n          break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"])\n          _i[\"return\"]();\n      } finally {\n        if (_d)\n          throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function(arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar _extends = Object.assign || function(target2) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target2[key] = source[key];\n      }\n    }\n  }\n  return target2;\n};\nvar _createClass = function() {\n  function defineProperties(target2, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor)\n        descriptor.writable = true;\n      Object.defineProperty(target2, descriptor.key, descriptor);\n    }\n  }\n  return function(Constructor, protoProps, staticProps) {\n    if (protoProps)\n      defineProperties(Constructor.prototype, protoProps);\n    if (staticProps)\n      defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nExplorer$1.defaultValue = defaultValue;\nvar _react = react.exports;\nvar React = _interopRequireWildcard(_react);\nvar _graphql = require$$1$2;\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key))\n          newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self2, call) {\n  if (!self2) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self2;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });\n  if (superClass)\n    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\nfunction capitalize(string2) {\n  return string2.charAt(0).toUpperCase() + string2.slice(1);\n}\nvar defaultColors = {\n  keyword: \"#B11A04\",\n  def: \"#D2054E\",\n  property: \"#1F61A0\",\n  qualifier: \"#1C92A9\",\n  attribute: \"#8B2BB9\",\n  number: \"#2882F9\",\n  string: \"#D64292\",\n  builtin: \"#D47509\",\n  string2: \"#0B7FC7\",\n  variable: \"#397D13\",\n  atom: \"#CA9800\"\n};\nvar defaultArrowOpen = React.createElement(\"svg\", { width: \"12\", height: \"9\" }, React.createElement(\"path\", { fill: \"#666\", d: \"M 0 2 L 9 2 L 4.5 7.5 z\" }));\nvar defaultArrowClosed = React.createElement(\"svg\", { width: \"12\", height: \"9\" }, React.createElement(\"path\", { fill: \"#666\", d: \"M 0 0 L 0 9 L 5.5 4.5 z\" }));\nvar defaultCheckboxChecked = React.createElement(\"svg\", {\n  style: { marginRight: \"3px\", marginLeft: \"-3px\" },\n  width: \"12\",\n  height: \"12\",\n  viewBox: \"0 0 18 18\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, React.createElement(\"path\", {\n  d: \"M16 0H2C0.9 0 0 0.9 0 2V16C0 17.1 0.9 18 2 18H16C17.1 18 18 17.1 18 16V2C18 0.9 17.1 0 16 0ZM16 16H2V2H16V16ZM14.99 6L13.58 4.58L6.99 11.17L4.41 8.6L2.99 10.01L6.99 14L14.99 6Z\",\n  fill: \"#666\"\n}));\nvar defaultCheckboxUnchecked = React.createElement(\"svg\", {\n  style: { marginRight: \"3px\", marginLeft: \"-3px\" },\n  width: \"12\",\n  height: \"12\",\n  viewBox: \"0 0 18 18\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, React.createElement(\"path\", {\n  d: \"M16 2V16H2V2H16ZM16 0H2C0.9 0 0 0.9 0 2V16C0 17.1 0.9 18 2 18H16C17.1 18 18 17.1 18 16V2C18 0.9 17.1 0 16 0Z\",\n  fill: \"#CCC\"\n}));\nfunction Checkbox(props) {\n  return props.checked ? props.styleConfig.checkboxChecked : props.styleConfig.checkboxUnchecked;\n}\nfunction defaultGetDefaultFieldNames(type2) {\n  var fields = type2.getFields();\n  if (fields[\"id\"]) {\n    var res = [\"id\"];\n    if (fields[\"email\"]) {\n      res.push(\"email\");\n    } else if (fields[\"name\"]) {\n      res.push(\"name\");\n    }\n    return res;\n  }\n  if (fields[\"edges\"]) {\n    return [\"edges\"];\n  }\n  if (fields[\"node\"]) {\n    return [\"node\"];\n  }\n  if (fields[\"nodes\"]) {\n    return [\"nodes\"];\n  }\n  var leafFieldNames = [];\n  Object.keys(fields).forEach(function(fieldName) {\n    if ((0, _graphql.isLeafType)(fields[fieldName].type)) {\n      leafFieldNames.push(fieldName);\n    }\n  });\n  if (!leafFieldNames.length) {\n    return [\"__typename\"];\n  }\n  return leafFieldNames.slice(0, 2);\n}\nfunction isRequiredArgument(arg) {\n  return (0, _graphql.isNonNullType)(arg.type) && arg.defaultValue === void 0;\n}\nfunction unwrapOutputType(outputType) {\n  var unwrappedType = outputType;\n  while ((0, _graphql.isWrappingType)(unwrappedType)) {\n    unwrappedType = unwrappedType.ofType;\n  }\n  return unwrappedType;\n}\nfunction unwrapInputType(inputType) {\n  var unwrappedType = inputType;\n  while ((0, _graphql.isWrappingType)(unwrappedType)) {\n    unwrappedType = unwrappedType.ofType;\n  }\n  return unwrappedType;\n}\nfunction coerceArgValue(argType, value) {\n  if (typeof value !== \"string\" && value.kind === \"VariableDefinition\") {\n    return value.variable;\n  } else if ((0, _graphql.isScalarType)(argType)) {\n    try {\n      switch (argType.name) {\n        case \"String\":\n          return {\n            kind: \"StringValue\",\n            value: String(argType.parseValue(value))\n          };\n        case \"Float\":\n          return {\n            kind: \"FloatValue\",\n            value: String(argType.parseValue(parseFloat(value)))\n          };\n        case \"Int\":\n          return {\n            kind: \"IntValue\",\n            value: String(argType.parseValue(parseInt(value, 10)))\n          };\n        case \"Boolean\":\n          try {\n            var parsed = JSON.parse(value);\n            if (typeof parsed === \"boolean\") {\n              return { kind: \"BooleanValue\", value: parsed };\n            } else {\n              return { kind: \"BooleanValue\", value: false };\n            }\n          } catch (e) {\n            return {\n              kind: \"BooleanValue\",\n              value: false\n            };\n          }\n        default:\n          return {\n            kind: \"StringValue\",\n            value: String(argType.parseValue(value))\n          };\n      }\n    } catch (e) {\n      console.error(\"error coercing arg value\", e, value);\n      return { kind: \"StringValue\", value };\n    }\n  } else {\n    try {\n      var parsedValue = argType.parseValue(value);\n      if (parsedValue) {\n        return { kind: \"EnumValue\", value: String(parsedValue) };\n      } else {\n        return { kind: \"EnumValue\", value: argType.getValues()[0].name };\n      }\n    } catch (e) {\n      return { kind: \"EnumValue\", value: argType.getValues()[0].name };\n    }\n  }\n}\nvar InputArgView = function(_React$PureComponent) {\n  _inherits(InputArgView2, _React$PureComponent);\n  function InputArgView2() {\n    var _ref;\n    var _temp, _this, _ret;\n    _classCallCheck(this, InputArgView2);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = InputArgView2.__proto__ || Object.getPrototypeOf(InputArgView2)).call.apply(_ref, [this].concat(args))), _this), _this._getArgSelection = function() {\n      return _this.props.selection.fields.find(function(field) {\n        return field.name.value === _this.props.arg.name;\n      });\n    }, _this._removeArg = function() {\n      var selection = _this.props.selection;\n      var argSelection = _this._getArgSelection();\n      _this._previousArgSelection = argSelection;\n      _this.props.modifyFields(selection.fields.filter(function(field) {\n        return field !== argSelection;\n      }), true);\n    }, _this._addArg = function() {\n      var _this$props = _this.props, selection = _this$props.selection, arg = _this$props.arg, getDefaultScalarArgValue = _this$props.getDefaultScalarArgValue, parentField = _this$props.parentField, makeDefaultArg = _this$props.makeDefaultArg;\n      var argType = unwrapInputType(arg.type);\n      var argSelection = null;\n      if (_this._previousArgSelection) {\n        argSelection = _this._previousArgSelection;\n      } else if ((0, _graphql.isInputObjectType)(argType)) {\n        var _fields = argType.getFields();\n        argSelection = {\n          kind: \"ObjectField\",\n          name: { kind: \"Name\", value: arg.name },\n          value: {\n            kind: \"ObjectValue\",\n            fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, Object.keys(_fields).map(function(k) {\n              return _fields[k];\n            }))\n          }\n        };\n      } else if ((0, _graphql.isLeafType)(argType)) {\n        argSelection = {\n          kind: \"ObjectField\",\n          name: { kind: \"Name\", value: arg.name },\n          value: getDefaultScalarArgValue(parentField, arg, argType)\n        };\n      }\n      if (!argSelection) {\n        console.error(\"Unable to add arg for argType\", argType);\n      } else {\n        return _this.props.modifyFields([].concat(_toConsumableArray(selection.fields || []), [argSelection]), true);\n      }\n    }, _this._setArgValue = function(event, options) {\n      var settingToNull = false;\n      var settingToVariable = false;\n      var settingToLiteralValue = false;\n      try {\n        if (event.kind === \"VariableDefinition\") {\n          settingToVariable = true;\n        } else if (event === null || typeof event === \"undefined\") {\n          settingToNull = true;\n        } else if (typeof event.kind === \"string\") {\n          settingToLiteralValue = true;\n        }\n      } catch (e) {\n      }\n      var selection = _this.props.selection;\n      var argSelection = _this._getArgSelection();\n      if (!argSelection) {\n        console.error(\"missing arg selection when setting arg value\");\n        return;\n      }\n      var argType = unwrapInputType(_this.props.arg.type);\n      var handleable = (0, _graphql.isLeafType)(argType) || settingToVariable || settingToNull || settingToLiteralValue;\n      if (!handleable) {\n        console.warn(\"Unable to handle non leaf types in InputArgView.setArgValue\", event);\n        return;\n      }\n      var targetValue = void 0;\n      var value = void 0;\n      if (event === null || typeof event === \"undefined\") {\n        value = null;\n      } else if (!event.target && !!event.kind && event.kind === \"VariableDefinition\") {\n        targetValue = event;\n        value = targetValue.variable;\n      } else if (typeof event.kind === \"string\") {\n        value = event;\n      } else if (event.target && typeof event.target.value === \"string\") {\n        targetValue = event.target.value;\n        value = coerceArgValue(argType, targetValue);\n      }\n      var newDoc = _this.props.modifyFields((selection.fields || []).map(function(field) {\n        var isTarget = field === argSelection;\n        var newField = isTarget ? _extends({}, field, {\n          value\n        }) : field;\n        return newField;\n      }), options);\n      return newDoc;\n    }, _this._modifyChildFields = function(fields) {\n      return _this.props.modifyFields(_this.props.selection.fields.map(function(field) {\n        return field.name.value === _this.props.arg.name ? _extends({}, field, {\n          value: {\n            kind: \"ObjectValue\",\n            fields\n          }\n        }) : field;\n      }), true);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  _createClass(InputArgView2, [{\n    key: \"render\",\n    value: function render() {\n      var _props = this.props, arg = _props.arg, parentField = _props.parentField;\n      var argSelection = this._getArgSelection();\n      return React.createElement(AbstractArgView, {\n        argValue: argSelection ? argSelection.value : null,\n        arg,\n        parentField,\n        addArg: this._addArg,\n        removeArg: this._removeArg,\n        setArgFields: this._modifyChildFields,\n        setArgValue: this._setArgValue,\n        getDefaultScalarArgValue: this.props.getDefaultScalarArgValue,\n        makeDefaultArg: this.props.makeDefaultArg,\n        onRunOperation: this.props.onRunOperation,\n        styleConfig: this.props.styleConfig,\n        onCommit: this.props.onCommit,\n        definition: this.props.definition\n      });\n    }\n  }]);\n  return InputArgView2;\n}(React.PureComponent);\nfunction defaultValue(argType) {\n  if ((0, _graphql.isEnumType)(argType)) {\n    return { kind: \"EnumValue\", value: argType.getValues()[0].name };\n  } else {\n    switch (argType.name) {\n      case \"String\":\n        return { kind: \"StringValue\", value: \"\" };\n      case \"Float\":\n        return { kind: \"FloatValue\", value: \"1.5\" };\n      case \"Int\":\n        return { kind: \"IntValue\", value: \"10\" };\n      case \"Boolean\":\n        return { kind: \"BooleanValue\", value: false };\n      default:\n        return { kind: \"StringValue\", value: \"\" };\n    }\n  }\n}\nfunction defaultGetDefaultScalarArgValue(parentField, arg, argType) {\n  return defaultValue(argType);\n}\nvar ArgView = function(_React$PureComponent2) {\n  _inherits(ArgView2, _React$PureComponent2);\n  function ArgView2() {\n    var _ref2;\n    var _temp2, _this2, _ret2;\n    _classCallCheck(this, ArgView2);\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, (_ref2 = ArgView2.__proto__ || Object.getPrototypeOf(ArgView2)).call.apply(_ref2, [this].concat(args))), _this2), _this2._getArgSelection = function() {\n      var selection = _this2.props.selection;\n      return (selection.arguments || []).find(function(arg) {\n        return arg.name.value === _this2.props.arg.name;\n      });\n    }, _this2._removeArg = function(commit) {\n      var selection = _this2.props.selection;\n      var argSelection = _this2._getArgSelection();\n      _this2._previousArgSelection = argSelection;\n      return _this2.props.modifyArguments((selection.arguments || []).filter(function(arg) {\n        return arg !== argSelection;\n      }), commit);\n    }, _this2._addArg = function(commit) {\n      var _this2$props = _this2.props, selection = _this2$props.selection, getDefaultScalarArgValue = _this2$props.getDefaultScalarArgValue, makeDefaultArg = _this2$props.makeDefaultArg, parentField = _this2$props.parentField, arg = _this2$props.arg;\n      var argType = unwrapInputType(arg.type);\n      var argSelection = null;\n      if (_this2._previousArgSelection) {\n        argSelection = _this2._previousArgSelection;\n      } else if ((0, _graphql.isInputObjectType)(argType)) {\n        var _fields2 = argType.getFields();\n        argSelection = {\n          kind: \"Argument\",\n          name: { kind: \"Name\", value: arg.name },\n          value: {\n            kind: \"ObjectValue\",\n            fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, Object.keys(_fields2).map(function(k) {\n              return _fields2[k];\n            }))\n          }\n        };\n      } else if ((0, _graphql.isLeafType)(argType)) {\n        argSelection = {\n          kind: \"Argument\",\n          name: { kind: \"Name\", value: arg.name },\n          value: getDefaultScalarArgValue(parentField, arg, argType)\n        };\n      }\n      if (!argSelection) {\n        console.error(\"Unable to add arg for argType\", argType);\n        return null;\n      } else {\n        return _this2.props.modifyArguments([].concat(_toConsumableArray(selection.arguments || []), [argSelection]), commit);\n      }\n    }, _this2._setArgValue = function(event, options) {\n      var settingToNull = false;\n      var settingToVariable = false;\n      var settingToLiteralValue = false;\n      try {\n        if (event.kind === \"VariableDefinition\") {\n          settingToVariable = true;\n        } else if (event === null || typeof event === \"undefined\") {\n          settingToNull = true;\n        } else if (typeof event.kind === \"string\") {\n          settingToLiteralValue = true;\n        }\n      } catch (e) {\n      }\n      var selection = _this2.props.selection;\n      var argSelection = _this2._getArgSelection();\n      if (!argSelection && !settingToVariable) {\n        console.error(\"missing arg selection when setting arg value\");\n        return;\n      }\n      var argType = unwrapInputType(_this2.props.arg.type);\n      var handleable = (0, _graphql.isLeafType)(argType) || settingToVariable || settingToNull || settingToLiteralValue;\n      if (!handleable) {\n        console.warn(\"Unable to handle non leaf types in ArgView._setArgValue\");\n        return;\n      }\n      var targetValue = void 0;\n      var value = void 0;\n      if (event === null || typeof event === \"undefined\") {\n        value = null;\n      } else if (event.target && typeof event.target.value === \"string\") {\n        targetValue = event.target.value;\n        value = coerceArgValue(argType, targetValue);\n      } else if (!event.target && event.kind === \"VariableDefinition\") {\n        targetValue = event;\n        value = targetValue.variable;\n      } else if (typeof event.kind === \"string\") {\n        value = event;\n      }\n      return _this2.props.modifyArguments((selection.arguments || []).map(function(a) {\n        return a === argSelection ? _extends({}, a, {\n          value\n        }) : a;\n      }), options);\n    }, _this2._setArgFields = function(fields, commit) {\n      var selection = _this2.props.selection;\n      var argSelection = _this2._getArgSelection();\n      if (!argSelection) {\n        console.error(\"missing arg selection when setting arg value\");\n        return;\n      }\n      return _this2.props.modifyArguments((selection.arguments || []).map(function(a) {\n        return a === argSelection ? _extends({}, a, {\n          value: {\n            kind: \"ObjectValue\",\n            fields\n          }\n        }) : a;\n      }), commit);\n    }, _temp2), _possibleConstructorReturn(_this2, _ret2);\n  }\n  _createClass(ArgView2, [{\n    key: \"render\",\n    value: function render() {\n      var _props2 = this.props, arg = _props2.arg, parentField = _props2.parentField;\n      var argSelection = this._getArgSelection();\n      return React.createElement(AbstractArgView, {\n        argValue: argSelection ? argSelection.value : null,\n        arg,\n        parentField,\n        addArg: this._addArg,\n        removeArg: this._removeArg,\n        setArgFields: this._setArgFields,\n        setArgValue: this._setArgValue,\n        getDefaultScalarArgValue: this.props.getDefaultScalarArgValue,\n        makeDefaultArg: this.props.makeDefaultArg,\n        onRunOperation: this.props.onRunOperation,\n        styleConfig: this.props.styleConfig,\n        onCommit: this.props.onCommit,\n        definition: this.props.definition\n      });\n    }\n  }]);\n  return ArgView2;\n}(React.PureComponent);\nfunction isRunShortcut(event) {\n  return event.ctrlKey && event.key === \"Enter\";\n}\nfunction canRunOperation(operationName) {\n  return operationName !== \"FragmentDefinition\";\n}\nvar ScalarInput = function(_React$PureComponent3) {\n  _inherits(ScalarInput2, _React$PureComponent3);\n  function ScalarInput2() {\n    var _ref3;\n    var _temp3, _this3, _ret3;\n    _classCallCheck(this, ScalarInput2);\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return _ret3 = (_temp3 = (_this3 = _possibleConstructorReturn(this, (_ref3 = ScalarInput2.__proto__ || Object.getPrototypeOf(ScalarInput2)).call.apply(_ref3, [this].concat(args))), _this3), _this3._handleChange = function(event) {\n      _this3.props.setArgValue(event, true);\n    }, _temp3), _possibleConstructorReturn(_this3, _ret3);\n  }\n  _createClass(ScalarInput2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var input = this._ref;\n      var activeElement = document.activeElement;\n      if (input && activeElement && !(activeElement instanceof HTMLTextAreaElement)) {\n        input.focus();\n        input.setSelectionRange(0, input.value.length);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n      var _props3 = this.props, arg = _props3.arg, argValue = _props3.argValue, styleConfig = _props3.styleConfig;\n      var argType = unwrapInputType(arg.type);\n      var value = typeof argValue.value === \"string\" ? argValue.value : \"\";\n      var color = this.props.argValue.kind === \"StringValue\" ? styleConfig.colors.string : styleConfig.colors.number;\n      return React.createElement(\"span\", { style: { color } }, argType.name === \"String\" ? '\"' : \"\", React.createElement(\"input\", {\n        style: {\n          border: \"none\",\n          borderBottom: \"1px solid #888\",\n          outline: \"none\",\n          width: Math.max(1, Math.min(15, value.length)) + \"ch\",\n          color\n        },\n        ref: function ref(_ref4) {\n          _this4._ref = _ref4;\n        },\n        type: \"text\",\n        onChange: this._handleChange,\n        value\n      }), argType.name === \"String\" ? '\"' : \"\");\n    }\n  }]);\n  return ScalarInput2;\n}(React.PureComponent);\nvar AbstractArgView = function(_React$PureComponent4) {\n  _inherits(AbstractArgView2, _React$PureComponent4);\n  function AbstractArgView2() {\n    var _ref5;\n    var _temp4, _this5, _ret4;\n    _classCallCheck(this, AbstractArgView2);\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return _ret4 = (_temp4 = (_this5 = _possibleConstructorReturn(this, (_ref5 = AbstractArgView2.__proto__ || Object.getPrototypeOf(AbstractArgView2)).call.apply(_ref5, [this].concat(args))), _this5), _this5.state = { displayArgActions: false }, _temp4), _possibleConstructorReturn(_this5, _ret4);\n  }\n  _createClass(AbstractArgView2, [{\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n      var _props4 = this.props, argValue = _props4.argValue, arg = _props4.arg, styleConfig = _props4.styleConfig;\n      var argType = unwrapInputType(arg.type);\n      var input = null;\n      if (argValue) {\n        if (argValue.kind === \"Variable\") {\n          input = React.createElement(\"span\", { style: { color: styleConfig.colors.variable } }, \"$\", argValue.name.value);\n        } else if ((0, _graphql.isScalarType)(argType)) {\n          if (argType.name === \"Boolean\") {\n            input = React.createElement(\"select\", {\n              style: {\n                color: styleConfig.colors.builtin\n              },\n              onChange: this.props.setArgValue,\n              value: argValue.kind === \"BooleanValue\" ? argValue.value : void 0\n            }, React.createElement(\"option\", { key: \"true\", value: \"true\" }, \"true\"), React.createElement(\"option\", { key: \"false\", value: \"false\" }, \"false\"));\n          } else {\n            input = React.createElement(ScalarInput, {\n              setArgValue: this.props.setArgValue,\n              arg,\n              argValue,\n              onRunOperation: this.props.onRunOperation,\n              styleConfig: this.props.styleConfig\n            });\n          }\n        } else if ((0, _graphql.isEnumType)(argType)) {\n          if (argValue.kind === \"EnumValue\") {\n            input = React.createElement(\"select\", {\n              style: {\n                backgroundColor: \"white\",\n                color: styleConfig.colors.string2\n              },\n              onChange: this.props.setArgValue,\n              value: argValue.value\n            }, argType.getValues().map(function(value) {\n              return React.createElement(\"option\", { key: value.name, value: value.name }, value.name);\n            }));\n          } else {\n            console.error(\"arg mismatch between arg and selection\", argType, argValue);\n          }\n        } else if ((0, _graphql.isInputObjectType)(argType)) {\n          if (argValue.kind === \"ObjectValue\") {\n            var _fields3 = argType.getFields();\n            input = React.createElement(\"div\", { style: { marginLeft: 16 } }, Object.keys(_fields3).sort().map(function(fieldName) {\n              return React.createElement(InputArgView, {\n                key: fieldName,\n                arg: _fields3[fieldName],\n                parentField: _this6.props.parentField,\n                selection: argValue,\n                modifyFields: _this6.props.setArgFields,\n                getDefaultScalarArgValue: _this6.props.getDefaultScalarArgValue,\n                makeDefaultArg: _this6.props.makeDefaultArg,\n                onRunOperation: _this6.props.onRunOperation,\n                styleConfig: _this6.props.styleConfig,\n                onCommit: _this6.props.onCommit,\n                definition: _this6.props.definition\n              });\n            }));\n          } else {\n            console.error(\"arg mismatch between arg and selection\", argType, argValue);\n          }\n        }\n      }\n      var variablize = function variablize2() {\n        var baseVariableName = arg.name;\n        var conflictingNameCount = (_this6.props.definition.variableDefinitions || []).filter(function(varDef) {\n          return varDef.variable.name.value.startsWith(baseVariableName);\n        }).length;\n        var variableName = void 0;\n        if (conflictingNameCount > 0) {\n          variableName = \"\" + baseVariableName + conflictingNameCount;\n        } else {\n          variableName = baseVariableName;\n        }\n        var argPrintedType = arg.type.toString();\n        var argType2 = (0, _graphql.parseType)(argPrintedType);\n        var base2 = {\n          kind: \"VariableDefinition\",\n          variable: {\n            kind: \"Variable\",\n            name: {\n              kind: \"Name\",\n              value: variableName\n            }\n          },\n          type: argType2,\n          directives: []\n        };\n        var variableDefinitionByName = function variableDefinitionByName2(name2) {\n          return (_this6.props.definition.variableDefinitions || []).find(function(varDef) {\n            return varDef.variable.name.value === name2;\n          });\n        };\n        var variable = void 0;\n        var subVariableUsageCountByName = {};\n        if (typeof argValue !== \"undefined\" && argValue !== null) {\n          var cleanedDefaultValue = (0, _graphql.visit)(argValue, {\n            Variable: function Variable(node) {\n              var varName = node.name.value;\n              var varDef = variableDefinitionByName(varName);\n              subVariableUsageCountByName[varName] = subVariableUsageCountByName[varName] + 1 || 1;\n              if (!varDef) {\n                return;\n              }\n              return varDef.defaultValue;\n            }\n          });\n          var isNonNullable = base2.type.kind === \"NonNullType\";\n          var unwrappedBase = isNonNullable ? _extends({}, base2, { type: base2.type.type }) : base2;\n          variable = _extends({}, unwrappedBase, { defaultValue: cleanedDefaultValue });\n        } else {\n          variable = base2;\n        }\n        var newlyUnusedVariables = Object.entries(subVariableUsageCountByName).filter(function(_ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2);\n          _ref7[0];\n          var usageCount = _ref7[1];\n          return usageCount < 2;\n        }).map(function(_ref8) {\n          var _ref9 = _slicedToArray(_ref8, 2), varName = _ref9[0];\n          _ref9[1];\n          return varName;\n        });\n        if (variable) {\n          var _newDoc = _this6.props.setArgValue(variable, false);\n          if (_newDoc) {\n            var targetOperation = _newDoc.definitions.find(function(definition) {\n              if (!!definition.operation && !!definition.name && !!definition.name.value && !!_this6.props.definition.name && !!_this6.props.definition.name.value) {\n                return definition.name.value === _this6.props.definition.name.value;\n              } else {\n                return false;\n              }\n            });\n            var newVariableDefinitions = [].concat(_toConsumableArray(targetOperation.variableDefinitions || []), [variable]).filter(function(varDef) {\n              return newlyUnusedVariables.indexOf(varDef.variable.name.value) === -1;\n            });\n            var newOperation = _extends({}, targetOperation, {\n              variableDefinitions: newVariableDefinitions\n            });\n            var existingDefs = _newDoc.definitions;\n            var newDefinitions = existingDefs.map(function(existingOperation) {\n              if (targetOperation === existingOperation) {\n                return newOperation;\n              } else {\n                return existingOperation;\n              }\n            });\n            var finalDoc = _extends({}, _newDoc, {\n              definitions: newDefinitions\n            });\n            _this6.props.onCommit(finalDoc);\n          }\n        }\n      };\n      var devariablize = function devariablize2() {\n        if (!argValue || !argValue.name || !argValue.name.value) {\n          return;\n        }\n        var variableName = argValue.name.value;\n        var variableDefinition = (_this6.props.definition.variableDefinitions || []).find(function(varDef) {\n          return varDef.variable.name.value === variableName;\n        });\n        if (!variableDefinition) {\n          return;\n        }\n        var defaultValue2 = variableDefinition.defaultValue;\n        var newDoc = _this6.props.setArgValue(defaultValue2, {\n          commit: false\n        });\n        if (newDoc) {\n          var targetOperation = newDoc.definitions.find(function(definition) {\n            return definition.name.value === _this6.props.definition.name.value;\n          });\n          if (!targetOperation) {\n            return;\n          }\n          var variableUseCount = 0;\n          (0, _graphql.visit)(targetOperation, {\n            Variable: function Variable(node) {\n              if (node.name.value === variableName) {\n                variableUseCount = variableUseCount + 1;\n              }\n            }\n          });\n          var newVariableDefinitions = targetOperation.variableDefinitions || [];\n          if (variableUseCount < 2) {\n            newVariableDefinitions = newVariableDefinitions.filter(function(varDef) {\n              return varDef.variable.name.value !== variableName;\n            });\n          }\n          var newOperation = _extends({}, targetOperation, {\n            variableDefinitions: newVariableDefinitions\n          });\n          var existingDefs = newDoc.definitions;\n          var newDefinitions = existingDefs.map(function(existingOperation) {\n            if (targetOperation === existingOperation) {\n              return newOperation;\n            } else {\n              return existingOperation;\n            }\n          });\n          var finalDoc = _extends({}, newDoc, {\n            definitions: newDefinitions\n          });\n          _this6.props.onCommit(finalDoc);\n        }\n      };\n      var isArgValueVariable = argValue && argValue.kind === \"Variable\";\n      var variablizeActionButton = !this.state.displayArgActions ? null : React.createElement(\"button\", {\n        type: \"submit\",\n        className: \"toolbar-button\",\n        title: isArgValueVariable ? \"Remove the variable\" : \"Extract the current value into a GraphQL variable\",\n        onClick: function onClick(event) {\n          event.preventDefault();\n          event.stopPropagation();\n          if (isArgValueVariable) {\n            devariablize();\n          } else {\n            variablize();\n          }\n        },\n        style: styleConfig.styles.actionButtonStyle\n      }, React.createElement(\"span\", { style: { color: styleConfig.colors.variable } }, \"$\"));\n      return React.createElement(\"div\", {\n        style: {\n          cursor: \"pointer\",\n          minHeight: \"16px\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\"\n        },\n        \"data-arg-name\": arg.name,\n        \"data-arg-type\": argType.name,\n        className: \"graphiql-explorer-\" + arg.name\n      }, React.createElement(\"span\", {\n        style: { cursor: \"pointer\" },\n        onClick: function onClick(event) {\n          var shouldAdd = !argValue;\n          if (shouldAdd) {\n            _this6.props.addArg(true);\n          } else {\n            _this6.props.removeArg(true);\n          }\n          _this6.setState({ displayArgActions: shouldAdd });\n        }\n      }, (0, _graphql.isInputObjectType)(argType) ? React.createElement(\"span\", null, !!argValue ? this.props.styleConfig.arrowOpen : this.props.styleConfig.arrowClosed) : React.createElement(Checkbox, {\n        checked: !!argValue,\n        styleConfig: this.props.styleConfig\n      }), React.createElement(\"span\", {\n        style: { color: styleConfig.colors.attribute },\n        title: arg.description,\n        onMouseEnter: function onMouseEnter() {\n          if (argValue !== null && typeof argValue !== \"undefined\") {\n            _this6.setState({ displayArgActions: true });\n          }\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this6.setState({ displayArgActions: false });\n        }\n      }, arg.name, isRequiredArgument(arg) ? \"*\" : \"\", \": \", variablizeActionButton, \" \"), \" \"), input || React.createElement(\"span\", null), \" \");\n    }\n  }]);\n  return AbstractArgView2;\n}(React.PureComponent);\nvar AbstractView = function(_React$PureComponent5) {\n  _inherits(AbstractView2, _React$PureComponent5);\n  function AbstractView2() {\n    var _ref10;\n    var _temp5, _this7, _ret5;\n    _classCallCheck(this, AbstractView2);\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    return _ret5 = (_temp5 = (_this7 = _possibleConstructorReturn(this, (_ref10 = AbstractView2.__proto__ || Object.getPrototypeOf(AbstractView2)).call.apply(_ref10, [this].concat(args))), _this7), _this7._addFragment = function() {\n      _this7.props.modifySelections([].concat(_toConsumableArray(_this7.props.selections), [_this7._previousSelection || {\n        kind: \"InlineFragment\",\n        typeCondition: {\n          kind: \"NamedType\",\n          name: { kind: \"Name\", value: _this7.props.implementingType.name }\n        },\n        selectionSet: {\n          kind: \"SelectionSet\",\n          selections: _this7.props.getDefaultFieldNames(_this7.props.implementingType).map(function(fieldName) {\n            return {\n              kind: \"Field\",\n              name: { kind: \"Name\", value: fieldName }\n            };\n          })\n        }\n      }]));\n    }, _this7._removeFragment = function() {\n      var thisSelection = _this7._getSelection();\n      _this7._previousSelection = thisSelection;\n      _this7.props.modifySelections(_this7.props.selections.filter(function(s) {\n        return s !== thisSelection;\n      }));\n    }, _this7._getSelection = function() {\n      var selection = _this7.props.selections.find(function(selection2) {\n        return selection2.kind === \"InlineFragment\" && selection2.typeCondition && _this7.props.implementingType.name === selection2.typeCondition.name.value;\n      });\n      if (!selection) {\n        return null;\n      }\n      if (selection.kind === \"InlineFragment\") {\n        return selection;\n      }\n    }, _this7._modifyChildSelections = function(selections, options) {\n      var thisSelection = _this7._getSelection();\n      return _this7.props.modifySelections(_this7.props.selections.map(function(selection) {\n        if (selection === thisSelection) {\n          return {\n            directives: selection.directives,\n            kind: \"InlineFragment\",\n            typeCondition: {\n              kind: \"NamedType\",\n              name: { kind: \"Name\", value: _this7.props.implementingType.name }\n            },\n            selectionSet: {\n              kind: \"SelectionSet\",\n              selections\n            }\n          };\n        }\n        return selection;\n      }), options);\n    }, _temp5), _possibleConstructorReturn(_this7, _ret5);\n  }\n  _createClass(AbstractView2, [{\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      var _props5 = this.props, implementingType = _props5.implementingType, schema = _props5.schema, getDefaultFieldNames = _props5.getDefaultFieldNames, styleConfig = _props5.styleConfig;\n      var selection = this._getSelection();\n      var fields = implementingType.getFields();\n      var childSelections = selection ? selection.selectionSet ? selection.selectionSet.selections : [] : [];\n      return React.createElement(\"div\", { className: \"graphiql-explorer-\" + implementingType.name }, React.createElement(\"span\", {\n        style: { cursor: \"pointer\" },\n        onClick: selection ? this._removeFragment : this._addFragment\n      }, React.createElement(Checkbox, {\n        checked: !!selection,\n        styleConfig: this.props.styleConfig\n      }), React.createElement(\"span\", { style: { color: styleConfig.colors.atom } }, this.props.implementingType.name)), selection ? React.createElement(\"div\", { style: { marginLeft: 16 } }, Object.keys(fields).sort().map(function(fieldName) {\n        return React.createElement(FieldView, {\n          key: fieldName,\n          field: fields[fieldName],\n          selections: childSelections,\n          modifySelections: _this8._modifyChildSelections,\n          schema,\n          getDefaultFieldNames,\n          getDefaultScalarArgValue: _this8.props.getDefaultScalarArgValue,\n          makeDefaultArg: _this8.props.makeDefaultArg,\n          onRunOperation: _this8.props.onRunOperation,\n          onCommit: _this8.props.onCommit,\n          styleConfig: _this8.props.styleConfig,\n          definition: _this8.props.definition,\n          availableFragments: _this8.props.availableFragments\n        });\n      })) : null);\n    }\n  }]);\n  return AbstractView2;\n}(React.PureComponent);\nvar FragmentView = function(_React$PureComponent6) {\n  _inherits(FragmentView2, _React$PureComponent6);\n  function FragmentView2() {\n    var _ref11;\n    var _temp6, _this9, _ret6;\n    _classCallCheck(this, FragmentView2);\n    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    return _ret6 = (_temp6 = (_this9 = _possibleConstructorReturn(this, (_ref11 = FragmentView2.__proto__ || Object.getPrototypeOf(FragmentView2)).call.apply(_ref11, [this].concat(args))), _this9), _this9._addFragment = function() {\n      _this9.props.modifySelections([].concat(_toConsumableArray(_this9.props.selections), [_this9._previousSelection || {\n        kind: \"FragmentSpread\",\n        name: _this9.props.fragment.name\n      }]));\n    }, _this9._removeFragment = function() {\n      var thisSelection = _this9._getSelection();\n      _this9._previousSelection = thisSelection;\n      _this9.props.modifySelections(_this9.props.selections.filter(function(s) {\n        var isTargetSelection = s.kind === \"FragmentSpread\" && s.name.value === _this9.props.fragment.name.value;\n        return !isTargetSelection;\n      }));\n    }, _this9._getSelection = function() {\n      var selection = _this9.props.selections.find(function(selection2) {\n        return selection2.kind === \"FragmentSpread\" && selection2.name.value === _this9.props.fragment.name.value;\n      });\n      return selection;\n    }, _temp6), _possibleConstructorReturn(_this9, _ret6);\n  }\n  _createClass(FragmentView2, [{\n    key: \"render\",\n    value: function render() {\n      var styleConfig = this.props.styleConfig;\n      var selection = this._getSelection();\n      return React.createElement(\"div\", { className: \"graphiql-explorer-\" + this.props.fragment.name.value }, React.createElement(\"span\", {\n        style: { cursor: \"pointer\" },\n        onClick: selection ? this._removeFragment : this._addFragment\n      }, React.createElement(Checkbox, {\n        checked: !!selection,\n        styleConfig: this.props.styleConfig\n      }), React.createElement(\"span\", {\n        style: { color: styleConfig.colors.def },\n        className: \"graphiql-explorer-\" + this.props.fragment.name.value\n      }, this.props.fragment.name.value)));\n    }\n  }]);\n  return FragmentView2;\n}(React.PureComponent);\nfunction defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, fields) {\n  var nodes = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = void 0;\n  try {\n    for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _field = _step.value;\n      if ((0, _graphql.isRequiredInputField)(_field) || makeDefaultArg && makeDefaultArg(parentField, _field)) {\n        var fieldType = unwrapInputType(_field.type);\n        if ((0, _graphql.isInputObjectType)(fieldType)) {\n          (function() {\n            var fields2 = fieldType.getFields();\n            nodes.push({\n              kind: \"ObjectField\",\n              name: { kind: \"Name\", value: _field.name },\n              value: {\n                kind: \"ObjectValue\",\n                fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, Object.keys(fields2).map(function(k) {\n                  return fields2[k];\n                }))\n              }\n            });\n          })();\n        } else if ((0, _graphql.isLeafType)(fieldType)) {\n          nodes.push({\n            kind: \"ObjectField\",\n            name: { kind: \"Name\", value: _field.name },\n            value: getDefaultScalarArgValue(parentField, _field, fieldType)\n          });\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  return nodes;\n}\nfunction defaultArgs(getDefaultScalarArgValue, makeDefaultArg, field) {\n  var args = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = void 0;\n  try {\n    for (var _iterator2 = field.args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _arg = _step2.value;\n      if (isRequiredArgument(_arg) || makeDefaultArg && makeDefaultArg(field, _arg)) {\n        var argType = unwrapInputType(_arg.type);\n        if ((0, _graphql.isInputObjectType)(argType)) {\n          (function() {\n            var fields = argType.getFields();\n            args.push({\n              kind: \"Argument\",\n              name: { kind: \"Name\", value: _arg.name },\n              value: {\n                kind: \"ObjectValue\",\n                fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, field, Object.keys(fields).map(function(k) {\n                  return fields[k];\n                }))\n              }\n            });\n          })();\n        } else if ((0, _graphql.isLeafType)(argType)) {\n          args.push({\n            kind: \"Argument\",\n            name: { kind: \"Name\", value: _arg.name },\n            value: getDefaultScalarArgValue(field, _arg, argType)\n          });\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n  return args;\n}\nvar FieldView = function(_React$PureComponent7) {\n  _inherits(FieldView2, _React$PureComponent7);\n  function FieldView2() {\n    var _ref12;\n    var _temp7, _this10, _ret9;\n    _classCallCheck(this, FieldView2);\n    for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    return _ret9 = (_temp7 = (_this10 = _possibleConstructorReturn(this, (_ref12 = FieldView2.__proto__ || Object.getPrototypeOf(FieldView2)).call.apply(_ref12, [this].concat(args))), _this10), _this10.state = { displayFieldActions: false }, _this10._addAllFieldsToSelections = function(rawSubfields) {\n      var subFields = !!rawSubfields ? Object.keys(rawSubfields).map(function(fieldName) {\n        return {\n          kind: \"Field\",\n          name: { kind: \"Name\", value: fieldName },\n          arguments: []\n        };\n      }) : [];\n      var subSelectionSet = {\n        kind: \"SelectionSet\",\n        selections: subFields\n      };\n      var nextSelections = [].concat(_toConsumableArray(_this10.props.selections.filter(function(selection) {\n        if (selection.kind === \"InlineFragment\") {\n          return true;\n        } else {\n          return selection.name.value !== _this10.props.field.name;\n        }\n      })), [{\n        kind: \"Field\",\n        name: { kind: \"Name\", value: _this10.props.field.name },\n        arguments: defaultArgs(_this10.props.getDefaultScalarArgValue, _this10.props.makeDefaultArg, _this10.props.field),\n        selectionSet: subSelectionSet\n      }]);\n      _this10.props.modifySelections(nextSelections);\n    }, _this10._addFieldToSelections = function(rawSubfields) {\n      var nextSelections = [].concat(_toConsumableArray(_this10.props.selections), [_this10._previousSelection || {\n        kind: \"Field\",\n        name: { kind: \"Name\", value: _this10.props.field.name },\n        arguments: defaultArgs(_this10.props.getDefaultScalarArgValue, _this10.props.makeDefaultArg, _this10.props.field)\n      }]);\n      _this10.props.modifySelections(nextSelections);\n    }, _this10._handleUpdateSelections = function(event) {\n      var selection = _this10._getSelection();\n      if (selection && !event.altKey) {\n        _this10._removeFieldFromSelections();\n      } else {\n        var fieldType = (0, _graphql.getNamedType)(_this10.props.field.type);\n        var rawSubfields = (0, _graphql.isObjectType)(fieldType) && fieldType.getFields();\n        var shouldSelectAllSubfields = !!rawSubfields && event.altKey;\n        shouldSelectAllSubfields ? _this10._addAllFieldsToSelections(rawSubfields) : _this10._addFieldToSelections(rawSubfields);\n      }\n    }, _this10._removeFieldFromSelections = function() {\n      var previousSelection = _this10._getSelection();\n      _this10._previousSelection = previousSelection;\n      _this10.props.modifySelections(_this10.props.selections.filter(function(selection) {\n        return selection !== previousSelection;\n      }));\n    }, _this10._getSelection = function() {\n      var selection = _this10.props.selections.find(function(selection2) {\n        return selection2.kind === \"Field\" && _this10.props.field.name === selection2.name.value;\n      });\n      if (!selection) {\n        return null;\n      }\n      if (selection.kind === \"Field\") {\n        return selection;\n      }\n    }, _this10._setArguments = function(argumentNodes, options) {\n      var selection = _this10._getSelection();\n      if (!selection) {\n        console.error(\"Missing selection when setting arguments\", argumentNodes);\n        return;\n      }\n      return _this10.props.modifySelections(_this10.props.selections.map(function(s) {\n        return s === selection ? {\n          alias: selection.alias,\n          arguments: argumentNodes,\n          directives: selection.directives,\n          kind: \"Field\",\n          name: selection.name,\n          selectionSet: selection.selectionSet\n        } : s;\n      }), options);\n    }, _this10._modifyChildSelections = function(selections, options) {\n      return _this10.props.modifySelections(_this10.props.selections.map(function(selection) {\n        if (selection.kind === \"Field\" && _this10.props.field.name === selection.name.value) {\n          if (selection.kind !== \"Field\") {\n            throw new Error(\"invalid selection\");\n          }\n          return {\n            alias: selection.alias,\n            arguments: selection.arguments,\n            directives: selection.directives,\n            kind: \"Field\",\n            name: selection.name,\n            selectionSet: {\n              kind: \"SelectionSet\",\n              selections\n            }\n          };\n        }\n        return selection;\n      }), options);\n    }, _temp7), _possibleConstructorReturn(_this10, _ret9);\n  }\n  _createClass(FieldView2, [{\n    key: \"render\",\n    value: function render() {\n      var _this11 = this;\n      var _props6 = this.props, field = _props6.field, schema = _props6.schema, getDefaultFieldNames = _props6.getDefaultFieldNames, styleConfig = _props6.styleConfig;\n      var selection = this._getSelection();\n      var type2 = unwrapOutputType(field.type);\n      var args = field.args.sort(function(a, b) {\n        return a.name.localeCompare(b.name);\n      });\n      var className = \"graphiql-explorer-node graphiql-explorer-\" + field.name;\n      if (field.isDeprecated) {\n        className += \" graphiql-explorer-deprecated\";\n      }\n      var applicableFragments = (0, _graphql.isObjectType)(type2) || (0, _graphql.isInterfaceType)(type2) || (0, _graphql.isUnionType)(type2) ? this.props.availableFragments && this.props.availableFragments[type2.name] : null;\n      var node = React.createElement(\"div\", { className }, React.createElement(\"span\", {\n        title: field.description,\n        style: {\n          cursor: \"pointer\",\n          display: \"inline-flex\",\n          alignItems: \"center\",\n          minHeight: \"16px\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\"\n        },\n        \"data-field-name\": field.name,\n        \"data-field-type\": type2.name,\n        onClick: this._handleUpdateSelections,\n        onMouseEnter: function onMouseEnter() {\n          var containsMeaningfulSubselection = (0, _graphql.isObjectType)(type2) && selection && selection.selectionSet && selection.selectionSet.selections.filter(function(selection2) {\n            return selection2.kind !== \"FragmentSpread\";\n          }).length > 0;\n          if (containsMeaningfulSubselection) {\n            _this11.setState({ displayFieldActions: true });\n          }\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this11.setState({ displayFieldActions: false });\n        }\n      }, (0, _graphql.isObjectType)(type2) ? React.createElement(\"span\", null, !!selection ? this.props.styleConfig.arrowOpen : this.props.styleConfig.arrowClosed) : null, (0, _graphql.isObjectType)(type2) ? null : React.createElement(Checkbox, {\n        checked: !!selection,\n        styleConfig: this.props.styleConfig\n      }), React.createElement(\"span\", {\n        style: { color: styleConfig.colors.property },\n        className: \"graphiql-explorer-field-view\"\n      }, field.name), !this.state.displayFieldActions ? null : React.createElement(\"button\", {\n        type: \"submit\",\n        className: \"toolbar-button\",\n        title: \"Extract selections into a new reusable fragment\",\n        onClick: function onClick(event) {\n          event.preventDefault();\n          event.stopPropagation();\n          var typeName = type2.name;\n          var newFragmentName = typeName + \"Fragment\";\n          var conflictingNameCount = (applicableFragments || []).filter(function(fragment) {\n            return fragment.name.value.startsWith(newFragmentName);\n          }).length;\n          if (conflictingNameCount > 0) {\n            newFragmentName = \"\" + newFragmentName + conflictingNameCount;\n          }\n          var childSelections2 = selection ? selection.selectionSet ? selection.selectionSet.selections : [] : [];\n          var nextSelections = [{\n            kind: \"FragmentSpread\",\n            name: {\n              kind: \"Name\",\n              value: newFragmentName\n            },\n            directives: []\n          }];\n          var newFragmentDefinition = {\n            kind: \"FragmentDefinition\",\n            name: {\n              kind: \"Name\",\n              value: newFragmentName\n            },\n            typeCondition: {\n              kind: \"NamedType\",\n              name: {\n                kind: \"Name\",\n                value: type2.name\n              }\n            },\n            directives: [],\n            selectionSet: {\n              kind: \"SelectionSet\",\n              selections: childSelections2\n            }\n          };\n          var newDoc = _this11._modifyChildSelections(nextSelections, false);\n          if (newDoc) {\n            var newDocWithFragment = _extends({}, newDoc, {\n              definitions: [].concat(_toConsumableArray(newDoc.definitions), [newFragmentDefinition])\n            });\n            _this11.props.onCommit(newDocWithFragment);\n          } else {\n            console.warn(\"Unable to complete extractFragment operation\");\n          }\n        },\n        style: _extends({}, styleConfig.styles.actionButtonStyle)\n      }, React.createElement(\"span\", null, \"\\u2026\"))), selection && args.length ? React.createElement(\"div\", {\n        style: { marginLeft: 16 },\n        className: \"graphiql-explorer-graphql-arguments\"\n      }, args.map(function(arg) {\n        return React.createElement(ArgView, {\n          key: arg.name,\n          parentField: field,\n          arg,\n          selection,\n          modifyArguments: _this11._setArguments,\n          getDefaultScalarArgValue: _this11.props.getDefaultScalarArgValue,\n          makeDefaultArg: _this11.props.makeDefaultArg,\n          onRunOperation: _this11.props.onRunOperation,\n          styleConfig: _this11.props.styleConfig,\n          onCommit: _this11.props.onCommit,\n          definition: _this11.props.definition\n        });\n      })) : null);\n      if (selection && ((0, _graphql.isObjectType)(type2) || (0, _graphql.isInterfaceType)(type2) || (0, _graphql.isUnionType)(type2))) {\n        var _fields4 = (0, _graphql.isUnionType)(type2) ? {} : type2.getFields();\n        var childSelections = selection ? selection.selectionSet ? selection.selectionSet.selections : [] : [];\n        return React.createElement(\"div\", { className: \"graphiql-explorer-\" + field.name }, node, React.createElement(\"div\", { style: { marginLeft: 16 } }, !!applicableFragments ? applicableFragments.map(function(fragment) {\n          var type3 = schema.getType(fragment.typeCondition.name.value);\n          var fragmentName = fragment.name.value;\n          return !type3 ? null : React.createElement(FragmentView, {\n            key: fragmentName,\n            fragment,\n            selections: childSelections,\n            modifySelections: _this11._modifyChildSelections,\n            schema,\n            styleConfig: _this11.props.styleConfig,\n            onCommit: _this11.props.onCommit\n          });\n        }) : null, Object.keys(_fields4).sort().map(function(fieldName) {\n          return React.createElement(FieldView2, {\n            key: fieldName,\n            field: _fields4[fieldName],\n            selections: childSelections,\n            modifySelections: _this11._modifyChildSelections,\n            schema,\n            getDefaultFieldNames,\n            getDefaultScalarArgValue: _this11.props.getDefaultScalarArgValue,\n            makeDefaultArg: _this11.props.makeDefaultArg,\n            onRunOperation: _this11.props.onRunOperation,\n            styleConfig: _this11.props.styleConfig,\n            onCommit: _this11.props.onCommit,\n            definition: _this11.props.definition,\n            availableFragments: _this11.props.availableFragments\n          });\n        }), (0, _graphql.isInterfaceType)(type2) || (0, _graphql.isUnionType)(type2) ? schema.getPossibleTypes(type2).map(function(type3) {\n          return React.createElement(AbstractView, {\n            key: type3.name,\n            implementingType: type3,\n            selections: childSelections,\n            modifySelections: _this11._modifyChildSelections,\n            schema,\n            getDefaultFieldNames,\n            getDefaultScalarArgValue: _this11.props.getDefaultScalarArgValue,\n            makeDefaultArg: _this11.props.makeDefaultArg,\n            onRunOperation: _this11.props.onRunOperation,\n            styleConfig: _this11.props.styleConfig,\n            onCommit: _this11.props.onCommit,\n            definition: _this11.props.definition\n          });\n        }) : null));\n      }\n      return node;\n    }\n  }]);\n  return FieldView2;\n}(React.PureComponent);\nfunction parseQuery(text3) {\n  try {\n    if (!text3.trim()) {\n      return null;\n    }\n    return (0, _graphql.parse)(text3, { noLocation: true });\n  } catch (e) {\n    return new Error(e);\n  }\n}\nvar DEFAULT_OPERATION = {\n  kind: \"OperationDefinition\",\n  operation: \"query\",\n  variableDefinitions: [],\n  name: { kind: \"Name\", value: \"MyQuery\" },\n  directives: [],\n  selectionSet: {\n    kind: \"SelectionSet\",\n    selections: []\n  }\n};\nvar DEFAULT_DOCUMENT = {\n  kind: \"Document\",\n  definitions: [DEFAULT_OPERATION]\n};\nvar parseQueryMemoize = null;\nfunction memoizeParseQuery(query) {\n  if (parseQueryMemoize && parseQueryMemoize[0] === query) {\n    return parseQueryMemoize[1];\n  } else {\n    var result2 = parseQuery(query);\n    if (!result2) {\n      return DEFAULT_DOCUMENT;\n    } else if (result2 instanceof Error) {\n      if (parseQueryMemoize) {\n        return parseQueryMemoize[1];\n      } else {\n        return DEFAULT_DOCUMENT;\n      }\n    } else {\n      parseQueryMemoize = [query, result2];\n      return result2;\n    }\n  }\n}\nvar defaultStyles = {\n  buttonStyle: {\n    fontSize: \"1.2em\",\n    padding: \"0px\",\n    backgroundColor: \"white\",\n    border: \"none\",\n    margin: \"5px 0px\",\n    height: \"40px\",\n    width: \"100%\",\n    display: \"block\",\n    maxWidth: \"none\"\n  },\n  actionButtonStyle: {\n    padding: \"0px\",\n    backgroundColor: \"white\",\n    border: \"none\",\n    margin: \"0px\",\n    maxWidth: \"none\",\n    height: \"15px\",\n    width: \"15px\",\n    display: \"inline-block\",\n    fontSize: \"smaller\"\n  },\n  explorerActionsStyle: {\n    margin: \"4px -8px -8px\",\n    paddingLeft: \"8px\",\n    bottom: \"0px\",\n    width: \"100%\",\n    textAlign: \"center\",\n    background: \"none\",\n    borderTop: \"none\",\n    borderBottom: \"none\"\n  }\n};\nvar RootView = function(_React$PureComponent8) {\n  _inherits(RootView2, _React$PureComponent8);\n  function RootView2() {\n    var _ref13;\n    var _temp8, _this12, _ret10;\n    _classCallCheck(this, RootView2);\n    for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    return _ret10 = (_temp8 = (_this12 = _possibleConstructorReturn(this, (_ref13 = RootView2.__proto__ || Object.getPrototypeOf(RootView2)).call.apply(_ref13, [this].concat(args))), _this12), _this12.state = { newOperationType: \"query\", displayTitleActions: false }, _this12._modifySelections = function(selections, options) {\n      var operationDef = _this12.props.definition;\n      if (operationDef.selectionSet.selections.length === 0 && _this12._previousOperationDef) {\n        operationDef = _this12._previousOperationDef;\n      }\n      var newOperationDef = void 0;\n      if (operationDef.kind === \"FragmentDefinition\") {\n        newOperationDef = _extends({}, operationDef, {\n          selectionSet: _extends({}, operationDef.selectionSet, {\n            selections\n          })\n        });\n      } else if (operationDef.kind === \"OperationDefinition\") {\n        var cleanedSelections = selections.filter(function(selection) {\n          return !(selection.kind === \"Field\" && selection.name.value === \"__typename\");\n        });\n        if (cleanedSelections.length === 0) {\n          cleanedSelections = [{\n            kind: \"Field\",\n            name: {\n              kind: \"Name\",\n              value: \"__typename ## Placeholder value\"\n            }\n          }];\n        }\n        newOperationDef = _extends({}, operationDef, {\n          selectionSet: _extends({}, operationDef.selectionSet, {\n            selections: cleanedSelections\n          })\n        });\n      }\n      return _this12.props.onEdit(newOperationDef, options);\n    }, _this12._onOperationRename = function(event) {\n      return _this12.props.onOperationRename(event.target.value);\n    }, _this12._handlePotentialRun = function(event) {\n      if (isRunShortcut(event) && canRunOperation(_this12.props.definition.kind)) {\n        _this12.props.onRunOperation(_this12.props.name);\n      }\n    }, _this12._rootViewElId = function() {\n      var _this12$props = _this12.props, operationType = _this12$props.operationType, name2 = _this12$props.name;\n      var rootViewElId = operationType + \"-\" + (name2 || \"unknown\");\n      return rootViewElId;\n    }, _temp8), _possibleConstructorReturn(_this12, _ret10);\n  }\n  _createClass(RootView2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var rootViewElId = this._rootViewElId();\n      this.props.onMount(rootViewElId);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this13 = this;\n      var _props7 = this.props, operationType = _props7.operationType, definition = _props7.definition, schema = _props7.schema, getDefaultFieldNames = _props7.getDefaultFieldNames, styleConfig = _props7.styleConfig;\n      var rootViewElId = this._rootViewElId();\n      var fields = this.props.fields || {};\n      var operationDef = definition;\n      var selections = operationDef.selectionSet.selections;\n      var operationDisplayName = this.props.name || capitalize(operationType) + \" Name\";\n      return React.createElement(\"div\", {\n        id: rootViewElId,\n        tabIndex: \"0\",\n        onKeyDown: this._handlePotentialRun,\n        style: {\n          borderBottom: this.props.isLast ? \"none\" : \"1px solid #d6d6d6\",\n          marginBottom: \"0em\",\n          paddingBottom: \"1em\"\n        }\n      }, React.createElement(\"div\", {\n        style: { color: styleConfig.colors.keyword, paddingBottom: 4 },\n        className: \"graphiql-operation-title-bar\",\n        onMouseEnter: function onMouseEnter() {\n          return _this13.setState({ displayTitleActions: true });\n        },\n        onMouseLeave: function onMouseLeave() {\n          return _this13.setState({ displayTitleActions: false });\n        }\n      }, operationType, \" \", React.createElement(\"span\", { style: { color: styleConfig.colors.def } }, React.createElement(\"input\", {\n        style: {\n          color: styleConfig.colors.def,\n          border: \"none\",\n          borderBottom: \"1px solid #888\",\n          outline: \"none\",\n          width: Math.max(4, operationDisplayName.length) + \"ch\"\n        },\n        autoComplete: \"false\",\n        placeholder: capitalize(operationType) + \" Name\",\n        value: this.props.name,\n        onKeyDown: this._handlePotentialRun,\n        onChange: this._onOperationRename\n      })), !!this.props.onTypeName ? React.createElement(\"span\", null, React.createElement(\"br\", null), \"on \" + this.props.onTypeName) : \"\", !!this.state.displayTitleActions ? React.createElement(React.Fragment, null, React.createElement(\"button\", {\n        type: \"submit\",\n        className: \"toolbar-button\",\n        onClick: function onClick() {\n          return _this13.props.onOperationDestroy();\n        },\n        style: _extends({}, styleConfig.styles.actionButtonStyle)\n      }, React.createElement(\"span\", null, \"\\u2715\")), React.createElement(\"button\", {\n        type: \"submit\",\n        className: \"toolbar-button\",\n        onClick: function onClick() {\n          return _this13.props.onOperationClone();\n        },\n        style: _extends({}, styleConfig.styles.actionButtonStyle)\n      }, React.createElement(\"span\", null, \"\\u2398\"))) : \"\"), Object.keys(fields).sort().map(function(fieldName) {\n        return React.createElement(FieldView, {\n          key: fieldName,\n          field: fields[fieldName],\n          selections,\n          modifySelections: _this13._modifySelections,\n          schema,\n          getDefaultFieldNames,\n          getDefaultScalarArgValue: _this13.props.getDefaultScalarArgValue,\n          makeDefaultArg: _this13.props.makeDefaultArg,\n          onRunOperation: _this13.props.onRunOperation,\n          styleConfig: _this13.props.styleConfig,\n          onCommit: _this13.props.onCommit,\n          definition: _this13.props.definition,\n          availableFragments: _this13.props.availableFragments\n        });\n      }));\n    }\n  }]);\n  return RootView2;\n}(React.PureComponent);\nfunction Attribution() {\n  return React.createElement(\"div\", {\n    style: {\n      fontFamily: \"sans-serif\",\n      display: \"flex\",\n      flexDirection: \"column\",\n      alignItems: \"center\",\n      margin: \"1em\",\n      marginTop: 0,\n      flexGrow: 1,\n      justifyContent: \"flex-end\"\n    }\n  }, React.createElement(\"div\", {\n    style: {\n      borderTop: \"1px solid #d6d6d6\",\n      paddingTop: \"1em\",\n      width: \"100%\",\n      textAlign: \"center\"\n    }\n  }, \"GraphiQL Explorer by \", React.createElement(\"a\", { href: \"https://www.onegraph.com\" }, \"OneGraph\")), React.createElement(\"div\", null, \"Contribute on\", \" \", React.createElement(\"a\", { href: \"https://github.com/OneGraph/graphiql-explorer\" }, \"GitHub\")));\n}\nvar Explorer = function(_React$PureComponent9) {\n  _inherits(Explorer2, _React$PureComponent9);\n  function Explorer2() {\n    var _ref14;\n    var _temp9, _this14, _ret11;\n    _classCallCheck(this, Explorer2);\n    for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    return _ret11 = (_temp9 = (_this14 = _possibleConstructorReturn(this, (_ref14 = Explorer2.__proto__ || Object.getPrototypeOf(Explorer2)).call.apply(_ref14, [this].concat(args))), _this14), _this14.state = {\n      newOperationType: \"query\",\n      operation: null,\n      operationToScrollTo: null\n    }, _this14._resetScroll = function() {\n      var container = _this14._ref;\n      if (container) {\n        container.scrollLeft = 0;\n      }\n    }, _this14._onEdit = function(query) {\n      return _this14.props.onEdit(query);\n    }, _this14._setAddOperationType = function(value) {\n      _this14.setState({ newOperationType: value });\n    }, _this14._handleRootViewMount = function(rootViewElId) {\n      if (!!_this14.state.operationToScrollTo && _this14.state.operationToScrollTo === rootViewElId) {\n        var selector = \".graphiql-explorer-root #\" + rootViewElId;\n        var el2 = document.querySelector(selector);\n        el2 && el2.scrollIntoView();\n      }\n    }, _temp9), _possibleConstructorReturn(_this14, _ret11);\n  }\n  _createClass(Explorer2, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._resetScroll();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this15 = this;\n      var _props8 = this.props, schema = _props8.schema, query = _props8.query, makeDefaultArg = _props8.makeDefaultArg;\n      if (!schema) {\n        return React.createElement(\"div\", { style: { fontFamily: \"sans-serif\" }, className: \"error-container\" }, \"No Schema Available\");\n      }\n      var styleConfig = {\n        colors: this.props.colors || defaultColors,\n        checkboxChecked: this.props.checkboxChecked || defaultCheckboxChecked,\n        checkboxUnchecked: this.props.checkboxUnchecked || defaultCheckboxUnchecked,\n        arrowClosed: this.props.arrowClosed || defaultArrowClosed,\n        arrowOpen: this.props.arrowOpen || defaultArrowOpen,\n        styles: this.props.styles ? _extends({}, defaultStyles, this.props.styles) : defaultStyles\n      };\n      var queryType = schema.getQueryType();\n      var mutationType = schema.getMutationType();\n      var subscriptionType = schema.getSubscriptionType();\n      if (!queryType && !mutationType && !subscriptionType) {\n        return React.createElement(\"div\", null, \"Missing query type\");\n      }\n      var queryFields = queryType && queryType.getFields();\n      var mutationFields = mutationType && mutationType.getFields();\n      var subscriptionFields = subscriptionType && subscriptionType.getFields();\n      var parsedQuery = memoizeParseQuery(query);\n      var getDefaultFieldNames = this.props.getDefaultFieldNames || defaultGetDefaultFieldNames;\n      var getDefaultScalarArgValue = this.props.getDefaultScalarArgValue || defaultGetDefaultScalarArgValue;\n      var definitions = parsedQuery.definitions;\n      var _relevantOperations = definitions.map(function(definition) {\n        if (definition.kind === \"FragmentDefinition\") {\n          return definition;\n        } else if (definition.kind === \"OperationDefinition\") {\n          return definition;\n        } else {\n          return null;\n        }\n      }).filter(Boolean);\n      var relevantOperations = _relevantOperations.length === 0 ? DEFAULT_DOCUMENT.definitions : _relevantOperations;\n      var renameOperation = function renameOperation2(targetOperation, name2) {\n        var newName = name2 == null || name2 === \"\" ? null : { kind: \"Name\", value: name2, loc: void 0 };\n        var newOperation = _extends({}, targetOperation, { name: newName });\n        var existingDefs = parsedQuery.definitions;\n        var newDefinitions = existingDefs.map(function(existingOperation) {\n          if (targetOperation === existingOperation) {\n            return newOperation;\n          } else {\n            return existingOperation;\n          }\n        });\n        return _extends({}, parsedQuery, {\n          definitions: newDefinitions\n        });\n      };\n      var cloneOperation = function cloneOperation2(targetOperation) {\n        var kind2 = void 0;\n        if (targetOperation.kind === \"FragmentDefinition\") {\n          kind2 = \"fragment\";\n        } else {\n          kind2 = targetOperation.operation;\n        }\n        var newOperationName = (targetOperation.name && targetOperation.name.value || \"\") + \"Copy\";\n        var newName = {\n          kind: \"Name\",\n          value: newOperationName,\n          loc: void 0\n        };\n        var newOperation = _extends({}, targetOperation, { name: newName });\n        var existingDefs = parsedQuery.definitions;\n        var newDefinitions = [].concat(_toConsumableArray(existingDefs), [newOperation]);\n        _this15.setState({ operationToScrollTo: kind2 + \"-\" + newOperationName });\n        return _extends({}, parsedQuery, {\n          definitions: newDefinitions\n        });\n      };\n      var destroyOperation = function destroyOperation2(targetOperation) {\n        var existingDefs = parsedQuery.definitions;\n        var newDefinitions = existingDefs.filter(function(existingOperation) {\n          if (targetOperation === existingOperation) {\n            return false;\n          } else {\n            return true;\n          }\n        });\n        return _extends({}, parsedQuery, {\n          definitions: newDefinitions\n        });\n      };\n      var addOperation = function addOperation2(kind2) {\n        var existingDefs = parsedQuery.definitions;\n        var viewingDefaultOperation = parsedQuery.definitions.length === 1 && parsedQuery.definitions[0] === DEFAULT_DOCUMENT.definitions[0];\n        var MySiblingDefs = viewingDefaultOperation ? [] : existingDefs.filter(function(def) {\n          if (def.kind === \"OperationDefinition\") {\n            return def.operation === kind2;\n          } else {\n            return false;\n          }\n        });\n        var newOperationName = \"My\" + capitalize(kind2) + (MySiblingDefs.length === 0 ? \"\" : MySiblingDefs.length + 1);\n        var firstFieldName = \"__typename # Placeholder value\";\n        var selectionSet = {\n          kind: \"SelectionSet\",\n          selections: [{\n            kind: \"Field\",\n            name: {\n              kind: \"Name\",\n              value: firstFieldName,\n              loc: null\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n            loc: null\n          }],\n          loc: null\n        };\n        var newDefinition = {\n          kind: \"OperationDefinition\",\n          operation: kind2,\n          name: { kind: \"Name\", value: newOperationName },\n          variableDefinitions: [],\n          directives: [],\n          selectionSet,\n          loc: null\n        };\n        var newDefinitions = viewingDefaultOperation ? [newDefinition] : [].concat(_toConsumableArray(parsedQuery.definitions), [newDefinition]);\n        var newOperationDef = _extends({}, parsedQuery, {\n          definitions: newDefinitions\n        });\n        _this15.setState({ operationToScrollTo: kind2 + \"-\" + newOperationName });\n        _this15.props.onEdit((0, _graphql.print)(newOperationDef));\n      };\n      var actionsOptions = [!!queryFields ? React.createElement(\"option\", {\n        key: \"query\",\n        className: \"toolbar-button\",\n        style: styleConfig.styles.buttonStyle,\n        type: \"link\",\n        value: \"query\"\n      }, \"Query\") : null, !!mutationFields ? React.createElement(\"option\", {\n        key: \"mutation\",\n        className: \"toolbar-button\",\n        style: styleConfig.styles.buttonStyle,\n        type: \"link\",\n        value: \"mutation\"\n      }, \"Mutation\") : null, !!subscriptionFields ? React.createElement(\"option\", {\n        key: \"subscription\",\n        className: \"toolbar-button\",\n        style: styleConfig.styles.buttonStyle,\n        type: \"link\",\n        value: \"subscription\"\n      }, \"Subscription\") : null].filter(Boolean);\n      var actionsEl = actionsOptions.length === 0 || this.props.hideActions ? null : React.createElement(\"div\", {\n        style: {\n          minHeight: \"50px\",\n          maxHeight: \"50px\",\n          overflow: \"none\"\n        }\n      }, React.createElement(\"form\", {\n        className: \"variable-editor-title graphiql-explorer-actions\",\n        style: _extends({}, styleConfig.styles.explorerActionsStyle, {\n          display: \"flex\",\n          flexDirection: \"row\",\n          alignItems: \"center\",\n          borderTop: \"1px solid rgb(214, 214, 214)\"\n        }),\n        onSubmit: function onSubmit(event) {\n          return event.preventDefault();\n        }\n      }, React.createElement(\"span\", {\n        style: {\n          display: \"inline-block\",\n          flexGrow: \"0\",\n          textAlign: \"right\"\n        }\n      }, \"Add new\", \" \"), React.createElement(\"select\", {\n        onChange: function onChange(event) {\n          return _this15._setAddOperationType(event.target.value);\n        },\n        value: this.state.newOperationType,\n        style: { flexGrow: \"2\" }\n      }, actionsOptions), React.createElement(\"button\", {\n        type: \"submit\",\n        className: \"toolbar-button\",\n        onClick: function onClick() {\n          return _this15.state.newOperationType ? addOperation(_this15.state.newOperationType) : null;\n        },\n        style: _extends({}, styleConfig.styles.buttonStyle, {\n          height: \"22px\",\n          width: \"22px\"\n        })\n      }, React.createElement(\"span\", null, \"+\"))));\n      var externalFragments = this.props.externalFragments && this.props.externalFragments.reduce(function(acc, fragment) {\n        if (fragment.kind === \"FragmentDefinition\") {\n          var fragmentTypeName = fragment.typeCondition.name.value;\n          var existingFragmentsForType = acc[fragmentTypeName] || [];\n          var newFragmentsForType = [].concat(_toConsumableArray(existingFragmentsForType), [fragment]).sort(function(a, b) {\n            return a.name.value.localeCompare(b.name.value);\n          });\n          return _extends({}, acc, _defineProperty({}, fragmentTypeName, newFragmentsForType));\n        }\n        return acc;\n      }, {});\n      var documentFragments = relevantOperations.reduce(function(acc, operation) {\n        if (operation.kind === \"FragmentDefinition\") {\n          var fragmentTypeName = operation.typeCondition.name.value;\n          var existingFragmentsForType = acc[fragmentTypeName] || [];\n          var newFragmentsForType = [].concat(_toConsumableArray(existingFragmentsForType), [operation]).sort(function(a, b) {\n            return a.name.value.localeCompare(b.name.value);\n          });\n          return _extends({}, acc, _defineProperty({}, fragmentTypeName, newFragmentsForType));\n        }\n        return acc;\n      }, {});\n      var availableFragments = _extends({}, documentFragments, externalFragments);\n      var attribution = this.props.showAttribution ? React.createElement(Attribution, null) : null;\n      return React.createElement(\"div\", {\n        ref: function ref(_ref15) {\n          _this15._ref = _ref15;\n        },\n        style: {\n          fontSize: 12,\n          textOverflow: \"ellipsis\",\n          whiteSpace: \"nowrap\",\n          margin: 0,\n          padding: 8,\n          fontFamily: 'Consolas, Inconsolata, \"Droid Sans Mono\", Monaco, monospace',\n          display: \"flex\",\n          flexDirection: \"column\",\n          height: \"100%\"\n        },\n        className: \"graphiql-explorer-root\"\n      }, React.createElement(\"div\", {\n        style: {\n          flexGrow: \"1\",\n          overflow: \"scroll\"\n        }\n      }, relevantOperations.map(function(operation, index) {\n        var operationName = operation && operation.name && operation.name.value;\n        var operationType = operation.kind === \"FragmentDefinition\" ? \"fragment\" : operation && operation.operation || \"query\";\n        var onOperationRename = function onOperationRename2(newName) {\n          var newOperationDef = renameOperation(operation, newName);\n          _this15.props.onEdit((0, _graphql.print)(newOperationDef));\n        };\n        var onOperationClone = function onOperationClone2() {\n          var newOperationDef = cloneOperation(operation);\n          _this15.props.onEdit((0, _graphql.print)(newOperationDef));\n        };\n        var onOperationDestroy = function onOperationDestroy2() {\n          var newOperationDef = destroyOperation(operation);\n          _this15.props.onEdit((0, _graphql.print)(newOperationDef));\n        };\n        var fragmentType = operation.kind === \"FragmentDefinition\" && operation.typeCondition.kind === \"NamedType\" && schema.getType(operation.typeCondition.name.value);\n        var fragmentFields = fragmentType instanceof _graphql.GraphQLObjectType ? fragmentType.getFields() : null;\n        var fields = operationType === \"query\" ? queryFields : operationType === \"mutation\" ? mutationFields : operationType === \"subscription\" ? subscriptionFields : operation.kind === \"FragmentDefinition\" ? fragmentFields : null;\n        var fragmentTypeName = operation.kind === \"FragmentDefinition\" ? operation.typeCondition.name.value : null;\n        var onCommit = function onCommit2(parsedDocument) {\n          var textualNewDocument = (0, _graphql.print)(parsedDocument);\n          _this15.props.onEdit(textualNewDocument);\n        };\n        return React.createElement(RootView, {\n          key: index,\n          isLast: index === relevantOperations.length - 1,\n          fields,\n          operationType,\n          name: operationName,\n          definition: operation,\n          onOperationRename,\n          onOperationDestroy,\n          onOperationClone,\n          onTypeName: fragmentTypeName,\n          onMount: _this15._handleRootViewMount,\n          onCommit,\n          onEdit: function onEdit(newDefinition, options) {\n            var commit = void 0;\n            if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) === \"object\" && typeof options.commit !== \"undefined\") {\n              commit = options.commit;\n            } else {\n              commit = true;\n            }\n            if (!!newDefinition) {\n              var newQuery = _extends({}, parsedQuery, {\n                definitions: parsedQuery.definitions.map(function(existingDefinition) {\n                  return existingDefinition === operation ? newDefinition : existingDefinition;\n                })\n              });\n              if (commit) {\n                onCommit(newQuery);\n                return newQuery;\n              } else {\n                return newQuery;\n              }\n            } else {\n              return parsedQuery;\n            }\n          },\n          schema,\n          getDefaultFieldNames,\n          getDefaultScalarArgValue,\n          makeDefaultArg,\n          onRunOperation: function onRunOperation() {\n            if (!!_this15.props.onRunOperation) {\n              _this15.props.onRunOperation(operationName);\n            }\n          },\n          styleConfig,\n          availableFragments\n        });\n      }), attribution), actionsEl);\n    }\n  }]);\n  return Explorer2;\n}(React.PureComponent);\nExplorer.defaultProps = {\n  getDefaultFieldNames: defaultGetDefaultFieldNames,\n  getDefaultScalarArgValue: defaultGetDefaultScalarArgValue\n};\nvar ErrorBoundary = function(_React$Component) {\n  _inherits(ErrorBoundary2, _React$Component);\n  function ErrorBoundary2() {\n    var _ref16;\n    var _temp10, _this16, _ret12;\n    _classCallCheck(this, ErrorBoundary2);\n    for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    return _ret12 = (_temp10 = (_this16 = _possibleConstructorReturn(this, (_ref16 = ErrorBoundary2.__proto__ || Object.getPrototypeOf(ErrorBoundary2)).call.apply(_ref16, [this].concat(args))), _this16), _this16.state = { hasError: false, error: null, errorInfo: null }, _temp10), _possibleConstructorReturn(_this16, _ret12);\n  }\n  _createClass(ErrorBoundary2, [{\n    key: \"componentDidCatch\",\n    value: function componentDidCatch(error2, errorInfo) {\n      this.setState({ hasError: true, error: error2, errorInfo });\n      console.error(\"Error in component\", error2, errorInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (this.state.hasError) {\n        return React.createElement(\"div\", { style: { padding: 18, fontFamily: \"sans-serif\" } }, React.createElement(\"div\", null, \"Something went wrong\"), React.createElement(\"details\", { style: { whiteSpace: \"pre-wrap\" } }, this.state.error ? this.state.error.toString() : null, React.createElement(\"br\", null), this.state.errorInfo ? this.state.errorInfo.componentStack : null));\n      }\n      return this.props.children;\n    }\n  }]);\n  return ErrorBoundary2;\n}(React.Component);\nvar ExplorerWrapper = function(_React$PureComponent10) {\n  _inherits(ExplorerWrapper2, _React$PureComponent10);\n  function ExplorerWrapper2() {\n    _classCallCheck(this, ExplorerWrapper2);\n    return _possibleConstructorReturn(this, (ExplorerWrapper2.__proto__ || Object.getPrototypeOf(ExplorerWrapper2)).apply(this, arguments));\n  }\n  _createClass(ExplorerWrapper2, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        className: \"docExplorerWrap\",\n        style: {\n          height: \"100%\",\n          width: this.props.width,\n          minWidth: this.props.width,\n          zIndex: 7,\n          display: this.props.explorerIsOpen ? \"flex\" : \"none\",\n          flexDirection: \"column\",\n          overflow: \"hidden\"\n        }\n      }, React.createElement(\"section\", {\n        className: \"doc-explorer\"\n      }, React.createElement(\"div\", { className: \"doc-explorer-title-bar\" }, React.createElement(\"div\", { className: \"doc-explorer-title\" }, this.props.title), React.createElement(\"div\", { className: \"doc-explorer-rhs\" }, React.createElement(\"div\", {\n        className: \"docExplorerHide\",\n        onClick: this.props.onToggleExplorer\n      }, \"\\u2715\"))), React.createElement(\"div\", {\n        className: \"doc-explorer-contents\",\n        style: {\n          padding: \"0px\",\n          overflowY: \"unset\"\n        }\n      }, React.createElement(ErrorBoundary, null, React.createElement(Explorer, this.props)))));\n    }\n  }]);\n  return ExplorerWrapper2;\n}(React.PureComponent);\nExplorerWrapper.defaultValue = defaultValue;\nExplorerWrapper.defaultProps = {\n  width: 320,\n  title: \"Explorer\"\n};\nExplorer$1.default = ExplorerWrapper;\nObject.defineProperty(dist, \"__esModule\", {\n  value: true\n});\ndist.Explorer = void 0;\nvar _Explorer = Explorer$1;\nvar _Explorer2 = _interopRequireDefault(_Explorer);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : { default: obj };\n}\ndist.Explorer = _Explorer2.default;\nvar _default = dist.default = _Explorer2.default;\nvar graphiql = \"\";\nvar styles = \"\";\nvar darkMode = \"\";\nconst YogaLogo = () => /* @__PURE__ */ React$1.createElement(\"svg\", {\n  viewBox: \"0 0 90 90\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, /* @__PURE__ */ React$1.createElement(\"path\", {\n  d: \"M21 25.35c.728 0 1.42.156 2.043.435l19.1-10.985c.9-.5 2-.8 3-.8 1.1 0 2.1.3 3 .8l16.4 9.5c-1.2.8-2.1 2-2.7 3.4l-15.9-9.2c-.3-.2-.599-.2-.899-.2-.3 0-.6.1-.9.2L25.823 29.025A5.005 5.005 0 0 1 21 35.35a5 5 0 0 1 0-10Z\",\n  fill: \"url(#a)\"\n}), /* @__PURE__ */ React$1.createElement(\"path\", {\n  d: \"M67.244 35.033A5.002 5.002 0 0 1 69 25.35a5 5 0 0 1 2.544 9.305V55.2c0 2.2-1.2 4.2-3 5.3l-16.4 9.4c0-1.5-.5-3-1.4-4.1l15.6-9c.6-.3.9-.9.9-1.6V35.033Z\",\n  fill: \"url(#b)\"\n}), /* @__PURE__ */ React$1.createElement(\"path\", {\n  d: \"M49.844 69.106a5 5 0 1 1-9.78 2.043L21.843 60.6c-1.9-1.1-3-3.1-3-5.3V36.8c.7.2 1.5.4 2.2.4.7 0 1.4-.1 2-.3v18.4c0 .7.4 1.3.9 1.6l17.382 10.058a5.002 5.002 0 0 1 8.516 2.14l.002.002v.006Z\",\n  fill: \"url(#c)\"\n}), /* @__PURE__ */ React$1.createElement(\"mask\", {\n  id: \"g\",\n  style: {\n    maskType: \"alpha\"\n  },\n  maskUnits: \"userSpaceOnUse\",\n  x: 16,\n  y: 14,\n  width: 58,\n  height: 62\n}, /* @__PURE__ */ React$1.createElement(\"path\", {\n  d: \"M21 25.35c.728 0 1.42.156 2.043.435l19.1-10.985c.9-.5 2-.8 3-.8 1.1 0 2.1.3 3 .8l16.4 9.5c-1.2.8-2.1 2-2.7 3.4l-15.9-9.2c-.3-.2-.599-.2-.899-.2-.3 0-.6.1-.9.2L25.823 29.025A5.005 5.005 0 0 1 21 35.35a5 5 0 0 1 0-10Z\",\n  fill: \"url(#d)\"\n}), /* @__PURE__ */ React$1.createElement(\"path\", {\n  d: \"M67.244 35.033A5.002 5.002 0 0 1 69 25.35a5 5 0 0 1 2.544 9.305V55.2c0 2.2-1.2 4.2-3 5.3l-16.4 9.4c0-1.5-.5-3-1.4-4.1l15.6-9c.6-.3.9-.9.9-1.6V35.033Z\",\n  fill: \"url(#e)\"\n}), /* @__PURE__ */ React$1.createElement(\"path\", {\n  d: \"M49.844 69.106a5 5 0 1 1-9.78 2.043L21.843 60.6c-1.9-1.1-3-3.1-3-5.3V36.8c.7.2 1.5.4 2.2.4.7 0 1.4-.1 2-.3v18.4c0 .7.4 1.3.9 1.6l17.382 10.058a5.002 5.002 0 0 1 8.516 2.14l.002.002v.006Z\",\n  fill: \"url(#f)\"\n})), /* @__PURE__ */ React$1.createElement(\"g\", {\n  mask: \"url(#g)\"\n}, /* @__PURE__ */ React$1.createElement(\"g\", {\n  filter: \"url(#h)\"\n}, /* @__PURE__ */ React$1.createElement(\"circle\", {\n  cx: 73,\n  cy: 25,\n  r: 26,\n  fill: \"#ED2E7E\"\n})), /* @__PURE__ */ React$1.createElement(\"g\", {\n  filter: \"url(#i)\"\n}, /* @__PURE__ */ React$1.createElement(\"circle\", {\n  cx: 26,\n  cy: 69,\n  r: 26,\n  fill: \"#1CC8EE\"\n}))), /* @__PURE__ */ React$1.createElement(\"path\", {\n  fillRule: \"evenodd\",\n  clipRule: \"evenodd\",\n  d: \"M49.395 32.395c0 2.314-1.815 6.152-4.395 6.152-2.573 0-4.395-3.836-4.395-6.152A4.4 4.4 0 0 1 45 28a4.4 4.4 0 0 1 4.395 4.395ZM35.331 49.043v-.828c0-5.403 2.521-7.215 4.548-8.67.513-.368.98-.705 1.369-1.07 1.08 1.19 2.377 1.83 3.751 1.83 1.375 0 2.672-.64 3.753-1.83.388.366.855.702 1.367 1.07 2.027 1.455 4.548 3.267 4.548 8.67v.828l-.827.049c-3.856.227-6.976-2.192-8.841-5.514-1.884 3.357-5.015 5.74-8.84 5.514l-.828-.049Zm22.814 2.032c-1.128-.184-8.133-1.324-13.145 4.618-4.99-5.938-11.804-4.834-13.091-4.625a1.74 1.74 0 0 1-.21.028l.002.023c.024.281.266 3.156 2.355 5.123L30 58h30l-4.104-1.758c1.958-1.766 2.244-3.973 2.355-4.833.019-.146.033-.253.049-.313a1.388 1.388 0 0 1-.154-.021Zm-17.662-.971c1.912-.783 3.19-1.93 4.516-3.494 1.332 1.574 2.616 2.716 4.516 3.494l.06.114.01.021c-1.495.574-3.16 1.586-4.581 2.905-1.414-1.322-3.038-2.324-4.58-2.929l.059-.111Z\",\n  fill: \"url(#j)\"\n}), /* @__PURE__ */ React$1.createElement(\"mask\", {\n  id: \"k\",\n  style: {\n    maskType: \"alpha\"\n  },\n  maskUnits: \"userSpaceOnUse\",\n  x: 30,\n  y: 28,\n  width: 30,\n  height: 30\n}, /* @__PURE__ */ React$1.createElement(\"path\", {\n  fillRule: \"evenodd\",\n  clipRule: \"evenodd\",\n  d: \"M49.395 32.395c0 2.314-1.815 6.152-4.395 6.152-2.573 0-4.395-3.836-4.395-6.152A4.4 4.4 0 0 1 45 28a4.4 4.4 0 0 1 4.395 4.395ZM35.331 49.043v-.828c0-5.403 2.521-7.215 4.548-8.67.513-.368.98-.705 1.369-1.07 1.08 1.19 2.377 1.83 3.751 1.83 1.375 0 2.672-.64 3.753-1.83.388.366.855.702 1.367 1.07 2.027 1.455 4.548 3.267 4.548 8.67v.828l-.827.049c-3.856.227-6.976-2.192-8.841-5.514-1.884 3.357-5.015 5.74-8.84 5.514l-.828-.049Zm22.814 2.032c-1.128-.184-8.133-1.324-13.145 4.618-4.99-5.938-11.804-4.834-13.091-4.625a1.74 1.74 0 0 1-.21.028l.002.023c.024.281.266 3.156 2.355 5.123L30 58h30l-4.104-1.758c1.958-1.766 2.244-3.973 2.355-4.833.019-.146.033-.253.049-.313a1.388 1.388 0 0 1-.154-.021Zm-17.662-.971c1.912-.783 3.19-1.93 4.516-3.494 1.332 1.574 2.616 2.716 4.516 3.494l.06.114.01.021c-1.495.574-3.16 1.586-4.581 2.905-1.414-1.322-3.038-2.324-4.58-2.929l.059-.111Z\",\n  fill: \"#000\"\n})), /* @__PURE__ */ React$1.createElement(\"g\", {\n  mask: \"url(#k)\"\n}, /* @__PURE__ */ React$1.createElement(\"g\", {\n  filter: \"url(#l)\"\n}, /* @__PURE__ */ React$1.createElement(\"circle\", {\n  cx: 38,\n  cy: 6,\n  r: 26,\n  fill: \"#ED2E7E\"\n})), /* @__PURE__ */ React$1.createElement(\"g\", {\n  filter: \"url(#m)\"\n}, /* @__PURE__ */ React$1.createElement(\"circle\", {\n  cx: 63,\n  cy: 69,\n  r: 26,\n  fill: \"#1CC8EE\"\n}))), /* @__PURE__ */ React$1.createElement(\"defs\", null, /* @__PURE__ */ React$1.createElement(\"linearGradient\", {\n  id: \"a\",\n  x1: 16,\n  y1: 14,\n  x2: 87.213,\n  y2: 44.598,\n  gradientUnits: \"userSpaceOnUse\"\n}, /* @__PURE__ */ React$1.createElement(\"stop\", {\n  stopColor: \"#7433FF\"\n}), /* @__PURE__ */ React$1.createElement(\"stop\", {\n  offset: 1,\n  stopColor: \"#FFA3FD\"\n})), /* @__PURE__ */ React$1.createElement(\"linearGradient\", {\n  id: \"b\",\n  x1: 16,\n  y1: 14,\n  x2: 87.213,\n  y2: 44.598,\n  gradientUnits: \"userSpaceOnUse\"\n}, /* @__PURE__ */ React$1.createElement(\"stop\", {\n  stopColor: \"#7433FF\"\n}), /* @__PURE__ */ React$1.createElement(\"stop\", {\n  offset: 1,\n  stopColor: \"#FFA3FD\"\n})), /* @__PURE__ */ React$1.createElement(\"linearGradient\", {\n  id: \"c\",\n  x1: 16,\n  y1: 14,\n  x2: 87.213,\n  y2: 44.598,\n  gradientUnits: \"userSpaceOnUse\"\n}, /* @__PURE__ */ React$1.createElement(\"stop\", {\n  stopColor: \"#7433FF\"\n}), /* @__PURE__ */ React$1.createElement(\"stop\", {\n  offset: 1,\n  stopColor: \"#FFA3FD\"\n})), /* @__PURE__ */ React$1.createElement(\"linearGradient\", {\n  id: \"d\",\n  x1: 16,\n  y1: 14,\n  x2: 87.213,\n  y2: 44.598,\n  gradientUnits: \"userSpaceOnUse\"\n}, /* @__PURE__ */ React$1.createElement(\"stop\", {\n  stopColor: \"#7433FF\"\n}), /* @__PURE__ */ React$1.createElement(\"stop\", {\n  offset: 1,\n  stopColor: \"#FFA3FD\"\n})), /* @__PURE__ */ React$1.createElement(\"linearGradient\", {\n  id: \"e\",\n  x1: 16,\n  y1: 14,\n  x2: 87.213,\n  y2: 44.598,\n  gradientUnits: \"userSpaceOnUse\"\n}, /* @__PURE__ */ React$1.createElement(\"stop\", {\n  stopColor: \"#7433FF\"\n}), /* @__PURE__ */ React$1.createElement(\"stop\", {\n  offset: 1,\n  stopColor: \"#FFA3FD\"\n})), /* @__PURE__ */ React$1.createElement(\"linearGradient\", {\n  id: \"f\",\n  x1: 16,\n  y1: 14,\n  x2: 87.213,\n  y2: 44.598,\n  gradientUnits: \"userSpaceOnUse\"\n}, /* @__PURE__ */ React$1.createElement(\"stop\", {\n  stopColor: \"#7433FF\"\n}), /* @__PURE__ */ React$1.createElement(\"stop\", {\n  offset: 1,\n  stopColor: \"#FFA3FD\"\n})), /* @__PURE__ */ React$1.createElement(\"linearGradient\", {\n  id: \"j\",\n  x1: 30,\n  y1: 28,\n  x2: 66.165,\n  y2: 44.436,\n  gradientUnits: \"userSpaceOnUse\"\n}, /* @__PURE__ */ React$1.createElement(\"stop\", {\n  stopColor: \"#7433FF\"\n}), /* @__PURE__ */ React$1.createElement(\"stop\", {\n  offset: 1,\n  stopColor: \"#FFA3FD\"\n})), /* @__PURE__ */ React$1.createElement(\"filter\", {\n  id: \"h\",\n  x: 23,\n  y: -25,\n  width: 100,\n  height: 100,\n  filterUnits: \"userSpaceOnUse\",\n  colorInterpolationFilters: \"sRGB\"\n}, /* @__PURE__ */ React$1.createElement(\"feFlood\", {\n  floodOpacity: 0,\n  result: \"BackgroundImageFix\"\n}), /* @__PURE__ */ React$1.createElement(\"feBlend\", {\n  in: \"SourceGraphic\",\n  in2: \"BackgroundImageFix\",\n  result: \"shape\"\n}), /* @__PURE__ */ React$1.createElement(\"feGaussianBlur\", {\n  stdDeviation: 12,\n  result: \"effect1_foregroundBlur_1677_11483\"\n})), /* @__PURE__ */ React$1.createElement(\"filter\", {\n  id: \"i\",\n  x: -24,\n  y: 19,\n  width: 100,\n  height: 100,\n  filterUnits: \"userSpaceOnUse\",\n  colorInterpolationFilters: \"sRGB\"\n}, /* @__PURE__ */ React$1.createElement(\"feFlood\", {\n  floodOpacity: 0,\n  result: \"BackgroundImageFix\"\n}), /* @__PURE__ */ React$1.createElement(\"feBlend\", {\n  in: \"SourceGraphic\",\n  in2: \"BackgroundImageFix\",\n  result: \"shape\"\n}), /* @__PURE__ */ React$1.createElement(\"feGaussianBlur\", {\n  stdDeviation: 12,\n  result: \"effect1_foregroundBlur_1677_11483\"\n})), /* @__PURE__ */ React$1.createElement(\"filter\", {\n  id: \"l\",\n  x: -12,\n  y: -44,\n  width: 100,\n  height: 100,\n  filterUnits: \"userSpaceOnUse\",\n  colorInterpolationFilters: \"sRGB\"\n}, /* @__PURE__ */ React$1.createElement(\"feFlood\", {\n  floodOpacity: 0,\n  result: \"BackgroundImageFix\"\n}), /* @__PURE__ */ React$1.createElement(\"feBlend\", {\n  in: \"SourceGraphic\",\n  in2: \"BackgroundImageFix\",\n  result: \"shape\"\n}), /* @__PURE__ */ React$1.createElement(\"feGaussianBlur\", {\n  stdDeviation: 12,\n  result: \"effect1_foregroundBlur_1677_11483\"\n})), /* @__PURE__ */ React$1.createElement(\"filter\", {\n  id: \"m\",\n  x: 13,\n  y: 19,\n  width: 100,\n  height: 100,\n  filterUnits: \"userSpaceOnUse\",\n  colorInterpolationFilters: \"sRGB\"\n}, /* @__PURE__ */ React$1.createElement(\"feFlood\", {\n  floodOpacity: 0,\n  result: \"BackgroundImageFix\"\n}), /* @__PURE__ */ React$1.createElement(\"feBlend\", {\n  in: \"SourceGraphic\",\n  in2: \"BackgroundImageFix\",\n  result: \"shape\"\n}), /* @__PURE__ */ React$1.createElement(\"feGaussianBlur\", {\n  stdDeviation: 12,\n  result: \"effect1_foregroundBlur_1677_11483\"\n}))));\nconst noop = function() {\n};\nconst listeners = {\n  popstate: []\n};\nlet mockWindow = {\n  URL: function URL2() {\n    return {\n      searchParams: {\n        set: noop,\n        append: noop,\n        delete: noop\n      }\n    };\n  },\n  location: {\n    href: \"\",\n    search: \"\"\n  },\n  history: {\n    pushState: noop\n  },\n  fireEvent: function(eventName) {\n    listeners[eventName].forEach((listener) => {\n      listener();\n    });\n  },\n  addEventListener: function(eventName, listener) {\n    listeners[eventName].push(listener);\n  },\n  removeEventListener: function(eventName, listener) {\n    const eventListeners = listeners[eventName];\n    const i = eventListeners.findIndex((l2) => l2 === listener);\n    eventListeners.splice(i, 1);\n  }\n};\nfunction getWindow() {\n  if (typeof window !== \"undefined\")\n    return window;\n  return mockWindow;\n}\nconst SUPPORTED_PARAMS_TYPES = [Number, String, Boolean, Date];\nfunction setQueryToCurrentUrl(params) {\n  const { URL: URL3 } = getWindow();\n  const url = new URL3(getWindow().location.href);\n  Object.keys(params).forEach((key) => {\n    const value = params[key];\n    if (value !== null && value !== void 0) {\n      if (Array.isArray(value)) {\n        url.searchParams.delete(key);\n        value.forEach((valueItem) => {\n          url.searchParams.append(key, valueItem);\n        });\n      } else if (value instanceof Date) {\n        if (!isNaN(value.getTime())) {\n          url.searchParams.set(key, value.toISOString());\n        }\n      } else if (typeof value === \"object\") {\n        url.searchParams.set(key, JSON.stringify(value));\n      } else {\n        url.searchParams.set(key, value);\n      }\n    } else {\n      url.searchParams.delete(key);\n    }\n  });\n  return url;\n}\nfunction isNoneEmptyPrimitiveArray(input) {\n  return Array.isArray(input) && input.length > 0 && input.every((item) => typeof item === \"number\" || typeof item === \"string\" || typeof item === \"boolean\");\n}\nfunction validateTypes(types = {}) {\n  const isValidTypes = Object.values(types).every((type2) => SUPPORTED_PARAMS_TYPES.includes(type2) || isNoneEmptyPrimitiveArray(type2) || typeof type2 === \"function\");\n  if (!isValidTypes) {\n    throw new Error(`Unsupported param types. Must be one of [${SUPPORTED_PARAMS_TYPES.map((item) => item.name).join(\", \")}]`);\n  }\n}\nfunction useUrlSearchParams(initial = {}, types = {}, replace2 = false) {\n  if (types)\n    validateTypes(types);\n  const [, forceUpdate] = react.exports.useState();\n  const locationSearch = getWindow().location.search;\n  const urlSearchParams = react.exports.useMemo(() => {\n    return new URLSearchParams(locationSearch);\n  }, [locationSearch]);\n  const params = react.exports.useMemo(() => {\n    let result2 = [];\n    urlSearchParams.forEach((value, key) => {\n      result2.push({\n        key,\n        value\n      });\n    });\n    result2 = result2.reduce((acc, val) => {\n      (acc[val.key] = acc[val.key] || []).push(val);\n      return acc;\n    }, {});\n    result2 = Object.keys(result2).map((key) => {\n      const valueGroup = result2[key];\n      if (valueGroup.length === 1) {\n        return [key, valueGroup[0].value];\n      } else {\n        return [key, valueGroup.map(({ value }) => value)];\n      }\n    });\n    const params2 = Object.assign({}, initial);\n    result2.forEach(([key, value]) => {\n      params2[key] = parseValue(key, value, types, initial);\n    });\n    return params2;\n  }, [urlSearchParams]);\n  function redirectToNewSearchParams(params2) {\n    const url = setQueryToCurrentUrl(params2);\n    if (getWindow().location.search !== url.search) {\n      if (replace2) {\n        getWindow().history.replaceState({}, \"\", url.toString());\n      } else {\n        getWindow().history.pushState({}, \"\", url.toString());\n      }\n    }\n    if (urlSearchParams.toString() !== url.searchParams.toString()) {\n      forceUpdate({});\n    }\n  }\n  react.exports.useEffect(() => {\n    redirectToNewSearchParams(Object.assign(Object.assign({}, initial), params));\n  }, [params]);\n  const setParams = (params2) => {\n    redirectToNewSearchParams(params2);\n  };\n  react.exports.useEffect(() => {\n    const onPopState = () => {\n      forceUpdate({});\n    };\n    getWindow().addEventListener(\"popstate\", onPopState);\n    return () => {\n      getWindow().removeEventListener(\"popstate\", onPopState);\n    };\n  }, []);\n  return [params, setParams];\n}\nconst booleanValues = {\n  true: true,\n  false: false\n};\nfunction parseValue(key, _value, types, defaultParams) {\n  if (!types)\n    return _value;\n  const type2 = types[key];\n  const value = _value === void 0 ? defaultParams[key] : _value;\n  if (type2 === Number) {\n    return Number(value);\n  }\n  if (type2 === Boolean) {\n    return booleanValues[value];\n  }\n  if (type2 === Date) {\n    return new Date(value);\n  }\n  if (Array.isArray(type2)) {\n    return type2.find((item) => item == value) || defaultParams[key];\n  }\n  if (typeof type2 === \"function\") {\n    return type2(value);\n  }\n  return value;\n}\nconst getOperationWithFragments = (document2, operationName) => {\n  const definitions = document2.definitions.filter((definition) => {\n    var _a2;\n    if (definition.kind === Kind.OPERATION_DEFINITION) {\n      if (operationName) {\n        if (((_a2 = definition.name) == null ? void 0 : _a2.value) !== operationName) {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n  return {\n    kind: Kind.DOCUMENT,\n    definitions\n  };\n};\nfunction YogaGraphiQL(props) {\n  var _a2, _b;\n  const initialQuery = `#\n# Welcome to ${props.title || \"Yoga GraphiQL\"}\n#\n# ${props.title || \"Yoga GraphiQL\"} is an in-browser tool for writing, validating, and\n# testing GraphQL queries.\n#\n# Type queries into this side of the screen, and you will see intelligent\n# typeaheads aware of the current GraphQL type schema and live syntax and\n# validation errors highlighted within the text.\n#\n# GraphQL queries typically start with a \"{\" character. Lines that start\n# with a # are ignored.\n#\n# An example GraphQL query might look like:\n#\n#     {\n#       field(arg: \"value\") {\n#         subField\n#       }\n#     }\n#\n# Keyboard shortcuts:\n#\n#  Prettify Query:  Shift-Ctrl-P (or press the prettify button above)\n#\n#     Merge Query:  Shift-Ctrl-M (or press the merge button above)\n#\n#       Run Query:  Ctrl-Enter (or press the play button above)\n#\n#   Auto Complete:  Ctrl-Space (or just start typing)\n#\n`;\n  const endpoint = (_a2 = props.endpoint) != null ? _a2 : \"/graphql\";\n  const credentials = (_b = props.credentials) != null ? _b : \"same-origin\";\n  const graphiqlRef = React$1.useRef(null);\n  const urlLoader = react.exports.useMemo(() => new UrlLoader(), []);\n  const fetcher = react.exports.useMemo(() => {\n    const executor = urlLoader.getExecutorAsync(endpoint, {\n      subscriptionsProtocol: SubscriptionProtocol.SSE,\n      specifiedByUrl: true,\n      directiveIsRepeatable: true,\n      schemaDescription: true,\n      credentials\n    });\n    return function fetcher2(graphQLParams, opts) {\n      const document2 = getOperationWithFragments(parse$1(graphQLParams.query), graphQLParams.operationName);\n      return executor({\n        document: document2,\n        operationName: graphQLParams.operationName,\n        variables: graphQLParams.variables,\n        extensions: {\n          headers: opts == null ? void 0 : opts.headers\n        }\n      });\n    };\n  }, [urlLoader, endpoint, credentials]);\n  const [showExplorer, setShowExplorer] = React$1.useState(false);\n  const [schema, setSchema] = React$1.useState(null);\n  const types = {\n    query: String\n  };\n  const [params, setParams] = useUrlSearchParams({\n    query: props.defaultQuery || initialQuery\n  }, types, false);\n  const [showDocs, setShowDocs] = React$1.useState(false);\n  return /* @__PURE__ */ React$1.createElement(\"div\", {\n    className: \"graphiql-container\"\n  }, schema && (params == null ? void 0 : params.query) != null ? /* @__PURE__ */ React$1.createElement(_default, {\n    schema,\n    query: params.query.toString(),\n    onEdit: (query) => {\n      setParams({\n        query\n      });\n    },\n    explorerIsOpen: showExplorer,\n    onToggleExplorer: () => setShowExplorer((isOpen) => !isOpen),\n    colors: {\n      keyword: \"#FF6D5D\",\n      def: \"#9F51D9\",\n      property: \"#0083c7\",\n      qualifier: \"#008AED\",\n      attribute: \"#00b8ff\",\n      number: \"#97b1aa\",\n      string: \"#00917D\",\n      string2: \"#146574\",\n      builtin: \"#da8aff\",\n      variable: \"#FF6D5D\",\n      atom: \"#ff9f4c\"\n    }\n  }) : null, (params == null ? void 0 : params.query) != null ? /* @__PURE__ */ React$1.createElement(GraphiQL, __spreadValues({\n    ref: graphiqlRef,\n    fetcher,\n    headerEditorEnabled: true,\n    defaultVariableEditorOpen: true,\n    docExplorerOpen: showDocs,\n    onToggleDocs: () => setShowDocs((isOpen) => !isOpen),\n    tabs: true,\n    toolbar: {\n      additionalContent: /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement(\"button\", {\n        className: \"toolbar-button\",\n        onClick: () => {\n          var _a3;\n          const state = (_a3 = graphiqlRef.current) == null ? void 0 : _a3.state;\n          copyToClipboard(urlLoader.prepareGETUrl({\n            baseUrl: window.location.href,\n            query: (state == null ? void 0 : state.query) || \"\",\n            variables: state == null ? void 0 : state.variables,\n            operationName: state == null ? void 0 : state.operationName\n          }));\n        }\n      }, \"Copy Link\"))\n    },\n    onSchemaChange: (schema2) => {\n      setSchema(schema2);\n    },\n    query: params.query.toString(),\n    onEditQuery: (query) => setParams({\n      query\n    }),\n    beforeTopBarContent: schema ? showExplorer ? null : /* @__PURE__ */ React$1.createElement(\"button\", {\n      className: \"docExplorerShow docExplorerShowReverse\",\n      onClick: () => setShowExplorer((isOpen) => !isOpen)\n    }, \"Explorer\") : null\n  }, props), /* @__PURE__ */ React$1.createElement(GraphiQL.Logo, null, /* @__PURE__ */ React$1.createElement(\"div\", {\n    style: { display: \"flex\", alignItems: \"center\" }\n  }, /* @__PURE__ */ React$1.createElement(\"div\", {\n    style: { width: 40, display: \"flex\" }\n  }, /* @__PURE__ */ React$1.createElement(YogaLogo, null)), /* @__PURE__ */ React$1.createElement(\"span\", null, (props == null ? void 0 : props.title) ? props.title : /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, \"Yoga Graph\", /* @__PURE__ */ React$1.createElement(\"em\", null, \"i\"), \"QL\"))))) : null);\n}\nfunction renderYogaGraphiQL(element, opts) {\n  ReactDOM.render(/* @__PURE__ */ React$1.createElement(YogaGraphiQL, __spreadValues({}, opts)), element);\n}\nvar codemirror$2 = { exports: {} };\n(function(module2, exports) {\n  (function(global2, factory) {\n    module2.exports = factory();\n  })(commonjsGlobal, function() {\n    var userAgent = navigator.userAgent;\n    var platform = navigator.platform;\n    var gecko = /gecko\\/\\d/i.test(userAgent);\n    var ie_upto10 = /MSIE \\d/.test(userAgent);\n    var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n    var edge = /Edge\\/(\\d+)/.exec(userAgent);\n    var ie2 = ie_upto10 || ie_11up || edge;\n    var ie_version = ie2 && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n    var webkit = !edge && /WebKit\\//.test(userAgent);\n    var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n    var chrome = !edge && /Chrome\\//.test(userAgent);\n    var presto = /Opera\\//.test(userAgent);\n    var safari = /Apple Computer/.test(navigator.vendor);\n    var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n    var phantom = /PhantomJS/.test(userAgent);\n    var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n    var android = /Android/.test(userAgent);\n    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n    var mac = ios || /Mac/.test(platform);\n    var chromeOS = /\\bCrOS\\b/.test(userAgent);\n    var windows = /win/i.test(platform);\n    var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n    if (presto_version) {\n      presto_version = Number(presto_version[1]);\n    }\n    if (presto_version && presto_version >= 15) {\n      presto = false;\n      webkit = true;\n    }\n    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n    var captureRightClick = gecko || ie2 && ie_version >= 9;\n    function classTest(cls) {\n      return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n    }\n    var rmClass = function(node, cls) {\n      var current = node.className;\n      var match2 = classTest(cls).exec(current);\n      if (match2) {\n        var after = current.slice(match2.index + match2[0].length);\n        node.className = current.slice(0, match2.index) + (after ? match2[1] + after : \"\");\n      }\n    };\n    function removeChildren(e) {\n      for (var count = e.childNodes.length; count > 0; --count) {\n        e.removeChild(e.firstChild);\n      }\n      return e;\n    }\n    function removeChildrenAndAdd(parent, e) {\n      return removeChildren(parent).appendChild(e);\n    }\n    function elt(tag, content, className, style) {\n      var e = document.createElement(tag);\n      if (className) {\n        e.className = className;\n      }\n      if (style) {\n        e.style.cssText = style;\n      }\n      if (typeof content == \"string\") {\n        e.appendChild(document.createTextNode(content));\n      } else if (content) {\n        for (var i2 = 0; i2 < content.length; ++i2) {\n          e.appendChild(content[i2]);\n        }\n      }\n      return e;\n    }\n    function eltP(tag, content, className, style) {\n      var e = elt(tag, content, className, style);\n      e.setAttribute(\"role\", \"presentation\");\n      return e;\n    }\n    var range2;\n    if (document.createRange) {\n      range2 = function(node, start2, end2, endNode) {\n        var r2 = document.createRange();\n        r2.setEnd(endNode || node, end2);\n        r2.setStart(node, start2);\n        return r2;\n      };\n    } else {\n      range2 = function(node, start2, end2) {\n        var r2 = document.body.createTextRange();\n        try {\n          r2.moveToElementText(node.parentNode);\n        } catch (e) {\n          return r2;\n        }\n        r2.collapse(true);\n        r2.moveEnd(\"character\", end2);\n        r2.moveStart(\"character\", start2);\n        return r2;\n      };\n    }\n    function contains(parent, child) {\n      if (child.nodeType == 3) {\n        child = child.parentNode;\n      }\n      if (parent.contains) {\n        return parent.contains(child);\n      }\n      do {\n        if (child.nodeType == 11) {\n          child = child.host;\n        }\n        if (child == parent) {\n          return true;\n        }\n      } while (child = child.parentNode);\n    }\n    function activeElt() {\n      var activeElement;\n      try {\n        activeElement = document.activeElement;\n      } catch (e) {\n        activeElement = document.body || null;\n      }\n      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n        activeElement = activeElement.shadowRoot.activeElement;\n      }\n      return activeElement;\n    }\n    function addClass(node, cls) {\n      var current = node.className;\n      if (!classTest(cls).test(current)) {\n        node.className += (current ? \" \" : \"\") + cls;\n      }\n    }\n    function joinClasses(a, b) {\n      var as = a.split(\" \");\n      for (var i2 = 0; i2 < as.length; i2++) {\n        if (as[i2] && !classTest(as[i2]).test(b)) {\n          b += \" \" + as[i2];\n        }\n      }\n      return b;\n    }\n    var selectInput = function(node) {\n      node.select();\n    };\n    if (ios) {\n      selectInput = function(node) {\n        node.selectionStart = 0;\n        node.selectionEnd = node.value.length;\n      };\n    } else if (ie2) {\n      selectInput = function(node) {\n        try {\n          node.select();\n        } catch (_e) {\n        }\n      };\n    }\n    function bind(f) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      return function() {\n        return f.apply(null, args);\n      };\n    }\n    function copyObj(obj, target2, overwrite) {\n      if (!target2) {\n        target2 = {};\n      }\n      for (var prop3 in obj) {\n        if (obj.hasOwnProperty(prop3) && (overwrite !== false || !target2.hasOwnProperty(prop3))) {\n          target2[prop3] = obj[prop3];\n        }\n      }\n      return target2;\n    }\n    function countColumn(string2, end2, tabSize, startIndex, startValue) {\n      if (end2 == null) {\n        end2 = string2.search(/[^\\s\\u00a0]/);\n        if (end2 == -1) {\n          end2 = string2.length;\n        }\n      }\n      for (var i2 = startIndex || 0, n2 = startValue || 0; ; ) {\n        var nextTab = string2.indexOf(\"\t\", i2);\n        if (nextTab < 0 || nextTab >= end2) {\n          return n2 + (end2 - i2);\n        }\n        n2 += nextTab - i2;\n        n2 += tabSize - n2 % tabSize;\n        i2 = nextTab + 1;\n      }\n    }\n    var Delayed = function() {\n      this.id = null;\n      this.f = null;\n      this.time = 0;\n      this.handler = bind(this.onTimeout, this);\n    };\n    Delayed.prototype.onTimeout = function(self2) {\n      self2.id = 0;\n      if (self2.time <= +new Date()) {\n        self2.f();\n      } else {\n        setTimeout(self2.handler, self2.time - +new Date());\n      }\n    };\n    Delayed.prototype.set = function(ms, f) {\n      this.f = f;\n      var time = +new Date() + ms;\n      if (!this.id || time < this.time) {\n        clearTimeout(this.id);\n        this.id = setTimeout(this.handler, ms);\n        this.time = time;\n      }\n    };\n    function indexOf(array, elt2) {\n      for (var i2 = 0; i2 < array.length; ++i2) {\n        if (array[i2] == elt2) {\n          return i2;\n        }\n      }\n      return -1;\n    }\n    var scrollerGap = 50;\n    var Pass = { toString: function() {\n      return \"CodeMirror.Pass\";\n    } };\n    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: \"*mouse\" }, sel_move = { origin: \"+move\" };\n    function findColumn(string2, goal, tabSize) {\n      for (var pos = 0, col = 0; ; ) {\n        var nextTab = string2.indexOf(\"\t\", pos);\n        if (nextTab == -1) {\n          nextTab = string2.length;\n        }\n        var skipped = nextTab - pos;\n        if (nextTab == string2.length || col + skipped >= goal) {\n          return pos + Math.min(skipped, goal - col);\n        }\n        col += nextTab - pos;\n        col += tabSize - col % tabSize;\n        pos = nextTab + 1;\n        if (col >= goal) {\n          return pos;\n        }\n      }\n    }\n    var spaceStrs = [\"\"];\n    function spaceStr(n2) {\n      while (spaceStrs.length <= n2) {\n        spaceStrs.push(lst(spaceStrs) + \" \");\n      }\n      return spaceStrs[n2];\n    }\n    function lst(arr) {\n      return arr[arr.length - 1];\n    }\n    function map2(array, f) {\n      var out = [];\n      for (var i2 = 0; i2 < array.length; i2++) {\n        out[i2] = f(array[i2], i2);\n      }\n      return out;\n    }\n    function insertSorted(array, value, score) {\n      var pos = 0, priority = score(value);\n      while (pos < array.length && score(array[pos]) <= priority) {\n        pos++;\n      }\n      array.splice(pos, 0, value);\n    }\n    function nothing() {\n    }\n    function createObj(base2, props) {\n      var inst;\n      if (Object.create) {\n        inst = Object.create(base2);\n      } else {\n        nothing.prototype = base2;\n        inst = new nothing();\n      }\n      if (props) {\n        copyObj(props, inst);\n      }\n      return inst;\n    }\n    var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n    function isWordCharBasic(ch2) {\n      return /\\w/.test(ch2) || ch2 > \"\\x80\" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2));\n    }\n    function isWordChar(ch2, helper) {\n      if (!helper) {\n        return isWordCharBasic(ch2);\n      }\n      if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch2)) {\n        return true;\n      }\n      return helper.test(ch2);\n    }\n    function isEmpty2(obj) {\n      for (var n2 in obj) {\n        if (obj.hasOwnProperty(n2) && obj[n2]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n    function isExtendingChar(ch2) {\n      return ch2.charCodeAt(0) >= 768 && extendingChars.test(ch2);\n    }\n    function skipExtendingChars(str, pos, dir) {\n      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {\n        pos += dir;\n      }\n      return pos;\n    }\n    function findFirst(pred, from, to) {\n      var dir = from > to ? -1 : 1;\n      for (; ; ) {\n        if (from == to) {\n          return from;\n        }\n        var midF = (from + to) / 2, mid2 = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n        if (mid2 == from) {\n          return pred(mid2) ? from : to;\n        }\n        if (pred(mid2)) {\n          to = mid2;\n        } else {\n          from = mid2 + dir;\n        }\n      }\n    }\n    function iterateBidiSections(order2, from, to, f) {\n      if (!order2) {\n        return f(from, to, \"ltr\", 0);\n      }\n      var found = false;\n      for (var i2 = 0; i2 < order2.length; ++i2) {\n        var part2 = order2[i2];\n        if (part2.from < to && part2.to > from || from == to && part2.to == from) {\n          f(Math.max(part2.from, from), Math.min(part2.to, to), part2.level == 1 ? \"rtl\" : \"ltr\", i2);\n          found = true;\n        }\n      }\n      if (!found) {\n        f(from, to, \"ltr\");\n      }\n    }\n    var bidiOther = null;\n    function getBidiPartAt(order2, ch2, sticky) {\n      var found;\n      bidiOther = null;\n      for (var i2 = 0; i2 < order2.length; ++i2) {\n        var cur = order2[i2];\n        if (cur.from < ch2 && cur.to > ch2) {\n          return i2;\n        }\n        if (cur.to == ch2) {\n          if (cur.from != cur.to && sticky == \"before\") {\n            found = i2;\n          } else {\n            bidiOther = i2;\n          }\n        }\n        if (cur.from == ch2) {\n          if (cur.from != cur.to && sticky != \"before\") {\n            found = i2;\n          } else {\n            bidiOther = i2;\n          }\n        }\n      }\n      return found != null ? found : bidiOther;\n    }\n    var bidiOrdering = function() {\n      var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n      var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n      function charType(code3) {\n        if (code3 <= 247) {\n          return lowTypes.charAt(code3);\n        } else if (1424 <= code3 && code3 <= 1524) {\n          return \"R\";\n        } else if (1536 <= code3 && code3 <= 1785) {\n          return arabicTypes.charAt(code3 - 1536);\n        } else if (1774 <= code3 && code3 <= 2220) {\n          return \"r\";\n        } else if (8192 <= code3 && code3 <= 8203) {\n          return \"w\";\n        } else if (code3 == 8204) {\n          return \"b\";\n        } else {\n          return \"L\";\n        }\n      }\n      var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n      function BidiSpan(level, from, to) {\n        this.level = level;\n        this.from = from;\n        this.to = to;\n      }\n      return function(str, direction) {\n        var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n        if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) {\n          return false;\n        }\n        var len = str.length, types = [];\n        for (var i2 = 0; i2 < len; ++i2) {\n          types.push(charType(str.charCodeAt(i2)));\n        }\n        for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {\n          var type2 = types[i$12];\n          if (type2 == \"m\") {\n            types[i$12] = prev;\n          } else {\n            prev = type2;\n          }\n        }\n        for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {\n          var type$1 = types[i$22];\n          if (type$1 == \"1\" && cur == \"r\") {\n            types[i$22] = \"n\";\n          } else if (isStrong.test(type$1)) {\n            cur = type$1;\n            if (type$1 == \"r\") {\n              types[i$22] = \"R\";\n            }\n          }\n        }\n        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n          var type$2 = types[i$3];\n          if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3 + 1] == \"1\") {\n            types[i$3] = \"1\";\n          } else if (type$2 == \",\" && prev$1 == types[i$3 + 1] && (prev$1 == \"1\" || prev$1 == \"n\")) {\n            types[i$3] = prev$1;\n          }\n          prev$1 = type$2;\n        }\n        for (var i$4 = 0; i$4 < len; ++i$4) {\n          var type$3 = types[i$4];\n          if (type$3 == \",\") {\n            types[i$4] = \"N\";\n          } else if (type$3 == \"%\") {\n            var end2 = void 0;\n            for (end2 = i$4 + 1; end2 < len && types[end2] == \"%\"; ++end2) {\n            }\n            var replace2 = i$4 && types[i$4 - 1] == \"!\" || end2 < len && types[end2] == \"1\" ? \"1\" : \"N\";\n            for (var j = i$4; j < end2; ++j) {\n              types[j] = replace2;\n            }\n            i$4 = end2 - 1;\n          }\n        }\n        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n          var type$4 = types[i$5];\n          if (cur$1 == \"L\" && type$4 == \"1\") {\n            types[i$5] = \"L\";\n          } else if (isStrong.test(type$4)) {\n            cur$1 = type$4;\n          }\n        }\n        for (var i$6 = 0; i$6 < len; ++i$6) {\n          if (isNeutral.test(types[i$6])) {\n            var end$1 = void 0;\n            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {\n            }\n            var before = (i$6 ? types[i$6 - 1] : outerType) == \"L\";\n            var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n            var replace$1 = before == after ? before ? \"L\" : \"R\" : outerType;\n            for (var j$1 = i$6; j$1 < end$1; ++j$1) {\n              types[j$1] = replace$1;\n            }\n            i$6 = end$1 - 1;\n          }\n        }\n        var order2 = [], m2;\n        for (var i$7 = 0; i$7 < len; ) {\n          if (countsAsLeft.test(types[i$7])) {\n            var start2 = i$7;\n            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {\n            }\n            order2.push(new BidiSpan(0, start2, i$7));\n          } else {\n            var pos = i$7, at = order2.length, isRTL = direction == \"rtl\" ? 1 : 0;\n            for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {\n            }\n            for (var j$2 = pos; j$2 < i$7; ) {\n              if (countsAsNum.test(types[j$2])) {\n                if (pos < j$2) {\n                  order2.splice(at, 0, new BidiSpan(1, pos, j$2));\n                  at += isRTL;\n                }\n                var nstart = j$2;\n                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {\n                }\n                order2.splice(at, 0, new BidiSpan(2, nstart, j$2));\n                at += isRTL;\n                pos = j$2;\n              } else {\n                ++j$2;\n              }\n            }\n            if (pos < i$7) {\n              order2.splice(at, 0, new BidiSpan(1, pos, i$7));\n            }\n          }\n        }\n        if (direction == \"ltr\") {\n          if (order2[0].level == 1 && (m2 = str.match(/^\\s+/))) {\n            order2[0].from = m2[0].length;\n            order2.unshift(new BidiSpan(0, 0, m2[0].length));\n          }\n          if (lst(order2).level == 1 && (m2 = str.match(/\\s+$/))) {\n            lst(order2).to -= m2[0].length;\n            order2.push(new BidiSpan(0, len - m2[0].length, len));\n          }\n        }\n        return direction == \"rtl\" ? order2.reverse() : order2;\n      };\n    }();\n    function getOrder(line, direction) {\n      var order2 = line.order;\n      if (order2 == null) {\n        order2 = line.order = bidiOrdering(line.text, direction);\n      }\n      return order2;\n    }\n    var noHandlers = [];\n    var on = function(emitter, type2, f) {\n      if (emitter.addEventListener) {\n        emitter.addEventListener(type2, f, false);\n      } else if (emitter.attachEvent) {\n        emitter.attachEvent(\"on\" + type2, f);\n      } else {\n        var map3 = emitter._handlers || (emitter._handlers = {});\n        map3[type2] = (map3[type2] || noHandlers).concat(f);\n      }\n    };\n    function getHandlers(emitter, type2) {\n      return emitter._handlers && emitter._handlers[type2] || noHandlers;\n    }\n    function off(emitter, type2, f) {\n      if (emitter.removeEventListener) {\n        emitter.removeEventListener(type2, f, false);\n      } else if (emitter.detachEvent) {\n        emitter.detachEvent(\"on\" + type2, f);\n      } else {\n        var map3 = emitter._handlers, arr = map3 && map3[type2];\n        if (arr) {\n          var index = indexOf(arr, f);\n          if (index > -1) {\n            map3[type2] = arr.slice(0, index).concat(arr.slice(index + 1));\n          }\n        }\n      }\n    }\n    function signal(emitter, type2) {\n      var handlers = getHandlers(emitter, type2);\n      if (!handlers.length) {\n        return;\n      }\n      var args = Array.prototype.slice.call(arguments, 2);\n      for (var i2 = 0; i2 < handlers.length; ++i2) {\n        handlers[i2].apply(null, args);\n      }\n    }\n    function signalDOMEvent(cm, e, override) {\n      if (typeof e == \"string\") {\n        e = { type: e, preventDefault: function() {\n          this.defaultPrevented = true;\n        } };\n      }\n      signal(cm, override || e.type, cm, e);\n      return e_defaultPrevented(e) || e.codemirrorIgnore;\n    }\n    function signalCursorActivity(cm) {\n      var arr = cm._handlers && cm._handlers.cursorActivity;\n      if (!arr) {\n        return;\n      }\n      var set2 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n      for (var i2 = 0; i2 < arr.length; ++i2) {\n        if (indexOf(set2, arr[i2]) == -1) {\n          set2.push(arr[i2]);\n        }\n      }\n    }\n    function hasHandler(emitter, type2) {\n      return getHandlers(emitter, type2).length > 0;\n    }\n    function eventMixin(ctor) {\n      ctor.prototype.on = function(type2, f) {\n        on(this, type2, f);\n      };\n      ctor.prototype.off = function(type2, f) {\n        off(this, type2, f);\n      };\n    }\n    function e_preventDefault(e) {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n    }\n    function e_stopPropagation(e) {\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } else {\n        e.cancelBubble = true;\n      }\n    }\n    function e_defaultPrevented(e) {\n      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n    }\n    function e_stop(e) {\n      e_preventDefault(e);\n      e_stopPropagation(e);\n    }\n    function e_target(e) {\n      return e.target || e.srcElement;\n    }\n    function e_button(e) {\n      var b = e.which;\n      if (b == null) {\n        if (e.button & 1) {\n          b = 1;\n        } else if (e.button & 2) {\n          b = 3;\n        } else if (e.button & 4) {\n          b = 2;\n        }\n      }\n      if (mac && e.ctrlKey && b == 1) {\n        b = 3;\n      }\n      return b;\n    }\n    var dragAndDrop = function() {\n      if (ie2 && ie_version < 9) {\n        return false;\n      }\n      var div2 = elt(\"div\");\n      return \"draggable\" in div2 || \"dragDrop\" in div2;\n    }();\n    var zwspSupported;\n    function zeroWidthElement(measure) {\n      if (zwspSupported == null) {\n        var test2 = elt(\"span\", \"\\u200B\");\n        removeChildrenAndAdd(measure, elt(\"span\", [test2, document.createTextNode(\"x\")]));\n        if (measure.firstChild.offsetHeight != 0) {\n          zwspSupported = test2.offsetWidth <= 1 && test2.offsetHeight > 2 && !(ie2 && ie_version < 8);\n        }\n      }\n      var node = zwspSupported ? elt(\"span\", \"\\u200B\") : elt(\"span\", \"\\xA0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n      node.setAttribute(\"cm-text\", \"\");\n      return node;\n    }\n    var badBidiRects;\n    function hasBadBidiRects(measure) {\n      if (badBidiRects != null) {\n        return badBidiRects;\n      }\n      var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062EA\"));\n      var r0 = range2(txt, 0, 1).getBoundingClientRect();\n      var r1 = range2(txt, 1, 2).getBoundingClientRect();\n      removeChildren(measure);\n      if (!r0 || r0.left == r0.right) {\n        return false;\n      }\n      return badBidiRects = r1.right - r0.right < 3;\n    }\n    var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string2) {\n      var pos = 0, result2 = [], l2 = string2.length;\n      while (pos <= l2) {\n        var nl = string2.indexOf(\"\\n\", pos);\n        if (nl == -1) {\n          nl = string2.length;\n        }\n        var line = string2.slice(pos, string2.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n        var rt = line.indexOf(\"\\r\");\n        if (rt != -1) {\n          result2.push(line.slice(0, rt));\n          pos += rt + 1;\n        } else {\n          result2.push(line);\n          pos = nl + 1;\n        }\n      }\n      return result2;\n    } : function(string2) {\n      return string2.split(/\\r\\n?|\\n/);\n    };\n    var hasSelection = window.getSelection ? function(te2) {\n      try {\n        return te2.selectionStart != te2.selectionEnd;\n      } catch (e) {\n        return false;\n      }\n    } : function(te2) {\n      var range3;\n      try {\n        range3 = te2.ownerDocument.selection.createRange();\n      } catch (e) {\n      }\n      if (!range3 || range3.parentElement() != te2) {\n        return false;\n      }\n      return range3.compareEndPoints(\"StartToEnd\", range3) != 0;\n    };\n    var hasCopyEvent = function() {\n      var e = elt(\"div\");\n      if (\"oncopy\" in e) {\n        return true;\n      }\n      e.setAttribute(\"oncopy\", \"return;\");\n      return typeof e.oncopy == \"function\";\n    }();\n    var badZoomedRects = null;\n    function hasBadZoomedRects(measure) {\n      if (badZoomedRects != null) {\n        return badZoomedRects;\n      }\n      var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n      var normal = node.getBoundingClientRect();\n      var fromRange = range2(node, 0, 1).getBoundingClientRect();\n      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n    }\n    var modes = {}, mimeModes = {};\n    function defineMode(name2, mode2) {\n      if (arguments.length > 2) {\n        mode2.dependencies = Array.prototype.slice.call(arguments, 2);\n      }\n      modes[name2] = mode2;\n    }\n    function defineMIME(mime, spec) {\n      mimeModes[mime] = spec;\n    }\n    function resolveMode(spec) {\n      if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n        spec = mimeModes[spec];\n      } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n        var found = mimeModes[spec.name];\n        if (typeof found == \"string\") {\n          found = { name: found };\n        }\n        spec = createObj(found, spec);\n        spec.name = found.name;\n      } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n        return resolveMode(\"application/xml\");\n      } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n        return resolveMode(\"application/json\");\n      }\n      if (typeof spec == \"string\") {\n        return { name: spec };\n      } else {\n        return spec || { name: \"null\" };\n      }\n    }\n    function getMode(options, spec) {\n      spec = resolveMode(spec);\n      var mfactory = modes[spec.name];\n      if (!mfactory) {\n        return getMode(options, \"text/plain\");\n      }\n      var modeObj = mfactory(options, spec);\n      if (modeExtensions.hasOwnProperty(spec.name)) {\n        var exts = modeExtensions[spec.name];\n        for (var prop3 in exts) {\n          if (!exts.hasOwnProperty(prop3)) {\n            continue;\n          }\n          if (modeObj.hasOwnProperty(prop3)) {\n            modeObj[\"_\" + prop3] = modeObj[prop3];\n          }\n          modeObj[prop3] = exts[prop3];\n        }\n      }\n      modeObj.name = spec.name;\n      if (spec.helperType) {\n        modeObj.helperType = spec.helperType;\n      }\n      if (spec.modeProps) {\n        for (var prop$1 in spec.modeProps) {\n          modeObj[prop$1] = spec.modeProps[prop$1];\n        }\n      }\n      return modeObj;\n    }\n    var modeExtensions = {};\n    function extendMode(mode2, properties) {\n      var exts = modeExtensions.hasOwnProperty(mode2) ? modeExtensions[mode2] : modeExtensions[mode2] = {};\n      copyObj(properties, exts);\n    }\n    function copyState(mode2, state) {\n      if (state === true) {\n        return state;\n      }\n      if (mode2.copyState) {\n        return mode2.copyState(state);\n      }\n      var nstate = {};\n      for (var n2 in state) {\n        var val = state[n2];\n        if (val instanceof Array) {\n          val = val.concat([]);\n        }\n        nstate[n2] = val;\n      }\n      return nstate;\n    }\n    function innerMode(mode2, state) {\n      var info2;\n      while (mode2.innerMode) {\n        info2 = mode2.innerMode(state);\n        if (!info2 || info2.mode == mode2) {\n          break;\n        }\n        state = info2.state;\n        mode2 = info2.mode;\n      }\n      return info2 || { mode: mode2, state };\n    }\n    function startState(mode2, a1, a2) {\n      return mode2.startState ? mode2.startState(a1, a2) : true;\n    }\n    var StringStream = function(string2, tabSize, lineOracle) {\n      this.pos = this.start = 0;\n      this.string = string2;\n      this.tabSize = tabSize || 8;\n      this.lastColumnPos = this.lastColumnValue = 0;\n      this.lineStart = 0;\n      this.lineOracle = lineOracle;\n    };\n    StringStream.prototype.eol = function() {\n      return this.pos >= this.string.length;\n    };\n    StringStream.prototype.sol = function() {\n      return this.pos == this.lineStart;\n    };\n    StringStream.prototype.peek = function() {\n      return this.string.charAt(this.pos) || void 0;\n    };\n    StringStream.prototype.next = function() {\n      if (this.pos < this.string.length) {\n        return this.string.charAt(this.pos++);\n      }\n    };\n    StringStream.prototype.eat = function(match2) {\n      var ch2 = this.string.charAt(this.pos);\n      var ok2;\n      if (typeof match2 == \"string\") {\n        ok2 = ch2 == match2;\n      } else {\n        ok2 = ch2 && (match2.test ? match2.test(ch2) : match2(ch2));\n      }\n      if (ok2) {\n        ++this.pos;\n        return ch2;\n      }\n    };\n    StringStream.prototype.eatWhile = function(match2) {\n      var start2 = this.pos;\n      while (this.eat(match2)) {\n      }\n      return this.pos > start2;\n    };\n    StringStream.prototype.eatSpace = function() {\n      var start2 = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n        ++this.pos;\n      }\n      return this.pos > start2;\n    };\n    StringStream.prototype.skipToEnd = function() {\n      this.pos = this.string.length;\n    };\n    StringStream.prototype.skipTo = function(ch2) {\n      var found = this.string.indexOf(ch2, this.pos);\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    };\n    StringStream.prototype.backUp = function(n2) {\n      this.pos -= n2;\n    };\n    StringStream.prototype.column = function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    };\n    StringStream.prototype.indentation = function() {\n      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    };\n    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) {\n            this.pos += pattern.length;\n          }\n          return true;\n        }\n      } else {\n        var match2 = this.string.slice(this.pos).match(pattern);\n        if (match2 && match2.index > 0) {\n          return null;\n        }\n        if (match2 && consume !== false) {\n          this.pos += match2[0].length;\n        }\n        return match2;\n      }\n    };\n    StringStream.prototype.current = function() {\n      return this.string.slice(this.start, this.pos);\n    };\n    StringStream.prototype.hideFirstChars = function(n2, inner) {\n      this.lineStart += n2;\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n2;\n      }\n    };\n    StringStream.prototype.lookAhead = function(n2) {\n      var oracle = this.lineOracle;\n      return oracle && oracle.lookAhead(n2);\n    };\n    StringStream.prototype.baseToken = function() {\n      var oracle = this.lineOracle;\n      return oracle && oracle.baseToken(this.pos);\n    };\n    function getLine2(doc, n2) {\n      n2 -= doc.first;\n      if (n2 < 0 || n2 >= doc.size) {\n        throw new Error(\"There is no line \" + (n2 + doc.first) + \" in the document.\");\n      }\n      var chunk = doc;\n      while (!chunk.lines) {\n        for (var i2 = 0; ; ++i2) {\n          var child = chunk.children[i2], sz = child.chunkSize();\n          if (n2 < sz) {\n            chunk = child;\n            break;\n          }\n          n2 -= sz;\n        }\n      }\n      return chunk.lines[n2];\n    }\n    function getBetween(doc, start2, end2) {\n      var out = [], n2 = start2.line;\n      doc.iter(start2.line, end2.line + 1, function(line) {\n        var text3 = line.text;\n        if (n2 == end2.line) {\n          text3 = text3.slice(0, end2.ch);\n        }\n        if (n2 == start2.line) {\n          text3 = text3.slice(start2.ch);\n        }\n        out.push(text3);\n        ++n2;\n      });\n      return out;\n    }\n    function getLines2(doc, from, to) {\n      var out = [];\n      doc.iter(from, to, function(line) {\n        out.push(line.text);\n      });\n      return out;\n    }\n    function updateLineHeight(line, height) {\n      var diff2 = height - line.height;\n      if (diff2) {\n        for (var n2 = line; n2; n2 = n2.parent) {\n          n2.height += diff2;\n        }\n      }\n    }\n    function lineNo(line) {\n      if (line.parent == null) {\n        return null;\n      }\n      var cur = line.parent, no = indexOf(cur.lines, line);\n      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n        for (var i2 = 0; ; ++i2) {\n          if (chunk.children[i2] == cur) {\n            break;\n          }\n          no += chunk.children[i2].chunkSize();\n        }\n      }\n      return no + cur.first;\n    }\n    function lineAtHeight(chunk, h) {\n      var n2 = chunk.first;\n      outer:\n        do {\n          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {\n            var child = chunk.children[i$12], ch2 = child.height;\n            if (h < ch2) {\n              chunk = child;\n              continue outer;\n            }\n            h -= ch2;\n            n2 += child.chunkSize();\n          }\n          return n2;\n        } while (!chunk.lines);\n      var i2 = 0;\n      for (; i2 < chunk.lines.length; ++i2) {\n        var line = chunk.lines[i2], lh2 = line.height;\n        if (h < lh2) {\n          break;\n        }\n        h -= lh2;\n      }\n      return n2 + i2;\n    }\n    function isLine(doc, l2) {\n      return l2 >= doc.first && l2 < doc.first + doc.size;\n    }\n    function lineNumberFor(options, i2) {\n      return String(options.lineNumberFormatter(i2 + options.firstLineNumber));\n    }\n    function Pos(line, ch2, sticky) {\n      if (sticky === void 0)\n        sticky = null;\n      if (!(this instanceof Pos)) {\n        return new Pos(line, ch2, sticky);\n      }\n      this.line = line;\n      this.ch = ch2;\n      this.sticky = sticky;\n    }\n    function cmp(a, b) {\n      return a.line - b.line || a.ch - b.ch;\n    }\n    function equalCursorPos(a, b) {\n      return a.sticky == b.sticky && cmp(a, b) == 0;\n    }\n    function copyPos(x2) {\n      return Pos(x2.line, x2.ch);\n    }\n    function maxPos(a, b) {\n      return cmp(a, b) < 0 ? b : a;\n    }\n    function minPos(a, b) {\n      return cmp(a, b) < 0 ? a : b;\n    }\n    function clipLine(doc, n2) {\n      return Math.max(doc.first, Math.min(n2, doc.first + doc.size - 1));\n    }\n    function clipPos(doc, pos) {\n      if (pos.line < doc.first) {\n        return Pos(doc.first, 0);\n      }\n      var last = doc.first + doc.size - 1;\n      if (pos.line > last) {\n        return Pos(last, getLine2(doc, last).text.length);\n      }\n      return clipToLen(pos, getLine2(doc, pos.line).text.length);\n    }\n    function clipToLen(pos, linelen) {\n      var ch2 = pos.ch;\n      if (ch2 == null || ch2 > linelen) {\n        return Pos(pos.line, linelen);\n      } else if (ch2 < 0) {\n        return Pos(pos.line, 0);\n      } else {\n        return pos;\n      }\n    }\n    function clipPosArray(doc, array) {\n      var out = [];\n      for (var i2 = 0; i2 < array.length; i2++) {\n        out[i2] = clipPos(doc, array[i2]);\n      }\n      return out;\n    }\n    var SavedContext = function(state, lookAhead) {\n      this.state = state;\n      this.lookAhead = lookAhead;\n    };\n    var Context = function(doc, state, line, lookAhead) {\n      this.state = state;\n      this.doc = doc;\n      this.line = line;\n      this.maxLookAhead = lookAhead || 0;\n      this.baseTokens = null;\n      this.baseTokenPos = 1;\n    };\n    Context.prototype.lookAhead = function(n2) {\n      var line = this.doc.getLine(this.line + n2);\n      if (line != null && n2 > this.maxLookAhead) {\n        this.maxLookAhead = n2;\n      }\n      return line;\n    };\n    Context.prototype.baseToken = function(n2) {\n      if (!this.baseTokens) {\n        return null;\n      }\n      while (this.baseTokens[this.baseTokenPos] <= n2) {\n        this.baseTokenPos += 2;\n      }\n      var type2 = this.baseTokens[this.baseTokenPos + 1];\n      return {\n        type: type2 && type2.replace(/( |^)overlay .*/, \"\"),\n        size: this.baseTokens[this.baseTokenPos] - n2\n      };\n    };\n    Context.prototype.nextLine = function() {\n      this.line++;\n      if (this.maxLookAhead > 0) {\n        this.maxLookAhead--;\n      }\n    };\n    Context.fromSaved = function(doc, saved, line) {\n      if (saved instanceof SavedContext) {\n        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);\n      } else {\n        return new Context(doc, copyState(doc.mode, saved), line);\n      }\n    };\n    Context.prototype.save = function(copy2) {\n      var state = copy2 !== false ? copyState(this.doc.mode, this.state) : this.state;\n      return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n    };\n    function highlightLine(cm, line, context, forceToEnd) {\n      var st = [cm.state.modeGen], lineClasses = {};\n      runMode(cm, line.text, cm.doc.mode, context, function(end2, style) {\n        return st.push(end2, style);\n      }, lineClasses, forceToEnd);\n      var state = context.state;\n      var loop = function(o2) {\n        context.baseTokens = st;\n        var overlay = cm.state.overlays[o2], i2 = 1, at = 0;\n        context.state = true;\n        runMode(cm, line.text, overlay.mode, context, function(end2, style) {\n          var start2 = i2;\n          while (at < end2) {\n            var i_end = st[i2];\n            if (i_end > end2) {\n              st.splice(i2, 1, end2, st[i2 + 1], i_end);\n            }\n            i2 += 2;\n            at = Math.min(end2, i_end);\n          }\n          if (!style) {\n            return;\n          }\n          if (overlay.opaque) {\n            st.splice(start2, i2 - start2, end2, \"overlay \" + style);\n            i2 = start2 + 2;\n          } else {\n            for (; start2 < i2; start2 += 2) {\n              var cur = st[start2 + 1];\n              st[start2 + 1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n            }\n          }\n        }, lineClasses);\n        context.state = state;\n        context.baseTokens = null;\n        context.baseTokenPos = 1;\n      };\n      for (var o = 0; o < cm.state.overlays.length; ++o)\n        loop(o);\n      return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };\n    }\n    function getLineStyles(cm, line, updateFrontier) {\n      if (!line.styles || line.styles[0] != cm.state.modeGen) {\n        var context = getContextBefore(cm, lineNo(line));\n        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n        var result2 = highlightLine(cm, line, context);\n        if (resetState) {\n          context.state = resetState;\n        }\n        line.stateAfter = context.save(!resetState);\n        line.styles = result2.styles;\n        if (result2.classes) {\n          line.styleClasses = result2.classes;\n        } else if (line.styleClasses) {\n          line.styleClasses = null;\n        }\n        if (updateFrontier === cm.doc.highlightFrontier) {\n          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n        }\n      }\n      return line.styles;\n    }\n    function getContextBefore(cm, n2, precise) {\n      var doc = cm.doc, display = cm.display;\n      if (!doc.mode.startState) {\n        return new Context(doc, true, n2);\n      }\n      var start2 = findStartLine(cm, n2, precise);\n      var saved = start2 > doc.first && getLine2(doc, start2 - 1).stateAfter;\n      var context = saved ? Context.fromSaved(doc, saved, start2) : new Context(doc, startState(doc.mode), start2);\n      doc.iter(start2, n2, function(line) {\n        processLine(cm, line.text, context);\n        var pos = context.line;\n        line.stateAfter = pos == n2 - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n        context.nextLine();\n      });\n      if (precise) {\n        doc.modeFrontier = context.line;\n      }\n      return context;\n    }\n    function processLine(cm, text3, context, startAt) {\n      var mode2 = cm.doc.mode;\n      var stream = new StringStream(text3, cm.options.tabSize, context);\n      stream.start = stream.pos = startAt || 0;\n      if (text3 == \"\") {\n        callBlankLine(mode2, context.state);\n      }\n      while (!stream.eol()) {\n        readToken(mode2, stream, context.state);\n        stream.start = stream.pos;\n      }\n    }\n    function callBlankLine(mode2, state) {\n      if (mode2.blankLine) {\n        return mode2.blankLine(state);\n      }\n      if (!mode2.innerMode) {\n        return;\n      }\n      var inner = innerMode(mode2, state);\n      if (inner.mode.blankLine) {\n        return inner.mode.blankLine(inner.state);\n      }\n    }\n    function readToken(mode2, stream, state, inner) {\n      for (var i2 = 0; i2 < 10; i2++) {\n        if (inner) {\n          inner[0] = innerMode(mode2, state).mode;\n        }\n        var style = mode2.token(stream, state);\n        if (stream.pos > stream.start) {\n          return style;\n        }\n      }\n      throw new Error(\"Mode \" + mode2.name + \" failed to advance stream.\");\n    }\n    var Token2 = function(stream, type2, state) {\n      this.start = stream.start;\n      this.end = stream.pos;\n      this.string = stream.current();\n      this.type = type2 || null;\n      this.state = state;\n    };\n    function takeToken(cm, pos, precise, asArray) {\n      var doc = cm.doc, mode2 = doc.mode, style;\n      pos = clipPos(doc, pos);\n      var line = getLine2(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n      var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n      if (asArray) {\n        tokens = [];\n      }\n      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n        stream.start = stream.pos;\n        style = readToken(mode2, stream, context.state);\n        if (asArray) {\n          tokens.push(new Token2(stream, style, copyState(doc.mode, context.state)));\n        }\n      }\n      return asArray ? tokens : new Token2(stream, style, context.state);\n    }\n    function extractLineClasses(type2, output) {\n      if (type2) {\n        for (; ; ) {\n          var lineClass = type2.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n          if (!lineClass) {\n            break;\n          }\n          type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);\n          var prop3 = lineClass[1] ? \"bgClass\" : \"textClass\";\n          if (output[prop3] == null) {\n            output[prop3] = lineClass[2];\n          } else if (!new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\").test(output[prop3])) {\n            output[prop3] += \" \" + lineClass[2];\n          }\n        }\n      }\n      return type2;\n    }\n    function runMode(cm, text3, mode2, context, f, lineClasses, forceToEnd) {\n      var flattenSpans = mode2.flattenSpans;\n      if (flattenSpans == null) {\n        flattenSpans = cm.options.flattenSpans;\n      }\n      var curStart = 0, curStyle = null;\n      var stream = new StringStream(text3, cm.options.tabSize, context), style;\n      var inner = cm.options.addModeClass && [null];\n      if (text3 == \"\") {\n        extractLineClasses(callBlankLine(mode2, context.state), lineClasses);\n      }\n      while (!stream.eol()) {\n        if (stream.pos > cm.options.maxHighlightLength) {\n          flattenSpans = false;\n          if (forceToEnd) {\n            processLine(cm, text3, context, stream.pos);\n          }\n          stream.pos = text3.length;\n          style = null;\n        } else {\n          style = extractLineClasses(readToken(mode2, stream, context.state, inner), lineClasses);\n        }\n        if (inner) {\n          var mName = inner[0].name;\n          if (mName) {\n            style = \"m-\" + (style ? mName + \" \" + style : mName);\n          }\n        }\n        if (!flattenSpans || curStyle != style) {\n          while (curStart < stream.start) {\n            curStart = Math.min(stream.start, curStart + 5e3);\n            f(curStart, curStyle);\n          }\n          curStyle = style;\n        }\n        stream.start = stream.pos;\n      }\n      while (curStart < stream.pos) {\n        var pos = Math.min(stream.pos, curStart + 5e3);\n        f(pos, curStyle);\n        curStart = pos;\n      }\n    }\n    function findStartLine(cm, n2, precise) {\n      var minindent, minline, doc = cm.doc;\n      var lim = precise ? -1 : n2 - (cm.doc.mode.innerMode ? 1e3 : 100);\n      for (var search2 = n2; search2 > lim; --search2) {\n        if (search2 <= doc.first) {\n          return doc.first;\n        }\n        var line = getLine2(doc, search2 - 1), after = line.stateAfter;\n        if (after && (!precise || search2 + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {\n          return search2;\n        }\n        var indented = countColumn(line.text, null, cm.options.tabSize);\n        if (minline == null || minindent > indented) {\n          minline = search2 - 1;\n          minindent = indented;\n        }\n      }\n      return minline;\n    }\n    function retreatFrontier(doc, n2) {\n      doc.modeFrontier = Math.min(doc.modeFrontier, n2);\n      if (doc.highlightFrontier < n2 - 10) {\n        return;\n      }\n      var start2 = doc.first;\n      for (var line = n2 - 1; line > start2; line--) {\n        var saved = getLine2(doc, line).stateAfter;\n        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n2)) {\n          start2 = line + 1;\n          break;\n        }\n      }\n      doc.highlightFrontier = Math.min(doc.highlightFrontier, start2);\n    }\n    var sawReadOnlySpans = false, sawCollapsedSpans = false;\n    function seeReadOnlySpans() {\n      sawReadOnlySpans = true;\n    }\n    function seeCollapsedSpans() {\n      sawCollapsedSpans = true;\n    }\n    function MarkedSpan(marker2, from, to) {\n      this.marker = marker2;\n      this.from = from;\n      this.to = to;\n    }\n    function getMarkedSpanFor(spans, marker2) {\n      if (spans) {\n        for (var i2 = 0; i2 < spans.length; ++i2) {\n          var span = spans[i2];\n          if (span.marker == marker2) {\n            return span;\n          }\n        }\n      }\n    }\n    function removeMarkedSpan(spans, span) {\n      var r2;\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        if (spans[i2] != span) {\n          (r2 || (r2 = [])).push(spans[i2]);\n        }\n      }\n      return r2;\n    }\n    function addMarkedSpan(line, span, op) {\n      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));\n      if (inThisOp && inThisOp.has(line.markedSpans)) {\n        line.markedSpans.push(span);\n      } else {\n        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n        if (inThisOp) {\n          inThisOp.add(line.markedSpans);\n        }\n      }\n      span.marker.attachLine(line);\n    }\n    function markedSpansBefore(old, startCh, isInsert) {\n      var nw;\n      if (old) {\n        for (var i2 = 0; i2 < old.length; ++i2) {\n          var span = old[i2], marker2 = span.marker;\n          var startsBefore = span.from == null || (marker2.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n          if (startsBefore || span.from == startCh && marker2.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n            var endsAfter = span.to == null || (marker2.inclusiveRight ? span.to >= startCh : span.to > startCh);\n            (nw || (nw = [])).push(new MarkedSpan(marker2, span.from, endsAfter ? null : span.to));\n          }\n        }\n      }\n      return nw;\n    }\n    function markedSpansAfter(old, endCh, isInsert) {\n      var nw;\n      if (old) {\n        for (var i2 = 0; i2 < old.length; ++i2) {\n          var span = old[i2], marker2 = span.marker;\n          var endsAfter = span.to == null || (marker2.inclusiveRight ? span.to >= endCh : span.to > endCh);\n          if (endsAfter || span.from == endCh && marker2.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n            var startsBefore = span.from == null || (marker2.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n            (nw || (nw = [])).push(new MarkedSpan(marker2, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n          }\n        }\n      }\n      return nw;\n    }\n    function stretchSpansOverChange(doc, change) {\n      if (change.full) {\n        return null;\n      }\n      var oldFirst = isLine(doc, change.from.line) && getLine2(doc, change.from.line).markedSpans;\n      var oldLast = isLine(doc, change.to.line) && getLine2(doc, change.to.line).markedSpans;\n      if (!oldFirst && !oldLast) {\n        return null;\n      }\n      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n      var first = markedSpansBefore(oldFirst, startCh, isInsert);\n      var last = markedSpansAfter(oldLast, endCh, isInsert);\n      var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n      if (first) {\n        for (var i2 = 0; i2 < first.length; ++i2) {\n          var span = first[i2];\n          if (span.to == null) {\n            var found = getMarkedSpanFor(last, span.marker);\n            if (!found) {\n              span.to = startCh;\n            } else if (sameLine) {\n              span.to = found.to == null ? null : found.to + offset;\n            }\n          }\n        }\n      }\n      if (last) {\n        for (var i$12 = 0; i$12 < last.length; ++i$12) {\n          var span$1 = last[i$12];\n          if (span$1.to != null) {\n            span$1.to += offset;\n          }\n          if (span$1.from == null) {\n            var found$1 = getMarkedSpanFor(first, span$1.marker);\n            if (!found$1) {\n              span$1.from = offset;\n              if (sameLine) {\n                (first || (first = [])).push(span$1);\n              }\n            }\n          } else {\n            span$1.from += offset;\n            if (sameLine) {\n              (first || (first = [])).push(span$1);\n            }\n          }\n        }\n      }\n      if (first) {\n        first = clearEmptySpans(first);\n      }\n      if (last && last != first) {\n        last = clearEmptySpans(last);\n      }\n      var newMarkers = [first];\n      if (!sameLine) {\n        var gap2 = change.text.length - 2, gapMarkers;\n        if (gap2 > 0 && first) {\n          for (var i$22 = 0; i$22 < first.length; ++i$22) {\n            if (first[i$22].to == null) {\n              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));\n            }\n          }\n        }\n        for (var i$3 = 0; i$3 < gap2; ++i$3) {\n          newMarkers.push(gapMarkers);\n        }\n        newMarkers.push(last);\n      }\n      return newMarkers;\n    }\n    function clearEmptySpans(spans) {\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        var span = spans[i2];\n        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n          spans.splice(i2--, 1);\n        }\n      }\n      if (!spans.length) {\n        return null;\n      }\n      return spans;\n    }\n    function removeReadOnlyRanges(doc, from, to) {\n      var markers = null;\n      doc.iter(from.line, to.line + 1, function(line) {\n        if (line.markedSpans) {\n          for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {\n            var mark = line.markedSpans[i3].marker;\n            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {\n              (markers || (markers = [])).push(mark);\n            }\n          }\n        }\n      });\n      if (!markers) {\n        return null;\n      }\n      var parts = [{ from, to }];\n      for (var i2 = 0; i2 < markers.length; ++i2) {\n        var mk2 = markers[i2], m2 = mk2.find(0);\n        for (var j = 0; j < parts.length; ++j) {\n          var p2 = parts[j];\n          if (cmp(p2.to, m2.from) < 0 || cmp(p2.from, m2.to) > 0) {\n            continue;\n          }\n          var newParts = [j, 1], dfrom = cmp(p2.from, m2.from), dto = cmp(p2.to, m2.to);\n          if (dfrom < 0 || !mk2.inclusiveLeft && !dfrom) {\n            newParts.push({ from: p2.from, to: m2.from });\n          }\n          if (dto > 0 || !mk2.inclusiveRight && !dto) {\n            newParts.push({ from: m2.to, to: p2.to });\n          }\n          parts.splice.apply(parts, newParts);\n          j += newParts.length - 3;\n        }\n      }\n      return parts;\n    }\n    function detachMarkedSpans(line) {\n      var spans = line.markedSpans;\n      if (!spans) {\n        return;\n      }\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        spans[i2].marker.detachLine(line);\n      }\n      line.markedSpans = null;\n    }\n    function attachMarkedSpans(line, spans) {\n      if (!spans) {\n        return;\n      }\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        spans[i2].marker.attachLine(line);\n      }\n      line.markedSpans = spans;\n    }\n    function extraLeft(marker2) {\n      return marker2.inclusiveLeft ? -1 : 0;\n    }\n    function extraRight(marker2) {\n      return marker2.inclusiveRight ? 1 : 0;\n    }\n    function compareCollapsedMarkers(a, b) {\n      var lenDiff = a.lines.length - b.lines.length;\n      if (lenDiff != 0) {\n        return lenDiff;\n      }\n      var aPos = a.find(), bPos = b.find();\n      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n      if (fromCmp) {\n        return -fromCmp;\n      }\n      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n      if (toCmp) {\n        return toCmp;\n      }\n      return b.id - a.id;\n    }\n    function collapsedSpanAtSide(line, start2) {\n      var sps = sawCollapsedSpans && line.markedSpans, found;\n      if (sps) {\n        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {\n          sp = sps[i2];\n          if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n            found = sp.marker;\n          }\n        }\n      }\n      return found;\n    }\n    function collapsedSpanAtStart(line) {\n      return collapsedSpanAtSide(line, true);\n    }\n    function collapsedSpanAtEnd(line) {\n      return collapsedSpanAtSide(line, false);\n    }\n    function collapsedSpanAround(line, ch2) {\n      var sps = sawCollapsedSpans && line.markedSpans, found;\n      if (sps) {\n        for (var i2 = 0; i2 < sps.length; ++i2) {\n          var sp = sps[i2];\n          if (sp.marker.collapsed && (sp.from == null || sp.from < ch2) && (sp.to == null || sp.to > ch2) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n            found = sp.marker;\n          }\n        }\n      }\n      return found;\n    }\n    function conflictingCollapsedRange(doc, lineNo2, from, to, marker2) {\n      var line = getLine2(doc, lineNo2);\n      var sps = sawCollapsedSpans && line.markedSpans;\n      if (sps) {\n        for (var i2 = 0; i2 < sps.length; ++i2) {\n          var sp = sps[i2];\n          if (!sp.marker.collapsed) {\n            continue;\n          }\n          var found = sp.marker.find(0);\n          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker2);\n          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker2);\n          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n            continue;\n          }\n          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker2.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker2.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {\n            return true;\n          }\n        }\n      }\n    }\n    function visualLine(line) {\n      var merged;\n      while (merged = collapsedSpanAtStart(line)) {\n        line = merged.find(-1, true).line;\n      }\n      return line;\n    }\n    function visualLineEnd(line) {\n      var merged;\n      while (merged = collapsedSpanAtEnd(line)) {\n        line = merged.find(1, true).line;\n      }\n      return line;\n    }\n    function visualLineContinued(line) {\n      var merged, lines;\n      while (merged = collapsedSpanAtEnd(line)) {\n        line = merged.find(1, true).line;\n        (lines || (lines = [])).push(line);\n      }\n      return lines;\n    }\n    function visualLineNo(doc, lineN) {\n      var line = getLine2(doc, lineN), vis = visualLine(line);\n      if (line == vis) {\n        return lineN;\n      }\n      return lineNo(vis);\n    }\n    function visualLineEndNo(doc, lineN) {\n      if (lineN > doc.lastLine()) {\n        return lineN;\n      }\n      var line = getLine2(doc, lineN), merged;\n      if (!lineIsHidden(doc, line)) {\n        return lineN;\n      }\n      while (merged = collapsedSpanAtEnd(line)) {\n        line = merged.find(1, true).line;\n      }\n      return lineNo(line) + 1;\n    }\n    function lineIsHidden(doc, line) {\n      var sps = sawCollapsedSpans && line.markedSpans;\n      if (sps) {\n        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {\n          sp = sps[i2];\n          if (!sp.marker.collapsed) {\n            continue;\n          }\n          if (sp.from == null) {\n            return true;\n          }\n          if (sp.marker.widgetNode) {\n            continue;\n          }\n          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {\n            return true;\n          }\n        }\n      }\n    }\n    function lineIsHiddenInner(doc, line, span) {\n      if (span.to == null) {\n        var end2 = span.marker.find(1, true);\n        return lineIsHiddenInner(doc, end2.line, getMarkedSpanFor(end2.line.markedSpans, span.marker));\n      }\n      if (span.marker.inclusiveRight && span.to == line.text.length) {\n        return true;\n      }\n      for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {\n        sp = line.markedSpans[i2];\n        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {\n          return true;\n        }\n      }\n    }\n    function heightAtLine(lineObj) {\n      lineObj = visualLine(lineObj);\n      var h = 0, chunk = lineObj.parent;\n      for (var i2 = 0; i2 < chunk.lines.length; ++i2) {\n        var line = chunk.lines[i2];\n        if (line == lineObj) {\n          break;\n        } else {\n          h += line.height;\n        }\n      }\n      for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {\n        for (var i$12 = 0; i$12 < p2.children.length; ++i$12) {\n          var cur = p2.children[i$12];\n          if (cur == chunk) {\n            break;\n          } else {\n            h += cur.height;\n          }\n        }\n      }\n      return h;\n    }\n    function lineLength(line) {\n      if (line.height == 0) {\n        return 0;\n      }\n      var len = line.text.length, merged, cur = line;\n      while (merged = collapsedSpanAtStart(cur)) {\n        var found = merged.find(0, true);\n        cur = found.from.line;\n        len += found.from.ch - found.to.ch;\n      }\n      cur = line;\n      while (merged = collapsedSpanAtEnd(cur)) {\n        var found$1 = merged.find(0, true);\n        len -= cur.text.length - found$1.from.ch;\n        cur = found$1.to.line;\n        len += cur.text.length - found$1.to.ch;\n      }\n      return len;\n    }\n    function findMaxLine(cm) {\n      var d = cm.display, doc = cm.doc;\n      d.maxLine = getLine2(doc, doc.first);\n      d.maxLineLength = lineLength(d.maxLine);\n      d.maxLineChanged = true;\n      doc.iter(function(line) {\n        var len = lineLength(line);\n        if (len > d.maxLineLength) {\n          d.maxLineLength = len;\n          d.maxLine = line;\n        }\n      });\n    }\n    var Line = function(text3, markedSpans, estimateHeight2) {\n      this.text = text3;\n      attachMarkedSpans(this, markedSpans);\n      this.height = estimateHeight2 ? estimateHeight2(this) : 1;\n    };\n    Line.prototype.lineNo = function() {\n      return lineNo(this);\n    };\n    eventMixin(Line);\n    function updateLine(line, text3, markedSpans, estimateHeight2) {\n      line.text = text3;\n      if (line.stateAfter) {\n        line.stateAfter = null;\n      }\n      if (line.styles) {\n        line.styles = null;\n      }\n      if (line.order != null) {\n        line.order = null;\n      }\n      detachMarkedSpans(line);\n      attachMarkedSpans(line, markedSpans);\n      var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;\n      if (estHeight != line.height) {\n        updateLineHeight(line, estHeight);\n      }\n    }\n    function cleanUpLine(line) {\n      line.parent = null;\n      detachMarkedSpans(line);\n    }\n    var styleToClassCache = {}, styleToClassCacheWithMode = {};\n    function interpretTokenStyle(style, options) {\n      if (!style || /^\\s*$/.test(style)) {\n        return null;\n      }\n      var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n      return cache[style] || (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n    }\n    function buildLineContent(cm, lineView) {\n      var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n      var builder = {\n        pre: eltP(\"pre\", [content], \"CodeMirror-line\"),\n        content,\n        col: 0,\n        pos: 0,\n        cm,\n        trailingSpace: false,\n        splitSpaces: cm.getOption(\"lineWrapping\")\n      };\n      lineView.measure = {};\n      for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {\n        var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order2 = void 0;\n        builder.pos = 0;\n        builder.addToken = buildToken2;\n        if (hasBadBidiRects(cm.display.measure) && (order2 = getOrder(line, cm.doc.direction))) {\n          builder.addToken = buildTokenBadBidi(builder.addToken, order2);\n        }\n        builder.map = [];\n        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n        if (line.styleClasses) {\n          if (line.styleClasses.bgClass) {\n            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n          }\n          if (line.styleClasses.textClass) {\n            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n          }\n        }\n        if (builder.map.length == 0) {\n          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n        }\n        if (i2 == 0) {\n          lineView.measure.map = builder.map;\n          lineView.measure.cache = {};\n        } else {\n          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n          (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n        }\n      }\n      if (webkit) {\n        var last = builder.content.lastChild;\n        if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(\".cm-tab\")) {\n          builder.content.className = \"cm-tab-wrap-hack\";\n        }\n      }\n      signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n      if (builder.pre.className) {\n        builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n      }\n      return builder;\n    }\n    function defaultSpecialCharPlaceholder(ch2) {\n      var token2 = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n      token2.title = \"\\\\u\" + ch2.charCodeAt(0).toString(16);\n      token2.setAttribute(\"aria-label\", token2.title);\n      return token2;\n    }\n    function buildToken2(builder, text3, style, startStyle, endStyle, css, attributes) {\n      if (!text3) {\n        return;\n      }\n      var displayText = builder.splitSpaces ? splitSpaces(text3, builder.trailingSpace) : text3;\n      var special = builder.cm.state.specialChars, mustWrap = false;\n      var content;\n      if (!special.test(text3)) {\n        builder.col += text3.length;\n        content = document.createTextNode(displayText);\n        builder.map.push(builder.pos, builder.pos + text3.length, content);\n        if (ie2 && ie_version < 9) {\n          mustWrap = true;\n        }\n        builder.pos += text3.length;\n      } else {\n        content = document.createDocumentFragment();\n        var pos = 0;\n        while (true) {\n          special.lastIndex = pos;\n          var m2 = special.exec(text3);\n          var skipped = m2 ? m2.index - pos : text3.length - pos;\n          if (skipped) {\n            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n            if (ie2 && ie_version < 9) {\n              content.appendChild(elt(\"span\", [txt]));\n            } else {\n              content.appendChild(txt);\n            }\n            builder.map.push(builder.pos, builder.pos + skipped, txt);\n            builder.col += skipped;\n            builder.pos += skipped;\n          }\n          if (!m2) {\n            break;\n          }\n          pos += skipped + 1;\n          var txt$1 = void 0;\n          if (m2[0] == \"\t\") {\n            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n            txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n            txt$1.setAttribute(\"role\", \"presentation\");\n            txt$1.setAttribute(\"cm-text\", \"\t\");\n            builder.col += tabWidth;\n          } else if (m2[0] == \"\\r\" || m2[0] == \"\\n\") {\n            txt$1 = content.appendChild(elt(\"span\", m2[0] == \"\\r\" ? \"\\u240D\" : \"\\u2424\", \"cm-invalidchar\"));\n            txt$1.setAttribute(\"cm-text\", m2[0]);\n            builder.col += 1;\n          } else {\n            txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);\n            txt$1.setAttribute(\"cm-text\", m2[0]);\n            if (ie2 && ie_version < 9) {\n              content.appendChild(elt(\"span\", [txt$1]));\n            } else {\n              content.appendChild(txt$1);\n            }\n            builder.col += 1;\n          }\n          builder.map.push(builder.pos, builder.pos + 1, txt$1);\n          builder.pos++;\n        }\n      }\n      builder.trailingSpace = displayText.charCodeAt(text3.length - 1) == 32;\n      if (style || startStyle || endStyle || mustWrap || css || attributes) {\n        var fullStyle = style || \"\";\n        if (startStyle) {\n          fullStyle += startStyle;\n        }\n        if (endStyle) {\n          fullStyle += endStyle;\n        }\n        var token2 = elt(\"span\", [content], fullStyle, css);\n        if (attributes) {\n          for (var attr in attributes) {\n            if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\") {\n              token2.setAttribute(attr, attributes[attr]);\n            }\n          }\n        }\n        return builder.content.appendChild(token2);\n      }\n      builder.content.appendChild(content);\n    }\n    function splitSpaces(text3, trailingBefore) {\n      if (text3.length > 1 && !/  /.test(text3)) {\n        return text3;\n      }\n      var spaceBefore = trailingBefore, result2 = \"\";\n      for (var i2 = 0; i2 < text3.length; i2++) {\n        var ch2 = text3.charAt(i2);\n        if (ch2 == \" \" && spaceBefore && (i2 == text3.length - 1 || text3.charCodeAt(i2 + 1) == 32)) {\n          ch2 = \"\\xA0\";\n        }\n        result2 += ch2;\n        spaceBefore = ch2 == \" \";\n      }\n      return result2;\n    }\n    function buildTokenBadBidi(inner, order2) {\n      return function(builder, text3, style, startStyle, endStyle, css, attributes) {\n        style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n        var start2 = builder.pos, end2 = start2 + text3.length;\n        for (; ; ) {\n          var part2 = void 0;\n          for (var i2 = 0; i2 < order2.length; i2++) {\n            part2 = order2[i2];\n            if (part2.to > start2 && part2.from <= start2) {\n              break;\n            }\n          }\n          if (part2.to >= end2) {\n            return inner(builder, text3, style, startStyle, endStyle, css, attributes);\n          }\n          inner(builder, text3.slice(0, part2.to - start2), style, startStyle, null, css, attributes);\n          startStyle = null;\n          text3 = text3.slice(part2.to - start2);\n          start2 = part2.to;\n        }\n      };\n    }\n    function buildCollapsedSpan(builder, size, marker2, ignoreWidget) {\n      var widget = !ignoreWidget && marker2.widgetNode;\n      if (widget) {\n        builder.map.push(builder.pos, builder.pos + size, widget);\n      }\n      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n        if (!widget) {\n          widget = builder.content.appendChild(document.createElement(\"span\"));\n        }\n        widget.setAttribute(\"cm-marker\", marker2.id);\n      }\n      if (widget) {\n        builder.cm.display.input.setUneditable(widget);\n        builder.content.appendChild(widget);\n      }\n      builder.pos += size;\n      builder.trailingSpace = false;\n    }\n    function insertLineContent(line, builder, styles2) {\n      var spans = line.markedSpans, allText = line.text, at = 0;\n      if (!spans) {\n        for (var i$12 = 1; i$12 < styles2.length; i$12 += 2) {\n          builder.addToken(builder, allText.slice(at, at = styles2[i$12]), interpretTokenStyle(styles2[i$12 + 1], builder.cm.options));\n        }\n        return;\n      }\n      var len = allText.length, pos = 0, i2 = 1, text3 = \"\", style, css;\n      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n      for (; ; ) {\n        if (nextChange == pos) {\n          spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n          attributes = null;\n          collapsed = null;\n          nextChange = Infinity;\n          var foundBookmarks = [], endStyles = void 0;\n          for (var j = 0; j < spans.length; ++j) {\n            var sp = spans[j], m2 = sp.marker;\n            if (m2.type == \"bookmark\" && sp.from == pos && m2.widgetNode) {\n              foundBookmarks.push(m2);\n            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {\n              if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n                nextChange = sp.to;\n                spanEndStyle = \"\";\n              }\n              if (m2.className) {\n                spanStyle += \" \" + m2.className;\n              }\n              if (m2.css) {\n                css = (css ? css + \";\" : \"\") + m2.css;\n              }\n              if (m2.startStyle && sp.from == pos) {\n                spanStartStyle += \" \" + m2.startStyle;\n              }\n              if (m2.endStyle && sp.to == nextChange) {\n                (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);\n              }\n              if (m2.title) {\n                (attributes || (attributes = {})).title = m2.title;\n              }\n              if (m2.attributes) {\n                for (var attr in m2.attributes) {\n                  (attributes || (attributes = {}))[attr] = m2.attributes[attr];\n                }\n              }\n              if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {\n                collapsed = sp;\n              }\n            } else if (sp.from > pos && nextChange > sp.from) {\n              nextChange = sp.from;\n            }\n          }\n          if (endStyles) {\n            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {\n              if (endStyles[j$1 + 1] == nextChange) {\n                spanEndStyle += \" \" + endStyles[j$1];\n              }\n            }\n          }\n          if (!collapsed || collapsed.from == pos) {\n            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {\n              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n            }\n          }\n          if (collapsed && (collapsed.from || 0) == pos) {\n            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n            if (collapsed.to == null) {\n              return;\n            }\n            if (collapsed.to == pos) {\n              collapsed = false;\n            }\n          }\n        }\n        if (pos >= len) {\n          break;\n        }\n        var upto = Math.min(len, nextChange);\n        while (true) {\n          if (text3) {\n            var end2 = pos + text3.length;\n            if (!collapsed) {\n              var tokenText = end2 > upto ? text3.slice(0, upto - pos) : text3;\n              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n            }\n            if (end2 >= upto) {\n              text3 = text3.slice(upto - pos);\n              pos = upto;\n              break;\n            }\n            pos = end2;\n            spanStartStyle = \"\";\n          }\n          text3 = allText.slice(at, at = styles2[i2++]);\n          style = interpretTokenStyle(styles2[i2++], builder.cm.options);\n        }\n      }\n    }\n    function LineView(doc, line, lineN) {\n      this.line = line;\n      this.rest = visualLineContinued(line);\n      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n      this.node = this.text = null;\n      this.hidden = lineIsHidden(doc, line);\n    }\n    function buildViewArray(cm, from, to) {\n      var array = [], nextPos;\n      for (var pos = from; pos < to; pos = nextPos) {\n        var view = new LineView(cm.doc, getLine2(cm.doc, pos), pos);\n        nextPos = pos + view.size;\n        array.push(view);\n      }\n      return array;\n    }\n    var operationGroup = null;\n    function pushOperation(op) {\n      if (operationGroup) {\n        operationGroup.ops.push(op);\n      } else {\n        op.ownsGroup = operationGroup = {\n          ops: [op],\n          delayedCallbacks: []\n        };\n      }\n    }\n    function fireCallbacksForOps(group) {\n      var callbacks = group.delayedCallbacks, i2 = 0;\n      do {\n        for (; i2 < callbacks.length; i2++) {\n          callbacks[i2].call(null);\n        }\n        for (var j = 0; j < group.ops.length; j++) {\n          var op = group.ops[j];\n          if (op.cursorActivityHandlers) {\n            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {\n              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n            }\n          }\n        }\n      } while (i2 < callbacks.length);\n    }\n    function finishOperation(op, endCb) {\n      var group = op.ownsGroup;\n      if (!group) {\n        return;\n      }\n      try {\n        fireCallbacksForOps(group);\n      } finally {\n        operationGroup = null;\n        endCb(group);\n      }\n    }\n    var orphanDelayedCallbacks = null;\n    function signalLater(emitter, type2) {\n      var arr = getHandlers(emitter, type2);\n      if (!arr.length) {\n        return;\n      }\n      var args = Array.prototype.slice.call(arguments, 2), list3;\n      if (operationGroup) {\n        list3 = operationGroup.delayedCallbacks;\n      } else if (orphanDelayedCallbacks) {\n        list3 = orphanDelayedCallbacks;\n      } else {\n        list3 = orphanDelayedCallbacks = [];\n        setTimeout(fireOrphanDelayed, 0);\n      }\n      var loop = function(i3) {\n        list3.push(function() {\n          return arr[i3].apply(null, args);\n        });\n      };\n      for (var i2 = 0; i2 < arr.length; ++i2)\n        loop(i2);\n    }\n    function fireOrphanDelayed() {\n      var delayed = orphanDelayedCallbacks;\n      orphanDelayedCallbacks = null;\n      for (var i2 = 0; i2 < delayed.length; ++i2) {\n        delayed[i2]();\n      }\n    }\n    function updateLineForChanges(cm, lineView, lineN, dims) {\n      for (var j = 0; j < lineView.changes.length; j++) {\n        var type2 = lineView.changes[j];\n        if (type2 == \"text\") {\n          updateLineText(cm, lineView);\n        } else if (type2 == \"gutter\") {\n          updateLineGutter(cm, lineView, lineN, dims);\n        } else if (type2 == \"class\") {\n          updateLineClasses(cm, lineView);\n        } else if (type2 == \"widget\") {\n          updateLineWidgets(cm, lineView, dims);\n        }\n      }\n      lineView.changes = null;\n    }\n    function ensureLineWrapped(lineView) {\n      if (lineView.node == lineView.text) {\n        lineView.node = elt(\"div\", null, null, \"position: relative\");\n        if (lineView.text.parentNode) {\n          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n        }\n        lineView.node.appendChild(lineView.text);\n        if (ie2 && ie_version < 8) {\n          lineView.node.style.zIndex = 2;\n        }\n      }\n      return lineView.node;\n    }\n    function updateLineBackground(cm, lineView) {\n      var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n      if (cls) {\n        cls += \" CodeMirror-linebackground\";\n      }\n      if (lineView.background) {\n        if (cls) {\n          lineView.background.className = cls;\n        } else {\n          lineView.background.parentNode.removeChild(lineView.background);\n          lineView.background = null;\n        }\n      } else if (cls) {\n        var wrap2 = ensureLineWrapped(lineView);\n        lineView.background = wrap2.insertBefore(elt(\"div\", null, cls), wrap2.firstChild);\n        cm.display.input.setUneditable(lineView.background);\n      }\n    }\n    function getLineContent(cm, lineView) {\n      var ext = cm.display.externalMeasured;\n      if (ext && ext.line == lineView.line) {\n        cm.display.externalMeasured = null;\n        lineView.measure = ext.measure;\n        return ext.built;\n      }\n      return buildLineContent(cm, lineView);\n    }\n    function updateLineText(cm, lineView) {\n      var cls = lineView.text.className;\n      var built = getLineContent(cm, lineView);\n      if (lineView.text == lineView.node) {\n        lineView.node = built.pre;\n      }\n      lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n      lineView.text = built.pre;\n      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n        lineView.bgClass = built.bgClass;\n        lineView.textClass = built.textClass;\n        updateLineClasses(cm, lineView);\n      } else if (cls) {\n        lineView.text.className = cls;\n      }\n    }\n    function updateLineClasses(cm, lineView) {\n      updateLineBackground(cm, lineView);\n      if (lineView.line.wrapClass) {\n        ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n      } else if (lineView.node != lineView.text) {\n        lineView.node.className = \"\";\n      }\n      var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n      lineView.text.className = textClass || \"\";\n    }\n    function updateLineGutter(cm, lineView, lineN, dims) {\n      if (lineView.gutter) {\n        lineView.node.removeChild(lineView.gutter);\n        lineView.gutter = null;\n      }\n      if (lineView.gutterBackground) {\n        lineView.node.removeChild(lineView.gutterBackground);\n        lineView.gutterBackground = null;\n      }\n      if (lineView.line.gutterClass) {\n        var wrap2 = ensureLineWrapped(lineView);\n        lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass, \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + dims.gutterTotalWidth + \"px\");\n        cm.display.input.setUneditable(lineView.gutterBackground);\n        wrap2.insertBefore(lineView.gutterBackground, lineView.text);\n      }\n      var markers = lineView.line.gutterMarkers;\n      if (cm.options.lineNumbers || markers) {\n        var wrap$12 = ensureLineWrapped(lineView);\n        var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n        gutterWrap.setAttribute(\"aria-hidden\", \"true\");\n        cm.display.input.setUneditable(gutterWrap);\n        wrap$12.insertBefore(gutterWrap, lineView.text);\n        if (lineView.line.gutterClass) {\n          gutterWrap.className += \" \" + lineView.line.gutterClass;\n        }\n        if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"])) {\n          lineView.lineNumber = gutterWrap.appendChild(elt(\"div\", lineNumberFor(cm.options, lineN), \"CodeMirror-linenumber CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \" + cm.display.lineNumInnerWidth + \"px\"));\n        }\n        if (markers) {\n          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n            var id2 = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id2) && markers[id2];\n            if (found) {\n              gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[id2] + \"px; width: \" + dims.gutterWidth[id2] + \"px\"));\n            }\n          }\n        }\n      }\n    }\n    function updateLineWidgets(cm, lineView, dims) {\n      if (lineView.alignable) {\n        lineView.alignable = null;\n      }\n      var isWidget = classTest(\"CodeMirror-linewidget\");\n      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\n        next = node.nextSibling;\n        if (isWidget.test(node.className)) {\n          lineView.node.removeChild(node);\n        }\n      }\n      insertLineWidgets(cm, lineView, dims);\n    }\n    function buildLineElement(cm, lineView, lineN, dims) {\n      var built = getLineContent(cm, lineView);\n      lineView.text = lineView.node = built.pre;\n      if (built.bgClass) {\n        lineView.bgClass = built.bgClass;\n      }\n      if (built.textClass) {\n        lineView.textClass = built.textClass;\n      }\n      updateLineClasses(cm, lineView);\n      updateLineGutter(cm, lineView, lineN, dims);\n      insertLineWidgets(cm, lineView, dims);\n      return lineView.node;\n    }\n    function insertLineWidgets(cm, lineView, dims) {\n      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n      if (lineView.rest) {\n        for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n          insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);\n        }\n      }\n    }\n    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n      if (!line.widgets) {\n        return;\n      }\n      var wrap2 = ensureLineWrapped(lineView);\n      for (var i2 = 0, ws2 = line.widgets; i2 < ws2.length; ++i2) {\n        var widget = ws2[i2], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n        if (!widget.handleMouseEvents) {\n          node.setAttribute(\"cm-ignore-events\", \"true\");\n        }\n        positionLineWidget(widget, node, lineView, dims);\n        cm.display.input.setUneditable(node);\n        if (allowAbove && widget.above) {\n          wrap2.insertBefore(node, lineView.gutter || lineView.text);\n        } else {\n          wrap2.appendChild(node);\n        }\n        signalLater(widget, \"redraw\");\n      }\n    }\n    function positionLineWidget(widget, node, lineView, dims) {\n      if (widget.noHScroll) {\n        (lineView.alignable || (lineView.alignable = [])).push(node);\n        var width = dims.wrapperWidth;\n        node.style.left = dims.fixedPos + \"px\";\n        if (!widget.coverGutter) {\n          width -= dims.gutterTotalWidth;\n          node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n        }\n        node.style.width = width + \"px\";\n      }\n      if (widget.coverGutter) {\n        node.style.zIndex = 5;\n        node.style.position = \"relative\";\n        if (!widget.noHScroll) {\n          node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n        }\n      }\n    }\n    function widgetHeight(widget) {\n      if (widget.height != null) {\n        return widget.height;\n      }\n      var cm = widget.doc.cm;\n      if (!cm) {\n        return 0;\n      }\n      if (!contains(document.body, widget.node)) {\n        var parentStyle = \"position: relative;\";\n        if (widget.coverGutter) {\n          parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n        }\n        if (widget.noHScroll) {\n          parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n        }\n        removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n      }\n      return widget.height = widget.node.parentNode.offsetHeight;\n    }\n    function eventInWidget(display, e) {\n      for (var n2 = e_target(e); n2 != display.wrapper; n2 = n2.parentNode) {\n        if (!n2 || n2.nodeType == 1 && n2.getAttribute(\"cm-ignore-events\") == \"true\" || n2.parentNode == display.sizer && n2 != display.mover) {\n          return true;\n        }\n      }\n    }\n    function paddingTop(display) {\n      return display.lineSpace.offsetTop;\n    }\n    function paddingVert(display) {\n      return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n    }\n    function paddingH(display) {\n      if (display.cachedPaddingH) {\n        return display.cachedPaddingH;\n      }\n      var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n      var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };\n      if (!isNaN(data.left) && !isNaN(data.right)) {\n        display.cachedPaddingH = data;\n      }\n      return data;\n    }\n    function scrollGap(cm) {\n      return scrollerGap - cm.display.nativeBarWidth;\n    }\n    function displayWidth(cm) {\n      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n    }\n    function displayHeight(cm) {\n      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n    }\n    function ensureLineHeights(cm, lineView, rect2) {\n      var wrapping = cm.options.lineWrapping;\n      var curWidth = wrapping && displayWidth(cm);\n      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n        var heights = lineView.measure.heights = [];\n        if (wrapping) {\n          lineView.measure.width = curWidth;\n          var rects = lineView.text.firstChild.getClientRects();\n          for (var i2 = 0; i2 < rects.length - 1; i2++) {\n            var cur = rects[i2], next = rects[i2 + 1];\n            if (Math.abs(cur.bottom - next.bottom) > 2) {\n              heights.push((cur.bottom + next.top) / 2 - rect2.top);\n            }\n          }\n        }\n        heights.push(rect2.bottom - rect2.top);\n      }\n    }\n    function mapFromLineView(lineView, line, lineN) {\n      if (lineView.line == line) {\n        return { map: lineView.measure.map, cache: lineView.measure.cache };\n      }\n      if (lineView.rest) {\n        for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n          if (lineView.rest[i2] == line) {\n            return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };\n          }\n        }\n        for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {\n          if (lineNo(lineView.rest[i$12]) > lineN) {\n            return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };\n          }\n        }\n      }\n    }\n    function updateExternalMeasurement(cm, line) {\n      line = visualLine(line);\n      var lineN = lineNo(line);\n      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n      view.lineN = lineN;\n      var built = view.built = buildLineContent(cm, view);\n      view.text = built.pre;\n      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n      return view;\n    }\n    function measureChar(cm, line, ch2, bias) {\n      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch2, bias);\n    }\n    function findViewForLine(cm, lineN) {\n      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n        return cm.display.view[findViewIndex(cm, lineN)];\n      }\n      var ext = cm.display.externalMeasured;\n      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n        return ext;\n      }\n    }\n    function prepareMeasureForLine(cm, line) {\n      var lineN = lineNo(line);\n      var view = findViewForLine(cm, lineN);\n      if (view && !view.text) {\n        view = null;\n      } else if (view && view.changes) {\n        updateLineForChanges(cm, view, lineN, getDimensions(cm));\n        cm.curOp.forceUpdate = true;\n      }\n      if (!view) {\n        view = updateExternalMeasurement(cm, line);\n      }\n      var info2 = mapFromLineView(view, line, lineN);\n      return {\n        line,\n        view,\n        rect: null,\n        map: info2.map,\n        cache: info2.cache,\n        before: info2.before,\n        hasHeights: false\n      };\n    }\n    function measureCharPrepared(cm, prepared, ch2, bias, varHeight) {\n      if (prepared.before) {\n        ch2 = -1;\n      }\n      var key = ch2 + (bias || \"\"), found;\n      if (prepared.cache.hasOwnProperty(key)) {\n        found = prepared.cache[key];\n      } else {\n        if (!prepared.rect) {\n          prepared.rect = prepared.view.text.getBoundingClientRect();\n        }\n        if (!prepared.hasHeights) {\n          ensureLineHeights(cm, prepared.view, prepared.rect);\n          prepared.hasHeights = true;\n        }\n        found = measureCharInner(cm, prepared, ch2, bias);\n        if (!found.bogus) {\n          prepared.cache[key] = found;\n        }\n      }\n      return {\n        left: found.left,\n        right: found.right,\n        top: varHeight ? found.rtop : found.top,\n        bottom: varHeight ? found.rbottom : found.bottom\n      };\n    }\n    var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };\n    function nodeAndOffsetInLineMap(map3, ch2, bias) {\n      var node, start2, end2, collapse, mStart, mEnd;\n      for (var i2 = 0; i2 < map3.length; i2 += 3) {\n        mStart = map3[i2];\n        mEnd = map3[i2 + 1];\n        if (ch2 < mStart) {\n          start2 = 0;\n          end2 = 1;\n          collapse = \"left\";\n        } else if (ch2 < mEnd) {\n          start2 = ch2 - mStart;\n          end2 = start2 + 1;\n        } else if (i2 == map3.length - 3 || ch2 == mEnd && map3[i2 + 3] > ch2) {\n          end2 = mEnd - mStart;\n          start2 = end2 - 1;\n          if (ch2 >= mEnd) {\n            collapse = \"right\";\n          }\n        }\n        if (start2 != null) {\n          node = map3[i2 + 2];\n          if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\")) {\n            collapse = bias;\n          }\n          if (bias == \"left\" && start2 == 0) {\n            while (i2 && map3[i2 - 2] == map3[i2 - 3] && map3[i2 - 1].insertLeft) {\n              node = map3[(i2 -= 3) + 2];\n              collapse = \"left\";\n            }\n          }\n          if (bias == \"right\" && start2 == mEnd - mStart) {\n            while (i2 < map3.length - 3 && map3[i2 + 3] == map3[i2 + 4] && !map3[i2 + 5].insertLeft) {\n              node = map3[(i2 += 3) + 2];\n              collapse = \"right\";\n            }\n          }\n          break;\n        }\n      }\n      return { node, start: start2, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };\n    }\n    function getUsefulRect(rects, bias) {\n      var rect2 = nullRect;\n      if (bias == \"left\") {\n        for (var i2 = 0; i2 < rects.length; i2++) {\n          if ((rect2 = rects[i2]).left != rect2.right) {\n            break;\n          }\n        }\n      } else {\n        for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {\n          if ((rect2 = rects[i$12]).left != rect2.right) {\n            break;\n          }\n        }\n      }\n      return rect2;\n    }\n    function measureCharInner(cm, prepared, ch2, bias) {\n      var place = nodeAndOffsetInLineMap(prepared.map, ch2, bias);\n      var node = place.node, start2 = place.start, end2 = place.end, collapse = place.collapse;\n      var rect2;\n      if (node.nodeType == 3) {\n        for (var i$12 = 0; i$12 < 4; i$12++) {\n          while (start2 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start2))) {\n            --start2;\n          }\n          while (place.coverStart + end2 < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end2))) {\n            ++end2;\n          }\n          if (ie2 && ie_version < 9 && start2 == 0 && end2 == place.coverEnd - place.coverStart) {\n            rect2 = node.parentNode.getBoundingClientRect();\n          } else {\n            rect2 = getUsefulRect(range2(node, start2, end2).getClientRects(), bias);\n          }\n          if (rect2.left || rect2.right || start2 == 0) {\n            break;\n          }\n          end2 = start2;\n          start2 = start2 - 1;\n          collapse = \"right\";\n        }\n        if (ie2 && ie_version < 11) {\n          rect2 = maybeUpdateRectForZooming(cm.display.measure, rect2);\n        }\n      } else {\n        if (start2 > 0) {\n          collapse = bias = \"right\";\n        }\n        var rects;\n        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n          rect2 = rects[bias == \"right\" ? rects.length - 1 : 0];\n        } else {\n          rect2 = node.getBoundingClientRect();\n        }\n      }\n      if (ie2 && ie_version < 9 && !start2 && (!rect2 || !rect2.left && !rect2.right)) {\n        var rSpan = node.parentNode.getClientRects()[0];\n        if (rSpan) {\n          rect2 = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };\n        } else {\n          rect2 = nullRect;\n        }\n      }\n      var rtop = rect2.top - prepared.rect.top, rbot = rect2.bottom - prepared.rect.top;\n      var mid2 = (rtop + rbot) / 2;\n      var heights = prepared.view.measure.heights;\n      var i2 = 0;\n      for (; i2 < heights.length - 1; i2++) {\n        if (mid2 < heights[i2]) {\n          break;\n        }\n      }\n      var top2 = i2 ? heights[i2 - 1] : 0, bot2 = heights[i2];\n      var result2 = {\n        left: (collapse == \"right\" ? rect2.right : rect2.left) - prepared.rect.left,\n        right: (collapse == \"left\" ? rect2.left : rect2.right) - prepared.rect.left,\n        top: top2,\n        bottom: bot2\n      };\n      if (!rect2.left && !rect2.right) {\n        result2.bogus = true;\n      }\n      if (!cm.options.singleCursorHeightPerLine) {\n        result2.rtop = rtop;\n        result2.rbottom = rbot;\n      }\n      return result2;\n    }\n    function maybeUpdateRectForZooming(measure, rect2) {\n      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n        return rect2;\n      }\n      var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n      var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n      return {\n        left: rect2.left * scaleX,\n        right: rect2.right * scaleX,\n        top: rect2.top * scaleY,\n        bottom: rect2.bottom * scaleY\n      };\n    }\n    function clearLineMeasurementCacheFor(lineView) {\n      if (lineView.measure) {\n        lineView.measure.cache = {};\n        lineView.measure.heights = null;\n        if (lineView.rest) {\n          for (var i2 = 0; i2 < lineView.rest.length; i2++) {\n            lineView.measure.caches[i2] = {};\n          }\n        }\n      }\n    }\n    function clearLineMeasurementCache(cm) {\n      cm.display.externalMeasure = null;\n      removeChildren(cm.display.lineMeasure);\n      for (var i2 = 0; i2 < cm.display.view.length; i2++) {\n        clearLineMeasurementCacheFor(cm.display.view[i2]);\n      }\n    }\n    function clearCaches(cm) {\n      clearLineMeasurementCache(cm);\n      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n      if (!cm.options.lineWrapping) {\n        cm.display.maxLineChanged = true;\n      }\n      cm.display.lineNumChars = null;\n    }\n    function pageScrollX() {\n      if (chrome && android) {\n        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));\n      }\n      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n    }\n    function pageScrollY() {\n      if (chrome && android) {\n        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));\n      }\n      return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n    }\n    function widgetTopHeight(lineObj) {\n      var ref = visualLine(lineObj);\n      var widgets = ref.widgets;\n      var height = 0;\n      if (widgets) {\n        for (var i2 = 0; i2 < widgets.length; ++i2) {\n          if (widgets[i2].above) {\n            height += widgetHeight(widgets[i2]);\n          }\n        }\n      }\n      return height;\n    }\n    function intoCoordSystem(cm, lineObj, rect2, context, includeWidgets) {\n      if (!includeWidgets) {\n        var height = widgetTopHeight(lineObj);\n        rect2.top += height;\n        rect2.bottom += height;\n      }\n      if (context == \"line\") {\n        return rect2;\n      }\n      if (!context) {\n        context = \"local\";\n      }\n      var yOff = heightAtLine(lineObj);\n      if (context == \"local\") {\n        yOff += paddingTop(cm.display);\n      } else {\n        yOff -= cm.display.viewOffset;\n      }\n      if (context == \"page\" || context == \"window\") {\n        var lOff = cm.display.lineSpace.getBoundingClientRect();\n        yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n        var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n        rect2.left += xOff;\n        rect2.right += xOff;\n      }\n      rect2.top += yOff;\n      rect2.bottom += yOff;\n      return rect2;\n    }\n    function fromCoordSystem(cm, coords, context) {\n      if (context == \"div\") {\n        return coords;\n      }\n      var left = coords.left, top2 = coords.top;\n      if (context == \"page\") {\n        left -= pageScrollX();\n        top2 -= pageScrollY();\n      } else if (context == \"local\" || !context) {\n        var localBox = cm.display.sizer.getBoundingClientRect();\n        left += localBox.left;\n        top2 += localBox.top;\n      }\n      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n      return { left: left - lineSpaceBox.left, top: top2 - lineSpaceBox.top };\n    }\n    function charCoords(cm, pos, context, lineObj, bias) {\n      if (!lineObj) {\n        lineObj = getLine2(cm.doc, pos.line);\n      }\n      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n    }\n    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n      lineObj = lineObj || getLine2(cm.doc, pos.line);\n      if (!preparedMeasure) {\n        preparedMeasure = prepareMeasureForLine(cm, lineObj);\n      }\n      function get(ch3, right) {\n        var m2 = measureCharPrepared(cm, preparedMeasure, ch3, right ? \"right\" : \"left\", varHeight);\n        if (right) {\n          m2.left = m2.right;\n        } else {\n          m2.right = m2.left;\n        }\n        return intoCoordSystem(cm, lineObj, m2, context);\n      }\n      var order2 = getOrder(lineObj, cm.doc.direction), ch2 = pos.ch, sticky = pos.sticky;\n      if (ch2 >= lineObj.text.length) {\n        ch2 = lineObj.text.length;\n        sticky = \"before\";\n      } else if (ch2 <= 0) {\n        ch2 = 0;\n        sticky = \"after\";\n      }\n      if (!order2) {\n        return get(sticky == \"before\" ? ch2 - 1 : ch2, sticky == \"before\");\n      }\n      function getBidi(ch3, partPos2, invert) {\n        var part2 = order2[partPos2], right = part2.level == 1;\n        return get(invert ? ch3 - 1 : ch3, right != invert);\n      }\n      var partPos = getBidiPartAt(order2, ch2, sticky);\n      var other = bidiOther;\n      var val = getBidi(ch2, partPos, sticky == \"before\");\n      if (other != null) {\n        val.other = getBidi(ch2, other, sticky != \"before\");\n      }\n      return val;\n    }\n    function estimateCoords(cm, pos) {\n      var left = 0;\n      pos = clipPos(cm.doc, pos);\n      if (!cm.options.lineWrapping) {\n        left = charWidth(cm.display) * pos.ch;\n      }\n      var lineObj = getLine2(cm.doc, pos.line);\n      var top2 = heightAtLine(lineObj) + paddingTop(cm.display);\n      return { left, right: left, top: top2, bottom: top2 + lineObj.height };\n    }\n    function PosWithInfo(line, ch2, sticky, outside, xRel) {\n      var pos = Pos(line, ch2, sticky);\n      pos.xRel = xRel;\n      if (outside) {\n        pos.outside = outside;\n      }\n      return pos;\n    }\n    function coordsChar(cm, x2, y2) {\n      var doc = cm.doc;\n      y2 += cm.display.viewOffset;\n      if (y2 < 0) {\n        return PosWithInfo(doc.first, 0, null, -1, -1);\n      }\n      var lineN = lineAtHeight(doc, y2), last = doc.first + doc.size - 1;\n      if (lineN > last) {\n        return PosWithInfo(doc.first + doc.size - 1, getLine2(doc, last).text.length, null, 1, 1);\n      }\n      if (x2 < 0) {\n        x2 = 0;\n      }\n      var lineObj = getLine2(doc, lineN);\n      for (; ; ) {\n        var found = coordsCharInner(cm, lineObj, lineN, x2, y2);\n        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n        if (!collapsed) {\n          return found;\n        }\n        var rangeEnd = collapsed.find(1);\n        if (rangeEnd.line == lineN) {\n          return rangeEnd;\n        }\n        lineObj = getLine2(doc, lineN = rangeEnd.line);\n      }\n    }\n    function wrappedLineExtent(cm, lineObj, preparedMeasure, y2) {\n      y2 -= widgetTopHeight(lineObj);\n      var end2 = lineObj.text.length;\n      var begin = findFirst(function(ch2) {\n        return measureCharPrepared(cm, preparedMeasure, ch2 - 1).bottom <= y2;\n      }, end2, 0);\n      end2 = findFirst(function(ch2) {\n        return measureCharPrepared(cm, preparedMeasure, ch2).top > y2;\n      }, begin, end2);\n      return { begin, end: end2 };\n    }\n    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target2) {\n      if (!preparedMeasure) {\n        preparedMeasure = prepareMeasureForLine(cm, lineObj);\n      }\n      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target2), \"line\").top;\n      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n    }\n    function boxIsAfter(box, x2, y2, left) {\n      return box.bottom <= y2 ? false : box.top > y2 ? true : (left ? box.left : box.right) > x2;\n    }\n    function coordsCharInner(cm, lineObj, lineNo2, x2, y2) {\n      y2 -= heightAtLine(lineObj);\n      var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n      var widgetHeight2 = widgetTopHeight(lineObj);\n      var begin = 0, end2 = lineObj.text.length, ltr = true;\n      var order2 = getOrder(lineObj, cm.doc.direction);\n      if (order2) {\n        var part2 = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2);\n        ltr = part2.level != 1;\n        begin = ltr ? part2.from : part2.to - 1;\n        end2 = ltr ? part2.to : part2.from - 1;\n      }\n      var chAround = null, boxAround = null;\n      var ch2 = findFirst(function(ch3) {\n        var box = measureCharPrepared(cm, preparedMeasure, ch3);\n        box.top += widgetHeight2;\n        box.bottom += widgetHeight2;\n        if (!boxIsAfter(box, x2, y2, false)) {\n          return false;\n        }\n        if (box.top <= y2 && box.left <= x2) {\n          chAround = ch3;\n          boxAround = box;\n        }\n        return true;\n      }, begin, end2);\n      var baseX, sticky, outside = false;\n      if (boxAround) {\n        var atLeft = x2 - boxAround.left < boxAround.right - x2, atStart = atLeft == ltr;\n        ch2 = chAround + (atStart ? 0 : 1);\n        sticky = atStart ? \"after\" : \"before\";\n        baseX = atLeft ? boxAround.left : boxAround.right;\n      } else {\n        if (!ltr && (ch2 == end2 || ch2 == begin)) {\n          ch2++;\n        }\n        sticky = ch2 == 0 ? \"after\" : ch2 == lineObj.text.length ? \"before\" : measureCharPrepared(cm, preparedMeasure, ch2 - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y2 == ltr ? \"after\" : \"before\";\n        var coords = cursorCoords(cm, Pos(lineNo2, ch2, sticky), \"line\", lineObj, preparedMeasure);\n        baseX = coords.left;\n        outside = y2 < coords.top ? -1 : y2 >= coords.bottom ? 1 : 0;\n      }\n      ch2 = skipExtendingChars(lineObj.text, ch2, 1);\n      return PosWithInfo(lineNo2, ch2, sticky, outside, x2 - baseX);\n    }\n    function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2) {\n      var index = findFirst(function(i2) {\n        var part3 = order2[i2], ltr2 = part3.level != 1;\n        return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part3.to : part3.from, ltr2 ? \"before\" : \"after\"), \"line\", lineObj, preparedMeasure), x2, y2, true);\n      }, 0, order2.length - 1);\n      var part2 = order2[index];\n      if (index > 0) {\n        var ltr = part2.level != 1;\n        var start2 = cursorCoords(cm, Pos(lineNo2, ltr ? part2.from : part2.to, ltr ? \"after\" : \"before\"), \"line\", lineObj, preparedMeasure);\n        if (boxIsAfter(start2, x2, y2, true) && start2.top > y2) {\n          part2 = order2[index - 1];\n        }\n      }\n      return part2;\n    }\n    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order2, x2, y2) {\n      var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y2);\n      var begin = ref.begin;\n      var end2 = ref.end;\n      if (/\\s/.test(lineObj.text.charAt(end2 - 1))) {\n        end2--;\n      }\n      var part2 = null, closestDist = null;\n      for (var i2 = 0; i2 < order2.length; i2++) {\n        var p2 = order2[i2];\n        if (p2.from >= end2 || p2.to <= begin) {\n          continue;\n        }\n        var ltr = p2.level != 1;\n        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end2, p2.to) - 1 : Math.max(begin, p2.from)).right;\n        var dist2 = endX < x2 ? x2 - endX + 1e9 : endX - x2;\n        if (!part2 || closestDist > dist2) {\n          part2 = p2;\n          closestDist = dist2;\n        }\n      }\n      if (!part2) {\n        part2 = order2[order2.length - 1];\n      }\n      if (part2.from < begin) {\n        part2 = { from: begin, to: part2.to, level: part2.level };\n      }\n      if (part2.to > end2) {\n        part2 = { from: part2.from, to: end2, level: part2.level };\n      }\n      return part2;\n    }\n    var measureText;\n    function textHeight(display) {\n      if (display.cachedTextHeight != null) {\n        return display.cachedTextHeight;\n      }\n      if (measureText == null) {\n        measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n        for (var i2 = 0; i2 < 49; ++i2) {\n          measureText.appendChild(document.createTextNode(\"x\"));\n          measureText.appendChild(elt(\"br\"));\n        }\n        measureText.appendChild(document.createTextNode(\"x\"));\n      }\n      removeChildrenAndAdd(display.measure, measureText);\n      var height = measureText.offsetHeight / 50;\n      if (height > 3) {\n        display.cachedTextHeight = height;\n      }\n      removeChildren(display.measure);\n      return height || 1;\n    }\n    function charWidth(display) {\n      if (display.cachedCharWidth != null) {\n        return display.cachedCharWidth;\n      }\n      var anchor = elt(\"span\", \"xxxxxxxxxx\");\n      var pre2 = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n      removeChildrenAndAdd(display.measure, pre2);\n      var rect2 = anchor.getBoundingClientRect(), width = (rect2.right - rect2.left) / 10;\n      if (width > 2) {\n        display.cachedCharWidth = width;\n      }\n      return width || 10;\n    }\n    function getDimensions(cm) {\n      var d = cm.display, left = {}, width = {};\n      var gutterLeft = d.gutters.clientLeft;\n      for (var n2 = d.gutters.firstChild, i2 = 0; n2; n2 = n2.nextSibling, ++i2) {\n        var id2 = cm.display.gutterSpecs[i2].className;\n        left[id2] = n2.offsetLeft + n2.clientLeft + gutterLeft;\n        width[id2] = n2.clientWidth;\n      }\n      return {\n        fixedPos: compensateForHScroll(d),\n        gutterTotalWidth: d.gutters.offsetWidth,\n        gutterLeft: left,\n        gutterWidth: width,\n        wrapperWidth: d.wrapper.clientWidth\n      };\n    }\n    function compensateForHScroll(display) {\n      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n    }\n    function estimateHeight(cm) {\n      var th2 = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n      return function(line) {\n        if (lineIsHidden(cm.doc, line)) {\n          return 0;\n        }\n        var widgetsHeight = 0;\n        if (line.widgets) {\n          for (var i2 = 0; i2 < line.widgets.length; i2++) {\n            if (line.widgets[i2].height) {\n              widgetsHeight += line.widgets[i2].height;\n            }\n          }\n        }\n        if (wrapping) {\n          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th2;\n        } else {\n          return widgetsHeight + th2;\n        }\n      };\n    }\n    function estimateLineHeights(cm) {\n      var doc = cm.doc, est = estimateHeight(cm);\n      doc.iter(function(line) {\n        var estHeight = est(line);\n        if (estHeight != line.height) {\n          updateLineHeight(line, estHeight);\n        }\n      });\n    }\n    function posFromMouse(cm, e, liberal, forRect) {\n      var display = cm.display;\n      if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") {\n        return null;\n      }\n      var x2, y2, space = display.lineSpace.getBoundingClientRect();\n      try {\n        x2 = e.clientX - space.left;\n        y2 = e.clientY - space.top;\n      } catch (e$1) {\n        return null;\n      }\n      var coords = coordsChar(cm, x2, y2), line;\n      if (forRect && coords.xRel > 0 && (line = getLine2(cm.doc, coords.line).text).length == coords.ch) {\n        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n        coords = Pos(coords.line, Math.max(0, Math.round((x2 - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n      }\n      return coords;\n    }\n    function findViewIndex(cm, n2) {\n      if (n2 >= cm.display.viewTo) {\n        return null;\n      }\n      n2 -= cm.display.viewFrom;\n      if (n2 < 0) {\n        return null;\n      }\n      var view = cm.display.view;\n      for (var i2 = 0; i2 < view.length; i2++) {\n        n2 -= view[i2].size;\n        if (n2 < 0) {\n          return i2;\n        }\n      }\n    }\n    function regChange(cm, from, to, lendiff) {\n      if (from == null) {\n        from = cm.doc.first;\n      }\n      if (to == null) {\n        to = cm.doc.first + cm.doc.size;\n      }\n      if (!lendiff) {\n        lendiff = 0;\n      }\n      var display = cm.display;\n      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n        display.updateLineNumbers = from;\n      }\n      cm.curOp.viewChanged = true;\n      if (from >= display.viewTo) {\n        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n          resetView(cm);\n        }\n      } else if (to <= display.viewFrom) {\n        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n          resetView(cm);\n        } else {\n          display.viewFrom += lendiff;\n          display.viewTo += lendiff;\n        }\n      } else if (from <= display.viewFrom && to >= display.viewTo) {\n        resetView(cm);\n      } else if (from <= display.viewFrom) {\n        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n        if (cut) {\n          display.view = display.view.slice(cut.index);\n          display.viewFrom = cut.lineN;\n          display.viewTo += lendiff;\n        } else {\n          resetView(cm);\n        }\n      } else if (to >= display.viewTo) {\n        var cut$1 = viewCuttingPoint(cm, from, from, -1);\n        if (cut$1) {\n          display.view = display.view.slice(0, cut$1.index);\n          display.viewTo = cut$1.lineN;\n        } else {\n          resetView(cm);\n        }\n      } else {\n        var cutTop = viewCuttingPoint(cm, from, from, -1);\n        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n        if (cutTop && cutBot) {\n          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n          display.viewTo += lendiff;\n        } else {\n          resetView(cm);\n        }\n      }\n      var ext = display.externalMeasured;\n      if (ext) {\n        if (to < ext.lineN) {\n          ext.lineN += lendiff;\n        } else if (from < ext.lineN + ext.size) {\n          display.externalMeasured = null;\n        }\n      }\n    }\n    function regLineChange(cm, line, type2) {\n      cm.curOp.viewChanged = true;\n      var display = cm.display, ext = cm.display.externalMeasured;\n      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n        display.externalMeasured = null;\n      }\n      if (line < display.viewFrom || line >= display.viewTo) {\n        return;\n      }\n      var lineView = display.view[findViewIndex(cm, line)];\n      if (lineView.node == null) {\n        return;\n      }\n      var arr = lineView.changes || (lineView.changes = []);\n      if (indexOf(arr, type2) == -1) {\n        arr.push(type2);\n      }\n    }\n    function resetView(cm) {\n      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n      cm.display.view = [];\n      cm.display.viewOffset = 0;\n    }\n    function viewCuttingPoint(cm, oldN, newN, dir) {\n      var index = findViewIndex(cm, oldN), diff2, view = cm.display.view;\n      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n        return { index, lineN: newN };\n      }\n      var n2 = cm.display.viewFrom;\n      for (var i2 = 0; i2 < index; i2++) {\n        n2 += view[i2].size;\n      }\n      if (n2 != oldN) {\n        if (dir > 0) {\n          if (index == view.length - 1) {\n            return null;\n          }\n          diff2 = n2 + view[index].size - oldN;\n          index++;\n        } else {\n          diff2 = n2 - oldN;\n        }\n        oldN += diff2;\n        newN += diff2;\n      }\n      while (visualLineNo(cm.doc, newN) != newN) {\n        if (index == (dir < 0 ? 0 : view.length - 1)) {\n          return null;\n        }\n        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n        index += dir;\n      }\n      return { index, lineN: newN };\n    }\n    function adjustView(cm, from, to) {\n      var display = cm.display, view = display.view;\n      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n        display.view = buildViewArray(cm, from, to);\n        display.viewFrom = from;\n      } else {\n        if (display.viewFrom > from) {\n          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n        } else if (display.viewFrom < from) {\n          display.view = display.view.slice(findViewIndex(cm, from));\n        }\n        display.viewFrom = from;\n        if (display.viewTo < to) {\n          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n        } else if (display.viewTo > to) {\n          display.view = display.view.slice(0, findViewIndex(cm, to));\n        }\n      }\n      display.viewTo = to;\n    }\n    function countDirtyView(cm) {\n      var view = cm.display.view, dirty = 0;\n      for (var i2 = 0; i2 < view.length; i2++) {\n        var lineView = view[i2];\n        if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n          ++dirty;\n        }\n      }\n      return dirty;\n    }\n    function updateSelection(cm) {\n      cm.display.input.showSelection(cm.display.input.prepareSelection());\n    }\n    function prepareSelection(cm, primary) {\n      if (primary === void 0)\n        primary = true;\n      var doc = cm.doc, result2 = {};\n      var curFragment = result2.cursors = document.createDocumentFragment();\n      var selFragment = result2.selection = document.createDocumentFragment();\n      var customCursor = cm.options.$customCursor;\n      if (customCursor) {\n        primary = true;\n      }\n      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n        if (!primary && i2 == doc.sel.primIndex) {\n          continue;\n        }\n        var range3 = doc.sel.ranges[i2];\n        if (range3.from().line >= cm.display.viewTo || range3.to().line < cm.display.viewFrom) {\n          continue;\n        }\n        var collapsed = range3.empty();\n        if (customCursor) {\n          var head = customCursor(cm, range3);\n          if (head) {\n            drawSelectionCursor(cm, head, curFragment);\n          }\n        } else if (collapsed || cm.options.showCursorWhenSelecting) {\n          drawSelectionCursor(cm, range3.head, curFragment);\n        }\n        if (!collapsed) {\n          drawSelectionRange(cm, range3, selFragment);\n        }\n      }\n      return result2;\n    }\n    function drawSelectionCursor(cm, head, output) {\n      var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n      var cursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor\"));\n      cursor.style.left = pos.left + \"px\";\n      cursor.style.top = pos.top + \"px\";\n      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n      if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n        var charPos = charCoords(cm, head, \"div\", null, null);\n        var width = charPos.right - charPos.left;\n        cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + \"px\";\n      }\n      if (pos.other) {\n        var otherCursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n        otherCursor.style.display = \"\";\n        otherCursor.style.left = pos.other.left + \"px\";\n        otherCursor.style.top = pos.other.top + \"px\";\n        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + \"px\";\n      }\n    }\n    function cmpCoords(a, b) {\n      return a.top - b.top || a.left - b.left;\n    }\n    function drawSelectionRange(cm, range3, output) {\n      var display = cm.display, doc = cm.doc;\n      var fragment = document.createDocumentFragment();\n      var padding = paddingH(cm.display), leftSide = padding.left;\n      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n      var docLTR = doc.direction == \"ltr\";\n      function add2(left, top2, width, bottom2) {\n        if (top2 < 0) {\n          top2 = 0;\n        }\n        top2 = Math.round(top2);\n        bottom2 = Math.round(bottom2);\n        fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left + \"px;\\n                             top: \" + top2 + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom2 - top2) + \"px\"));\n      }\n      function drawForLine(line, fromArg, toArg) {\n        var lineObj = getLine2(doc, line);\n        var lineLen = lineObj.text.length;\n        var start2, end2;\n        function coords(ch2, bias) {\n          return charCoords(cm, Pos(line, ch2), \"div\", lineObj, bias);\n        }\n        function wrapX(pos, dir, side) {\n          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n          var prop3 = dir == \"ltr\" == (side == \"after\") ? \"left\" : \"right\";\n          var ch2 = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n          return coords(ch2, prop3)[prop3];\n        }\n        var order2 = getOrder(lineObj, doc.direction);\n        iterateBidiSections(order2, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {\n          var ltr = dir == \"ltr\";\n          var fromPos = coords(from, ltr ? \"left\" : \"right\");\n          var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n          var first = i2 == 0, last = !order2 || i2 == order2.length - 1;\n          if (toPos.top - fromPos.top <= 3) {\n            var openLeft = (docLTR ? openStart : openEnd) && first;\n            var openRight = (docLTR ? openEnd : openStart) && last;\n            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n            add2(left, fromPos.top, right - left, fromPos.bottom);\n          } else {\n            var topLeft, topRight, botLeft, botRight;\n            if (ltr) {\n              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n              topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n              botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n              botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n            } else {\n              topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n              botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n            }\n            add2(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n            if (fromPos.bottom < toPos.top) {\n              add2(leftSide, fromPos.bottom, null, toPos.top);\n            }\n            add2(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n          }\n          if (!start2 || cmpCoords(fromPos, start2) < 0) {\n            start2 = fromPos;\n          }\n          if (cmpCoords(toPos, start2) < 0) {\n            start2 = toPos;\n          }\n          if (!end2 || cmpCoords(fromPos, end2) < 0) {\n            end2 = fromPos;\n          }\n          if (cmpCoords(toPos, end2) < 0) {\n            end2 = toPos;\n          }\n        });\n        return { start: start2, end: end2 };\n      }\n      var sFrom = range3.from(), sTo = range3.to();\n      if (sFrom.line == sTo.line) {\n        drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n      } else {\n        var fromLine = getLine2(doc, sFrom.line), toLine = getLine2(doc, sTo.line);\n        var singleVLine = visualLine(fromLine) == visualLine(toLine);\n        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n        if (singleVLine) {\n          if (leftEnd.top < rightStart.top - 2) {\n            add2(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n            add2(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n          } else {\n            add2(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n          }\n        }\n        if (leftEnd.bottom < rightStart.top) {\n          add2(leftSide, leftEnd.bottom, null, rightStart.top);\n        }\n      }\n      output.appendChild(fragment);\n    }\n    function restartBlink(cm) {\n      if (!cm.state.focused) {\n        return;\n      }\n      var display = cm.display;\n      clearInterval(display.blinker);\n      var on2 = true;\n      display.cursorDiv.style.visibility = \"\";\n      if (cm.options.cursorBlinkRate > 0) {\n        display.blinker = setInterval(function() {\n          if (!cm.hasFocus()) {\n            onBlur(cm);\n          }\n          display.cursorDiv.style.visibility = (on2 = !on2) ? \"\" : \"hidden\";\n        }, cm.options.cursorBlinkRate);\n      } else if (cm.options.cursorBlinkRate < 0) {\n        display.cursorDiv.style.visibility = \"hidden\";\n      }\n    }\n    function ensureFocus(cm) {\n      if (!cm.hasFocus()) {\n        cm.display.input.focus();\n        if (!cm.state.focused) {\n          onFocus(cm);\n        }\n      }\n    }\n    function delayBlurEvent(cm) {\n      cm.state.delayingBlurEvent = true;\n      setTimeout(function() {\n        if (cm.state.delayingBlurEvent) {\n          cm.state.delayingBlurEvent = false;\n          if (cm.state.focused) {\n            onBlur(cm);\n          }\n        }\n      }, 100);\n    }\n    function onFocus(cm, e) {\n      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {\n        cm.state.delayingBlurEvent = false;\n      }\n      if (cm.options.readOnly == \"nocursor\") {\n        return;\n      }\n      if (!cm.state.focused) {\n        signal(cm, \"focus\", cm, e);\n        cm.state.focused = true;\n        addClass(cm.display.wrapper, \"CodeMirror-focused\");\n        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n          cm.display.input.reset();\n          if (webkit) {\n            setTimeout(function() {\n              return cm.display.input.reset(true);\n            }, 20);\n          }\n        }\n        cm.display.input.receivedFocus();\n      }\n      restartBlink(cm);\n    }\n    function onBlur(cm, e) {\n      if (cm.state.delayingBlurEvent) {\n        return;\n      }\n      if (cm.state.focused) {\n        signal(cm, \"blur\", cm, e);\n        cm.state.focused = false;\n        rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n      }\n      clearInterval(cm.display.blinker);\n      setTimeout(function() {\n        if (!cm.state.focused) {\n          cm.display.shift = false;\n        }\n      }, 150);\n    }\n    function updateHeightsInViewport(cm) {\n      var display = cm.display;\n      var prevBottom = display.lineDiv.offsetTop;\n      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n      var oldHeight = display.lineDiv.getBoundingClientRect().top;\n      var mustScroll = 0;\n      for (var i2 = 0; i2 < display.view.length; i2++) {\n        var cur = display.view[i2], wrapping = cm.options.lineWrapping;\n        var height = void 0, width = 0;\n        if (cur.hidden) {\n          continue;\n        }\n        oldHeight += cur.line.height;\n        if (ie2 && ie_version < 8) {\n          var bot2 = cur.node.offsetTop + cur.node.offsetHeight;\n          height = bot2 - prevBottom;\n          prevBottom = bot2;\n        } else {\n          var box = cur.node.getBoundingClientRect();\n          height = box.bottom - box.top;\n          if (!wrapping && cur.text.firstChild) {\n            width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n          }\n        }\n        var diff2 = cur.line.height - height;\n        if (diff2 > 5e-3 || diff2 < -5e-3) {\n          if (oldHeight < viewTop) {\n            mustScroll -= diff2;\n          }\n          updateLineHeight(cur.line, height);\n          updateWidgetHeight(cur.line);\n          if (cur.rest) {\n            for (var j = 0; j < cur.rest.length; j++) {\n              updateWidgetHeight(cur.rest[j]);\n            }\n          }\n        }\n        if (width > cm.display.sizerWidth) {\n          var chWidth = Math.ceil(width / charWidth(cm.display));\n          if (chWidth > cm.display.maxLineLength) {\n            cm.display.maxLineLength = chWidth;\n            cm.display.maxLine = cur.line;\n            cm.display.maxLineChanged = true;\n          }\n        }\n      }\n      if (Math.abs(mustScroll) > 2) {\n        display.scroller.scrollTop += mustScroll;\n      }\n    }\n    function updateWidgetHeight(line) {\n      if (line.widgets) {\n        for (var i2 = 0; i2 < line.widgets.length; ++i2) {\n          var w = line.widgets[i2], parent = w.node.parentNode;\n          if (parent) {\n            w.height = parent.offsetHeight;\n          }\n        }\n      }\n    }\n    function visibleLines(display, doc, viewport) {\n      var top2 = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n      top2 = Math.floor(top2 - paddingTop(display));\n      var bottom2 = viewport && viewport.bottom != null ? viewport.bottom : top2 + display.wrapper.clientHeight;\n      var from = lineAtHeight(doc, top2), to = lineAtHeight(doc, bottom2);\n      if (viewport && viewport.ensure) {\n        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n        if (ensureFrom < from) {\n          from = ensureFrom;\n          to = lineAtHeight(doc, heightAtLine(getLine2(doc, ensureFrom)) + display.wrapper.clientHeight);\n        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n          from = lineAtHeight(doc, heightAtLine(getLine2(doc, ensureTo)) - display.wrapper.clientHeight);\n          to = ensureTo;\n        }\n      }\n      return { from, to: Math.max(to, from + 1) };\n    }\n    function maybeScrollWindow(cm, rect2) {\n      if (signalDOMEvent(cm, \"scrollCursorIntoView\")) {\n        return;\n      }\n      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n      if (rect2.top + box.top < 0) {\n        doScroll = true;\n      } else if (rect2.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {\n        doScroll = false;\n      }\n      if (doScroll != null && !phantom) {\n        var scrollNode = elt(\"div\", \"\\u200B\", null, \"position: absolute;\\n                         top: \" + (rect2.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect2.bottom - rect2.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + rect2.left + \"px; width: \" + Math.max(2, rect2.right - rect2.left) + \"px;\");\n        cm.display.lineSpace.appendChild(scrollNode);\n        scrollNode.scrollIntoView(doScroll);\n        cm.display.lineSpace.removeChild(scrollNode);\n      }\n    }\n    function scrollPosIntoView(cm, pos, end2, margin) {\n      if (margin == null) {\n        margin = 0;\n      }\n      var rect2;\n      if (!cm.options.lineWrapping && pos == end2) {\n        end2 = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n        pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      }\n      for (var limit = 0; limit < 5; limit++) {\n        var changed = false;\n        var coords = cursorCoords(cm, pos);\n        var endCoords = !end2 || end2 == pos ? coords : cursorCoords(cm, end2);\n        rect2 = {\n          left: Math.min(coords.left, endCoords.left),\n          top: Math.min(coords.top, endCoords.top) - margin,\n          right: Math.max(coords.left, endCoords.left),\n          bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n        };\n        var scrollPos = calculateScrollPos(cm, rect2);\n        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n        if (scrollPos.scrollTop != null) {\n          updateScrollTop(cm, scrollPos.scrollTop);\n          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n            changed = true;\n          }\n        }\n        if (scrollPos.scrollLeft != null) {\n          setScrollLeft(cm, scrollPos.scrollLeft);\n          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n      }\n      return rect2;\n    }\n    function scrollIntoView(cm, rect2) {\n      var scrollPos = calculateScrollPos(cm, rect2);\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n      }\n    }\n    function calculateScrollPos(cm, rect2) {\n      var display = cm.display, snapMargin = textHeight(cm.display);\n      if (rect2.top < 0) {\n        rect2.top = 0;\n      }\n      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n      var screen2 = displayHeight(cm), result2 = {};\n      if (rect2.bottom - rect2.top > screen2) {\n        rect2.bottom = rect2.top + screen2;\n      }\n      var docBottom = cm.doc.height + paddingVert(display);\n      var atTop = rect2.top < snapMargin, atBottom = rect2.bottom > docBottom - snapMargin;\n      if (rect2.top < screentop) {\n        result2.scrollTop = atTop ? 0 : rect2.top;\n      } else if (rect2.bottom > screentop + screen2) {\n        var newTop = Math.min(rect2.top, (atBottom ? docBottom : rect2.bottom) - screen2);\n        if (newTop != screentop) {\n          result2.scrollTop = newTop;\n        }\n      }\n      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n      var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n      var tooWide = rect2.right - rect2.left > screenw;\n      if (tooWide) {\n        rect2.right = rect2.left + screenw;\n      }\n      if (rect2.left < 10) {\n        result2.scrollLeft = 0;\n      } else if (rect2.left < screenleft) {\n        result2.scrollLeft = Math.max(0, rect2.left + gutterSpace - (tooWide ? 0 : 10));\n      } else if (rect2.right > screenw + screenleft - 3) {\n        result2.scrollLeft = rect2.right + (tooWide ? 0 : 10) - screenw;\n      }\n      return result2;\n    }\n    function addToScrollTop(cm, top2) {\n      if (top2 == null) {\n        return;\n      }\n      resolveScrollToPos(cm);\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;\n    }\n    function ensureCursorVisible(cm) {\n      resolveScrollToPos(cm);\n      var cur = cm.getCursor();\n      cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };\n    }\n    function scrollToCoords(cm, x2, y2) {\n      if (x2 != null || y2 != null) {\n        resolveScrollToPos(cm);\n      }\n      if (x2 != null) {\n        cm.curOp.scrollLeft = x2;\n      }\n      if (y2 != null) {\n        cm.curOp.scrollTop = y2;\n      }\n    }\n    function scrollToRange(cm, range3) {\n      resolveScrollToPos(cm);\n      cm.curOp.scrollToPos = range3;\n    }\n    function resolveScrollToPos(cm) {\n      var range3 = cm.curOp.scrollToPos;\n      if (range3) {\n        cm.curOp.scrollToPos = null;\n        var from = estimateCoords(cm, range3.from), to = estimateCoords(cm, range3.to);\n        scrollToCoordsRange(cm, from, to, range3.margin);\n      }\n    }\n    function scrollToCoordsRange(cm, from, to, margin) {\n      var sPos = calculateScrollPos(cm, {\n        left: Math.min(from.left, to.left),\n        top: Math.min(from.top, to.top) - margin,\n        right: Math.max(from.right, to.right),\n        bottom: Math.max(from.bottom, to.bottom) + margin\n      });\n      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n    }\n    function updateScrollTop(cm, val) {\n      if (Math.abs(cm.doc.scrollTop - val) < 2) {\n        return;\n      }\n      if (!gecko) {\n        updateDisplaySimple(cm, { top: val });\n      }\n      setScrollTop(cm, val, true);\n      if (gecko) {\n        updateDisplaySimple(cm);\n      }\n      startWorker(cm, 100);\n    }\n    function setScrollTop(cm, val, forceScroll) {\n      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n      if (cm.display.scroller.scrollTop == val && !forceScroll) {\n        return;\n      }\n      cm.doc.scrollTop = val;\n      cm.display.scrollbars.setScrollTop(val);\n      if (cm.display.scroller.scrollTop != val) {\n        cm.display.scroller.scrollTop = val;\n      }\n    }\n    function setScrollLeft(cm, val, isScroller, forceScroll) {\n      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n        return;\n      }\n      cm.doc.scrollLeft = val;\n      alignHorizontally(cm);\n      if (cm.display.scroller.scrollLeft != val) {\n        cm.display.scroller.scrollLeft = val;\n      }\n      cm.display.scrollbars.setScrollLeft(val);\n    }\n    function measureForScrollbars(cm) {\n      var d = cm.display, gutterW = d.gutters.offsetWidth;\n      var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n      return {\n        clientHeight: d.scroller.clientHeight,\n        viewHeight: d.wrapper.clientHeight,\n        scrollWidth: d.scroller.scrollWidth,\n        clientWidth: d.scroller.clientWidth,\n        viewWidth: d.wrapper.clientWidth,\n        barLeft: cm.options.fixedGutter ? gutterW : 0,\n        docHeight: docH,\n        scrollHeight: docH + scrollGap(cm) + d.barHeight,\n        nativeBarWidth: d.nativeBarWidth,\n        gutterWidth: gutterW\n      };\n    }\n    var NativeScrollbars = function(place, scroll, cm) {\n      this.cm = cm;\n      var vert2 = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n      var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n      vert2.tabIndex = horiz.tabIndex = -1;\n      place(vert2);\n      place(horiz);\n      on(vert2, \"scroll\", function() {\n        if (vert2.clientHeight) {\n          scroll(vert2.scrollTop, \"vertical\");\n        }\n      });\n      on(horiz, \"scroll\", function() {\n        if (horiz.clientWidth) {\n          scroll(horiz.scrollLeft, \"horizontal\");\n        }\n      });\n      this.checkedZeroWidth = false;\n      if (ie2 && ie_version < 8) {\n        this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n      }\n    };\n    NativeScrollbars.prototype.update = function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n      if (needsV) {\n        this.vert.style.display = \"block\";\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n      } else {\n        this.vert.scrollTop = 0;\n        this.vert.style.display = \"\";\n        this.vert.firstChild.style.height = \"0\";\n      }\n      if (needsH) {\n        this.horiz.style.display = \"block\";\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n        this.horiz.style.left = measure.barLeft + \"px\";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n      } else {\n        this.horiz.style.display = \"\";\n        this.horiz.firstChild.style.width = \"0\";\n      }\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n        if (sWidth == 0) {\n          this.zeroWidthHack();\n        }\n        this.checkedZeroWidth = true;\n      }\n      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };\n    };\n    NativeScrollbars.prototype.setScrollLeft = function(pos) {\n      if (this.horiz.scrollLeft != pos) {\n        this.horiz.scrollLeft = pos;\n      }\n      if (this.disableHoriz) {\n        this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\");\n      }\n    };\n    NativeScrollbars.prototype.setScrollTop = function(pos) {\n      if (this.vert.scrollTop != pos) {\n        this.vert.scrollTop = pos;\n      }\n      if (this.disableVert) {\n        this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\");\n      }\n    };\n    NativeScrollbars.prototype.zeroWidthHack = function() {\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n      this.horiz.style.height = this.vert.style.width = w;\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n      this.disableHoriz = new Delayed();\n      this.disableVert = new Delayed();\n    };\n    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type2) {\n      bar.style.pointerEvents = \"auto\";\n      function maybeDisable() {\n        var box = bar.getBoundingClientRect();\n        var elt2 = type2 == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n        if (elt2 != bar) {\n          bar.style.pointerEvents = \"none\";\n        } else {\n          delay.set(1e3, maybeDisable);\n        }\n      }\n      delay.set(1e3, maybeDisable);\n    };\n    NativeScrollbars.prototype.clear = function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    };\n    var NullScrollbars = function() {\n    };\n    NullScrollbars.prototype.update = function() {\n      return { bottom: 0, right: 0 };\n    };\n    NullScrollbars.prototype.setScrollLeft = function() {\n    };\n    NullScrollbars.prototype.setScrollTop = function() {\n    };\n    NullScrollbars.prototype.clear = function() {\n    };\n    function updateScrollbars(cm, measure) {\n      if (!measure) {\n        measure = measureForScrollbars(cm);\n      }\n      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n      updateScrollbarsInner(cm, measure);\n      for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {\n        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n          updateHeightsInViewport(cm);\n        }\n        updateScrollbarsInner(cm, measureForScrollbars(cm));\n        startWidth = cm.display.barWidth;\n        startHeight = cm.display.barHeight;\n      }\n    }\n    function updateScrollbarsInner(cm, measure) {\n      var d = cm.display;\n      var sizes = d.scrollbars.update(measure);\n      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n      d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n      if (sizes.right && sizes.bottom) {\n        d.scrollbarFiller.style.display = \"block\";\n        d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n        d.scrollbarFiller.style.width = sizes.right + \"px\";\n      } else {\n        d.scrollbarFiller.style.display = \"\";\n      }\n      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n        d.gutterFiller.style.display = \"block\";\n        d.gutterFiller.style.height = sizes.bottom + \"px\";\n        d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n      } else {\n        d.gutterFiller.style.display = \"\";\n      }\n    }\n    var scrollbarModel = { \"native\": NativeScrollbars, \"null\": NullScrollbars };\n    function initScrollbars(cm) {\n      if (cm.display.scrollbars) {\n        cm.display.scrollbars.clear();\n        if (cm.display.scrollbars.addClass) {\n          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n        }\n      }\n      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {\n        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n        on(node, \"mousedown\", function() {\n          if (cm.state.focused) {\n            setTimeout(function() {\n              return cm.display.input.focus();\n            }, 0);\n          }\n        });\n        node.setAttribute(\"cm-not-content\", \"true\");\n      }, function(pos, axis) {\n        if (axis == \"horizontal\") {\n          setScrollLeft(cm, pos);\n        } else {\n          updateScrollTop(cm, pos);\n        }\n      }, cm);\n      if (cm.display.scrollbars.addClass) {\n        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n      }\n    }\n    var nextOpId = 0;\n    function startOperation(cm) {\n      cm.curOp = {\n        cm,\n        viewChanged: false,\n        startHeight: cm.doc.height,\n        forceUpdate: false,\n        updateInput: 0,\n        typing: false,\n        changeObjs: null,\n        cursorActivityHandlers: null,\n        cursorActivityCalled: 0,\n        selectionChanged: false,\n        updateMaxLine: false,\n        scrollLeft: null,\n        scrollTop: null,\n        scrollToPos: null,\n        focus: false,\n        id: ++nextOpId,\n        markArrays: null\n      };\n      pushOperation(cm.curOp);\n    }\n    function endOperation(cm) {\n      var op = cm.curOp;\n      if (op) {\n        finishOperation(op, function(group) {\n          for (var i2 = 0; i2 < group.ops.length; i2++) {\n            group.ops[i2].cm.curOp = null;\n          }\n          endOperations(group);\n        });\n      }\n    }\n    function endOperations(group) {\n      var ops = group.ops;\n      for (var i2 = 0; i2 < ops.length; i2++) {\n        endOperation_R1(ops[i2]);\n      }\n      for (var i$12 = 0; i$12 < ops.length; i$12++) {\n        endOperation_W1(ops[i$12]);\n      }\n      for (var i$22 = 0; i$22 < ops.length; i$22++) {\n        endOperation_R2(ops[i$22]);\n      }\n      for (var i$3 = 0; i$3 < ops.length; i$3++) {\n        endOperation_W2(ops[i$3]);\n      }\n      for (var i$4 = 0; i$4 < ops.length; i$4++) {\n        endOperation_finish(ops[i$4]);\n      }\n    }\n    function endOperation_R1(op) {\n      var cm = op.cm, display = cm.display;\n      maybeClipScrollbars(cm);\n      if (op.updateMaxLine) {\n        findMaxLine(cm);\n      }\n      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);\n    }\n    function endOperation_W1(op) {\n      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n    }\n    function endOperation_R2(op) {\n      var cm = op.cm, display = cm.display;\n      if (op.updatedDisplay) {\n        updateHeightsInViewport(cm);\n      }\n      op.barMeasure = measureForScrollbars(cm);\n      if (display.maxLineChanged && !cm.options.lineWrapping) {\n        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n        cm.display.sizerWidth = op.adjustWidthTo;\n        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n      }\n      if (op.updatedDisplay || op.selectionChanged) {\n        op.preparedSelection = display.input.prepareSelection();\n      }\n    }\n    function endOperation_W2(op) {\n      var cm = op.cm;\n      if (op.adjustWidthTo != null) {\n        cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n        if (op.maxScrollLeft < cm.doc.scrollLeft) {\n          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n        }\n        cm.display.maxLineChanged = false;\n      }\n      var takeFocus = op.focus && op.focus == activeElt();\n      if (op.preparedSelection) {\n        cm.display.input.showSelection(op.preparedSelection, takeFocus);\n      }\n      if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n        updateScrollbars(cm, op.barMeasure);\n      }\n      if (op.updatedDisplay) {\n        setDocumentHeight(cm, op.barMeasure);\n      }\n      if (op.selectionChanged) {\n        restartBlink(cm);\n      }\n      if (cm.state.focused && op.updateInput) {\n        cm.display.input.reset(op.typing);\n      }\n      if (takeFocus) {\n        ensureFocus(op.cm);\n      }\n    }\n    function endOperation_finish(op) {\n      var cm = op.cm, display = cm.display, doc = cm.doc;\n      if (op.updatedDisplay) {\n        postUpdateDisplay(cm, op.update);\n      }\n      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n        display.wheelStartX = display.wheelStartY = null;\n      }\n      if (op.scrollTop != null) {\n        setScrollTop(cm, op.scrollTop, op.forceScroll);\n      }\n      if (op.scrollLeft != null) {\n        setScrollLeft(cm, op.scrollLeft, true, true);\n      }\n      if (op.scrollToPos) {\n        var rect2 = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n        maybeScrollWindow(cm, rect2);\n      }\n      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n      if (hidden) {\n        for (var i2 = 0; i2 < hidden.length; ++i2) {\n          if (!hidden[i2].lines.length) {\n            signal(hidden[i2], \"hide\");\n          }\n        }\n      }\n      if (unhidden) {\n        for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {\n          if (unhidden[i$12].lines.length) {\n            signal(unhidden[i$12], \"unhide\");\n          }\n        }\n      }\n      if (display.wrapper.offsetHeight) {\n        doc.scrollTop = cm.display.scroller.scrollTop;\n      }\n      if (op.changeObjs) {\n        signal(cm, \"changes\", cm, op.changeObjs);\n      }\n      if (op.update) {\n        op.update.finish();\n      }\n    }\n    function runInOp(cm, f) {\n      if (cm.curOp) {\n        return f();\n      }\n      startOperation(cm);\n      try {\n        return f();\n      } finally {\n        endOperation(cm);\n      }\n    }\n    function operation(cm, f) {\n      return function() {\n        if (cm.curOp) {\n          return f.apply(cm, arguments);\n        }\n        startOperation(cm);\n        try {\n          return f.apply(cm, arguments);\n        } finally {\n          endOperation(cm);\n        }\n      };\n    }\n    function methodOp(f) {\n      return function() {\n        if (this.curOp) {\n          return f.apply(this, arguments);\n        }\n        startOperation(this);\n        try {\n          return f.apply(this, arguments);\n        } finally {\n          endOperation(this);\n        }\n      };\n    }\n    function docMethodOp(f) {\n      return function() {\n        var cm = this.cm;\n        if (!cm || cm.curOp) {\n          return f.apply(this, arguments);\n        }\n        startOperation(cm);\n        try {\n          return f.apply(this, arguments);\n        } finally {\n          endOperation(cm);\n        }\n      };\n    }\n    function startWorker(cm, time) {\n      if (cm.doc.highlightFrontier < cm.display.viewTo) {\n        cm.state.highlight.set(time, bind(highlightWorker, cm));\n      }\n    }\n    function highlightWorker(cm) {\n      var doc = cm.doc;\n      if (doc.highlightFrontier >= cm.display.viewTo) {\n        return;\n      }\n      var end2 = +new Date() + cm.options.workTime;\n      var context = getContextBefore(cm, doc.highlightFrontier);\n      var changedLines = [];\n      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n        if (context.line >= cm.display.viewFrom) {\n          var oldStyles = line.styles;\n          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n          var highlighted = highlightLine(cm, line, context, true);\n          if (resetState) {\n            context.state = resetState;\n          }\n          line.styles = highlighted.styles;\n          var oldCls = line.styleClasses, newCls = highlighted.classes;\n          if (newCls) {\n            line.styleClasses = newCls;\n          } else if (oldCls) {\n            line.styleClasses = null;\n          }\n          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n          for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {\n            ischange = oldStyles[i2] != line.styles[i2];\n          }\n          if (ischange) {\n            changedLines.push(context.line);\n          }\n          line.stateAfter = context.save();\n          context.nextLine();\n        } else {\n          if (line.text.length <= cm.options.maxHighlightLength) {\n            processLine(cm, line.text, context);\n          }\n          line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n          context.nextLine();\n        }\n        if (+new Date() > end2) {\n          startWorker(cm, cm.options.workDelay);\n          return true;\n        }\n      });\n      doc.highlightFrontier = context.line;\n      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n      if (changedLines.length) {\n        runInOp(cm, function() {\n          for (var i2 = 0; i2 < changedLines.length; i2++) {\n            regLineChange(cm, changedLines[i2], \"text\");\n          }\n        });\n      }\n    }\n    var DisplayUpdate = function(cm, viewport, force) {\n      var display = cm.display;\n      this.viewport = viewport;\n      this.visible = visibleLines(display, cm.doc, viewport);\n      this.editorIsHidden = !display.wrapper.offsetWidth;\n      this.wrapperHeight = display.wrapper.clientHeight;\n      this.wrapperWidth = display.wrapper.clientWidth;\n      this.oldDisplayWidth = displayWidth(cm);\n      this.force = force;\n      this.dims = getDimensions(cm);\n      this.events = [];\n    };\n    DisplayUpdate.prototype.signal = function(emitter, type2) {\n      if (hasHandler(emitter, type2)) {\n        this.events.push(arguments);\n      }\n    };\n    DisplayUpdate.prototype.finish = function() {\n      for (var i2 = 0; i2 < this.events.length; i2++) {\n        signal.apply(null, this.events[i2]);\n      }\n    };\n    function maybeClipScrollbars(cm) {\n      var display = cm.display;\n      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n        display.heightForcer.style.height = scrollGap(cm) + \"px\";\n        display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n        display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n        display.scrollbarsClipped = true;\n      }\n    }\n    function selectionSnapshot(cm) {\n      if (cm.hasFocus()) {\n        return null;\n      }\n      var active = activeElt();\n      if (!active || !contains(cm.display.lineDiv, active)) {\n        return null;\n      }\n      var result2 = { activeElt: active };\n      if (window.getSelection) {\n        var sel = window.getSelection();\n        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n          result2.anchorNode = sel.anchorNode;\n          result2.anchorOffset = sel.anchorOffset;\n          result2.focusNode = sel.focusNode;\n          result2.focusOffset = sel.focusOffset;\n        }\n      }\n      return result2;\n    }\n    function restoreSelection(snapshot) {\n      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {\n        return;\n      }\n      snapshot.activeElt.focus();\n      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n        var sel = window.getSelection(), range3 = document.createRange();\n        range3.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n        range3.collapse(false);\n        sel.removeAllRanges();\n        sel.addRange(range3);\n        sel.extend(snapshot.focusNode, snapshot.focusOffset);\n      }\n    }\n    function updateDisplayIfNeeded(cm, update) {\n      var display = cm.display, doc = cm.doc;\n      if (update.editorIsHidden) {\n        resetView(cm);\n        return false;\n      }\n      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n        return false;\n      }\n      if (maybeUpdateLineNumberWidth(cm)) {\n        resetView(cm);\n        update.dims = getDimensions(cm);\n      }\n      var end2 = doc.first + doc.size;\n      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n      var to = Math.min(end2, update.visible.to + cm.options.viewportMargin);\n      if (display.viewFrom < from && from - display.viewFrom < 20) {\n        from = Math.max(doc.first, display.viewFrom);\n      }\n      if (display.viewTo > to && display.viewTo - to < 20) {\n        to = Math.min(end2, display.viewTo);\n      }\n      if (sawCollapsedSpans) {\n        from = visualLineNo(cm.doc, from);\n        to = visualLineEndNo(cm.doc, to);\n      }\n      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n      adjustView(cm, from, to);\n      display.viewOffset = heightAtLine(getLine2(cm.doc, display.viewFrom));\n      cm.display.mover.style.top = display.viewOffset + \"px\";\n      var toUpdate = countDirtyView(cm);\n      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n        return false;\n      }\n      var selSnapshot = selectionSnapshot(cm);\n      if (toUpdate > 4) {\n        display.lineDiv.style.display = \"none\";\n      }\n      patchDisplay(cm, display.updateLineNumbers, update.dims);\n      if (toUpdate > 4) {\n        display.lineDiv.style.display = \"\";\n      }\n      display.renderedView = display.view;\n      restoreSelection(selSnapshot);\n      removeChildren(display.cursorDiv);\n      removeChildren(display.selectionDiv);\n      display.gutters.style.height = display.sizer.style.minHeight = 0;\n      if (different) {\n        display.lastWrapHeight = update.wrapperHeight;\n        display.lastWrapWidth = update.wrapperWidth;\n        startWorker(cm, 400);\n      }\n      display.updateLineNumbers = null;\n      return true;\n    }\n    function postUpdateDisplay(cm, update) {\n      var viewport = update.viewport;\n      for (var first = true; ; first = false) {\n        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n          if (viewport && viewport.top != null) {\n            viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };\n          }\n          update.visible = visibleLines(cm.display, cm.doc, viewport);\n          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n            break;\n          }\n        } else if (first) {\n          update.visible = visibleLines(cm.display, cm.doc, viewport);\n        }\n        if (!updateDisplayIfNeeded(cm, update)) {\n          break;\n        }\n        updateHeightsInViewport(cm);\n        var barMeasure = measureForScrollbars(cm);\n        updateSelection(cm);\n        updateScrollbars(cm, barMeasure);\n        setDocumentHeight(cm, barMeasure);\n        update.force = false;\n      }\n      update.signal(cm, \"update\", cm);\n      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n        update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n        cm.display.reportedViewFrom = cm.display.viewFrom;\n        cm.display.reportedViewTo = cm.display.viewTo;\n      }\n    }\n    function updateDisplaySimple(cm, viewport) {\n      var update = new DisplayUpdate(cm, viewport);\n      if (updateDisplayIfNeeded(cm, update)) {\n        updateHeightsInViewport(cm);\n        postUpdateDisplay(cm, update);\n        var barMeasure = measureForScrollbars(cm);\n        updateSelection(cm);\n        updateScrollbars(cm, barMeasure);\n        setDocumentHeight(cm, barMeasure);\n        update.finish();\n      }\n    }\n    function patchDisplay(cm, updateNumbersFrom, dims) {\n      var display = cm.display, lineNumbers = cm.options.lineNumbers;\n      var container = display.lineDiv, cur = container.firstChild;\n      function rm(node2) {\n        var next = node2.nextSibling;\n        if (webkit && mac && cm.display.currentWheelTarget == node2) {\n          node2.style.display = \"none\";\n        } else {\n          node2.parentNode.removeChild(node2);\n        }\n        return next;\n      }\n      var view = display.view, lineN = display.viewFrom;\n      for (var i2 = 0; i2 < view.length; i2++) {\n        var lineView = view[i2];\n        if (lineView.hidden)\n          ;\n        else if (!lineView.node || lineView.node.parentNode != container) {\n          var node = buildLineElement(cm, lineView, lineN, dims);\n          container.insertBefore(node, cur);\n        } else {\n          while (cur != lineView.node) {\n            cur = rm(cur);\n          }\n          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n          if (lineView.changes) {\n            if (indexOf(lineView.changes, \"gutter\") > -1) {\n              updateNumber = false;\n            }\n            updateLineForChanges(cm, lineView, lineN, dims);\n          }\n          if (updateNumber) {\n            removeChildren(lineView.lineNumber);\n            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n          }\n          cur = lineView.node.nextSibling;\n        }\n        lineN += lineView.size;\n      }\n      while (cur) {\n        cur = rm(cur);\n      }\n    }\n    function updateGutterSpace(display) {\n      var width = display.gutters.offsetWidth;\n      display.sizer.style.marginLeft = width + \"px\";\n      signalLater(display, \"gutterChanged\", display);\n    }\n    function setDocumentHeight(cm, measure) {\n      cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n      cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + \"px\";\n    }\n    function alignHorizontally(cm) {\n      var display = cm.display, view = display.view;\n      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n        return;\n      }\n      var comp2 = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n      var gutterW = display.gutters.offsetWidth, left = comp2 + \"px\";\n      for (var i2 = 0; i2 < view.length; i2++) {\n        if (!view[i2].hidden) {\n          if (cm.options.fixedGutter) {\n            if (view[i2].gutter) {\n              view[i2].gutter.style.left = left;\n            }\n            if (view[i2].gutterBackground) {\n              view[i2].gutterBackground.style.left = left;\n            }\n          }\n          var align = view[i2].alignable;\n          if (align) {\n            for (var j = 0; j < align.length; j++) {\n              align[j].style.left = left;\n            }\n          }\n        }\n      }\n      if (cm.options.fixedGutter) {\n        display.gutters.style.left = comp2 + gutterW + \"px\";\n      }\n    }\n    function maybeUpdateLineNumberWidth(cm) {\n      if (!cm.options.lineNumbers) {\n        return false;\n      }\n      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n      if (last.length != display.lineNumChars) {\n        var test2 = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)], \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n        var innerW = test2.firstChild.offsetWidth, padding = test2.offsetWidth - innerW;\n        display.lineGutter.style.width = \"\";\n        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n        display.lineNumWidth = display.lineNumInnerWidth + padding;\n        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n        display.lineGutter.style.width = display.lineNumWidth + \"px\";\n        updateGutterSpace(cm.display);\n        return true;\n      }\n      return false;\n    }\n    function getGutters(gutters, lineNumbers) {\n      var result2 = [], sawLineNumbers = false;\n      for (var i2 = 0; i2 < gutters.length; i2++) {\n        var name2 = gutters[i2], style = null;\n        if (typeof name2 != \"string\") {\n          style = name2.style;\n          name2 = name2.className;\n        }\n        if (name2 == \"CodeMirror-linenumbers\") {\n          if (!lineNumbers) {\n            continue;\n          } else {\n            sawLineNumbers = true;\n          }\n        }\n        result2.push({ className: name2, style });\n      }\n      if (lineNumbers && !sawLineNumbers) {\n        result2.push({ className: \"CodeMirror-linenumbers\", style: null });\n      }\n      return result2;\n    }\n    function renderGutters(display) {\n      var gutters = display.gutters, specs = display.gutterSpecs;\n      removeChildren(gutters);\n      display.lineGutter = null;\n      for (var i2 = 0; i2 < specs.length; ++i2) {\n        var ref = specs[i2];\n        var className = ref.className;\n        var style = ref.style;\n        var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n        if (style) {\n          gElt.style.cssText = style;\n        }\n        if (className == \"CodeMirror-linenumbers\") {\n          display.lineGutter = gElt;\n          gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n        }\n      }\n      gutters.style.display = specs.length ? \"\" : \"none\";\n      updateGutterSpace(display);\n    }\n    function updateGutters(cm) {\n      renderGutters(cm.display);\n      regChange(cm);\n      alignHorizontally(cm);\n    }\n    function Display(place, doc, input, options) {\n      var d = this;\n      this.input = input;\n      d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n      d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n      d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n      d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n      d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n      d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n      d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n      d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n      d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n      d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, \"position: relative; outline: none\");\n      var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n      d.mover = elt(\"div\", [lines], null, \"position: relative\");\n      d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n      d.sizerWidth = null;\n      d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n      d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n      d.lineGutter = null;\n      d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n      d.scroller.setAttribute(\"tabIndex\", \"-1\");\n      d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n      d.wrapper.setAttribute(\"translate\", \"no\");\n      if (ie2 && ie_version < 8) {\n        d.gutters.style.zIndex = -1;\n        d.scroller.style.paddingRight = 0;\n      }\n      if (!webkit && !(gecko && mobile)) {\n        d.scroller.draggable = true;\n      }\n      if (place) {\n        if (place.appendChild) {\n          place.appendChild(d.wrapper);\n        } else {\n          place(d.wrapper);\n        }\n      }\n      d.viewFrom = d.viewTo = doc.first;\n      d.reportedViewFrom = d.reportedViewTo = doc.first;\n      d.view = [];\n      d.renderedView = null;\n      d.externalMeasured = null;\n      d.viewOffset = 0;\n      d.lastWrapHeight = d.lastWrapWidth = 0;\n      d.updateLineNumbers = null;\n      d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n      d.scrollbarsClipped = false;\n      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n      d.alignWidgets = false;\n      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n      d.maxLine = null;\n      d.maxLineLength = 0;\n      d.maxLineChanged = false;\n      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n      d.shift = false;\n      d.selForContextMenu = null;\n      d.activeTouch = null;\n      d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n      renderGutters(d);\n      input.init(d);\n    }\n    var wheelSamples = 0, wheelPixelsPerUnit = null;\n    if (ie2) {\n      wheelPixelsPerUnit = -0.53;\n    } else if (gecko) {\n      wheelPixelsPerUnit = 15;\n    } else if (chrome) {\n      wheelPixelsPerUnit = -0.7;\n    } else if (safari) {\n      wheelPixelsPerUnit = -1 / 3;\n    }\n    function wheelEventDelta(e) {\n      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n        dx = e.detail;\n      }\n      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n        dy = e.detail;\n      } else if (dy == null) {\n        dy = e.wheelDelta;\n      }\n      return { x: dx, y: dy };\n    }\n    function wheelEventPixels(e) {\n      var delta2 = wheelEventDelta(e);\n      delta2.x *= wheelPixelsPerUnit;\n      delta2.y *= wheelPixelsPerUnit;\n      return delta2;\n    }\n    function onScrollWheel(cm, e) {\n      var delta2 = wheelEventDelta(e), dx = delta2.x, dy = delta2.y;\n      var pixelsPerUnit = wheelPixelsPerUnit;\n      if (e.deltaMode === 0) {\n        dx = e.deltaX;\n        dy = e.deltaY;\n        pixelsPerUnit = 1;\n      }\n      var display = cm.display, scroll = display.scroller;\n      var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n      var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n      if (!(dx && canScrollX || dy && canScrollY)) {\n        return;\n      }\n      if (dy && mac && webkit) {\n        outer:\n          for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n            for (var i2 = 0; i2 < view.length; i2++) {\n              if (view[i2].node == cur) {\n                cm.display.currentWheelTarget = cur;\n                break outer;\n              }\n            }\n          }\n      }\n      if (dx && !gecko && !presto && pixelsPerUnit != null) {\n        if (dy && canScrollY) {\n          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));\n        }\n        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));\n        if (!dy || dy && canScrollY) {\n          e_preventDefault(e);\n        }\n        display.wheelStartX = null;\n        return;\n      }\n      if (dy && pixelsPerUnit != null) {\n        var pixels = dy * pixelsPerUnit;\n        var top2 = cm.doc.scrollTop, bot2 = top2 + display.wrapper.clientHeight;\n        if (pixels < 0) {\n          top2 = Math.max(0, top2 + pixels - 50);\n        } else {\n          bot2 = Math.min(cm.doc.height, bot2 + pixels + 50);\n        }\n        updateDisplaySimple(cm, { top: top2, bottom: bot2 });\n      }\n      if (wheelSamples < 20 && e.deltaMode !== 0) {\n        if (display.wheelStartX == null) {\n          display.wheelStartX = scroll.scrollLeft;\n          display.wheelStartY = scroll.scrollTop;\n          display.wheelDX = dx;\n          display.wheelDY = dy;\n          setTimeout(function() {\n            if (display.wheelStartX == null) {\n              return;\n            }\n            var movedX = scroll.scrollLeft - display.wheelStartX;\n            var movedY = scroll.scrollTop - display.wheelStartY;\n            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n            display.wheelStartX = display.wheelStartY = null;\n            if (!sample) {\n              return;\n            }\n            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n            ++wheelSamples;\n          }, 200);\n        } else {\n          display.wheelDX += dx;\n          display.wheelDY += dy;\n        }\n      }\n    }\n    var Selection = function(ranges, primIndex) {\n      this.ranges = ranges;\n      this.primIndex = primIndex;\n    };\n    Selection.prototype.primary = function() {\n      return this.ranges[this.primIndex];\n    };\n    Selection.prototype.equals = function(other) {\n      if (other == this) {\n        return true;\n      }\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n        return false;\n      }\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        var here = this.ranges[i2], there = other.ranges[i2];\n        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    Selection.prototype.deepCopy = function() {\n      var out = [];\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        out[i2] = new Range2(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));\n      }\n      return new Selection(out, this.primIndex);\n    };\n    Selection.prototype.somethingSelected = function() {\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        if (!this.ranges[i2].empty()) {\n          return true;\n        }\n      }\n      return false;\n    };\n    Selection.prototype.contains = function(pos, end2) {\n      if (!end2) {\n        end2 = pos;\n      }\n      for (var i2 = 0; i2 < this.ranges.length; i2++) {\n        var range3 = this.ranges[i2];\n        if (cmp(end2, range3.from()) >= 0 && cmp(pos, range3.to()) <= 0) {\n          return i2;\n        }\n      }\n      return -1;\n    };\n    var Range2 = function(anchor, head) {\n      this.anchor = anchor;\n      this.head = head;\n    };\n    Range2.prototype.from = function() {\n      return minPos(this.anchor, this.head);\n    };\n    Range2.prototype.to = function() {\n      return maxPos(this.anchor, this.head);\n    };\n    Range2.prototype.empty = function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    };\n    function normalizeSelection(cm, ranges, primIndex) {\n      var mayTouch = cm && cm.options.selectionsMayTouch;\n      var prim = ranges[primIndex];\n      ranges.sort(function(a, b) {\n        return cmp(a.from(), b.from());\n      });\n      primIndex = indexOf(ranges, prim);\n      for (var i2 = 1; i2 < ranges.length; i2++) {\n        var cur = ranges[i2], prev = ranges[i2 - 1];\n        var diff2 = cmp(prev.to(), cur.from());\n        if (mayTouch && !cur.empty() ? diff2 > 0 : diff2 >= 0) {\n          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n          if (i2 <= primIndex) {\n            --primIndex;\n          }\n          ranges.splice(--i2, 2, new Range2(inv ? to : from, inv ? from : to));\n        }\n      }\n      return new Selection(ranges, primIndex);\n    }\n    function simpleSelection(anchor, head) {\n      return new Selection([new Range2(anchor, head || anchor)], 0);\n    }\n    function changeEnd(change) {\n      if (!change.text) {\n        return change.to;\n      }\n      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n    }\n    function adjustForChange(pos, change) {\n      if (cmp(pos, change.from) < 0) {\n        return pos;\n      }\n      if (cmp(pos, change.to) <= 0) {\n        return changeEnd(change);\n      }\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch2 = pos.ch;\n      if (pos.line == change.to.line) {\n        ch2 += changeEnd(change).ch - change.to.ch;\n      }\n      return Pos(line, ch2);\n    }\n    function computeSelAfterChange(doc, change) {\n      var out = [];\n      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n        var range3 = doc.sel.ranges[i2];\n        out.push(new Range2(adjustForChange(range3.anchor, change), adjustForChange(range3.head, change)));\n      }\n      return normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    }\n    function offsetPos(pos, old, nw) {\n      if (pos.line == old.line) {\n        return Pos(nw.line, pos.ch - old.ch + nw.ch);\n      } else {\n        return Pos(nw.line + (pos.line - old.line), pos.ch);\n      }\n    }\n    function computeReplacedSel(doc, changes, hint2) {\n      var out = [];\n      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n      for (var i2 = 0; i2 < changes.length; i2++) {\n        var change = changes[i2];\n        var from = offsetPos(change.from, oldPrev, newPrev);\n        var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n        oldPrev = change.to;\n        newPrev = to;\n        if (hint2 == \"around\") {\n          var range3 = doc.sel.ranges[i2], inv = cmp(range3.head, range3.anchor) < 0;\n          out[i2] = new Range2(inv ? to : from, inv ? from : to);\n        } else {\n          out[i2] = new Range2(from, from);\n        }\n      }\n      return new Selection(out, doc.sel.primIndex);\n    }\n    function loadMode(cm) {\n      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n      resetModeState(cm);\n    }\n    function resetModeState(cm) {\n      cm.doc.iter(function(line) {\n        if (line.stateAfter) {\n          line.stateAfter = null;\n        }\n        if (line.styles) {\n          line.styles = null;\n        }\n      });\n      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n      startWorker(cm, 100);\n      cm.state.modeGen++;\n      if (cm.curOp) {\n        regChange(cm);\n      }\n    }\n    function isWholeLineUpdate(doc, change) {\n      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n    }\n    function updateDoc(doc, change, markedSpans, estimateHeight2) {\n      function spansFor(n2) {\n        return markedSpans ? markedSpans[n2] : null;\n      }\n      function update(line, text4, spans) {\n        updateLine(line, text4, spans, estimateHeight2);\n        signalLater(line, \"change\", line, change);\n      }\n      function linesFor(start2, end2) {\n        var result2 = [];\n        for (var i2 = start2; i2 < end2; ++i2) {\n          result2.push(new Line(text3[i2], spansFor(i2), estimateHeight2));\n        }\n        return result2;\n      }\n      var from = change.from, to = change.to, text3 = change.text;\n      var firstLine = getLine2(doc, from.line), lastLine = getLine2(doc, to.line);\n      var lastText = lst(text3), lastSpans = spansFor(text3.length - 1), nlines = to.line - from.line;\n      if (change.full) {\n        doc.insert(0, linesFor(0, text3.length));\n        doc.remove(text3.length, doc.size - text3.length);\n      } else if (isWholeLineUpdate(doc, change)) {\n        var added = linesFor(0, text3.length - 1);\n        update(lastLine, lastLine.text, lastSpans);\n        if (nlines) {\n          doc.remove(from.line, nlines);\n        }\n        if (added.length) {\n          doc.insert(from.line, added);\n        }\n      } else if (firstLine == lastLine) {\n        if (text3.length == 1) {\n          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n        } else {\n          var added$1 = linesFor(1, text3.length - 1);\n          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));\n          update(firstLine, firstLine.text.slice(0, from.ch) + text3[0], spansFor(0));\n          doc.insert(from.line + 1, added$1);\n        }\n      } else if (text3.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + text3[0] + lastLine.text.slice(to.ch), spansFor(0));\n        doc.remove(from.line + 1, nlines);\n      } else {\n        update(firstLine, firstLine.text.slice(0, from.ch) + text3[0], spansFor(0));\n        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n        var added$2 = linesFor(1, text3.length - 1);\n        if (nlines > 1) {\n          doc.remove(from.line + 1, nlines - 1);\n        }\n        doc.insert(from.line + 1, added$2);\n      }\n      signalLater(doc, \"change\", doc, change);\n    }\n    function linkedDocs(doc, f, sharedHistOnly) {\n      function propagate(doc2, skip2, sharedHist) {\n        if (doc2.linked) {\n          for (var i2 = 0; i2 < doc2.linked.length; ++i2) {\n            var rel = doc2.linked[i2];\n            if (rel.doc == skip2) {\n              continue;\n            }\n            var shared = sharedHist && rel.sharedHist;\n            if (sharedHistOnly && !shared) {\n              continue;\n            }\n            f(rel.doc, shared);\n            propagate(rel.doc, doc2, shared);\n          }\n        }\n      }\n      propagate(doc, null, true);\n    }\n    function attachDoc(cm, doc) {\n      if (doc.cm) {\n        throw new Error(\"This document is already in use.\");\n      }\n      cm.doc = doc;\n      doc.cm = cm;\n      estimateLineHeights(cm);\n      loadMode(cm);\n      setDirectionClass(cm);\n      cm.options.direction = doc.direction;\n      if (!cm.options.lineWrapping) {\n        findMaxLine(cm);\n      }\n      cm.options.mode = doc.modeOption;\n      regChange(cm);\n    }\n    function setDirectionClass(cm) {\n      (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n    }\n    function directionChanged(cm) {\n      runInOp(cm, function() {\n        setDirectionClass(cm);\n        regChange(cm);\n      });\n    }\n    function History(prev) {\n      this.done = [];\n      this.undone = [];\n      this.undoDepth = prev ? prev.undoDepth : Infinity;\n      this.lastModTime = this.lastSelTime = 0;\n      this.lastOp = this.lastSelOp = null;\n      this.lastOrigin = this.lastSelOrigin = null;\n      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n    }\n    function historyChangeFromChange(doc, change) {\n      var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };\n      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n      linkedDocs(doc, function(doc2) {\n        return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);\n      }, true);\n      return histChange;\n    }\n    function clearSelectionEvents(array) {\n      while (array.length) {\n        var last = lst(array);\n        if (last.ranges) {\n          array.pop();\n        } else {\n          break;\n        }\n      }\n    }\n    function lastChangeEvent(hist, force) {\n      if (force) {\n        clearSelectionEvents(hist.done);\n        return lst(hist.done);\n      } else if (hist.done.length && !lst(hist.done).ranges) {\n        return lst(hist.done);\n      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n        hist.done.pop();\n        return lst(hist.done);\n      }\n    }\n    function addChangeToHistory(doc, change, selAfter, opId) {\n      var hist = doc.history;\n      hist.undone.length = 0;\n      var time = +new Date(), cur;\n      var last;\n      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == \"*\")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n        last = lst(cur.changes);\n        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n          last.to = changeEnd(change);\n        } else {\n          cur.changes.push(historyChangeFromChange(doc, change));\n        }\n      } else {\n        var before = lst(hist.done);\n        if (!before || !before.ranges) {\n          pushSelectionToHistory(doc.sel, hist.done);\n        }\n        cur = {\n          changes: [historyChangeFromChange(doc, change)],\n          generation: hist.generation\n        };\n        hist.done.push(cur);\n        while (hist.done.length > hist.undoDepth) {\n          hist.done.shift();\n          if (!hist.done[0].ranges) {\n            hist.done.shift();\n          }\n        }\n      }\n      hist.done.push(selAfter);\n      hist.generation = ++hist.maxGeneration;\n      hist.lastModTime = hist.lastSelTime = time;\n      hist.lastOp = hist.lastSelOp = opId;\n      hist.lastOrigin = hist.lastSelOrigin = change.origin;\n      if (!last) {\n        signal(doc, \"historyAdded\");\n      }\n    }\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\n      var ch2 = origin.charAt(0);\n      return ch2 == \"*\" || ch2 == \"+\" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n    }\n    function addSelectionToHistory(doc, sel, opId, options) {\n      var hist = doc.history, origin = options && options.origin;\n      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {\n        hist.done[hist.done.length - 1] = sel;\n      } else {\n        pushSelectionToHistory(sel, hist.done);\n      }\n      hist.lastSelTime = +new Date();\n      hist.lastSelOrigin = origin;\n      hist.lastSelOp = opId;\n      if (options && options.clearRedo !== false) {\n        clearSelectionEvents(hist.undone);\n      }\n    }\n    function pushSelectionToHistory(sel, dest) {\n      var top2 = lst(dest);\n      if (!(top2 && top2.ranges && top2.equals(sel))) {\n        dest.push(sel);\n      }\n    }\n    function attachLocalSpans(doc, change, from, to) {\n      var existing = change[\"spans_\" + doc.id], n2 = 0;\n      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n        if (line.markedSpans) {\n          (existing || (existing = change[\"spans_\" + doc.id] = {}))[n2] = line.markedSpans;\n        }\n        ++n2;\n      });\n    }\n    function removeClearedSpans(spans) {\n      if (!spans) {\n        return null;\n      }\n      var out;\n      for (var i2 = 0; i2 < spans.length; ++i2) {\n        if (spans[i2].marker.explicitlyCleared) {\n          if (!out) {\n            out = spans.slice(0, i2);\n          }\n        } else if (out) {\n          out.push(spans[i2]);\n        }\n      }\n      return !out ? spans : out.length ? out : null;\n    }\n    function getOldSpans(doc, change) {\n      var found = change[\"spans_\" + doc.id];\n      if (!found) {\n        return null;\n      }\n      var nw = [];\n      for (var i2 = 0; i2 < change.text.length; ++i2) {\n        nw.push(removeClearedSpans(found[i2]));\n      }\n      return nw;\n    }\n    function mergeOldSpans(doc, change) {\n      var old = getOldSpans(doc, change);\n      var stretched = stretchSpansOverChange(doc, change);\n      if (!old) {\n        return stretched;\n      }\n      if (!stretched) {\n        return old;\n      }\n      for (var i2 = 0; i2 < old.length; ++i2) {\n        var oldCur = old[i2], stretchCur = stretched[i2];\n        if (oldCur && stretchCur) {\n          spans:\n            for (var j = 0; j < stretchCur.length; ++j) {\n              var span = stretchCur[j];\n              for (var k = 0; k < oldCur.length; ++k) {\n                if (oldCur[k].marker == span.marker) {\n                  continue spans;\n                }\n              }\n              oldCur.push(span);\n            }\n        } else if (stretchCur) {\n          old[i2] = stretchCur;\n        }\n      }\n      return old;\n    }\n    function copyHistoryArray(events, newGroup, instantiateSel) {\n      var copy2 = [];\n      for (var i2 = 0; i2 < events.length; ++i2) {\n        var event = events[i2];\n        if (event.ranges) {\n          copy2.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n          continue;\n        }\n        var changes = event.changes, newChanges = [];\n        copy2.push({ changes: newChanges });\n        for (var j = 0; j < changes.length; ++j) {\n          var change = changes[j], m2 = void 0;\n          newChanges.push({ from: change.from, to: change.to, text: change.text });\n          if (newGroup) {\n            for (var prop3 in change) {\n              if (m2 = prop3.match(/^spans_(\\d+)$/)) {\n                if (indexOf(newGroup, Number(m2[1])) > -1) {\n                  lst(newChanges)[prop3] = change[prop3];\n                  delete change[prop3];\n                }\n              }\n            }\n          }\n        }\n      }\n      return copy2;\n    }\n    function extendRange(range3, head, other, extend) {\n      if (extend) {\n        var anchor = range3.anchor;\n        if (other) {\n          var posBefore = cmp(head, anchor) < 0;\n          if (posBefore != cmp(other, anchor) < 0) {\n            anchor = head;\n            head = other;\n          } else if (posBefore != cmp(head, other) < 0) {\n            head = other;\n          }\n        }\n        return new Range2(anchor, head);\n      } else {\n        return new Range2(other || head, head);\n      }\n    }\n    function extendSelection(doc, head, other, options, extend) {\n      if (extend == null) {\n        extend = doc.cm && (doc.cm.display.shift || doc.extend);\n      }\n      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n    }\n    function extendSelections(doc, heads, options) {\n      var out = [];\n      var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n        out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend);\n      }\n      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n      setSelection(doc, newSel, options);\n    }\n    function replaceOneSelection(doc, i2, range3, options) {\n      var ranges = doc.sel.ranges.slice(0);\n      ranges[i2] = range3;\n      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n    }\n    function setSimpleSelection(doc, anchor, head, options) {\n      setSelection(doc, simpleSelection(anchor, head), options);\n    }\n    function filterSelectionChange(doc, sel, options) {\n      var obj = {\n        ranges: sel.ranges,\n        update: function(ranges) {\n          this.ranges = [];\n          for (var i2 = 0; i2 < ranges.length; i2++) {\n            this.ranges[i2] = new Range2(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));\n          }\n        },\n        origin: options && options.origin\n      };\n      signal(doc, \"beforeSelectionChange\", doc, obj);\n      if (doc.cm) {\n        signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n      }\n      if (obj.ranges != sel.ranges) {\n        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);\n      } else {\n        return sel;\n      }\n    }\n    function setSelectionReplaceHistory(doc, sel, options) {\n      var done = doc.history.done, last = lst(done);\n      if (last && last.ranges) {\n        done[done.length - 1] = sel;\n        setSelectionNoUndo(doc, sel, options);\n      } else {\n        setSelection(doc, sel, options);\n      }\n    }\n    function setSelection(doc, sel, options) {\n      setSelectionNoUndo(doc, sel, options);\n      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n    }\n    function setSelectionNoUndo(doc, sel, options) {\n      if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n        sel = filterSelectionChange(doc, sel, options);\n      }\n      var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n      if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\") {\n        ensureCursorVisible(doc.cm);\n      }\n    }\n    function setSelectionInner(doc, sel) {\n      if (sel.equals(doc.sel)) {\n        return;\n      }\n      doc.sel = sel;\n      if (doc.cm) {\n        doc.cm.curOp.updateInput = 1;\n        doc.cm.curOp.selectionChanged = true;\n        signalCursorActivity(doc.cm);\n      }\n      signalLater(doc, \"cursorActivity\", doc);\n    }\n    function reCheckSelection(doc) {\n      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n    }\n    function skipAtomicInSelection(doc, sel, bias, mayClear) {\n      var out;\n      for (var i2 = 0; i2 < sel.ranges.length; i2++) {\n        var range3 = sel.ranges[i2];\n        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];\n        var newAnchor = skipAtomic(doc, range3.anchor, old && old.anchor, bias, mayClear);\n        var newHead = skipAtomic(doc, range3.head, old && old.head, bias, mayClear);\n        if (out || newAnchor != range3.anchor || newHead != range3.head) {\n          if (!out) {\n            out = sel.ranges.slice(0, i2);\n          }\n          out[i2] = new Range2(newAnchor, newHead);\n        }\n      }\n      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;\n    }\n    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n      var line = getLine2(doc, pos.line);\n      if (line.markedSpans) {\n        for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {\n          var sp = line.markedSpans[i2], m2 = sp.marker;\n          var preventCursorLeft = \"selectLeft\" in m2 ? !m2.selectLeft : m2.inclusiveLeft;\n          var preventCursorRight = \"selectRight\" in m2 ? !m2.selectRight : m2.inclusiveRight;\n          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n            if (mayClear) {\n              signal(m2, \"beforeCursorEnter\");\n              if (m2.explicitlyCleared) {\n                if (!line.markedSpans) {\n                  break;\n                } else {\n                  --i2;\n                  continue;\n                }\n              }\n            }\n            if (!m2.atomic) {\n              continue;\n            }\n            if (oldPos) {\n              var near = m2.find(dir < 0 ? 1 : -1), diff2 = void 0;\n              if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n              }\n              if (near && near.line == pos.line && (diff2 = cmp(near, oldPos)) && (dir < 0 ? diff2 < 0 : diff2 > 0)) {\n                return skipAtomicInner(doc, near, pos, dir, mayClear);\n              }\n            }\n            var far = m2.find(dir < 0 ? -1 : 1);\n            if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n              far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n            }\n            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n          }\n        }\n      }\n      return pos;\n    }\n    function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n      var dir = bias || 1;\n      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);\n      if (!found) {\n        doc.cantEdit = true;\n        return Pos(doc.first, 0);\n      }\n      return found;\n    }\n    function movePos(doc, pos, dir, line) {\n      if (dir < 0 && pos.ch == 0) {\n        if (pos.line > doc.first) {\n          return clipPos(doc, Pos(pos.line - 1));\n        } else {\n          return null;\n        }\n      } else if (dir > 0 && pos.ch == (line || getLine2(doc, pos.line)).text.length) {\n        if (pos.line < doc.first + doc.size - 1) {\n          return Pos(pos.line + 1, 0);\n        } else {\n          return null;\n        }\n      } else {\n        return new Pos(pos.line, pos.ch + dir);\n      }\n    }\n    function selectAll(cm) {\n      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n    }\n    function filterChange(doc, change, update) {\n      var obj = {\n        canceled: false,\n        from: change.from,\n        to: change.to,\n        text: change.text,\n        origin: change.origin,\n        cancel: function() {\n          return obj.canceled = true;\n        }\n      };\n      if (update) {\n        obj.update = function(from, to, text3, origin) {\n          if (from) {\n            obj.from = clipPos(doc, from);\n          }\n          if (to) {\n            obj.to = clipPos(doc, to);\n          }\n          if (text3) {\n            obj.text = text3;\n          }\n          if (origin !== void 0) {\n            obj.origin = origin;\n          }\n        };\n      }\n      signal(doc, \"beforeChange\", doc, obj);\n      if (doc.cm) {\n        signal(doc.cm, \"beforeChange\", doc.cm, obj);\n      }\n      if (obj.canceled) {\n        if (doc.cm) {\n          doc.cm.curOp.updateInput = 2;\n        }\n        return null;\n      }\n      return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };\n    }\n    function makeChange(doc, change, ignoreReadOnly) {\n      if (doc.cm) {\n        if (!doc.cm.curOp) {\n          return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n        }\n        if (doc.cm.state.suppressEdits) {\n          return;\n        }\n      }\n      if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n        change = filterChange(doc, change, true);\n        if (!change) {\n          return;\n        }\n      }\n      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n      if (split) {\n        for (var i2 = split.length - 1; i2 >= 0; --i2) {\n          makeChangeInner(doc, { from: split[i2].from, to: split[i2].to, text: i2 ? [\"\"] : change.text, origin: change.origin });\n        }\n      } else {\n        makeChangeInner(doc, change);\n      }\n    }\n    function makeChangeInner(doc, change) {\n      if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) {\n        return;\n      }\n      var selAfter = computeSelAfterChange(doc, change);\n      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n      var rebased = [];\n      linkedDocs(doc, function(doc2, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc2.history) == -1) {\n          rebaseHist(doc2.history, change);\n          rebased.push(doc2.history);\n        }\n        makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));\n      });\n    }\n    function makeChangeFromHistory(doc, type2, allowSelectionOnly) {\n      var suppress = doc.cm && doc.cm.state.suppressEdits;\n      if (suppress && !allowSelectionOnly) {\n        return;\n      }\n      var hist = doc.history, event, selAfter = doc.sel;\n      var source = type2 == \"undo\" ? hist.done : hist.undone, dest = type2 == \"undo\" ? hist.undone : hist.done;\n      var i2 = 0;\n      for (; i2 < source.length; i2++) {\n        event = source[i2];\n        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {\n          break;\n        }\n      }\n      if (i2 == source.length) {\n        return;\n      }\n      hist.lastOrigin = hist.lastSelOrigin = null;\n      for (; ; ) {\n        event = source.pop();\n        if (event.ranges) {\n          pushSelectionToHistory(event, dest);\n          if (allowSelectionOnly && !event.equals(doc.sel)) {\n            setSelection(doc, event, { clearRedo: false });\n            return;\n          }\n          selAfter = event;\n        } else if (suppress) {\n          source.push(event);\n          return;\n        } else {\n          break;\n        }\n      }\n      var antiChanges = [];\n      pushSelectionToHistory(selAfter, dest);\n      dest.push({ changes: antiChanges, generation: hist.generation });\n      hist.generation = event.generation || ++hist.maxGeneration;\n      var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n      var loop = function(i3) {\n        var change = event.changes[i3];\n        change.origin = type2;\n        if (filter && !filterChange(doc, change, false)) {\n          source.length = 0;\n          return {};\n        }\n        antiChanges.push(historyChangeFromChange(doc, change));\n        var after = i3 ? computeSelAfterChange(doc, change) : lst(source);\n        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n        if (!i3 && doc.cm) {\n          doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });\n        }\n        var rebased = [];\n        linkedDocs(doc, function(doc2, sharedHist) {\n          if (!sharedHist && indexOf(rebased, doc2.history) == -1) {\n            rebaseHist(doc2.history, change);\n            rebased.push(doc2.history);\n          }\n          makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));\n        });\n      };\n      for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {\n        var returned = loop(i$12);\n        if (returned)\n          return returned.v;\n      }\n    }\n    function shiftDoc(doc, distance) {\n      if (distance == 0) {\n        return;\n      }\n      doc.first += distance;\n      doc.sel = new Selection(map2(doc.sel.ranges, function(range3) {\n        return new Range2(Pos(range3.anchor.line + distance, range3.anchor.ch), Pos(range3.head.line + distance, range3.head.ch));\n      }), doc.sel.primIndex);\n      if (doc.cm) {\n        regChange(doc.cm, doc.first, doc.first - distance, distance);\n        for (var d = doc.cm.display, l2 = d.viewFrom; l2 < d.viewTo; l2++) {\n          regLineChange(doc.cm, l2, \"gutter\");\n        }\n      }\n    }\n    function makeChangeSingleDoc(doc, change, selAfter, spans) {\n      if (doc.cm && !doc.cm.curOp) {\n        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n      }\n      if (change.to.line < doc.first) {\n        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n        return;\n      }\n      if (change.from.line > doc.lastLine()) {\n        return;\n      }\n      if (change.from.line < doc.first) {\n        var shift = change.text.length - 1 - (doc.first - change.from.line);\n        shiftDoc(doc, shift);\n        change = {\n          from: Pos(doc.first, 0),\n          to: Pos(change.to.line + shift, change.to.ch),\n          text: [lst(change.text)],\n          origin: change.origin\n        };\n      }\n      var last = doc.lastLine();\n      if (change.to.line > last) {\n        change = {\n          from: change.from,\n          to: Pos(last, getLine2(doc, last).text.length),\n          text: [change.text[0]],\n          origin: change.origin\n        };\n      }\n      change.removed = getBetween(doc, change.from, change.to);\n      if (!selAfter) {\n        selAfter = computeSelAfterChange(doc, change);\n      }\n      if (doc.cm) {\n        makeChangeSingleDocInEditor(doc.cm, change, spans);\n      } else {\n        updateDoc(doc, change, spans);\n      }\n      setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {\n        doc.cantEdit = false;\n      }\n    }\n    function makeChangeSingleDocInEditor(cm, change, spans) {\n      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n      var recomputeMaxLength = false, checkWidthStart = from.line;\n      if (!cm.options.lineWrapping) {\n        checkWidthStart = lineNo(visualLine(getLine2(doc, from.line)));\n        doc.iter(checkWidthStart, to.line + 1, function(line) {\n          if (line == display.maxLine) {\n            recomputeMaxLength = true;\n            return true;\n          }\n        });\n      }\n      if (doc.sel.contains(change.from, change.to) > -1) {\n        signalCursorActivity(cm);\n      }\n      updateDoc(doc, change, spans, estimateHeight(cm));\n      if (!cm.options.lineWrapping) {\n        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n          var len = lineLength(line);\n          if (len > display.maxLineLength) {\n            display.maxLine = line;\n            display.maxLineLength = len;\n            display.maxLineChanged = true;\n            recomputeMaxLength = false;\n          }\n        });\n        if (recomputeMaxLength) {\n          cm.curOp.updateMaxLine = true;\n        }\n      }\n      retreatFrontier(doc, from.line);\n      startWorker(cm, 400);\n      var lendiff = change.text.length - (to.line - from.line) - 1;\n      if (change.full) {\n        regChange(cm);\n      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n        regLineChange(cm, from.line, \"text\");\n      } else {\n        regChange(cm, from.line, to.line + 1, lendiff);\n      }\n      var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n      if (changeHandler || changesHandler) {\n        var obj = {\n          from,\n          to,\n          text: change.text,\n          removed: change.removed,\n          origin: change.origin\n        };\n        if (changeHandler) {\n          signalLater(cm, \"change\", cm, obj);\n        }\n        if (changesHandler) {\n          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n        }\n      }\n      cm.display.selForContextMenu = null;\n    }\n    function replaceRange(doc, code3, from, to, origin) {\n      var assign2;\n      if (!to) {\n        to = from;\n      }\n      if (cmp(to, from) < 0) {\n        assign2 = [to, from], from = assign2[0], to = assign2[1];\n      }\n      if (typeof code3 == \"string\") {\n        code3 = doc.splitLines(code3);\n      }\n      makeChange(doc, { from, to, text: code3, origin });\n    }\n    function rebaseHistSelSingle(pos, from, to, diff2) {\n      if (to < pos.line) {\n        pos.line += diff2;\n      } else if (from < pos.line) {\n        pos.line = from;\n        pos.ch = 0;\n      }\n    }\n    function rebaseHistArray(array, from, to, diff2) {\n      for (var i2 = 0; i2 < array.length; ++i2) {\n        var sub2 = array[i2], ok2 = true;\n        if (sub2.ranges) {\n          if (!sub2.copied) {\n            sub2 = array[i2] = sub2.deepCopy();\n            sub2.copied = true;\n          }\n          for (var j = 0; j < sub2.ranges.length; j++) {\n            rebaseHistSelSingle(sub2.ranges[j].anchor, from, to, diff2);\n            rebaseHistSelSingle(sub2.ranges[j].head, from, to, diff2);\n          }\n          continue;\n        }\n        for (var j$1 = 0; j$1 < sub2.changes.length; ++j$1) {\n          var cur = sub2.changes[j$1];\n          if (to < cur.from.line) {\n            cur.from = Pos(cur.from.line + diff2, cur.from.ch);\n            cur.to = Pos(cur.to.line + diff2, cur.to.ch);\n          } else if (from <= cur.to.line) {\n            ok2 = false;\n            break;\n          }\n        }\n        if (!ok2) {\n          array.splice(0, i2 + 1);\n          i2 = 0;\n        }\n      }\n    }\n    function rebaseHist(hist, change) {\n      var from = change.from.line, to = change.to.line, diff2 = change.text.length - (to - from) - 1;\n      rebaseHistArray(hist.done, from, to, diff2);\n      rebaseHistArray(hist.undone, from, to, diff2);\n    }\n    function changeLine(doc, handle, changeType, op) {\n      var no = handle, line = handle;\n      if (typeof handle == \"number\") {\n        line = getLine2(doc, clipLine(doc, handle));\n      } else {\n        no = lineNo(handle);\n      }\n      if (no == null) {\n        return null;\n      }\n      if (op(line, no) && doc.cm) {\n        regLineChange(doc.cm, no, changeType);\n      }\n      return line;\n    }\n    function LeafChunk(lines) {\n      this.lines = lines;\n      this.parent = null;\n      var height = 0;\n      for (var i2 = 0; i2 < lines.length; ++i2) {\n        lines[i2].parent = this;\n        height += lines[i2].height;\n      }\n      this.height = height;\n    }\n    LeafChunk.prototype = {\n      chunkSize: function() {\n        return this.lines.length;\n      },\n      removeInner: function(at, n2) {\n        for (var i2 = at, e = at + n2; i2 < e; ++i2) {\n          var line = this.lines[i2];\n          this.height -= line.height;\n          cleanUpLine(line);\n          signalLater(line, \"delete\");\n        }\n        this.lines.splice(at, n2);\n      },\n      collapse: function(lines) {\n        lines.push.apply(lines, this.lines);\n      },\n      insertInner: function(at, lines, height) {\n        this.height += height;\n        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n        for (var i2 = 0; i2 < lines.length; ++i2) {\n          lines[i2].parent = this;\n        }\n      },\n      iterN: function(at, n2, op) {\n        for (var e = at + n2; at < e; ++at) {\n          if (op(this.lines[at])) {\n            return true;\n          }\n        }\n      }\n    };\n    function BranchChunk(children) {\n      this.children = children;\n      var size = 0, height = 0;\n      for (var i2 = 0; i2 < children.length; ++i2) {\n        var ch2 = children[i2];\n        size += ch2.chunkSize();\n        height += ch2.height;\n        ch2.parent = this;\n      }\n      this.size = size;\n      this.height = height;\n      this.parent = null;\n    }\n    BranchChunk.prototype = {\n      chunkSize: function() {\n        return this.size;\n      },\n      removeInner: function(at, n2) {\n        this.size -= n2;\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          var child = this.children[i2], sz = child.chunkSize();\n          if (at < sz) {\n            var rm = Math.min(n2, sz - at), oldHeight = child.height;\n            child.removeInner(at, rm);\n            this.height -= oldHeight - child.height;\n            if (sz == rm) {\n              this.children.splice(i2--, 1);\n              child.parent = null;\n            }\n            if ((n2 -= rm) == 0) {\n              break;\n            }\n            at = 0;\n          } else {\n            at -= sz;\n          }\n        }\n        if (this.size - n2 < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n          var lines = [];\n          this.collapse(lines);\n          this.children = [new LeafChunk(lines)];\n          this.children[0].parent = this;\n        }\n      },\n      collapse: function(lines) {\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          this.children[i2].collapse(lines);\n        }\n      },\n      insertInner: function(at, lines, height) {\n        this.size += lines.length;\n        this.height += height;\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          var child = this.children[i2], sz = child.chunkSize();\n          if (at <= sz) {\n            child.insertInner(at, lines, height);\n            if (child.lines && child.lines.length > 50) {\n              var remaining = child.lines.length % 25 + 25;\n              for (var pos = remaining; pos < child.lines.length; ) {\n                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n                child.height -= leaf.height;\n                this.children.splice(++i2, 0, leaf);\n                leaf.parent = this;\n              }\n              child.lines = child.lines.slice(0, remaining);\n              this.maybeSpill();\n            }\n            break;\n          }\n          at -= sz;\n        }\n      },\n      maybeSpill: function() {\n        if (this.children.length <= 10) {\n          return;\n        }\n        var me2 = this;\n        do {\n          var spilled = me2.children.splice(me2.children.length - 5, 5);\n          var sibling = new BranchChunk(spilled);\n          if (!me2.parent) {\n            var copy2 = new BranchChunk(me2.children);\n            copy2.parent = me2;\n            me2.children = [copy2, sibling];\n            me2 = copy2;\n          } else {\n            me2.size -= sibling.size;\n            me2.height -= sibling.height;\n            var myIndex = indexOf(me2.parent.children, me2);\n            me2.parent.children.splice(myIndex + 1, 0, sibling);\n          }\n          sibling.parent = me2.parent;\n        } while (me2.children.length > 10);\n        me2.parent.maybeSpill();\n      },\n      iterN: function(at, n2, op) {\n        for (var i2 = 0; i2 < this.children.length; ++i2) {\n          var child = this.children[i2], sz = child.chunkSize();\n          if (at < sz) {\n            var used = Math.min(n2, sz - at);\n            if (child.iterN(at, used, op)) {\n              return true;\n            }\n            if ((n2 -= used) == 0) {\n              break;\n            }\n            at = 0;\n          } else {\n            at -= sz;\n          }\n        }\n      }\n    };\n    var LineWidget = function(doc, node, options) {\n      if (options) {\n        for (var opt2 in options) {\n          if (options.hasOwnProperty(opt2)) {\n            this[opt2] = options[opt2];\n          }\n        }\n      }\n      this.doc = doc;\n      this.node = node;\n    };\n    LineWidget.prototype.clear = function() {\n      var cm = this.doc.cm, ws2 = this.line.widgets, line = this.line, no = lineNo(line);\n      if (no == null || !ws2) {\n        return;\n      }\n      for (var i2 = 0; i2 < ws2.length; ++i2) {\n        if (ws2[i2] == this) {\n          ws2.splice(i2--, 1);\n        }\n      }\n      if (!ws2.length) {\n        line.widgets = null;\n      }\n      var height = widgetHeight(this);\n      updateLineHeight(line, Math.max(0, line.height - height));\n      if (cm) {\n        runInOp(cm, function() {\n          adjustScrollWhenAboveVisible(cm, line, -height);\n          regLineChange(cm, no, \"widget\");\n        });\n        signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n      }\n    };\n    LineWidget.prototype.changed = function() {\n      var this$1$1 = this;\n      var oldH = this.height, cm = this.doc.cm, line = this.line;\n      this.height = null;\n      var diff2 = widgetHeight(this) - oldH;\n      if (!diff2) {\n        return;\n      }\n      if (!lineIsHidden(this.doc, line)) {\n        updateLineHeight(line, line.height + diff2);\n      }\n      if (cm) {\n        runInOp(cm, function() {\n          cm.curOp.forceUpdate = true;\n          adjustScrollWhenAboveVisible(cm, line, diff2);\n          signalLater(cm, \"lineWidgetChanged\", cm, this$1$1, lineNo(line));\n        });\n      }\n    };\n    eventMixin(LineWidget);\n    function adjustScrollWhenAboveVisible(cm, line, diff2) {\n      if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n        addToScrollTop(cm, diff2);\n      }\n    }\n    function addLineWidget(doc, handle, node, options) {\n      var widget = new LineWidget(doc, node, options);\n      var cm = doc.cm;\n      if (cm && widget.noHScroll) {\n        cm.display.alignWidgets = true;\n      }\n      changeLine(doc, handle, \"widget\", function(line) {\n        var widgets = line.widgets || (line.widgets = []);\n        if (widget.insertAt == null) {\n          widgets.push(widget);\n        } else {\n          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);\n        }\n        widget.line = line;\n        if (cm && !lineIsHidden(doc, line)) {\n          var aboveVisible = heightAtLine(line) < doc.scrollTop;\n          updateLineHeight(line, line.height + widgetHeight(widget));\n          if (aboveVisible) {\n            addToScrollTop(cm, widget.height);\n          }\n          cm.curOp.forceUpdate = true;\n        }\n        return true;\n      });\n      if (cm) {\n        signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n      }\n      return widget;\n    }\n    var nextMarkerId = 0;\n    var TextMarker = function(doc, type2) {\n      this.lines = [];\n      this.type = type2;\n      this.doc = doc;\n      this.id = ++nextMarkerId;\n    };\n    TextMarker.prototype.clear = function() {\n      if (this.explicitlyCleared) {\n        return;\n      }\n      var cm = this.doc.cm, withOp = cm && !cm.curOp;\n      if (withOp) {\n        startOperation(cm);\n      }\n      if (hasHandler(this, \"clear\")) {\n        var found = this.find();\n        if (found) {\n          signalLater(this, \"clear\", found.from, found.to);\n        }\n      }\n      var min = null, max = null;\n      for (var i2 = 0; i2 < this.lines.length; ++i2) {\n        var line = this.lines[i2];\n        var span = getMarkedSpanFor(line.markedSpans, this);\n        if (cm && !this.collapsed) {\n          regLineChange(cm, lineNo(line), \"text\");\n        } else if (cm) {\n          if (span.to != null) {\n            max = lineNo(line);\n          }\n          if (span.from != null) {\n            min = lineNo(line);\n          }\n        }\n        line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {\n          updateLineHeight(line, textHeight(cm.display));\n        }\n      }\n      if (cm && this.collapsed && !cm.options.lineWrapping) {\n        for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {\n          var visual = visualLine(this.lines[i$12]), len = lineLength(visual);\n          if (len > cm.display.maxLineLength) {\n            cm.display.maxLine = visual;\n            cm.display.maxLineLength = len;\n            cm.display.maxLineChanged = true;\n          }\n        }\n      }\n      if (min != null && cm && this.collapsed) {\n        regChange(cm, min, max + 1);\n      }\n      this.lines.length = 0;\n      this.explicitlyCleared = true;\n      if (this.atomic && this.doc.cantEdit) {\n        this.doc.cantEdit = false;\n        if (cm) {\n          reCheckSelection(cm.doc);\n        }\n      }\n      if (cm) {\n        signalLater(cm, \"markerCleared\", cm, this, min, max);\n      }\n      if (withOp) {\n        endOperation(cm);\n      }\n      if (this.parent) {\n        this.parent.clear();\n      }\n    };\n    TextMarker.prototype.find = function(side, lineObj) {\n      if (side == null && this.type == \"bookmark\") {\n        side = 1;\n      }\n      var from, to;\n      for (var i2 = 0; i2 < this.lines.length; ++i2) {\n        var line = this.lines[i2];\n        var span = getMarkedSpanFor(line.markedSpans, this);\n        if (span.from != null) {\n          from = Pos(lineObj ? line : lineNo(line), span.from);\n          if (side == -1) {\n            return from;\n          }\n        }\n        if (span.to != null) {\n          to = Pos(lineObj ? line : lineNo(line), span.to);\n          if (side == 1) {\n            return to;\n          }\n        }\n      }\n      return from && { from, to };\n    };\n    TextMarker.prototype.changed = function() {\n      var this$1$1 = this;\n      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n      if (!pos || !cm) {\n        return;\n      }\n      runInOp(cm, function() {\n        var line = pos.line, lineN = lineNo(pos.line);\n        var view = findViewForLine(cm, lineN);\n        if (view) {\n          clearLineMeasurementCacheFor(view);\n          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n        }\n        cm.curOp.updateMaxLine = true;\n        if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n          var oldHeight = widget.height;\n          widget.height = null;\n          var dHeight = widgetHeight(widget) - oldHeight;\n          if (dHeight) {\n            updateLineHeight(line, line.height + dHeight);\n          }\n        }\n        signalLater(cm, \"markerChanged\", cm, this$1$1);\n      });\n    };\n    TextMarker.prototype.attachLine = function(line) {\n      if (!this.lines.length && this.doc.cm) {\n        var op = this.doc.cm.curOp;\n        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {\n          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n        }\n      }\n      this.lines.push(line);\n    };\n    TextMarker.prototype.detachLine = function(line) {\n      this.lines.splice(indexOf(this.lines, line), 1);\n      if (!this.lines.length && this.doc.cm) {\n        var op = this.doc.cm.curOp;\n        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n      }\n    };\n    eventMixin(TextMarker);\n    function markText(doc, from, to, options, type2) {\n      if (options && options.shared) {\n        return markTextShared(doc, from, to, options, type2);\n      }\n      if (doc.cm && !doc.cm.curOp) {\n        return operation(doc.cm, markText)(doc, from, to, options, type2);\n      }\n      var marker2 = new TextMarker(doc, type2), diff2 = cmp(from, to);\n      if (options) {\n        copyObj(options, marker2, false);\n      }\n      if (diff2 > 0 || diff2 == 0 && marker2.clearWhenEmpty !== false) {\n        return marker2;\n      }\n      if (marker2.replacedWith) {\n        marker2.collapsed = true;\n        marker2.widgetNode = eltP(\"span\", [marker2.replacedWith], \"CodeMirror-widget\");\n        if (!options.handleMouseEvents) {\n          marker2.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n        }\n        if (options.insertLeft) {\n          marker2.widgetNode.insertLeft = true;\n        }\n      }\n      if (marker2.collapsed) {\n        if (conflictingCollapsedRange(doc, from.line, from, to, marker2) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker2)) {\n          throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n        }\n        seeCollapsedSpans();\n      }\n      if (marker2.addToHistory) {\n        addChangeToHistory(doc, { from, to, origin: \"markText\" }, doc.sel, NaN);\n      }\n      var curLine = from.line, cm = doc.cm, updateMaxLine;\n      doc.iter(curLine, to.line + 1, function(line) {\n        if (cm && marker2.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n          updateMaxLine = true;\n        }\n        if (marker2.collapsed && curLine != from.line) {\n          updateLineHeight(line, 0);\n        }\n        addMarkedSpan(line, new MarkedSpan(marker2, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n        ++curLine;\n      });\n      if (marker2.collapsed) {\n        doc.iter(from.line, to.line + 1, function(line) {\n          if (lineIsHidden(doc, line)) {\n            updateLineHeight(line, 0);\n          }\n        });\n      }\n      if (marker2.clearOnEnter) {\n        on(marker2, \"beforeCursorEnter\", function() {\n          return marker2.clear();\n        });\n      }\n      if (marker2.readOnly) {\n        seeReadOnlySpans();\n        if (doc.history.done.length || doc.history.undone.length) {\n          doc.clearHistory();\n        }\n      }\n      if (marker2.collapsed) {\n        marker2.id = ++nextMarkerId;\n        marker2.atomic = true;\n      }\n      if (cm) {\n        if (updateMaxLine) {\n          cm.curOp.updateMaxLine = true;\n        }\n        if (marker2.collapsed) {\n          regChange(cm, from.line, to.line + 1);\n        } else if (marker2.className || marker2.startStyle || marker2.endStyle || marker2.css || marker2.attributes || marker2.title) {\n          for (var i2 = from.line; i2 <= to.line; i2++) {\n            regLineChange(cm, i2, \"text\");\n          }\n        }\n        if (marker2.atomic) {\n          reCheckSelection(cm.doc);\n        }\n        signalLater(cm, \"markerAdded\", cm, marker2);\n      }\n      return marker2;\n    }\n    var SharedTextMarker = function(markers, primary) {\n      this.markers = markers;\n      this.primary = primary;\n      for (var i2 = 0; i2 < markers.length; ++i2) {\n        markers[i2].parent = this;\n      }\n    };\n    SharedTextMarker.prototype.clear = function() {\n      if (this.explicitlyCleared) {\n        return;\n      }\n      this.explicitlyCleared = true;\n      for (var i2 = 0; i2 < this.markers.length; ++i2) {\n        this.markers[i2].clear();\n      }\n      signalLater(this, \"clear\");\n    };\n    SharedTextMarker.prototype.find = function(side, lineObj) {\n      return this.primary.find(side, lineObj);\n    };\n    eventMixin(SharedTextMarker);\n    function markTextShared(doc, from, to, options, type2) {\n      options = copyObj(options);\n      options.shared = false;\n      var markers = [markText(doc, from, to, options, type2)], primary = markers[0];\n      var widget = options.widgetNode;\n      linkedDocs(doc, function(doc2) {\n        if (widget) {\n          options.widgetNode = widget.cloneNode(true);\n        }\n        markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type2));\n        for (var i2 = 0; i2 < doc2.linked.length; ++i2) {\n          if (doc2.linked[i2].isParent) {\n            return;\n          }\n        }\n        primary = lst(markers);\n      });\n      return new SharedTextMarker(markers, primary);\n    }\n    function findSharedMarkers(doc) {\n      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m2) {\n        return m2.parent;\n      });\n    }\n    function copySharedMarkers(doc, markers) {\n      for (var i2 = 0; i2 < markers.length; i2++) {\n        var marker2 = markers[i2], pos = marker2.find();\n        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n        if (cmp(mFrom, mTo)) {\n          var subMark = markText(doc, mFrom, mTo, marker2.primary, marker2.primary.type);\n          marker2.markers.push(subMark);\n          subMark.parent = marker2;\n        }\n      }\n    }\n    function detachSharedMarkers(markers) {\n      var loop = function(i3) {\n        var marker2 = markers[i3], linked = [marker2.primary.doc];\n        linkedDocs(marker2.primary.doc, function(d) {\n          return linked.push(d);\n        });\n        for (var j = 0; j < marker2.markers.length; j++) {\n          var subMarker = marker2.markers[j];\n          if (indexOf(linked, subMarker.doc) == -1) {\n            subMarker.parent = null;\n            marker2.markers.splice(j--, 1);\n          }\n        }\n      };\n      for (var i2 = 0; i2 < markers.length; i2++)\n        loop(i2);\n    }\n    var nextDocId = 0;\n    var Doc = function(text3, mode2, firstLine, lineSep, direction) {\n      if (!(this instanceof Doc)) {\n        return new Doc(text3, mode2, firstLine, lineSep, direction);\n      }\n      if (firstLine == null) {\n        firstLine = 0;\n      }\n      BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n      this.first = firstLine;\n      this.scrollTop = this.scrollLeft = 0;\n      this.cantEdit = false;\n      this.cleanGeneration = 1;\n      this.modeFrontier = this.highlightFrontier = firstLine;\n      var start2 = Pos(firstLine, 0);\n      this.sel = simpleSelection(start2);\n      this.history = new History(null);\n      this.id = ++nextDocId;\n      this.modeOption = mode2;\n      this.lineSep = lineSep;\n      this.direction = direction == \"rtl\" ? \"rtl\" : \"ltr\";\n      this.extend = false;\n      if (typeof text3 == \"string\") {\n        text3 = this.splitLines(text3);\n      }\n      updateDoc(this, { from: start2, to: start2, text: text3 });\n      setSelection(this, simpleSelection(start2), sel_dontScroll);\n    };\n    Doc.prototype = createObj(BranchChunk.prototype, {\n      constructor: Doc,\n      iter: function(from, to, op) {\n        if (op) {\n          this.iterN(from - this.first, to - from, op);\n        } else {\n          this.iterN(this.first, this.first + this.size, from);\n        }\n      },\n      insert: function(at, lines) {\n        var height = 0;\n        for (var i2 = 0; i2 < lines.length; ++i2) {\n          height += lines[i2].height;\n        }\n        this.insertInner(at - this.first, lines, height);\n      },\n      remove: function(at, n2) {\n        this.removeInner(at - this.first, n2);\n      },\n      getValue: function(lineSep) {\n        var lines = getLines2(this, this.first, this.first + this.size);\n        if (lineSep === false) {\n          return lines;\n        }\n        return lines.join(lineSep || this.lineSeparator());\n      },\n      setValue: docMethodOp(function(code3) {\n        var top2 = Pos(this.first, 0), last = this.first + this.size - 1;\n        makeChange(this, {\n          from: top2,\n          to: Pos(last, getLine2(this, last).text.length),\n          text: this.splitLines(code3),\n          origin: \"setValue\",\n          full: true\n        }, true);\n        if (this.cm) {\n          scrollToCoords(this.cm, 0, 0);\n        }\n        setSelection(this, simpleSelection(top2), sel_dontScroll);\n      }),\n      replaceRange: function(code3, from, to, origin) {\n        from = clipPos(this, from);\n        to = to ? clipPos(this, to) : from;\n        replaceRange(this, code3, from, to, origin);\n      },\n      getRange: function(from, to, lineSep) {\n        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n        if (lineSep === false) {\n          return lines;\n        }\n        if (lineSep === \"\") {\n          return lines.join(\"\");\n        }\n        return lines.join(lineSep || this.lineSeparator());\n      },\n      getLine: function(line) {\n        var l2 = this.getLineHandle(line);\n        return l2 && l2.text;\n      },\n      getLineHandle: function(line) {\n        if (isLine(this, line)) {\n          return getLine2(this, line);\n        }\n      },\n      getLineNumber: function(line) {\n        return lineNo(line);\n      },\n      getLineHandleVisualStart: function(line) {\n        if (typeof line == \"number\") {\n          line = getLine2(this, line);\n        }\n        return visualLine(line);\n      },\n      lineCount: function() {\n        return this.size;\n      },\n      firstLine: function() {\n        return this.first;\n      },\n      lastLine: function() {\n        return this.first + this.size - 1;\n      },\n      clipPos: function(pos) {\n        return clipPos(this, pos);\n      },\n      getCursor: function(start2) {\n        var range3 = this.sel.primary(), pos;\n        if (start2 == null || start2 == \"head\") {\n          pos = range3.head;\n        } else if (start2 == \"anchor\") {\n          pos = range3.anchor;\n        } else if (start2 == \"end\" || start2 == \"to\" || start2 === false) {\n          pos = range3.to();\n        } else {\n          pos = range3.from();\n        }\n        return pos;\n      },\n      listSelections: function() {\n        return this.sel.ranges;\n      },\n      somethingSelected: function() {\n        return this.sel.somethingSelected();\n      },\n      setCursor: docMethodOp(function(line, ch2, options) {\n        setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch2 || 0) : line), null, options);\n      }),\n      setSelection: docMethodOp(function(anchor, head, options) {\n        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n      }),\n      extendSelection: docMethodOp(function(head, other, options) {\n        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n      }),\n      extendSelections: docMethodOp(function(heads, options) {\n        extendSelections(this, clipPosArray(this, heads), options);\n      }),\n      extendSelectionsBy: docMethodOp(function(f, options) {\n        var heads = map2(this.sel.ranges, f);\n        extendSelections(this, clipPosArray(this, heads), options);\n      }),\n      setSelections: docMethodOp(function(ranges, primary, options) {\n        if (!ranges.length) {\n          return;\n        }\n        var out = [];\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          out[i2] = new Range2(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));\n        }\n        if (primary == null) {\n          primary = Math.min(ranges.length - 1, this.sel.primIndex);\n        }\n        setSelection(this, normalizeSelection(this.cm, out, primary), options);\n      }),\n      addSelection: docMethodOp(function(anchor, head, options) {\n        var ranges = this.sel.ranges.slice(0);\n        ranges.push(new Range2(clipPos(this, anchor), clipPos(this, head || anchor)));\n        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n      }),\n      getSelection: function(lineSep) {\n        var ranges = this.sel.ranges, lines;\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());\n          lines = lines ? lines.concat(sel) : sel;\n        }\n        if (lineSep === false) {\n          return lines;\n        } else {\n          return lines.join(lineSep || this.lineSeparator());\n        }\n      },\n      getSelections: function(lineSep) {\n        var parts = [], ranges = this.sel.ranges;\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());\n          if (lineSep !== false) {\n            sel = sel.join(lineSep || this.lineSeparator());\n          }\n          parts[i2] = sel;\n        }\n        return parts;\n      },\n      replaceSelection: function(code3, collapse, origin) {\n        var dup = [];\n        for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {\n          dup[i2] = code3;\n        }\n        this.replaceSelections(dup, collapse, origin || \"+input\");\n      },\n      replaceSelections: docMethodOp(function(code3, collapse, origin) {\n        var changes = [], sel = this.sel;\n        for (var i2 = 0; i2 < sel.ranges.length; i2++) {\n          var range3 = sel.ranges[i2];\n          changes[i2] = { from: range3.from(), to: range3.to(), text: this.splitLines(code3[i2]), origin };\n        }\n        var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n        for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {\n          makeChange(this, changes[i$12]);\n        }\n        if (newSel) {\n          setSelectionReplaceHistory(this, newSel);\n        } else if (this.cm) {\n          ensureCursorVisible(this.cm);\n        }\n      }),\n      undo: docMethodOp(function() {\n        makeChangeFromHistory(this, \"undo\");\n      }),\n      redo: docMethodOp(function() {\n        makeChangeFromHistory(this, \"redo\");\n      }),\n      undoSelection: docMethodOp(function() {\n        makeChangeFromHistory(this, \"undo\", true);\n      }),\n      redoSelection: docMethodOp(function() {\n        makeChangeFromHistory(this, \"redo\", true);\n      }),\n      setExtending: function(val) {\n        this.extend = val;\n      },\n      getExtending: function() {\n        return this.extend;\n      },\n      historySize: function() {\n        var hist = this.history, done = 0, undone = 0;\n        for (var i2 = 0; i2 < hist.done.length; i2++) {\n          if (!hist.done[i2].ranges) {\n            ++done;\n          }\n        }\n        for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {\n          if (!hist.undone[i$12].ranges) {\n            ++undone;\n          }\n        }\n        return { undo: done, redo: undone };\n      },\n      clearHistory: function() {\n        var this$1$1 = this;\n        this.history = new History(this.history);\n        linkedDocs(this, function(doc) {\n          return doc.history = this$1$1.history;\n        }, true);\n      },\n      markClean: function() {\n        this.cleanGeneration = this.changeGeneration(true);\n      },\n      changeGeneration: function(forceSplit) {\n        if (forceSplit) {\n          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n        }\n        return this.history.generation;\n      },\n      isClean: function(gen) {\n        return this.history.generation == (gen || this.cleanGeneration);\n      },\n      getHistory: function() {\n        return {\n          done: copyHistoryArray(this.history.done),\n          undone: copyHistoryArray(this.history.undone)\n        };\n      },\n      setHistory: function(histData) {\n        var hist = this.history = new History(this.history);\n        hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n      },\n      setGutterMarker: docMethodOp(function(line, gutterID, value) {\n        return changeLine(this, line, \"gutter\", function(line2) {\n          var markers = line2.gutterMarkers || (line2.gutterMarkers = {});\n          markers[gutterID] = value;\n          if (!value && isEmpty2(markers)) {\n            line2.gutterMarkers = null;\n          }\n          return true;\n        });\n      }),\n      clearGutter: docMethodOp(function(gutterID) {\n        var this$1$1 = this;\n        this.iter(function(line) {\n          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n            changeLine(this$1$1, line, \"gutter\", function() {\n              line.gutterMarkers[gutterID] = null;\n              if (isEmpty2(line.gutterMarkers)) {\n                line.gutterMarkers = null;\n              }\n              return true;\n            });\n          }\n        });\n      }),\n      lineInfo: function(line) {\n        var n2;\n        if (typeof line == \"number\") {\n          if (!isLine(this, line)) {\n            return null;\n          }\n          n2 = line;\n          line = getLine2(this, line);\n          if (!line) {\n            return null;\n          }\n        } else {\n          n2 = lineNo(line);\n          if (n2 == null) {\n            return null;\n          }\n        }\n        return {\n          line: n2,\n          handle: line,\n          text: line.text,\n          gutterMarkers: line.gutterMarkers,\n          textClass: line.textClass,\n          bgClass: line.bgClass,\n          wrapClass: line.wrapClass,\n          widgets: line.widgets\n        };\n      },\n      addLineClass: docMethodOp(function(handle, where, cls) {\n        return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n          var prop3 = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n          if (!line[prop3]) {\n            line[prop3] = cls;\n          } else if (classTest(cls).test(line[prop3])) {\n            return false;\n          } else {\n            line[prop3] += \" \" + cls;\n          }\n          return true;\n        });\n      }),\n      removeLineClass: docMethodOp(function(handle, where, cls) {\n        return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n          var prop3 = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n          var cur = line[prop3];\n          if (!cur) {\n            return false;\n          } else if (cls == null) {\n            line[prop3] = null;\n          } else {\n            var found = cur.match(classTest(cls));\n            if (!found) {\n              return false;\n            }\n            var end2 = found.index + found[0].length;\n            line[prop3] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? \"\" : \" \") + cur.slice(end2) || null;\n          }\n          return true;\n        });\n      }),\n      addLineWidget: docMethodOp(function(handle, node, options) {\n        return addLineWidget(this, handle, node, options);\n      }),\n      removeLineWidget: function(widget) {\n        widget.clear();\n      },\n      markText: function(from, to, options) {\n        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n      },\n      setBookmark: function(pos, options) {\n        var realOpts = {\n          replacedWith: options && (options.nodeType == null ? options.widget : options),\n          insertLeft: options && options.insertLeft,\n          clearWhenEmpty: false,\n          shared: options && options.shared,\n          handleMouseEvents: options && options.handleMouseEvents\n        };\n        pos = clipPos(this, pos);\n        return markText(this, pos, pos, realOpts, \"bookmark\");\n      },\n      findMarksAt: function(pos) {\n        pos = clipPos(this, pos);\n        var markers = [], spans = getLine2(this, pos.line).markedSpans;\n        if (spans) {\n          for (var i2 = 0; i2 < spans.length; ++i2) {\n            var span = spans[i2];\n            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n              markers.push(span.marker.parent || span.marker);\n            }\n          }\n        }\n        return markers;\n      },\n      findMarks: function(from, to, filter) {\n        from = clipPos(this, from);\n        to = clipPos(this, to);\n        var found = [], lineNo2 = from.line;\n        this.iter(from.line, to.line + 1, function(line) {\n          var spans = line.markedSpans;\n          if (spans) {\n            for (var i2 = 0; i2 < spans.length; i2++) {\n              var span = spans[i2];\n              if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {\n                found.push(span.marker.parent || span.marker);\n              }\n            }\n          }\n          ++lineNo2;\n        });\n        return found;\n      },\n      getAllMarks: function() {\n        var markers = [];\n        this.iter(function(line) {\n          var sps = line.markedSpans;\n          if (sps) {\n            for (var i2 = 0; i2 < sps.length; ++i2) {\n              if (sps[i2].from != null) {\n                markers.push(sps[i2].marker);\n              }\n            }\n          }\n        });\n        return markers;\n      },\n      posFromIndex: function(off2) {\n        var ch2, lineNo2 = this.first, sepSize = this.lineSeparator().length;\n        this.iter(function(line) {\n          var sz = line.text.length + sepSize;\n          if (sz > off2) {\n            ch2 = off2;\n            return true;\n          }\n          off2 -= sz;\n          ++lineNo2;\n        });\n        return clipPos(this, Pos(lineNo2, ch2));\n      },\n      indexFromPos: function(coords) {\n        coords = clipPos(this, coords);\n        var index = coords.ch;\n        if (coords.line < this.first || coords.ch < 0) {\n          return 0;\n        }\n        var sepSize = this.lineSeparator().length;\n        this.iter(this.first, coords.line, function(line) {\n          index += line.text.length + sepSize;\n        });\n        return index;\n      },\n      copy: function(copyHistory) {\n        var doc = new Doc(getLines2(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n        doc.scrollTop = this.scrollTop;\n        doc.scrollLeft = this.scrollLeft;\n        doc.sel = this.sel;\n        doc.extend = false;\n        if (copyHistory) {\n          doc.history.undoDepth = this.history.undoDepth;\n          doc.setHistory(this.getHistory());\n        }\n        return doc;\n      },\n      linkedDoc: function(options) {\n        if (!options) {\n          options = {};\n        }\n        var from = this.first, to = this.first + this.size;\n        if (options.from != null && options.from > from) {\n          from = options.from;\n        }\n        if (options.to != null && options.to < to) {\n          to = options.to;\n        }\n        var copy2 = new Doc(getLines2(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n        if (options.sharedHist) {\n          copy2.history = this.history;\n        }\n        (this.linked || (this.linked = [])).push({ doc: copy2, sharedHist: options.sharedHist });\n        copy2.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];\n        copySharedMarkers(copy2, findSharedMarkers(this));\n        return copy2;\n      },\n      unlinkDoc: function(other) {\n        if (other instanceof CodeMirror) {\n          other = other.doc;\n        }\n        if (this.linked) {\n          for (var i2 = 0; i2 < this.linked.length; ++i2) {\n            var link3 = this.linked[i2];\n            if (link3.doc != other) {\n              continue;\n            }\n            this.linked.splice(i2, 1);\n            other.unlinkDoc(this);\n            detachSharedMarkers(findSharedMarkers(this));\n            break;\n          }\n        }\n        if (other.history == this.history) {\n          var splitIds = [other.id];\n          linkedDocs(other, function(doc) {\n            return splitIds.push(doc.id);\n          }, true);\n          other.history = new History(null);\n          other.history.done = copyHistoryArray(this.history.done, splitIds);\n          other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n        }\n      },\n      iterLinkedDocs: function(f) {\n        linkedDocs(this, f);\n      },\n      getMode: function() {\n        return this.mode;\n      },\n      getEditor: function() {\n        return this.cm;\n      },\n      splitLines: function(str) {\n        if (this.lineSep) {\n          return str.split(this.lineSep);\n        }\n        return splitLinesAuto(str);\n      },\n      lineSeparator: function() {\n        return this.lineSep || \"\\n\";\n      },\n      setDirection: docMethodOp(function(dir) {\n        if (dir != \"rtl\") {\n          dir = \"ltr\";\n        }\n        if (dir == this.direction) {\n          return;\n        }\n        this.direction = dir;\n        this.iter(function(line) {\n          return line.order = null;\n        });\n        if (this.cm) {\n          directionChanged(this.cm);\n        }\n      })\n    });\n    Doc.prototype.eachLine = Doc.prototype.iter;\n    var lastDrop = 0;\n    function onDrop(e) {\n      var cm = this;\n      clearDragCursor(cm);\n      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n        return;\n      }\n      e_preventDefault(e);\n      if (ie2) {\n        lastDrop = +new Date();\n      }\n      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n      if (!pos || cm.isReadOnly()) {\n        return;\n      }\n      if (files && files.length && window.FileReader && window.File) {\n        var n2 = files.length, text3 = Array(n2), read = 0;\n        var markAsReadAndPasteIfAllFilesAreRead = function() {\n          if (++read == n2) {\n            operation(cm, function() {\n              pos = clipPos(cm.doc, pos);\n              var change = {\n                from: pos,\n                to: pos,\n                text: cm.doc.splitLines(text3.filter(function(t2) {\n                  return t2 != null;\n                }).join(cm.doc.lineSeparator())),\n                origin: \"paste\"\n              };\n              makeChange(cm.doc, change);\n              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n            })();\n          }\n        };\n        var readTextFromFile = function(file, i3) {\n          if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return;\n          }\n          var reader = new FileReader();\n          reader.onerror = function() {\n            return markAsReadAndPasteIfAllFilesAreRead();\n          };\n          reader.onload = function() {\n            var content = reader.result;\n            if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n              markAsReadAndPasteIfAllFilesAreRead();\n              return;\n            }\n            text3[i3] = content;\n            markAsReadAndPasteIfAllFilesAreRead();\n          };\n          reader.readAsText(file);\n        };\n        for (var i2 = 0; i2 < files.length; i2++) {\n          readTextFromFile(files[i2], i2);\n        }\n      } else {\n        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n          cm.state.draggingText(e);\n          setTimeout(function() {\n            return cm.display.input.focus();\n          }, 20);\n          return;\n        }\n        try {\n          var text$12 = e.dataTransfer.getData(\"Text\");\n          if (text$12) {\n            var selected;\n            if (cm.state.draggingText && !cm.state.draggingText.copy) {\n              selected = cm.listSelections();\n            }\n            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n            if (selected) {\n              for (var i$12 = 0; i$12 < selected.length; ++i$12) {\n                replaceRange(cm.doc, \"\", selected[i$12].anchor, selected[i$12].head, \"drag\");\n              }\n            }\n            cm.replaceSelection(text$12, \"around\", \"paste\");\n            cm.display.input.focus();\n          }\n        } catch (e$1) {\n        }\n      }\n    }\n    function onDragStart(cm, e) {\n      if (ie2 && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {\n        e_stop(e);\n        return;\n      }\n      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n        return;\n      }\n      e.dataTransfer.setData(\"Text\", cm.getSelection());\n      e.dataTransfer.effectAllowed = \"copyMove\";\n      if (e.dataTransfer.setDragImage && !safari) {\n        var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n        img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n        if (presto) {\n          img.width = img.height = 1;\n          cm.display.wrapper.appendChild(img);\n          img._top = img.offsetTop;\n        }\n        e.dataTransfer.setDragImage(img, 0, 0);\n        if (presto) {\n          img.parentNode.removeChild(img);\n        }\n      }\n    }\n    function onDragOver(cm, e) {\n      var pos = posFromMouse(cm, e);\n      if (!pos) {\n        return;\n      }\n      var frag = document.createDocumentFragment();\n      drawSelectionCursor(cm, pos, frag);\n      if (!cm.display.dragCursor) {\n        cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n      }\n      removeChildrenAndAdd(cm.display.dragCursor, frag);\n    }\n    function clearDragCursor(cm) {\n      if (cm.display.dragCursor) {\n        cm.display.lineSpace.removeChild(cm.display.dragCursor);\n        cm.display.dragCursor = null;\n      }\n    }\n    function forEachCodeMirror(f) {\n      if (!document.getElementsByClassName) {\n        return;\n      }\n      var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n      for (var i2 = 0; i2 < byClass.length; i2++) {\n        var cm = byClass[i2].CodeMirror;\n        if (cm) {\n          editors.push(cm);\n        }\n      }\n      if (editors.length) {\n        editors[0].operation(function() {\n          for (var i3 = 0; i3 < editors.length; i3++) {\n            f(editors[i3]);\n          }\n        });\n      }\n    }\n    var globalsRegistered = false;\n    function ensureGlobalHandlers() {\n      if (globalsRegistered) {\n        return;\n      }\n      registerGlobalHandlers();\n      globalsRegistered = true;\n    }\n    function registerGlobalHandlers() {\n      var resizeTimer;\n      on(window, \"resize\", function() {\n        if (resizeTimer == null) {\n          resizeTimer = setTimeout(function() {\n            resizeTimer = null;\n            forEachCodeMirror(onResize);\n          }, 100);\n        }\n      });\n      on(window, \"blur\", function() {\n        return forEachCodeMirror(onBlur);\n      });\n    }\n    function onResize(cm) {\n      var d = cm.display;\n      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n      d.scrollbarsClipped = false;\n      cm.setSize();\n    }\n    var keyNames = {\n      3: \"Pause\",\n      8: \"Backspace\",\n      9: \"Tab\",\n      13: \"Enter\",\n      16: \"Shift\",\n      17: \"Ctrl\",\n      18: \"Alt\",\n      19: \"Pause\",\n      20: \"CapsLock\",\n      27: \"Esc\",\n      32: \"Space\",\n      33: \"PageUp\",\n      34: \"PageDown\",\n      35: \"End\",\n      36: \"Home\",\n      37: \"Left\",\n      38: \"Up\",\n      39: \"Right\",\n      40: \"Down\",\n      44: \"PrintScrn\",\n      45: \"Insert\",\n      46: \"Delete\",\n      59: \";\",\n      61: \"=\",\n      91: \"Mod\",\n      92: \"Mod\",\n      93: \"Mod\",\n      106: \"*\",\n      107: \"=\",\n      109: \"-\",\n      110: \".\",\n      111: \"/\",\n      145: \"ScrollLock\",\n      173: \"-\",\n      186: \";\",\n      187: \"=\",\n      188: \",\",\n      189: \"-\",\n      190: \".\",\n      191: \"/\",\n      192: \"`\",\n      219: \"[\",\n      220: \"\\\\\",\n      221: \"]\",\n      222: \"'\",\n      224: \"Mod\",\n      63232: \"Up\",\n      63233: \"Down\",\n      63234: \"Left\",\n      63235: \"Right\",\n      63272: \"Delete\",\n      63273: \"Home\",\n      63275: \"End\",\n      63276: \"PageUp\",\n      63277: \"PageDown\",\n      63302: \"Insert\"\n    };\n    for (var i = 0; i < 10; i++) {\n      keyNames[i + 48] = keyNames[i + 96] = String(i);\n    }\n    for (var i$1 = 65; i$1 <= 90; i$1++) {\n      keyNames[i$1] = String.fromCharCode(i$1);\n    }\n    for (var i$2 = 1; i$2 <= 12; i$2++) {\n      keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2;\n    }\n    var keyMap2 = {};\n    keyMap2.basic = {\n      \"Left\": \"goCharLeft\",\n      \"Right\": \"goCharRight\",\n      \"Up\": \"goLineUp\",\n      \"Down\": \"goLineDown\",\n      \"End\": \"goLineEnd\",\n      \"Home\": \"goLineStartSmart\",\n      \"PageUp\": \"goPageUp\",\n      \"PageDown\": \"goPageDown\",\n      \"Delete\": \"delCharAfter\",\n      \"Backspace\": \"delCharBefore\",\n      \"Shift-Backspace\": \"delCharBefore\",\n      \"Tab\": \"defaultTab\",\n      \"Shift-Tab\": \"indentAuto\",\n      \"Enter\": \"newlineAndIndent\",\n      \"Insert\": \"toggleOverwrite\",\n      \"Esc\": \"singleSelection\"\n    };\n    keyMap2.pcDefault = {\n      \"Ctrl-A\": \"selectAll\",\n      \"Ctrl-D\": \"deleteLine\",\n      \"Ctrl-Z\": \"undo\",\n      \"Shift-Ctrl-Z\": \"redo\",\n      \"Ctrl-Y\": \"redo\",\n      \"Ctrl-Home\": \"goDocStart\",\n      \"Ctrl-End\": \"goDocEnd\",\n      \"Ctrl-Up\": \"goLineUp\",\n      \"Ctrl-Down\": \"goLineDown\",\n      \"Ctrl-Left\": \"goGroupLeft\",\n      \"Ctrl-Right\": \"goGroupRight\",\n      \"Alt-Left\": \"goLineStart\",\n      \"Alt-Right\": \"goLineEnd\",\n      \"Ctrl-Backspace\": \"delGroupBefore\",\n      \"Ctrl-Delete\": \"delGroupAfter\",\n      \"Ctrl-S\": \"save\",\n      \"Ctrl-F\": \"find\",\n      \"Ctrl-G\": \"findNext\",\n      \"Shift-Ctrl-G\": \"findPrev\",\n      \"Shift-Ctrl-F\": \"replace\",\n      \"Shift-Ctrl-R\": \"replaceAll\",\n      \"Ctrl-[\": \"indentLess\",\n      \"Ctrl-]\": \"indentMore\",\n      \"Ctrl-U\": \"undoSelection\",\n      \"Shift-Ctrl-U\": \"redoSelection\",\n      \"Alt-U\": \"redoSelection\",\n      \"fallthrough\": \"basic\"\n    };\n    keyMap2.emacsy = {\n      \"Ctrl-F\": \"goCharRight\",\n      \"Ctrl-B\": \"goCharLeft\",\n      \"Ctrl-P\": \"goLineUp\",\n      \"Ctrl-N\": \"goLineDown\",\n      \"Ctrl-A\": \"goLineStart\",\n      \"Ctrl-E\": \"goLineEnd\",\n      \"Ctrl-V\": \"goPageDown\",\n      \"Shift-Ctrl-V\": \"goPageUp\",\n      \"Ctrl-D\": \"delCharAfter\",\n      \"Ctrl-H\": \"delCharBefore\",\n      \"Alt-Backspace\": \"delWordBefore\",\n      \"Ctrl-K\": \"killLine\",\n      \"Ctrl-T\": \"transposeChars\",\n      \"Ctrl-O\": \"openLine\"\n    };\n    keyMap2.macDefault = {\n      \"Cmd-A\": \"selectAll\",\n      \"Cmd-D\": \"deleteLine\",\n      \"Cmd-Z\": \"undo\",\n      \"Shift-Cmd-Z\": \"redo\",\n      \"Cmd-Y\": \"redo\",\n      \"Cmd-Home\": \"goDocStart\",\n      \"Cmd-Up\": \"goDocStart\",\n      \"Cmd-End\": \"goDocEnd\",\n      \"Cmd-Down\": \"goDocEnd\",\n      \"Alt-Left\": \"goGroupLeft\",\n      \"Alt-Right\": \"goGroupRight\",\n      \"Cmd-Left\": \"goLineLeft\",\n      \"Cmd-Right\": \"goLineRight\",\n      \"Alt-Backspace\": \"delGroupBefore\",\n      \"Ctrl-Alt-Backspace\": \"delGroupAfter\",\n      \"Alt-Delete\": \"delGroupAfter\",\n      \"Cmd-S\": \"save\",\n      \"Cmd-F\": \"find\",\n      \"Cmd-G\": \"findNext\",\n      \"Shift-Cmd-G\": \"findPrev\",\n      \"Cmd-Alt-F\": \"replace\",\n      \"Shift-Cmd-Alt-F\": \"replaceAll\",\n      \"Cmd-[\": \"indentLess\",\n      \"Cmd-]\": \"indentMore\",\n      \"Cmd-Backspace\": \"delWrappedLineLeft\",\n      \"Cmd-Delete\": \"delWrappedLineRight\",\n      \"Cmd-U\": \"undoSelection\",\n      \"Shift-Cmd-U\": \"redoSelection\",\n      \"Ctrl-Up\": \"goDocStart\",\n      \"Ctrl-Down\": \"goDocEnd\",\n      \"fallthrough\": [\"basic\", \"emacsy\"]\n    };\n    keyMap2[\"default\"] = mac ? keyMap2.macDefault : keyMap2.pcDefault;\n    function normalizeKeyName(name2) {\n      var parts = name2.split(/-(?!$)/);\n      name2 = parts[parts.length - 1];\n      var alt, ctrl, shift, cmd;\n      for (var i2 = 0; i2 < parts.length - 1; i2++) {\n        var mod = parts[i2];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n          cmd = true;\n        } else if (/^a(lt)?$/i.test(mod)) {\n          alt = true;\n        } else if (/^(c|ctrl|control)$/i.test(mod)) {\n          ctrl = true;\n        } else if (/^s(hift)?$/i.test(mod)) {\n          shift = true;\n        } else {\n          throw new Error(\"Unrecognized modifier name: \" + mod);\n        }\n      }\n      if (alt) {\n        name2 = \"Alt-\" + name2;\n      }\n      if (ctrl) {\n        name2 = \"Ctrl-\" + name2;\n      }\n      if (cmd) {\n        name2 = \"Cmd-\" + name2;\n      }\n      if (shift) {\n        name2 = \"Shift-\" + name2;\n      }\n      return name2;\n    }\n    function normalizeKeyMap(keymap) {\n      var copy2 = {};\n      for (var keyname in keymap) {\n        if (keymap.hasOwnProperty(keyname)) {\n          var value = keymap[keyname];\n          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n            continue;\n          }\n          if (value == \"...\") {\n            delete keymap[keyname];\n            continue;\n          }\n          var keys = map2(keyname.split(\" \"), normalizeKeyName);\n          for (var i2 = 0; i2 < keys.length; i2++) {\n            var val = void 0, name2 = void 0;\n            if (i2 == keys.length - 1) {\n              name2 = keys.join(\" \");\n              val = value;\n            } else {\n              name2 = keys.slice(0, i2 + 1).join(\" \");\n              val = \"...\";\n            }\n            var prev = copy2[name2];\n            if (!prev) {\n              copy2[name2] = val;\n            } else if (prev != val) {\n              throw new Error(\"Inconsistent bindings for \" + name2);\n            }\n          }\n          delete keymap[keyname];\n        }\n      }\n      for (var prop3 in copy2) {\n        keymap[prop3] = copy2[prop3];\n      }\n      return keymap;\n    }\n    function lookupKey(key, map3, handle, context) {\n      map3 = getKeyMap(map3);\n      var found = map3.call ? map3.call(key, context) : map3[key];\n      if (found === false) {\n        return \"nothing\";\n      }\n      if (found === \"...\") {\n        return \"multi\";\n      }\n      if (found != null && handle(found)) {\n        return \"handled\";\n      }\n      if (map3.fallthrough) {\n        if (Object.prototype.toString.call(map3.fallthrough) != \"[object Array]\") {\n          return lookupKey(key, map3.fallthrough, handle, context);\n        }\n        for (var i2 = 0; i2 < map3.fallthrough.length; i2++) {\n          var result2 = lookupKey(key, map3.fallthrough[i2], handle, context);\n          if (result2) {\n            return result2;\n          }\n        }\n      }\n    }\n    function isModifierKey(value) {\n      var name2 = typeof value == \"string\" ? value : keyNames[value.keyCode];\n      return name2 == \"Ctrl\" || name2 == \"Alt\" || name2 == \"Shift\" || name2 == \"Mod\";\n    }\n    function addModifierNames(name2, event, noShift) {\n      var base2 = name2;\n      if (event.altKey && base2 != \"Alt\") {\n        name2 = \"Alt-\" + name2;\n      }\n      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base2 != \"Ctrl\") {\n        name2 = \"Ctrl-\" + name2;\n      }\n      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base2 != \"Mod\") {\n        name2 = \"Cmd-\" + name2;\n      }\n      if (!noShift && event.shiftKey && base2 != \"Shift\") {\n        name2 = \"Shift-\" + name2;\n      }\n      return name2;\n    }\n    function keyName(event, noShift) {\n      if (presto && event.keyCode == 34 && event[\"char\"]) {\n        return false;\n      }\n      var name2 = keyNames[event.keyCode];\n      if (name2 == null || event.altGraphKey) {\n        return false;\n      }\n      if (event.keyCode == 3 && event.code) {\n        name2 = event.code;\n      }\n      return addModifierNames(name2, event, noShift);\n    }\n    function getKeyMap(val) {\n      return typeof val == \"string\" ? keyMap2[val] : val;\n    }\n    function deleteNearSelection(cm, compute) {\n      var ranges = cm.doc.sel.ranges, kill = [];\n      for (var i2 = 0; i2 < ranges.length; i2++) {\n        var toKill = compute(ranges[i2]);\n        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n          var replaced = kill.pop();\n          if (cmp(replaced.from, toKill.from) < 0) {\n            toKill.from = replaced.from;\n            break;\n          }\n        }\n        kill.push(toKill);\n      }\n      runInOp(cm, function() {\n        for (var i3 = kill.length - 1; i3 >= 0; i3--) {\n          replaceRange(cm.doc, \"\", kill[i3].from, kill[i3].to, \"+delete\");\n        }\n        ensureCursorVisible(cm);\n      });\n    }\n    function moveCharLogically(line, ch2, dir) {\n      var target2 = skipExtendingChars(line.text, ch2 + dir, dir);\n      return target2 < 0 || target2 > line.text.length ? null : target2;\n    }\n    function moveLogically(line, start2, dir) {\n      var ch2 = moveCharLogically(line, start2.ch, dir);\n      return ch2 == null ? null : new Pos(start2.line, ch2, dir < 0 ? \"after\" : \"before\");\n    }\n    function endOfLine(visually, cm, lineObj, lineNo2, dir) {\n      if (visually) {\n        if (cm.doc.direction == \"rtl\") {\n          dir = -dir;\n        }\n        var order2 = getOrder(lineObj, cm.doc.direction);\n        if (order2) {\n          var part2 = dir < 0 ? lst(order2) : order2[0];\n          var moveInStorageOrder = dir < 0 == (part2.level == 1);\n          var sticky = moveInStorageOrder ? \"after\" : \"before\";\n          var ch2;\n          if (part2.level > 0 || cm.doc.direction == \"rtl\") {\n            var prep = prepareMeasureForLine(cm, lineObj);\n            ch2 = dir < 0 ? lineObj.text.length - 1 : 0;\n            var targetTop = measureCharPrepared(cm, prep, ch2).top;\n            ch2 = findFirst(function(ch3) {\n              return measureCharPrepared(cm, prep, ch3).top == targetTop;\n            }, dir < 0 == (part2.level == 1) ? part2.from : part2.to - 1, ch2);\n            if (sticky == \"before\") {\n              ch2 = moveCharLogically(lineObj, ch2, 1);\n            }\n          } else {\n            ch2 = dir < 0 ? part2.to : part2.from;\n          }\n          return new Pos(lineNo2, ch2, sticky);\n        }\n      }\n      return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\");\n    }\n    function moveVisually(cm, line, start2, dir) {\n      var bidi = getOrder(line, cm.doc.direction);\n      if (!bidi) {\n        return moveLogically(line, start2, dir);\n      }\n      if (start2.ch >= line.text.length) {\n        start2.ch = line.text.length;\n        start2.sticky = \"before\";\n      } else if (start2.ch <= 0) {\n        start2.ch = 0;\n        start2.sticky = \"after\";\n      }\n      var partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part2 = bidi[partPos];\n      if (cm.doc.direction == \"ltr\" && part2.level % 2 == 0 && (dir > 0 ? part2.to > start2.ch : part2.from < start2.ch)) {\n        return moveLogically(line, start2, dir);\n      }\n      var mv = function(pos, dir2) {\n        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);\n      };\n      var prep;\n      var getWrappedLineExtent = function(ch3) {\n        if (!cm.options.lineWrapping) {\n          return { begin: 0, end: line.text.length };\n        }\n        prep = prep || prepareMeasureForLine(cm, line);\n        return wrappedLineExtentChar(cm, line, prep, ch3);\n      };\n      var wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == \"before\" ? mv(start2, -1) : start2.ch);\n      if (cm.doc.direction == \"rtl\" || part2.level == 1) {\n        var moveInStorageOrder = part2.level == 1 == dir < 0;\n        var ch2 = mv(start2, moveInStorageOrder ? 1 : -1);\n        if (ch2 != null && (!moveInStorageOrder ? ch2 >= part2.from && ch2 >= wrappedLineExtent2.begin : ch2 <= part2.to && ch2 <= wrappedLineExtent2.end)) {\n          var sticky = moveInStorageOrder ? \"before\" : \"after\";\n          return new Pos(start2.line, ch2, sticky);\n        }\n      }\n      var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {\n        var getRes = function(ch4, moveInStorageOrder3) {\n          return moveInStorageOrder3 ? new Pos(start2.line, mv(ch4, 1), \"before\") : new Pos(start2.line, ch4, \"after\");\n        };\n        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {\n          var part3 = bidi[partPos2];\n          var moveInStorageOrder2 = dir2 > 0 == (part3.level != 1);\n          var ch3 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);\n          if (part3.from <= ch3 && ch3 < part3.to) {\n            return getRes(ch3, moveInStorageOrder2);\n          }\n          ch3 = moveInStorageOrder2 ? part3.from : mv(part3.to, -1);\n          if (wrappedLineExtent3.begin <= ch3 && ch3 < wrappedLineExtent3.end) {\n            return getRes(ch3, moveInStorageOrder2);\n          }\n        }\n      };\n      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);\n      if (res) {\n        return res;\n      }\n      var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);\n      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n        if (res) {\n          return res;\n        }\n      }\n      return null;\n    }\n    var commands = {\n      selectAll,\n      singleSelection: function(cm) {\n        return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n      },\n      killLine: function(cm) {\n        return deleteNearSelection(cm, function(range3) {\n          if (range3.empty()) {\n            var len = getLine2(cm.doc, range3.head.line).text.length;\n            if (range3.head.ch == len && range3.head.line < cm.lastLine()) {\n              return { from: range3.head, to: Pos(range3.head.line + 1, 0) };\n            } else {\n              return { from: range3.head, to: Pos(range3.head.line, len) };\n            }\n          } else {\n            return { from: range3.from(), to: range3.to() };\n          }\n        });\n      },\n      deleteLine: function(cm) {\n        return deleteNearSelection(cm, function(range3) {\n          return {\n            from: Pos(range3.from().line, 0),\n            to: clipPos(cm.doc, Pos(range3.to().line + 1, 0))\n          };\n        });\n      },\n      delLineLeft: function(cm) {\n        return deleteNearSelection(cm, function(range3) {\n          return {\n            from: Pos(range3.from().line, 0),\n            to: range3.from()\n          };\n        });\n      },\n      delWrappedLineLeft: function(cm) {\n        return deleteNearSelection(cm, function(range3) {\n          var top2 = cm.charCoords(range3.head, \"div\").top + 5;\n          var leftPos = cm.coordsChar({ left: 0, top: top2 }, \"div\");\n          return { from: leftPos, to: range3.from() };\n        });\n      },\n      delWrappedLineRight: function(cm) {\n        return deleteNearSelection(cm, function(range3) {\n          var top2 = cm.charCoords(range3.head, \"div\").top + 5;\n          var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, \"div\");\n          return { from: range3.from(), to: rightPos };\n        });\n      },\n      undo: function(cm) {\n        return cm.undo();\n      },\n      redo: function(cm) {\n        return cm.redo();\n      },\n      undoSelection: function(cm) {\n        return cm.undoSelection();\n      },\n      redoSelection: function(cm) {\n        return cm.redoSelection();\n      },\n      goDocStart: function(cm) {\n        return cm.extendSelection(Pos(cm.firstLine(), 0));\n      },\n      goDocEnd: function(cm) {\n        return cm.extendSelection(Pos(cm.lastLine()));\n      },\n      goLineStart: function(cm) {\n        return cm.extendSelectionsBy(function(range3) {\n          return lineStart(cm, range3.head.line);\n        }, { origin: \"+move\", bias: 1 });\n      },\n      goLineStartSmart: function(cm) {\n        return cm.extendSelectionsBy(function(range3) {\n          return lineStartSmart(cm, range3.head);\n        }, { origin: \"+move\", bias: 1 });\n      },\n      goLineEnd: function(cm) {\n        return cm.extendSelectionsBy(function(range3) {\n          return lineEnd(cm, range3.head.line);\n        }, { origin: \"+move\", bias: -1 });\n      },\n      goLineRight: function(cm) {\n        return cm.extendSelectionsBy(function(range3) {\n          var top2 = cm.cursorCoords(range3.head, \"div\").top + 5;\n          return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, \"div\");\n        }, sel_move);\n      },\n      goLineLeft: function(cm) {\n        return cm.extendSelectionsBy(function(range3) {\n          var top2 = cm.cursorCoords(range3.head, \"div\").top + 5;\n          return cm.coordsChar({ left: 0, top: top2 }, \"div\");\n        }, sel_move);\n      },\n      goLineLeftSmart: function(cm) {\n        return cm.extendSelectionsBy(function(range3) {\n          var top2 = cm.cursorCoords(range3.head, \"div\").top + 5;\n          var pos = cm.coordsChar({ left: 0, top: top2 }, \"div\");\n          if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n            return lineStartSmart(cm, range3.head);\n          }\n          return pos;\n        }, sel_move);\n      },\n      goLineUp: function(cm) {\n        return cm.moveV(-1, \"line\");\n      },\n      goLineDown: function(cm) {\n        return cm.moveV(1, \"line\");\n      },\n      goPageUp: function(cm) {\n        return cm.moveV(-1, \"page\");\n      },\n      goPageDown: function(cm) {\n        return cm.moveV(1, \"page\");\n      },\n      goCharLeft: function(cm) {\n        return cm.moveH(-1, \"char\");\n      },\n      goCharRight: function(cm) {\n        return cm.moveH(1, \"char\");\n      },\n      goColumnLeft: function(cm) {\n        return cm.moveH(-1, \"column\");\n      },\n      goColumnRight: function(cm) {\n        return cm.moveH(1, \"column\");\n      },\n      goWordLeft: function(cm) {\n        return cm.moveH(-1, \"word\");\n      },\n      goGroupRight: function(cm) {\n        return cm.moveH(1, \"group\");\n      },\n      goGroupLeft: function(cm) {\n        return cm.moveH(-1, \"group\");\n      },\n      goWordRight: function(cm) {\n        return cm.moveH(1, \"word\");\n      },\n      delCharBefore: function(cm) {\n        return cm.deleteH(-1, \"codepoint\");\n      },\n      delCharAfter: function(cm) {\n        return cm.deleteH(1, \"char\");\n      },\n      delWordBefore: function(cm) {\n        return cm.deleteH(-1, \"word\");\n      },\n      delWordAfter: function(cm) {\n        return cm.deleteH(1, \"word\");\n      },\n      delGroupBefore: function(cm) {\n        return cm.deleteH(-1, \"group\");\n      },\n      delGroupAfter: function(cm) {\n        return cm.deleteH(1, \"group\");\n      },\n      indentAuto: function(cm) {\n        return cm.indentSelection(\"smart\");\n      },\n      indentMore: function(cm) {\n        return cm.indentSelection(\"add\");\n      },\n      indentLess: function(cm) {\n        return cm.indentSelection(\"subtract\");\n      },\n      insertTab: function(cm) {\n        return cm.replaceSelection(\"\t\");\n      },\n      insertSoftTab: function(cm) {\n        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var pos = ranges[i2].from();\n          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n          spaces.push(spaceStr(tabSize - col % tabSize));\n        }\n        cm.replaceSelections(spaces);\n      },\n      defaultTab: function(cm) {\n        if (cm.somethingSelected()) {\n          cm.indentSelection(\"add\");\n        } else {\n          cm.execCommand(\"insertTab\");\n        }\n      },\n      transposeChars: function(cm) {\n        return runInOp(cm, function() {\n          var ranges = cm.listSelections(), newSel = [];\n          for (var i2 = 0; i2 < ranges.length; i2++) {\n            if (!ranges[i2].empty()) {\n              continue;\n            }\n            var cur = ranges[i2].head, line = getLine2(cm.doc, cur.line).text;\n            if (line) {\n              if (cur.ch == line.length) {\n                cur = new Pos(cur.line, cur.ch - 1);\n              }\n              if (cur.ch > 0) {\n                cur = new Pos(cur.line, cur.ch + 1);\n                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n              } else if (cur.line > cm.doc.first) {\n                var prev = getLine2(cm.doc, cur.line - 1).text;\n                if (prev) {\n                  cur = new Pos(cur.line, 1);\n                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n                }\n              }\n            }\n            newSel.push(new Range2(cur, cur));\n          }\n          cm.setSelections(newSel);\n        });\n      },\n      newlineAndIndent: function(cm) {\n        return runInOp(cm, function() {\n          var sels = cm.listSelections();\n          for (var i2 = sels.length - 1; i2 >= 0; i2--) {\n            cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, \"+input\");\n          }\n          sels = cm.listSelections();\n          for (var i$12 = 0; i$12 < sels.length; i$12++) {\n            cm.indentLine(sels[i$12].from().line, null, true);\n          }\n          ensureCursorVisible(cm);\n        });\n      },\n      openLine: function(cm) {\n        return cm.replaceSelection(\"\\n\", \"start\");\n      },\n      toggleOverwrite: function(cm) {\n        return cm.toggleOverwrite();\n      }\n    };\n    function lineStart(cm, lineN) {\n      var line = getLine2(cm.doc, lineN);\n      var visual = visualLine(line);\n      if (visual != line) {\n        lineN = lineNo(visual);\n      }\n      return endOfLine(true, cm, visual, lineN, 1);\n    }\n    function lineEnd(cm, lineN) {\n      var line = getLine2(cm.doc, lineN);\n      var visual = visualLineEnd(line);\n      if (visual != line) {\n        lineN = lineNo(visual);\n      }\n      return endOfLine(true, cm, line, lineN, -1);\n    }\n    function lineStartSmart(cm, pos) {\n      var start2 = lineStart(cm, pos.line);\n      var line = getLine2(cm.doc, start2.line);\n      var order2 = getOrder(line, cm.doc.direction);\n      if (!order2 || order2[0].level == 0) {\n        var firstNonWS = Math.max(start2.ch, line.text.search(/\\S/));\n        var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;\n        return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);\n      }\n      return start2;\n    }\n    function doHandleBinding(cm, bound, dropShift) {\n      if (typeof bound == \"string\") {\n        bound = commands[bound];\n        if (!bound) {\n          return false;\n        }\n      }\n      cm.display.input.ensurePolled();\n      var prevShift = cm.display.shift, done = false;\n      try {\n        if (cm.isReadOnly()) {\n          cm.state.suppressEdits = true;\n        }\n        if (dropShift) {\n          cm.display.shift = false;\n        }\n        done = bound(cm) != Pass;\n      } finally {\n        cm.display.shift = prevShift;\n        cm.state.suppressEdits = false;\n      }\n      return done;\n    }\n    function lookupKeyForEditor(cm, name2, handle) {\n      for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {\n        var result2 = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);\n        if (result2) {\n          return result2;\n        }\n      }\n      return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);\n    }\n    var stopSeq = new Delayed();\n    function dispatchKey(cm, name2, e, handle) {\n      var seq = cm.state.keySeq;\n      if (seq) {\n        if (isModifierKey(name2)) {\n          return \"handled\";\n        }\n        if (/\\'$/.test(name2)) {\n          cm.state.keySeq = null;\n        } else {\n          stopSeq.set(50, function() {\n            if (cm.state.keySeq == seq) {\n              cm.state.keySeq = null;\n              cm.display.input.reset();\n            }\n          });\n        }\n        if (dispatchKeyInner(cm, seq + \" \" + name2, e, handle)) {\n          return true;\n        }\n      }\n      return dispatchKeyInner(cm, name2, e, handle);\n    }\n    function dispatchKeyInner(cm, name2, e, handle) {\n      var result2 = lookupKeyForEditor(cm, name2, handle);\n      if (result2 == \"multi\") {\n        cm.state.keySeq = name2;\n      }\n      if (result2 == \"handled\") {\n        signalLater(cm, \"keyHandled\", cm, name2, e);\n      }\n      if (result2 == \"handled\" || result2 == \"multi\") {\n        e_preventDefault(e);\n        restartBlink(cm);\n      }\n      return !!result2;\n    }\n    function handleKeyBinding(cm, e) {\n      var name2 = keyName(e, true);\n      if (!name2) {\n        return false;\n      }\n      if (e.shiftKey && !cm.state.keySeq) {\n        return dispatchKey(cm, \"Shift-\" + name2, e, function(b) {\n          return doHandleBinding(cm, b, true);\n        }) || dispatchKey(cm, name2, e, function(b) {\n          if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion) {\n            return doHandleBinding(cm, b);\n          }\n        });\n      } else {\n        return dispatchKey(cm, name2, e, function(b) {\n          return doHandleBinding(cm, b);\n        });\n      }\n    }\n    function handleCharBinding(cm, e, ch2) {\n      return dispatchKey(cm, \"'\" + ch2 + \"'\", e, function(b) {\n        return doHandleBinding(cm, b, true);\n      });\n    }\n    var lastStoppedKey = null;\n    function onKeyDown2(e) {\n      var cm = this;\n      if (e.target && e.target != cm.display.input.getField()) {\n        return;\n      }\n      cm.curOp.focus = activeElt();\n      if (signalDOMEvent(cm, e)) {\n        return;\n      }\n      if (ie2 && ie_version < 11 && e.keyCode == 27) {\n        e.returnValue = false;\n      }\n      var code3 = e.keyCode;\n      cm.display.shift = code3 == 16 || e.shiftKey;\n      var handled = handleKeyBinding(cm, e);\n      if (presto) {\n        lastStoppedKey = handled ? code3 : null;\n        if (!handled && code3 == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n          cm.replaceSelection(\"\", null, \"cut\");\n        }\n      }\n      if (gecko && !mac && !handled && code3 == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {\n        document.execCommand(\"cut\");\n      }\n      if (code3 == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n        showCrossHair(cm);\n      }\n    }\n    function showCrossHair(cm) {\n      var lineDiv = cm.display.lineDiv;\n      addClass(lineDiv, \"CodeMirror-crosshair\");\n      function up(e) {\n        if (e.keyCode == 18 || !e.altKey) {\n          rmClass(lineDiv, \"CodeMirror-crosshair\");\n          off(document, \"keyup\", up);\n          off(document, \"mouseover\", up);\n        }\n      }\n      on(document, \"keyup\", up);\n      on(document, \"mouseover\", up);\n    }\n    function onKeyUp(e) {\n      if (e.keyCode == 16) {\n        this.doc.sel.shift = false;\n      }\n      signalDOMEvent(this, e);\n    }\n    function onKeyPress(e) {\n      var cm = this;\n      if (e.target && e.target != cm.display.input.getField()) {\n        return;\n      }\n      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n        return;\n      }\n      var keyCode = e.keyCode, charCode = e.charCode;\n      if (presto && keyCode == lastStoppedKey) {\n        lastStoppedKey = null;\n        e_preventDefault(e);\n        return;\n      }\n      if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n        return;\n      }\n      var ch2 = String.fromCharCode(charCode == null ? keyCode : charCode);\n      if (ch2 == \"\\b\") {\n        return;\n      }\n      if (handleCharBinding(cm, e, ch2)) {\n        return;\n      }\n      cm.display.input.onKeyPress(e);\n    }\n    var DOUBLECLICK_DELAY = 400;\n    var PastClick = function(time, pos, button) {\n      this.time = time;\n      this.pos = pos;\n      this.button = button;\n    };\n    PastClick.prototype.compare = function(time, pos, button) {\n      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;\n    };\n    var lastClick, lastDoubleClick;\n    function clickRepeat(pos, button) {\n      var now = +new Date();\n      if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n        lastClick = lastDoubleClick = null;\n        return \"triple\";\n      } else if (lastClick && lastClick.compare(now, pos, button)) {\n        lastDoubleClick = new PastClick(now, pos, button);\n        lastClick = null;\n        return \"double\";\n      } else {\n        lastClick = new PastClick(now, pos, button);\n        lastDoubleClick = null;\n        return \"single\";\n      }\n    }\n    function onMouseDown(e) {\n      var cm = this, display = cm.display;\n      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n        return;\n      }\n      display.input.ensurePolled();\n      display.shift = e.shiftKey;\n      if (eventInWidget(display, e)) {\n        if (!webkit) {\n          display.scroller.draggable = false;\n          setTimeout(function() {\n            return display.scroller.draggable = true;\n          }, 100);\n        }\n        return;\n      }\n      if (clickInGutter(cm, e)) {\n        return;\n      }\n      var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n      window.focus();\n      if (button == 1 && cm.state.selectingText) {\n        cm.state.selectingText(e);\n      }\n      if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n        return;\n      }\n      if (button == 1) {\n        if (pos) {\n          leftButtonDown(cm, pos, repeat, e);\n        } else if (e_target(e) == display.scroller) {\n          e_preventDefault(e);\n        }\n      } else if (button == 2) {\n        if (pos) {\n          extendSelection(cm.doc, pos);\n        }\n        setTimeout(function() {\n          return display.input.focus();\n        }, 20);\n      } else if (button == 3) {\n        if (captureRightClick) {\n          cm.display.input.onContextMenu(e);\n        } else {\n          delayBlurEvent(cm);\n        }\n      }\n    }\n    function handleMappedButton(cm, button, pos, repeat, event) {\n      var name2 = \"Click\";\n      if (repeat == \"double\") {\n        name2 = \"Double\" + name2;\n      } else if (repeat == \"triple\") {\n        name2 = \"Triple\" + name2;\n      }\n      name2 = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name2;\n      return dispatchKey(cm, addModifierNames(name2, event), event, function(bound) {\n        if (typeof bound == \"string\") {\n          bound = commands[bound];\n        }\n        if (!bound) {\n          return false;\n        }\n        var done = false;\n        try {\n          if (cm.isReadOnly()) {\n            cm.state.suppressEdits = true;\n          }\n          done = bound(cm, pos) != Pass;\n        } finally {\n          cm.state.suppressEdits = false;\n        }\n        return done;\n      });\n    }\n    function configureMouse(cm, repeat, event) {\n      var option = cm.getOption(\"configureMouse\");\n      var value = option ? option(cm, repeat, event) : {};\n      if (value.unit == null) {\n        var rect2 = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n        value.unit = rect2 ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n      }\n      if (value.extend == null || cm.doc.extend) {\n        value.extend = cm.doc.extend || event.shiftKey;\n      }\n      if (value.addNew == null) {\n        value.addNew = mac ? event.metaKey : event.ctrlKey;\n      }\n      if (value.moveOnDrag == null) {\n        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n      }\n      return value;\n    }\n    function leftButtonDown(cm, pos, repeat, event) {\n      if (ie2) {\n        setTimeout(bind(ensureFocus, cm), 0);\n      } else {\n        cm.curOp.focus = activeElt();\n      }\n      var behavior = configureMouse(cm, repeat, event);\n      var sel = cm.doc.sel, contained;\n      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == \"single\" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {\n        leftButtonStartDrag(cm, event, pos, behavior);\n      } else {\n        leftButtonSelect(cm, event, pos, behavior);\n      }\n    }\n    function leftButtonStartDrag(cm, event, pos, behavior) {\n      var display = cm.display, moved = false;\n      var dragEnd = operation(cm, function(e) {\n        if (webkit) {\n          display.scroller.draggable = false;\n        }\n        cm.state.draggingText = false;\n        if (cm.state.delayingBlurEvent) {\n          if (cm.hasFocus()) {\n            cm.state.delayingBlurEvent = false;\n          } else {\n            delayBlurEvent(cm);\n          }\n        }\n        off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n        off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n        off(display.scroller, \"dragstart\", dragStart);\n        off(display.scroller, \"drop\", dragEnd);\n        if (!moved) {\n          e_preventDefault(e);\n          if (!behavior.addNew) {\n            extendSelection(cm.doc, pos, null, null, behavior.extend);\n          }\n          if (webkit && !safari || ie2 && ie_version == 9) {\n            setTimeout(function() {\n              display.wrapper.ownerDocument.body.focus({ preventScroll: true });\n              display.input.focus();\n            }, 20);\n          } else {\n            display.input.focus();\n          }\n        }\n      });\n      var mouseMove = function(e2) {\n        moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n      };\n      var dragStart = function() {\n        return moved = true;\n      };\n      if (webkit) {\n        display.scroller.draggable = true;\n      }\n      cm.state.draggingText = dragEnd;\n      dragEnd.copy = !behavior.moveOnDrag;\n      on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      on(display.scroller, \"dragstart\", dragStart);\n      on(display.scroller, \"drop\", dragEnd);\n      cm.state.delayingBlurEvent = true;\n      setTimeout(function() {\n        return display.input.focus();\n      }, 20);\n      if (display.scroller.dragDrop) {\n        display.scroller.dragDrop();\n      }\n    }\n    function rangeForUnit(cm, pos, unit) {\n      if (unit == \"char\") {\n        return new Range2(pos, pos);\n      }\n      if (unit == \"word\") {\n        return cm.findWordAt(pos);\n      }\n      if (unit == \"line\") {\n        return new Range2(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n      }\n      var result2 = unit(cm, pos);\n      return new Range2(result2.from, result2.to);\n    }\n    function leftButtonSelect(cm, event, start2, behavior) {\n      if (ie2) {\n        delayBlurEvent(cm);\n      }\n      var display = cm.display, doc = cm.doc;\n      e_preventDefault(event);\n      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n      if (behavior.addNew && !behavior.extend) {\n        ourIndex = doc.sel.contains(start2);\n        if (ourIndex > -1) {\n          ourRange = ranges[ourIndex];\n        } else {\n          ourRange = new Range2(start2, start2);\n        }\n      } else {\n        ourRange = doc.sel.primary();\n        ourIndex = doc.sel.primIndex;\n      }\n      if (behavior.unit == \"rectangle\") {\n        if (!behavior.addNew) {\n          ourRange = new Range2(start2, start2);\n        }\n        start2 = posFromMouse(cm, event, true, true);\n        ourIndex = -1;\n      } else {\n        var range3 = rangeForUnit(cm, start2, behavior.unit);\n        if (behavior.extend) {\n          ourRange = extendRange(ourRange, range3.anchor, range3.head, behavior.extend);\n        } else {\n          ourRange = range3;\n        }\n      }\n      if (!behavior.addNew) {\n        ourIndex = 0;\n        setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n        startSel = doc.sel;\n      } else if (ourIndex == -1) {\n        ourIndex = ranges.length;\n        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: \"*mouse\" });\n      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: \"*mouse\" });\n        startSel = doc.sel;\n      } else {\n        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n      }\n      var lastPos = start2;\n      function extendTo(pos) {\n        if (cmp(lastPos, pos) == 0) {\n          return;\n        }\n        lastPos = pos;\n        if (behavior.unit == \"rectangle\") {\n          var ranges2 = [], tabSize = cm.options.tabSize;\n          var startCol = countColumn(getLine2(doc, start2.line).text, start2.ch, tabSize);\n          var posCol = countColumn(getLine2(doc, pos.line).text, pos.ch, tabSize);\n          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n          for (var line = Math.min(start2.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end2; line++) {\n            var text3 = getLine2(doc, line).text, leftPos = findColumn(text3, left, tabSize);\n            if (left == right) {\n              ranges2.push(new Range2(Pos(line, leftPos), Pos(line, leftPos)));\n            } else if (text3.length > leftPos) {\n              ranges2.push(new Range2(Pos(line, leftPos), Pos(line, findColumn(text3, right, tabSize))));\n            }\n          }\n          if (!ranges2.length) {\n            ranges2.push(new Range2(start2, start2));\n          }\n          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: \"*mouse\", scroll: false });\n          cm.scrollIntoView(pos);\n        } else {\n          var oldRange = ourRange;\n          var range4 = rangeForUnit(cm, pos, behavior.unit);\n          var anchor = oldRange.anchor, head;\n          if (cmp(range4.anchor, anchor) > 0) {\n            head = range4.head;\n            anchor = minPos(oldRange.from(), range4.anchor);\n          } else {\n            head = range4.anchor;\n            anchor = maxPos(oldRange.to(), range4.head);\n          }\n          var ranges$1 = startSel.ranges.slice(0);\n          ranges$1[ourIndex] = bidiSimplify(cm, new Range2(clipPos(doc, anchor), head));\n          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n        }\n      }\n      var editorSize = display.wrapper.getBoundingClientRect();\n      var counter = 0;\n      function extend(e) {\n        var curCount = ++counter;\n        var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n        if (!cur) {\n          return;\n        }\n        if (cmp(cur, lastPos) != 0) {\n          cm.curOp.focus = activeElt();\n          extendTo(cur);\n          var visible = visibleLines(display, doc);\n          if (cur.line >= visible.to || cur.line < visible.from) {\n            setTimeout(operation(cm, function() {\n              if (counter == curCount) {\n                extend(e);\n              }\n            }), 150);\n          }\n        } else {\n          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n          if (outside) {\n            setTimeout(operation(cm, function() {\n              if (counter != curCount) {\n                return;\n              }\n              display.scroller.scrollTop += outside;\n              extend(e);\n            }), 50);\n          }\n        }\n      }\n      function done(e) {\n        cm.state.selectingText = false;\n        counter = Infinity;\n        if (e) {\n          e_preventDefault(e);\n          display.input.focus();\n        }\n        off(display.wrapper.ownerDocument, \"mousemove\", move);\n        off(display.wrapper.ownerDocument, \"mouseup\", up);\n        doc.history.lastSelOrigin = null;\n      }\n      var move = operation(cm, function(e) {\n        if (e.buttons === 0 || !e_button(e)) {\n          done(e);\n        } else {\n          extend(e);\n        }\n      });\n      var up = operation(cm, done);\n      cm.state.selectingText = up;\n      on(display.wrapper.ownerDocument, \"mousemove\", move);\n      on(display.wrapper.ownerDocument, \"mouseup\", up);\n    }\n    function bidiSimplify(cm, range3) {\n      var anchor = range3.anchor;\n      var head = range3.head;\n      var anchorLine = getLine2(cm.doc, anchor.line);\n      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {\n        return range3;\n      }\n      var order2 = getOrder(anchorLine);\n      if (!order2) {\n        return range3;\n      }\n      var index = getBidiPartAt(order2, anchor.ch, anchor.sticky), part2 = order2[index];\n      if (part2.from != anchor.ch && part2.to != anchor.ch) {\n        return range3;\n      }\n      var boundary = index + (part2.from == anchor.ch == (part2.level != 1) ? 0 : 1);\n      if (boundary == 0 || boundary == order2.length) {\n        return range3;\n      }\n      var leftSide;\n      if (head.line != anchor.line) {\n        leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n      } else {\n        var headIndex = getBidiPartAt(order2, head.ch, head.sticky);\n        var dir = headIndex - index || (head.ch - anchor.ch) * (part2.level == 1 ? -1 : 1);\n        if (headIndex == boundary - 1 || headIndex == boundary) {\n          leftSide = dir < 0;\n        } else {\n          leftSide = dir > 0;\n        }\n      }\n      var usePart = order2[boundary + (leftSide ? -1 : 0)];\n      var from = leftSide == (usePart.level == 1);\n      var ch2 = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n      return anchor.ch == ch2 && anchor.sticky == sticky ? range3 : new Range2(new Pos(anchor.line, ch2, sticky), head);\n    }\n    function gutterEvent(cm, e, type2, prevent) {\n      var mX, mY;\n      if (e.touches) {\n        mX = e.touches[0].clientX;\n        mY = e.touches[0].clientY;\n      } else {\n        try {\n          mX = e.clientX;\n          mY = e.clientY;\n        } catch (e$1) {\n          return false;\n        }\n      }\n      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n        return false;\n      }\n      if (prevent) {\n        e_preventDefault(e);\n      }\n      var display = cm.display;\n      var lineBox = display.lineDiv.getBoundingClientRect();\n      if (mY > lineBox.bottom || !hasHandler(cm, type2)) {\n        return e_defaultPrevented(e);\n      }\n      mY -= lineBox.top - display.viewOffset;\n      for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {\n        var g = display.gutters.childNodes[i2];\n        if (g && g.getBoundingClientRect().right >= mX) {\n          var line = lineAtHeight(cm.doc, mY);\n          var gutter = cm.display.gutterSpecs[i2];\n          signal(cm, type2, cm, line, gutter.className, e);\n          return e_defaultPrevented(e);\n        }\n      }\n    }\n    function clickInGutter(cm, e) {\n      return gutterEvent(cm, e, \"gutterClick\", true);\n    }\n    function onContextMenu(cm, e) {\n      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n        return;\n      }\n      if (signalDOMEvent(cm, e, \"contextmenu\")) {\n        return;\n      }\n      if (!captureRightClick) {\n        cm.display.input.onContextMenu(e);\n      }\n    }\n    function contextMenuInGutter(cm, e) {\n      if (!hasHandler(cm, \"gutterContextMenu\")) {\n        return false;\n      }\n      return gutterEvent(cm, e, \"gutterContextMenu\", false);\n    }\n    function themeChanged(cm) {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") + cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n      clearCaches(cm);\n    }\n    var Init = { toString: function() {\n      return \"CodeMirror.Init\";\n    } };\n    var defaults2 = {};\n    var optionHandlers = {};\n    function defineOptions(CodeMirror2) {\n      var optionHandlers2 = CodeMirror2.optionHandlers;\n      function option(name2, deflt, handle, notOnInit) {\n        CodeMirror2.defaults[name2] = deflt;\n        if (handle) {\n          optionHandlers2[name2] = notOnInit ? function(cm, val, old) {\n            if (old != Init) {\n              handle(cm, val, old);\n            }\n          } : handle;\n        }\n      }\n      CodeMirror2.defineOption = option;\n      CodeMirror2.Init = Init;\n      option(\"value\", \"\", function(cm, val) {\n        return cm.setValue(val);\n      }, true);\n      option(\"mode\", null, function(cm, val) {\n        cm.doc.modeOption = val;\n        loadMode(cm);\n      }, true);\n      option(\"indentUnit\", 2, loadMode, true);\n      option(\"indentWithTabs\", false);\n      option(\"smartIndent\", true);\n      option(\"tabSize\", 4, function(cm) {\n        resetModeState(cm);\n        clearCaches(cm);\n        regChange(cm);\n      }, true);\n      option(\"lineSeparator\", null, function(cm, val) {\n        cm.doc.lineSep = val;\n        if (!val) {\n          return;\n        }\n        var newBreaks = [], lineNo2 = cm.doc.first;\n        cm.doc.iter(function(line) {\n          for (var pos = 0; ; ) {\n            var found = line.text.indexOf(val, pos);\n            if (found == -1) {\n              break;\n            }\n            pos = found + val.length;\n            newBreaks.push(Pos(lineNo2, found));\n          }\n          lineNo2++;\n        });\n        for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {\n          replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));\n        }\n      });\n      option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function(cm, val, old) {\n        cm.state.specialChars = new RegExp(val.source + (val.test(\"\t\") ? \"\" : \"|\t\"), \"g\");\n        if (old != Init) {\n          cm.refresh();\n        }\n      });\n      option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {\n        return cm.refresh();\n      }, true);\n      option(\"electricChars\", true);\n      option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n        throw new Error(\"inputStyle can not (yet) be changed in a running editor\");\n      }, true);\n      option(\"spellcheck\", false, function(cm, val) {\n        return cm.getInputField().spellcheck = val;\n      }, true);\n      option(\"autocorrect\", false, function(cm, val) {\n        return cm.getInputField().autocorrect = val;\n      }, true);\n      option(\"autocapitalize\", false, function(cm, val) {\n        return cm.getInputField().autocapitalize = val;\n      }, true);\n      option(\"rtlMoveVisually\", !windows);\n      option(\"wholeLineUpdateBefore\", true);\n      option(\"theme\", \"default\", function(cm) {\n        themeChanged(cm);\n        updateGutters(cm);\n      }, true);\n      option(\"keyMap\", \"default\", function(cm, val, old) {\n        var next = getKeyMap(val);\n        var prev = old != Init && getKeyMap(old);\n        if (prev && prev.detach) {\n          prev.detach(cm, next);\n        }\n        if (next.attach) {\n          next.attach(cm, prev || null);\n        }\n      });\n      option(\"extraKeys\", null);\n      option(\"configureMouse\", null);\n      option(\"lineWrapping\", false, wrappingChanged, true);\n      option(\"gutters\", [], function(cm, val) {\n        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n        updateGutters(cm);\n      }, true);\n      option(\"fixedGutter\", true, function(cm, val) {\n        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n        cm.refresh();\n      }, true);\n      option(\"coverGutterNextToScrollbar\", false, function(cm) {\n        return updateScrollbars(cm);\n      }, true);\n      option(\"scrollbarStyle\", \"native\", function(cm) {\n        initScrollbars(cm);\n        updateScrollbars(cm);\n        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n      }, true);\n      option(\"lineNumbers\", false, function(cm, val) {\n        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n        updateGutters(cm);\n      }, true);\n      option(\"firstLineNumber\", 1, updateGutters, true);\n      option(\"lineNumberFormatter\", function(integer2) {\n        return integer2;\n      }, updateGutters, true);\n      option(\"showCursorWhenSelecting\", false, updateSelection, true);\n      option(\"resetSelectionOnContextMenu\", true);\n      option(\"lineWiseCopyCut\", true);\n      option(\"pasteLinesPerSelection\", true);\n      option(\"selectionsMayTouch\", false);\n      option(\"readOnly\", false, function(cm, val) {\n        if (val == \"nocursor\") {\n          onBlur(cm);\n          cm.display.input.blur();\n        }\n        cm.display.input.readOnlyChanged(val);\n      });\n      option(\"screenReaderLabel\", null, function(cm, val) {\n        val = val === \"\" ? null : val;\n        cm.display.input.screenReaderLabelChanged(val);\n      });\n      option(\"disableInput\", false, function(cm, val) {\n        if (!val) {\n          cm.display.input.reset();\n        }\n      }, true);\n      option(\"dragDrop\", true, dragDropChanged);\n      option(\"allowDropFileTypes\", null);\n      option(\"cursorBlinkRate\", 530);\n      option(\"cursorScrollMargin\", 0);\n      option(\"cursorHeight\", 1, updateSelection, true);\n      option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n      option(\"workTime\", 100);\n      option(\"workDelay\", 100);\n      option(\"flattenSpans\", true, resetModeState, true);\n      option(\"addModeClass\", false, resetModeState, true);\n      option(\"pollInterval\", 100);\n      option(\"undoDepth\", 200, function(cm, val) {\n        return cm.doc.history.undoDepth = val;\n      });\n      option(\"historyEventDelay\", 1250);\n      option(\"viewportMargin\", 10, function(cm) {\n        return cm.refresh();\n      }, true);\n      option(\"maxHighlightLength\", 1e4, resetModeState, true);\n      option(\"moveInputWithCursor\", true, function(cm, val) {\n        if (!val) {\n          cm.display.input.resetPosition();\n        }\n      });\n      option(\"tabindex\", null, function(cm, val) {\n        return cm.display.input.getField().tabIndex = val || \"\";\n      });\n      option(\"autofocus\", null);\n      option(\"direction\", \"ltr\", function(cm, val) {\n        return cm.doc.setDirection(val);\n      }, true);\n      option(\"phrases\", null);\n    }\n    function dragDropChanged(cm, value, old) {\n      var wasOn = old && old != Init;\n      if (!value != !wasOn) {\n        var funcs = cm.display.dragFunctions;\n        var toggle = value ? on : off;\n        toggle(cm.display.scroller, \"dragstart\", funcs.start);\n        toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n        toggle(cm.display.scroller, \"dragover\", funcs.over);\n        toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n        toggle(cm.display.scroller, \"drop\", funcs.drop);\n      }\n    }\n    function wrappingChanged(cm) {\n      if (cm.options.lineWrapping) {\n        addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n        cm.display.sizer.style.minWidth = \"\";\n        cm.display.sizerWidth = null;\n      } else {\n        rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n        findMaxLine(cm);\n      }\n      estimateLineHeights(cm);\n      regChange(cm);\n      clearCaches(cm);\n      setTimeout(function() {\n        return updateScrollbars(cm);\n      }, 100);\n    }\n    function CodeMirror(place, options) {\n      var this$1$1 = this;\n      if (!(this instanceof CodeMirror)) {\n        return new CodeMirror(place, options);\n      }\n      this.options = options = options ? copyObj(options) : {};\n      copyObj(defaults2, options, false);\n      var doc = options.value;\n      if (typeof doc == \"string\") {\n        doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);\n      } else if (options.mode) {\n        doc.modeOption = options.mode;\n      }\n      this.doc = doc;\n      var input = new CodeMirror.inputStyles[options.inputStyle](this);\n      var display = this.display = new Display(place, doc, input, options);\n      display.wrapper.CodeMirror = this;\n      themeChanged(this);\n      if (options.lineWrapping) {\n        this.display.wrapper.className += \" CodeMirror-wrap\";\n      }\n      initScrollbars(this);\n      this.state = {\n        keyMaps: [],\n        overlays: [],\n        modeGen: 0,\n        overwrite: false,\n        delayingBlurEvent: false,\n        focused: false,\n        suppressEdits: false,\n        pasteIncoming: -1,\n        cutIncoming: -1,\n        selectingText: false,\n        draggingText: false,\n        highlight: new Delayed(),\n        keySeq: null,\n        specialChars: null\n      };\n      if (options.autofocus && !mobile) {\n        display.input.focus();\n      }\n      if (ie2 && ie_version < 11) {\n        setTimeout(function() {\n          return this$1$1.display.input.reset(true);\n        }, 20);\n      }\n      registerEventHandlers(this);\n      ensureGlobalHandlers();\n      startOperation(this);\n      this.curOp.forceUpdate = true;\n      attachDoc(this, doc);\n      if (options.autofocus && !mobile || this.hasFocus()) {\n        setTimeout(function() {\n          if (this$1$1.hasFocus() && !this$1$1.state.focused) {\n            onFocus(this$1$1);\n          }\n        }, 20);\n      } else {\n        onBlur(this);\n      }\n      for (var opt2 in optionHandlers) {\n        if (optionHandlers.hasOwnProperty(opt2)) {\n          optionHandlers[opt2](this, options[opt2], Init);\n        }\n      }\n      maybeUpdateLineNumberWidth(this);\n      if (options.finishInit) {\n        options.finishInit(this);\n      }\n      for (var i2 = 0; i2 < initHooks.length; ++i2) {\n        initHooks[i2](this);\n      }\n      endOperation(this);\n      if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\") {\n        display.lineDiv.style.textRendering = \"auto\";\n      }\n    }\n    CodeMirror.defaults = defaults2;\n    CodeMirror.optionHandlers = optionHandlers;\n    function registerEventHandlers(cm) {\n      var d = cm.display;\n      on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n      if (ie2 && ie_version < 11) {\n        on(d.scroller, \"dblclick\", operation(cm, function(e) {\n          if (signalDOMEvent(cm, e)) {\n            return;\n          }\n          var pos = posFromMouse(cm, e);\n          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n            return;\n          }\n          e_preventDefault(e);\n          var word2 = cm.findWordAt(pos);\n          extendSelection(cm.doc, word2.anchor, word2.head);\n        }));\n      } else {\n        on(d.scroller, \"dblclick\", function(e) {\n          return signalDOMEvent(cm, e) || e_preventDefault(e);\n        });\n      }\n      on(d.scroller, \"contextmenu\", function(e) {\n        return onContextMenu(cm, e);\n      });\n      on(d.input.getField(), \"contextmenu\", function(e) {\n        if (!d.scroller.contains(e.target)) {\n          onContextMenu(cm, e);\n        }\n      });\n      var touchFinished, prevTouch = { end: 0 };\n      function finishTouch() {\n        if (d.activeTouch) {\n          touchFinished = setTimeout(function() {\n            return d.activeTouch = null;\n          }, 1e3);\n          prevTouch = d.activeTouch;\n          prevTouch.end = +new Date();\n        }\n      }\n      function isMouseLikeTouchEvent(e) {\n        if (e.touches.length != 1) {\n          return false;\n        }\n        var touch = e.touches[0];\n        return touch.radiusX <= 1 && touch.radiusY <= 1;\n      }\n      function farAway(touch, other) {\n        if (other.left == null) {\n          return true;\n        }\n        var dx = other.left - touch.left, dy = other.top - touch.top;\n        return dx * dx + dy * dy > 20 * 20;\n      }\n      on(d.scroller, \"touchstart\", function(e) {\n        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n          d.input.ensurePolled();\n          clearTimeout(touchFinished);\n          var now = +new Date();\n          d.activeTouch = {\n            start: now,\n            moved: false,\n            prev: now - prevTouch.end <= 300 ? prevTouch : null\n          };\n          if (e.touches.length == 1) {\n            d.activeTouch.left = e.touches[0].pageX;\n            d.activeTouch.top = e.touches[0].pageY;\n          }\n        }\n      });\n      on(d.scroller, \"touchmove\", function() {\n        if (d.activeTouch) {\n          d.activeTouch.moved = true;\n        }\n      });\n      on(d.scroller, \"touchend\", function(e) {\n        var touch = d.activeTouch;\n        if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {\n          var pos = cm.coordsChar(d.activeTouch, \"page\"), range3;\n          if (!touch.prev || farAway(touch, touch.prev)) {\n            range3 = new Range2(pos, pos);\n          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {\n            range3 = cm.findWordAt(pos);\n          } else {\n            range3 = new Range2(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n          }\n          cm.setSelection(range3.anchor, range3.head);\n          cm.focus();\n          e_preventDefault(e);\n        }\n        finishTouch();\n      });\n      on(d.scroller, \"touchcancel\", finishTouch);\n      on(d.scroller, \"scroll\", function() {\n        if (d.scroller.clientHeight) {\n          updateScrollTop(cm, d.scroller.scrollTop);\n          setScrollLeft(cm, d.scroller.scrollLeft, true);\n          signal(cm, \"scroll\", cm);\n        }\n      });\n      on(d.scroller, \"mousewheel\", function(e) {\n        return onScrollWheel(cm, e);\n      });\n      on(d.scroller, \"DOMMouseScroll\", function(e) {\n        return onScrollWheel(cm, e);\n      });\n      on(d.wrapper, \"scroll\", function() {\n        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n      });\n      d.dragFunctions = {\n        enter: function(e) {\n          if (!signalDOMEvent(cm, e)) {\n            e_stop(e);\n          }\n        },\n        over: function(e) {\n          if (!signalDOMEvent(cm, e)) {\n            onDragOver(cm, e);\n            e_stop(e);\n          }\n        },\n        start: function(e) {\n          return onDragStart(cm, e);\n        },\n        drop: operation(cm, onDrop),\n        leave: function(e) {\n          if (!signalDOMEvent(cm, e)) {\n            clearDragCursor(cm);\n          }\n        }\n      };\n      var inp = d.input.getField();\n      on(inp, \"keyup\", function(e) {\n        return onKeyUp.call(cm, e);\n      });\n      on(inp, \"keydown\", operation(cm, onKeyDown2));\n      on(inp, \"keypress\", operation(cm, onKeyPress));\n      on(inp, \"focus\", function(e) {\n        return onFocus(cm, e);\n      });\n      on(inp, \"blur\", function(e) {\n        return onBlur(cm, e);\n      });\n    }\n    var initHooks = [];\n    CodeMirror.defineInitHook = function(f) {\n      return initHooks.push(f);\n    };\n    function indentLine(cm, n2, how, aggressive) {\n      var doc = cm.doc, state;\n      if (how == null) {\n        how = \"add\";\n      }\n      if (how == \"smart\") {\n        if (!doc.mode.indent) {\n          how = \"prev\";\n        } else {\n          state = getContextBefore(cm, n2).state;\n        }\n      }\n      var tabSize = cm.options.tabSize;\n      var line = getLine2(doc, n2), curSpace = countColumn(line.text, null, tabSize);\n      if (line.stateAfter) {\n        line.stateAfter = null;\n      }\n      var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n      if (!aggressive && !/\\S/.test(line.text)) {\n        indentation = 0;\n        how = \"not\";\n      } else if (how == \"smart\") {\n        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n        if (indentation == Pass || indentation > 150) {\n          if (!aggressive) {\n            return;\n          }\n          how = \"prev\";\n        }\n      }\n      if (how == \"prev\") {\n        if (n2 > doc.first) {\n          indentation = countColumn(getLine2(doc, n2 - 1).text, null, tabSize);\n        } else {\n          indentation = 0;\n        }\n      } else if (how == \"add\") {\n        indentation = curSpace + cm.options.indentUnit;\n      } else if (how == \"subtract\") {\n        indentation = curSpace - cm.options.indentUnit;\n      } else if (typeof how == \"number\") {\n        indentation = curSpace + how;\n      }\n      indentation = Math.max(0, indentation);\n      var indentString = \"\", pos = 0;\n      if (cm.options.indentWithTabs) {\n        for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {\n          pos += tabSize;\n          indentString += \"\t\";\n        }\n      }\n      if (pos < indentation) {\n        indentString += spaceStr(indentation - pos);\n      }\n      if (indentString != curSpaceString) {\n        replaceRange(doc, indentString, Pos(n2, 0), Pos(n2, curSpaceString.length), \"+input\");\n        line.stateAfter = null;\n        return true;\n      } else {\n        for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {\n          var range3 = doc.sel.ranges[i$12];\n          if (range3.head.line == n2 && range3.head.ch < curSpaceString.length) {\n            var pos$1 = Pos(n2, curSpaceString.length);\n            replaceOneSelection(doc, i$12, new Range2(pos$1, pos$1));\n            break;\n          }\n        }\n      }\n    }\n    var lastCopied = null;\n    function setLastCopied(newLastCopied) {\n      lastCopied = newLastCopied;\n    }\n    function applyTextInput(cm, inserted, deleted, sel, origin) {\n      var doc = cm.doc;\n      cm.display.shift = false;\n      if (!sel) {\n        sel = doc.sel;\n      }\n      var recent = +new Date() - 200;\n      var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n      var textLines = splitLinesAuto(inserted), multiPaste = null;\n      if (paste && sel.ranges.length > 1) {\n        if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n          if (sel.ranges.length % lastCopied.text.length == 0) {\n            multiPaste = [];\n            for (var i2 = 0; i2 < lastCopied.text.length; i2++) {\n              multiPaste.push(doc.splitLines(lastCopied.text[i2]));\n            }\n          }\n        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n          multiPaste = map2(textLines, function(l2) {\n            return [l2];\n          });\n        }\n      }\n      var updateInput = cm.curOp.updateInput;\n      for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {\n        var range3 = sel.ranges[i$12];\n        var from = range3.from(), to = range3.to();\n        if (range3.empty()) {\n          if (deleted && deleted > 0) {\n            from = Pos(from.line, from.ch - deleted);\n          } else if (cm.state.overwrite && !paste) {\n            to = Pos(to.line, Math.min(getLine2(doc, to.line).text.length, to.ch + lst(textLines).length));\n          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\")) {\n            from = to = Pos(from.line, 0);\n          }\n        }\n        var changeEvent = {\n          from,\n          to,\n          text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,\n          origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")\n        };\n        makeChange(cm.doc, changeEvent);\n        signalLater(cm, \"inputRead\", cm, changeEvent);\n      }\n      if (inserted && !paste) {\n        triggerElectric(cm, inserted);\n      }\n      ensureCursorVisible(cm);\n      if (cm.curOp.updateInput < 2) {\n        cm.curOp.updateInput = updateInput;\n      }\n      cm.curOp.typing = true;\n      cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n    }\n    function handlePaste(e, cm) {\n      var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n      if (pasted) {\n        e.preventDefault();\n        if (!cm.isReadOnly() && !cm.options.disableInput) {\n          runInOp(cm, function() {\n            return applyTextInput(cm, pasted, 0, null, \"paste\");\n          });\n        }\n        return true;\n      }\n    }\n    function triggerElectric(cm, inserted) {\n      if (!cm.options.electricChars || !cm.options.smartIndent) {\n        return;\n      }\n      var sel = cm.doc.sel;\n      for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {\n        var range3 = sel.ranges[i2];\n        if (range3.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range3.head.line) {\n          continue;\n        }\n        var mode2 = cm.getModeAt(range3.head);\n        var indented = false;\n        if (mode2.electricChars) {\n          for (var j = 0; j < mode2.electricChars.length; j++) {\n            if (inserted.indexOf(mode2.electricChars.charAt(j)) > -1) {\n              indented = indentLine(cm, range3.head.line, \"smart\");\n              break;\n            }\n          }\n        } else if (mode2.electricInput) {\n          if (mode2.electricInput.test(getLine2(cm.doc, range3.head.line).text.slice(0, range3.head.ch))) {\n            indented = indentLine(cm, range3.head.line, \"smart\");\n          }\n        }\n        if (indented) {\n          signalLater(cm, \"electricInput\", cm, range3.head.line);\n        }\n      }\n    }\n    function copyableRanges(cm) {\n      var text3 = [], ranges = [];\n      for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {\n        var line = cm.doc.sel.ranges[i2].head.line;\n        var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };\n        ranges.push(lineRange);\n        text3.push(cm.getRange(lineRange.anchor, lineRange.head));\n      }\n      return { text: text3, ranges };\n    }\n    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n      field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n      field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n      field.setAttribute(\"spellcheck\", !!spellcheck);\n    }\n    function hiddenTextarea() {\n      var te2 = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none\");\n      var div2 = elt(\"div\", [te2], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n      if (webkit) {\n        te2.style.width = \"1000px\";\n      } else {\n        te2.setAttribute(\"wrap\", \"off\");\n      }\n      if (ios) {\n        te2.style.border = \"1px solid black\";\n      }\n      disableBrowserMagic(te2);\n      return div2;\n    }\n    function addEditorMethods(CodeMirror2) {\n      var optionHandlers2 = CodeMirror2.optionHandlers;\n      var helpers2 = CodeMirror2.helpers = {};\n      CodeMirror2.prototype = {\n        constructor: CodeMirror2,\n        focus: function() {\n          window.focus();\n          this.display.input.focus();\n        },\n        setOption: function(option, value) {\n          var options = this.options, old = options[option];\n          if (options[option] == value && option != \"mode\") {\n            return;\n          }\n          options[option] = value;\n          if (optionHandlers2.hasOwnProperty(option)) {\n            operation(this, optionHandlers2[option])(this, value, old);\n          }\n          signal(this, \"optionChange\", this, option);\n        },\n        getOption: function(option) {\n          return this.options[option];\n        },\n        getDoc: function() {\n          return this.doc;\n        },\n        addKeyMap: function(map3, bottom2) {\n          this.state.keyMaps[bottom2 ? \"push\" : \"unshift\"](getKeyMap(map3));\n        },\n        removeKeyMap: function(map3) {\n          var maps = this.state.keyMaps;\n          for (var i2 = 0; i2 < maps.length; ++i2) {\n            if (maps[i2] == map3 || maps[i2].name == map3) {\n              maps.splice(i2, 1);\n              return true;\n            }\n          }\n        },\n        addOverlay: methodOp(function(spec, options) {\n          var mode2 = spec.token ? spec : CodeMirror2.getMode(this.options, spec);\n          if (mode2.startState) {\n            throw new Error(\"Overlays may not be stateful.\");\n          }\n          insertSorted(this.state.overlays, {\n            mode: mode2,\n            modeSpec: spec,\n            opaque: options && options.opaque,\n            priority: options && options.priority || 0\n          }, function(overlay) {\n            return overlay.priority;\n          });\n          this.state.modeGen++;\n          regChange(this);\n        }),\n        removeOverlay: methodOp(function(spec) {\n          var overlays = this.state.overlays;\n          for (var i2 = 0; i2 < overlays.length; ++i2) {\n            var cur = overlays[i2].modeSpec;\n            if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n              overlays.splice(i2, 1);\n              this.state.modeGen++;\n              regChange(this);\n              return;\n            }\n          }\n        }),\n        indentLine: methodOp(function(n2, dir, aggressive) {\n          if (typeof dir != \"string\" && typeof dir != \"number\") {\n            if (dir == null) {\n              dir = this.options.smartIndent ? \"smart\" : \"prev\";\n            } else {\n              dir = dir ? \"add\" : \"subtract\";\n            }\n          }\n          if (isLine(this.doc, n2)) {\n            indentLine(this, n2, dir, aggressive);\n          }\n        }),\n        indentSelection: methodOp(function(how) {\n          var ranges = this.doc.sel.ranges, end2 = -1;\n          for (var i2 = 0; i2 < ranges.length; i2++) {\n            var range3 = ranges[i2];\n            if (!range3.empty()) {\n              var from = range3.from(), to = range3.to();\n              var start2 = Math.max(end2, from.line);\n              end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n              for (var j = start2; j < end2; ++j) {\n                indentLine(this, j, how);\n              }\n              var newRanges = this.doc.sel.ranges;\n              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {\n                replaceOneSelection(this.doc, i2, new Range2(from, newRanges[i2].to()), sel_dontScroll);\n              }\n            } else if (range3.head.line > end2) {\n              indentLine(this, range3.head.line, how, true);\n              end2 = range3.head.line;\n              if (i2 == this.doc.sel.primIndex) {\n                ensureCursorVisible(this);\n              }\n            }\n          }\n        }),\n        getTokenAt: function(pos, precise) {\n          return takeToken(this, pos, precise);\n        },\n        getLineTokens: function(line, precise) {\n          return takeToken(this, Pos(line), precise, true);\n        },\n        getTokenTypeAt: function(pos) {\n          pos = clipPos(this.doc, pos);\n          var styles2 = getLineStyles(this, getLine2(this.doc, pos.line));\n          var before = 0, after = (styles2.length - 1) / 2, ch2 = pos.ch;\n          var type2;\n          if (ch2 == 0) {\n            type2 = styles2[2];\n          } else {\n            for (; ; ) {\n              var mid2 = before + after >> 1;\n              if ((mid2 ? styles2[mid2 * 2 - 1] : 0) >= ch2) {\n                after = mid2;\n              } else if (styles2[mid2 * 2 + 1] < ch2) {\n                before = mid2 + 1;\n              } else {\n                type2 = styles2[mid2 * 2 + 2];\n                break;\n              }\n            }\n          }\n          var cut = type2 ? type2.indexOf(\"overlay \") : -1;\n          return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);\n        },\n        getModeAt: function(pos) {\n          var mode2 = this.doc.mode;\n          if (!mode2.innerMode) {\n            return mode2;\n          }\n          return CodeMirror2.innerMode(mode2, this.getTokenAt(pos).state).mode;\n        },\n        getHelper: function(pos, type2) {\n          return this.getHelpers(pos, type2)[0];\n        },\n        getHelpers: function(pos, type2) {\n          var found = [];\n          if (!helpers2.hasOwnProperty(type2)) {\n            return found;\n          }\n          var help = helpers2[type2], mode2 = this.getModeAt(pos);\n          if (typeof mode2[type2] == \"string\") {\n            if (help[mode2[type2]]) {\n              found.push(help[mode2[type2]]);\n            }\n          } else if (mode2[type2]) {\n            for (var i2 = 0; i2 < mode2[type2].length; i2++) {\n              var val = help[mode2[type2][i2]];\n              if (val) {\n                found.push(val);\n              }\n            }\n          } else if (mode2.helperType && help[mode2.helperType]) {\n            found.push(help[mode2.helperType]);\n          } else if (help[mode2.name]) {\n            found.push(help[mode2.name]);\n          }\n          for (var i$12 = 0; i$12 < help._global.length; i$12++) {\n            var cur = help._global[i$12];\n            if (cur.pred(mode2, this) && indexOf(found, cur.val) == -1) {\n              found.push(cur.val);\n            }\n          }\n          return found;\n        },\n        getStateAfter: function(line, precise) {\n          var doc = this.doc;\n          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n          return getContextBefore(this, line + 1, precise).state;\n        },\n        cursorCoords: function(start2, mode2) {\n          var pos, range3 = this.doc.sel.primary();\n          if (start2 == null) {\n            pos = range3.head;\n          } else if (typeof start2 == \"object\") {\n            pos = clipPos(this.doc, start2);\n          } else {\n            pos = start2 ? range3.from() : range3.to();\n          }\n          return cursorCoords(this, pos, mode2 || \"page\");\n        },\n        charCoords: function(pos, mode2) {\n          return charCoords(this, clipPos(this.doc, pos), mode2 || \"page\");\n        },\n        coordsChar: function(coords, mode2) {\n          coords = fromCoordSystem(this, coords, mode2 || \"page\");\n          return coordsChar(this, coords.left, coords.top);\n        },\n        lineAtHeight: function(height, mode2) {\n          height = fromCoordSystem(this, { top: height, left: 0 }, mode2 || \"page\").top;\n          return lineAtHeight(this.doc, height + this.display.viewOffset);\n        },\n        heightAtLine: function(line, mode2, includeWidgets) {\n          var end2 = false, lineObj;\n          if (typeof line == \"number\") {\n            var last = this.doc.first + this.doc.size - 1;\n            if (line < this.doc.first) {\n              line = this.doc.first;\n            } else if (line > last) {\n              line = last;\n              end2 = true;\n            }\n            lineObj = getLine2(this.doc, line);\n          } else {\n            lineObj = line;\n          }\n          return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode2 || \"page\", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine(lineObj) : 0);\n        },\n        defaultTextHeight: function() {\n          return textHeight(this.display);\n        },\n        defaultCharWidth: function() {\n          return charWidth(this.display);\n        },\n        getViewport: function() {\n          return { from: this.display.viewFrom, to: this.display.viewTo };\n        },\n        addWidget: function(pos, node, scroll, vert2, horiz) {\n          var display = this.display;\n          pos = cursorCoords(this, clipPos(this.doc, pos));\n          var top2 = pos.bottom, left = pos.left;\n          node.style.position = \"absolute\";\n          node.setAttribute(\"cm-ignore-events\", \"true\");\n          this.display.input.setUneditable(node);\n          display.sizer.appendChild(node);\n          if (vert2 == \"over\") {\n            top2 = pos.top;\n          } else if (vert2 == \"above\" || vert2 == \"near\") {\n            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n            if ((vert2 == \"above\" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n              top2 = pos.top - node.offsetHeight;\n            } else if (pos.bottom + node.offsetHeight <= vspace) {\n              top2 = pos.bottom;\n            }\n            if (left + node.offsetWidth > hspace) {\n              left = hspace - node.offsetWidth;\n            }\n          }\n          node.style.top = top2 + \"px\";\n          node.style.left = node.style.right = \"\";\n          if (horiz == \"right\") {\n            left = display.sizer.clientWidth - node.offsetWidth;\n            node.style.right = \"0px\";\n          } else {\n            if (horiz == \"left\") {\n              left = 0;\n            } else if (horiz == \"middle\") {\n              left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n            }\n            node.style.left = left + \"px\";\n          }\n          if (scroll) {\n            scrollIntoView(this, { left, top: top2, right: left + node.offsetWidth, bottom: top2 + node.offsetHeight });\n          }\n        },\n        triggerOnKeyDown: methodOp(onKeyDown2),\n        triggerOnKeyPress: methodOp(onKeyPress),\n        triggerOnKeyUp: onKeyUp,\n        triggerOnMouseDown: methodOp(onMouseDown),\n        execCommand: function(cmd) {\n          if (commands.hasOwnProperty(cmd)) {\n            return commands[cmd].call(null, this);\n          }\n        },\n        triggerElectric: methodOp(function(text3) {\n          triggerElectric(this, text3);\n        }),\n        findPosH: function(from, amount, unit, visually) {\n          var dir = 1;\n          if (amount < 0) {\n            dir = -1;\n            amount = -amount;\n          }\n          var cur = clipPos(this.doc, from);\n          for (var i2 = 0; i2 < amount; ++i2) {\n            cur = findPosH(this.doc, cur, dir, unit, visually);\n            if (cur.hitSide) {\n              break;\n            }\n          }\n          return cur;\n        },\n        moveH: methodOp(function(dir, unit) {\n          var this$1$1 = this;\n          this.extendSelectionsBy(function(range3) {\n            if (this$1$1.display.shift || this$1$1.doc.extend || range3.empty()) {\n              return findPosH(this$1$1.doc, range3.head, dir, unit, this$1$1.options.rtlMoveVisually);\n            } else {\n              return dir < 0 ? range3.from() : range3.to();\n            }\n          }, sel_move);\n        }),\n        deleteH: methodOp(function(dir, unit) {\n          var sel = this.doc.sel, doc = this.doc;\n          if (sel.somethingSelected()) {\n            doc.replaceSelection(\"\", null, \"+delete\");\n          } else {\n            deleteNearSelection(this, function(range3) {\n              var other = findPosH(doc, range3.head, dir, unit, false);\n              return dir < 0 ? { from: other, to: range3.head } : { from: range3.head, to: other };\n            });\n          }\n        }),\n        findPosV: function(from, amount, unit, goalColumn) {\n          var dir = 1, x2 = goalColumn;\n          if (amount < 0) {\n            dir = -1;\n            amount = -amount;\n          }\n          var cur = clipPos(this.doc, from);\n          for (var i2 = 0; i2 < amount; ++i2) {\n            var coords = cursorCoords(this, cur, \"div\");\n            if (x2 == null) {\n              x2 = coords.left;\n            } else {\n              coords.left = x2;\n            }\n            cur = findPosV(this, coords, dir, unit);\n            if (cur.hitSide) {\n              break;\n            }\n          }\n          return cur;\n        },\n        moveV: methodOp(function(dir, unit) {\n          var this$1$1 = this;\n          var doc = this.doc, goals = [];\n          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n          doc.extendSelectionsBy(function(range3) {\n            if (collapse) {\n              return dir < 0 ? range3.from() : range3.to();\n            }\n            var headPos = cursorCoords(this$1$1, range3.head, \"div\");\n            if (range3.goalColumn != null) {\n              headPos.left = range3.goalColumn;\n            }\n            goals.push(headPos.left);\n            var pos = findPosV(this$1$1, headPos, dir, unit);\n            if (unit == \"page\" && range3 == doc.sel.primary()) {\n              addToScrollTop(this$1$1, charCoords(this$1$1, pos, \"div\").top - headPos.top);\n            }\n            return pos;\n          }, sel_move);\n          if (goals.length) {\n            for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {\n              doc.sel.ranges[i2].goalColumn = goals[i2];\n            }\n          }\n        }),\n        findWordAt: function(pos) {\n          var doc = this.doc, line = getLine2(doc, pos.line).text;\n          var start2 = pos.ch, end2 = pos.ch;\n          if (line) {\n            var helper = this.getHelper(pos, \"wordChars\");\n            if ((pos.sticky == \"before\" || end2 == line.length) && start2) {\n              --start2;\n            } else {\n              ++end2;\n            }\n            var startChar = line.charAt(start2);\n            var check2 = isWordChar(startChar, helper) ? function(ch2) {\n              return isWordChar(ch2, helper);\n            } : /\\s/.test(startChar) ? function(ch2) {\n              return /\\s/.test(ch2);\n            } : function(ch2) {\n              return !/\\s/.test(ch2) && !isWordChar(ch2);\n            };\n            while (start2 > 0 && check2(line.charAt(start2 - 1))) {\n              --start2;\n            }\n            while (end2 < line.length && check2(line.charAt(end2))) {\n              ++end2;\n            }\n          }\n          return new Range2(Pos(pos.line, start2), Pos(pos.line, end2));\n        },\n        toggleOverwrite: function(value) {\n          if (value != null && value == this.state.overwrite) {\n            return;\n          }\n          if (this.state.overwrite = !this.state.overwrite) {\n            addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n          } else {\n            rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n          }\n          signal(this, \"overwriteToggle\", this, this.state.overwrite);\n        },\n        hasFocus: function() {\n          return this.display.input.getField() == activeElt();\n        },\n        isReadOnly: function() {\n          return !!(this.options.readOnly || this.doc.cantEdit);\n        },\n        scrollTo: methodOp(function(x2, y2) {\n          scrollToCoords(this, x2, y2);\n        }),\n        getScrollInfo: function() {\n          var scroller = this.display.scroller;\n          return {\n            left: scroller.scrollLeft,\n            top: scroller.scrollTop,\n            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n            clientHeight: displayHeight(this),\n            clientWidth: displayWidth(this)\n          };\n        },\n        scrollIntoView: methodOp(function(range3, margin) {\n          if (range3 == null) {\n            range3 = { from: this.doc.sel.primary().head, to: null };\n            if (margin == null) {\n              margin = this.options.cursorScrollMargin;\n            }\n          } else if (typeof range3 == \"number\") {\n            range3 = { from: Pos(range3, 0), to: null };\n          } else if (range3.from == null) {\n            range3 = { from: range3, to: null };\n          }\n          if (!range3.to) {\n            range3.to = range3.from;\n          }\n          range3.margin = margin || 0;\n          if (range3.from.line != null) {\n            scrollToRange(this, range3);\n          } else {\n            scrollToCoordsRange(this, range3.from, range3.to, range3.margin);\n          }\n        }),\n        setSize: methodOp(function(width, height) {\n          var this$1$1 = this;\n          var interpret = function(val) {\n            return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n          };\n          if (width != null) {\n            this.display.wrapper.style.width = interpret(width);\n          }\n          if (height != null) {\n            this.display.wrapper.style.height = interpret(height);\n          }\n          if (this.options.lineWrapping) {\n            clearLineMeasurementCache(this);\n          }\n          var lineNo2 = this.display.viewFrom;\n          this.doc.iter(lineNo2, this.display.viewTo, function(line) {\n            if (line.widgets) {\n              for (var i2 = 0; i2 < line.widgets.length; i2++) {\n                if (line.widgets[i2].noHScroll) {\n                  regLineChange(this$1$1, lineNo2, \"widget\");\n                  break;\n                }\n              }\n            }\n            ++lineNo2;\n          });\n          this.curOp.forceUpdate = true;\n          signal(this, \"refresh\", this);\n        }),\n        operation: function(f) {\n          return runInOp(this, f);\n        },\n        startOperation: function() {\n          return startOperation(this);\n        },\n        endOperation: function() {\n          return endOperation(this);\n        },\n        refresh: methodOp(function() {\n          var oldHeight = this.display.cachedTextHeight;\n          regChange(this);\n          this.curOp.forceUpdate = true;\n          clearCaches(this);\n          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n          updateGutterSpace(this.display);\n          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {\n            estimateLineHeights(this);\n          }\n          signal(this, \"refresh\", this);\n        }),\n        swapDoc: methodOp(function(doc) {\n          var old = this.doc;\n          old.cm = null;\n          if (this.state.selectingText) {\n            this.state.selectingText();\n          }\n          attachDoc(this, doc);\n          clearCaches(this);\n          this.display.input.reset();\n          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n          this.curOp.forceScroll = true;\n          signalLater(this, \"swapDoc\", this, old);\n          return old;\n        }),\n        phrase: function(phraseText) {\n          var phrases = this.options.phrases;\n          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n        },\n        getInputField: function() {\n          return this.display.input.getField();\n        },\n        getWrapperElement: function() {\n          return this.display.wrapper;\n        },\n        getScrollerElement: function() {\n          return this.display.scroller;\n        },\n        getGutterElement: function() {\n          return this.display.gutters;\n        }\n      };\n      eventMixin(CodeMirror2);\n      CodeMirror2.registerHelper = function(type2, name2, value) {\n        if (!helpers2.hasOwnProperty(type2)) {\n          helpers2[type2] = CodeMirror2[type2] = { _global: [] };\n        }\n        helpers2[type2][name2] = value;\n      };\n      CodeMirror2.registerGlobalHelper = function(type2, name2, predicate, value) {\n        CodeMirror2.registerHelper(type2, name2, value);\n        helpers2[type2]._global.push({ pred: predicate, val: value });\n      };\n    }\n    function findPosH(doc, pos, dir, unit, visually) {\n      var oldPos = pos;\n      var origDir = dir;\n      var lineObj = getLine2(doc, pos.line);\n      var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n      function findNextLine() {\n        var l2 = pos.line + lineDir;\n        if (l2 < doc.first || l2 >= doc.first + doc.size) {\n          return false;\n        }\n        pos = new Pos(l2, pos.ch, pos.sticky);\n        return lineObj = getLine2(doc, l2);\n      }\n      function moveOnce(boundToLine) {\n        var next;\n        if (unit == \"codepoint\") {\n          var ch2 = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n          if (isNaN(ch2)) {\n            next = null;\n          } else {\n            var astral = dir > 0 ? ch2 >= 55296 && ch2 < 56320 : ch2 >= 56320 && ch2 < 57343;\n            next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n          }\n        } else if (visually) {\n          next = moveVisually(doc.cm, lineObj, pos, dir);\n        } else {\n          next = moveLogically(lineObj, pos, dir);\n        }\n        if (next == null) {\n          if (!boundToLine && findNextLine()) {\n            pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);\n          } else {\n            return false;\n          }\n        } else {\n          pos = next;\n        }\n        return true;\n      }\n      if (unit == \"char\" || unit == \"codepoint\") {\n        moveOnce();\n      } else if (unit == \"column\") {\n        moveOnce(true);\n      } else if (unit == \"word\" || unit == \"group\") {\n        var sawType = null, group = unit == \"group\";\n        var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n        for (var first = true; ; first = false) {\n          if (dir < 0 && !moveOnce(!first)) {\n            break;\n          }\n          var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n          var type2 = isWordChar(cur, helper) ? \"w\" : group && cur == \"\\n\" ? \"n\" : !group || /\\s/.test(cur) ? null : \"p\";\n          if (group && !first && !type2) {\n            type2 = \"s\";\n          }\n          if (sawType && sawType != type2) {\n            if (dir < 0) {\n              dir = 1;\n              moveOnce();\n              pos.sticky = \"after\";\n            }\n            break;\n          }\n          if (type2) {\n            sawType = type2;\n          }\n          if (dir > 0 && !moveOnce(!first)) {\n            break;\n          }\n        }\n      }\n      var result2 = skipAtomic(doc, pos, oldPos, origDir, true);\n      if (equalCursorPos(oldPos, result2)) {\n        result2.hitSide = true;\n      }\n      return result2;\n    }\n    function findPosV(cm, pos, dir, unit) {\n      var doc = cm.doc, x2 = pos.left, y2;\n      if (unit == \"page\") {\n        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);\n        y2 = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n      } else if (unit == \"line\") {\n        y2 = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n      }\n      var target2;\n      for (; ; ) {\n        target2 = coordsChar(cm, x2, y2);\n        if (!target2.outside) {\n          break;\n        }\n        if (dir < 0 ? y2 <= 0 : y2 >= doc.height) {\n          target2.hitSide = true;\n          break;\n        }\n        y2 += dir * 5;\n      }\n      return target2;\n    }\n    var ContentEditableInput = function(cm) {\n      this.cm = cm;\n      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n      this.polling = new Delayed();\n      this.composing = null;\n      this.gracePeriod = false;\n      this.readDOMTimeout = null;\n    };\n    ContentEditableInput.prototype.init = function(display) {\n      var this$1$1 = this;\n      var input = this, cm = input.cm;\n      var div2 = input.div = display.lineDiv;\n      div2.contentEditable = true;\n      disableBrowserMagic(div2, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n      function belongsToInput(e) {\n        for (var t2 = e.target; t2; t2 = t2.parentNode) {\n          if (t2 == div2) {\n            return true;\n          }\n          if (/\\bCodeMirror-(?:line)?widget\\b/.test(t2.className)) {\n            break;\n          }\n        }\n        return false;\n      }\n      on(div2, \"paste\", function(e) {\n        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n          return;\n        }\n        if (ie_version <= 11) {\n          setTimeout(operation(cm, function() {\n            return this$1$1.updateFromDOM();\n          }), 20);\n        }\n      });\n      on(div2, \"compositionstart\", function(e) {\n        this$1$1.composing = { data: e.data, done: false };\n      });\n      on(div2, \"compositionupdate\", function(e) {\n        if (!this$1$1.composing) {\n          this$1$1.composing = { data: e.data, done: false };\n        }\n      });\n      on(div2, \"compositionend\", function(e) {\n        if (this$1$1.composing) {\n          if (e.data != this$1$1.composing.data) {\n            this$1$1.readFromDOMSoon();\n          }\n          this$1$1.composing.done = true;\n        }\n      });\n      on(div2, \"touchstart\", function() {\n        return input.forceCompositionEnd();\n      });\n      on(div2, \"input\", function() {\n        if (!this$1$1.composing) {\n          this$1$1.readFromDOMSoon();\n        }\n      });\n      function onCopyCut(e) {\n        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {\n          return;\n        }\n        if (cm.somethingSelected()) {\n          setLastCopied({ lineWise: false, text: cm.getSelections() });\n          if (e.type == \"cut\") {\n            cm.replaceSelection(\"\", null, \"cut\");\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          setLastCopied({ lineWise: true, text: ranges.text });\n          if (e.type == \"cut\") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection(\"\", null, \"cut\");\n            });\n          }\n        }\n        if (e.clipboardData) {\n          e.clipboardData.clearData();\n          var content = lastCopied.text.join(\"\\n\");\n          e.clipboardData.setData(\"Text\", content);\n          if (e.clipboardData.getData(\"Text\") == content) {\n            e.preventDefault();\n            return;\n          }\n        }\n        var kludge = hiddenTextarea(), te2 = kludge.firstChild;\n        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n        te2.value = lastCopied.text.join(\"\\n\");\n        var hadFocus = activeElt();\n        selectInput(te2);\n        setTimeout(function() {\n          cm.display.lineSpace.removeChild(kludge);\n          hadFocus.focus();\n          if (hadFocus == div2) {\n            input.showPrimarySelection();\n          }\n        }, 50);\n      }\n      on(div2, \"copy\", onCopyCut);\n      on(div2, \"cut\", onCopyCut);\n    };\n    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {\n      if (label) {\n        this.div.setAttribute(\"aria-label\", label);\n      } else {\n        this.div.removeAttribute(\"aria-label\");\n      }\n    };\n    ContentEditableInput.prototype.prepareSelection = function() {\n      var result2 = prepareSelection(this.cm, false);\n      result2.focus = activeElt() == this.div;\n      return result2;\n    };\n    ContentEditableInput.prototype.showSelection = function(info2, takeFocus) {\n      if (!info2 || !this.cm.display.view.length) {\n        return;\n      }\n      if (info2.focus || takeFocus) {\n        this.showPrimarySelection();\n      }\n      this.showMultipleSelections(info2);\n    };\n    ContentEditableInput.prototype.getSelection = function() {\n      return this.cm.display.wrapper.ownerDocument.getSelection();\n    };\n    ContentEditableInput.prototype.showPrimarySelection = function() {\n      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n      var from = prim.from(), to = prim.to();\n      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n        sel.removeAllRanges();\n        return;\n      }\n      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {\n        return;\n      }\n      var view = cm.display.view;\n      var start2 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };\n      var end2 = to.line < cm.display.viewTo && posToDOM(cm, to);\n      if (!end2) {\n        var measure = view[view.length - 1].measure;\n        var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end2 = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };\n      }\n      if (!start2 || !end2) {\n        sel.removeAllRanges();\n        return;\n      }\n      var old = sel.rangeCount && sel.getRangeAt(0), rng;\n      try {\n        rng = range2(start2.node, start2.offset, end2.offset, end2.node);\n      } catch (e) {\n      }\n      if (rng) {\n        if (!gecko && cm.state.focused) {\n          sel.collapse(start2.node, start2.offset);\n          if (!rng.collapsed) {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          }\n        } else {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n        if (old && sel.anchorNode == null) {\n          sel.addRange(old);\n        } else if (gecko) {\n          this.startGracePeriod();\n        }\n      }\n      this.rememberSelection();\n    };\n    ContentEditableInput.prototype.startGracePeriod = function() {\n      var this$1$1 = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        this$1$1.gracePeriod = false;\n        if (this$1$1.selectionChanged()) {\n          this$1$1.cm.operation(function() {\n            return this$1$1.cm.curOp.selectionChanged = true;\n          });\n        }\n      }, 20);\n    };\n    ContentEditableInput.prototype.showMultipleSelections = function(info2) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info2.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info2.selection);\n    };\n    ContentEditableInput.prototype.rememberSelection = function() {\n      var sel = this.getSelection();\n      this.lastAnchorNode = sel.anchorNode;\n      this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode;\n      this.lastFocusOffset = sel.focusOffset;\n    };\n    ContentEditableInput.prototype.selectionInEditor = function() {\n      var sel = this.getSelection();\n      if (!sel.rangeCount) {\n        return false;\n      }\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    };\n    ContentEditableInput.prototype.focus = function() {\n      if (this.cm.options.readOnly != \"nocursor\") {\n        if (!this.selectionInEditor() || activeElt() != this.div) {\n          this.showSelection(this.prepareSelection(), true);\n        }\n        this.div.focus();\n      }\n    };\n    ContentEditableInput.prototype.blur = function() {\n      this.div.blur();\n    };\n    ContentEditableInput.prototype.getField = function() {\n      return this.div;\n    };\n    ContentEditableInput.prototype.supportsTouch = function() {\n      return true;\n    };\n    ContentEditableInput.prototype.receivedFocus = function() {\n      var this$1$1 = this;\n      var input = this;\n      if (this.selectionInEditor()) {\n        setTimeout(function() {\n          return this$1$1.pollSelection();\n        }, 20);\n      } else {\n        runInOp(this.cm, function() {\n          return input.cm.curOp.selectionChanged = true;\n        });\n      }\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      this.polling.set(this.cm.options.pollInterval, poll);\n    };\n    ContentEditableInput.prototype.selectionChanged = function() {\n      var sel = this.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    };\n    ContentEditableInput.prototype.pollSelection = function() {\n      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n        return;\n      }\n      var sel = this.getSelection(), cm = this.cm;\n      if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n        this.cm.triggerOnKeyDown({ type: \"keydown\", keyCode: 8, preventDefault: Math.abs });\n        this.blur();\n        this.focus();\n        return;\n      }\n      if (this.composing) {\n        return;\n      }\n      this.rememberSelection();\n      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n      var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n      if (anchor && head) {\n        runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) {\n            cm.curOp.selectionChanged = true;\n          }\n        });\n      }\n    };\n    ContentEditableInput.prototype.pollContent = function() {\n      if (this.readDOMTimeout != null) {\n        clearTimeout(this.readDOMTimeout);\n        this.readDOMTimeout = null;\n      }\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.ch == 0 && from.line > cm.firstLine()) {\n        from = Pos(from.line - 1, getLine2(cm.doc, from.line - 1).length);\n      }\n      if (to.ch == getLine2(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n        to = Pos(to.line + 1, 0);\n      }\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n        return false;\n      }\n      var fromIndex, fromLine, fromNode;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        fromLine = lineNo(display.view[0].line);\n        fromNode = display.view[0].node;\n      } else {\n        fromLine = lineNo(display.view[fromIndex].line);\n        fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      var toLine, toNode;\n      if (toIndex == display.view.length - 1) {\n        toLine = display.viewTo - 1;\n        toNode = display.lineDiv.lastChild;\n      } else {\n        toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n      if (!fromNode) {\n        return false;\n      }\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine2(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) {\n          newText.pop();\n          oldText.pop();\n          toLine--;\n        } else if (newText[0] == oldText[0]) {\n          newText.shift();\n          oldText.shift();\n          fromLine++;\n        } else {\n          break;\n        }\n      }\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {\n        ++cutFront;\n      }\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        ++cutEnd;\n      }\n      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n          cutFront--;\n          cutEnd++;\n        }\n      }\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n      newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n        return true;\n      }\n    };\n    ContentEditableInput.prototype.ensurePolled = function() {\n      this.forceCompositionEnd();\n    };\n    ContentEditableInput.prototype.reset = function() {\n      this.forceCompositionEnd();\n    };\n    ContentEditableInput.prototype.forceCompositionEnd = function() {\n      if (!this.composing) {\n        return;\n      }\n      clearTimeout(this.readDOMTimeout);\n      this.composing = null;\n      this.updateFromDOM();\n      this.div.blur();\n      this.div.focus();\n    };\n    ContentEditableInput.prototype.readFromDOMSoon = function() {\n      var this$1$1 = this;\n      if (this.readDOMTimeout != null) {\n        return;\n      }\n      this.readDOMTimeout = setTimeout(function() {\n        this$1$1.readDOMTimeout = null;\n        if (this$1$1.composing) {\n          if (this$1$1.composing.done) {\n            this$1$1.composing = null;\n          } else {\n            return;\n          }\n        }\n        this$1$1.updateFromDOM();\n      }, 80);\n    };\n    ContentEditableInput.prototype.updateFromDOM = function() {\n      var this$1$1 = this;\n      if (this.cm.isReadOnly() || !this.pollContent()) {\n        runInOp(this.cm, function() {\n          return regChange(this$1$1.cm);\n        });\n      }\n    };\n    ContentEditableInput.prototype.setUneditable = function(node) {\n      node.contentEditable = \"false\";\n    };\n    ContentEditableInput.prototype.onKeyPress = function(e) {\n      if (e.charCode == 0 || this.composing) {\n        return;\n      }\n      e.preventDefault();\n      if (!this.cm.isReadOnly()) {\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n      }\n    };\n    ContentEditableInput.prototype.readOnlyChanged = function(val) {\n      this.div.contentEditable = String(val != \"nocursor\");\n    };\n    ContentEditableInput.prototype.onContextMenu = function() {\n    };\n    ContentEditableInput.prototype.resetPosition = function() {\n    };\n    ContentEditableInput.prototype.needsContentAttribute = true;\n    function posToDOM(cm, pos) {\n      var view = findViewForLine(cm, pos.line);\n      if (!view || view.hidden) {\n        return null;\n      }\n      var line = getLine2(cm.doc, pos.line);\n      var info2 = mapFromLineView(view, line, pos.line);\n      var order2 = getOrder(line, cm.doc.direction), side = \"left\";\n      if (order2) {\n        var partPos = getBidiPartAt(order2, pos.ch);\n        side = partPos % 2 ? \"right\" : \"left\";\n      }\n      var result2 = nodeAndOffsetInLineMap(info2.map, pos.ch, side);\n      result2.offset = result2.collapse == \"right\" ? result2.end : result2.start;\n      return result2;\n    }\n    function isInGutter(node) {\n      for (var scan = node; scan; scan = scan.parentNode) {\n        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function badPos(pos, bad) {\n      if (bad) {\n        pos.bad = true;\n      }\n      return pos;\n    }\n    function domTextBetween(cm, from, to, fromLine, toLine) {\n      var text3 = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n      function recognizeMarker(id2) {\n        return function(marker2) {\n          return marker2.id == id2;\n        };\n      }\n      function close() {\n        if (closing) {\n          text3 += lineSep;\n          if (extraLinebreak) {\n            text3 += lineSep;\n          }\n          closing = extraLinebreak = false;\n        }\n      }\n      function addText(str) {\n        if (str) {\n          close();\n          text3 += str;\n        }\n      }\n      function walk(node) {\n        if (node.nodeType == 1) {\n          var cmText = node.getAttribute(\"cm-text\");\n          if (cmText) {\n            addText(cmText);\n            return;\n          }\n          var markerID = node.getAttribute(\"cm-marker\"), range3;\n          if (markerID) {\n            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n            if (found.length && (range3 = found[0].find(0))) {\n              addText(getBetween(cm.doc, range3.from, range3.to).join(lineSep));\n            }\n            return;\n          }\n          if (node.getAttribute(\"contenteditable\") == \"false\") {\n            return;\n          }\n          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n            return;\n          }\n          if (isBlock) {\n            close();\n          }\n          for (var i2 = 0; i2 < node.childNodes.length; i2++) {\n            walk(node.childNodes[i2]);\n          }\n          if (/^(pre|p)$/i.test(node.nodeName)) {\n            extraLinebreak = true;\n          }\n          if (isBlock) {\n            closing = true;\n          }\n        } else if (node.nodeType == 3) {\n          addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n        }\n      }\n      for (; ; ) {\n        walk(from);\n        if (from == to) {\n          break;\n        }\n        from = from.nextSibling;\n        extraLinebreak = false;\n      }\n      return text3;\n    }\n    function domToPos(cm, node, offset) {\n      var lineNode;\n      if (node == cm.display.lineDiv) {\n        lineNode = cm.display.lineDiv.childNodes[offset];\n        if (!lineNode) {\n          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n        }\n        node = null;\n        offset = 0;\n      } else {\n        for (lineNode = node; ; lineNode = lineNode.parentNode) {\n          if (!lineNode || lineNode == cm.display.lineDiv) {\n            return null;\n          }\n          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n            break;\n          }\n        }\n      }\n      for (var i2 = 0; i2 < cm.display.view.length; i2++) {\n        var lineView = cm.display.view[i2];\n        if (lineView.node == lineNode) {\n          return locateNodeInLineView(lineView, node, offset);\n        }\n      }\n    }\n    function locateNodeInLineView(lineView, node, offset) {\n      var wrapper = lineView.text.firstChild, bad = false;\n      if (!node || !contains(wrapper, node)) {\n        return badPos(Pos(lineNo(lineView.line), 0), true);\n      }\n      if (node == wrapper) {\n        bad = true;\n        node = wrapper.childNodes[offset];\n        offset = 0;\n        if (!node) {\n          var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n          return badPos(Pos(lineNo(line), line.text.length), bad);\n        }\n      }\n      var textNode = node.nodeType == 3 ? node : null, topNode = node;\n      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n        textNode = node.firstChild;\n        if (offset) {\n          offset = textNode.nodeValue.length;\n        }\n      }\n      while (topNode.parentNode != wrapper) {\n        topNode = topNode.parentNode;\n      }\n      var measure = lineView.measure, maps = measure.maps;\n      function find2(textNode2, topNode2, offset2) {\n        for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {\n          var map3 = i2 < 0 ? measure.map : maps[i2];\n          for (var j = 0; j < map3.length; j += 3) {\n            var curNode = map3[j + 2];\n            if (curNode == textNode2 || curNode == topNode2) {\n              var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);\n              var ch2 = map3[j] + offset2;\n              if (offset2 < 0 || curNode != textNode2) {\n                ch2 = map3[j + (offset2 ? 1 : 0)];\n              }\n              return Pos(line2, ch2);\n            }\n          }\n        }\n      }\n      var found = find2(textNode, topNode, offset);\n      if (found) {\n        return badPos(found, bad);\n      }\n      for (var after = topNode.nextSibling, dist2 = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n        found = find2(after, after.firstChild, 0);\n        if (found) {\n          return badPos(Pos(found.line, found.ch - dist2), bad);\n        } else {\n          dist2 += after.textContent.length;\n        }\n      }\n      for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n        found = find2(before, before.firstChild, -1);\n        if (found) {\n          return badPos(Pos(found.line, found.ch + dist$1), bad);\n        } else {\n          dist$1 += before.textContent.length;\n        }\n      }\n    }\n    var TextareaInput = function(cm) {\n      this.cm = cm;\n      this.prevInput = \"\";\n      this.pollingFast = false;\n      this.polling = new Delayed();\n      this.hasSelection = false;\n      this.composing = null;\n    };\n    TextareaInput.prototype.init = function(display) {\n      var this$1$1 = this;\n      var input = this, cm = this.cm;\n      this.createField(display);\n      var te2 = this.textarea;\n      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n      if (ios) {\n        te2.style.width = \"0px\";\n      }\n      on(te2, \"input\", function() {\n        if (ie2 && ie_version >= 9 && this$1$1.hasSelection) {\n          this$1$1.hasSelection = null;\n        }\n        input.poll();\n      });\n      on(te2, \"paste\", function(e) {\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n          return;\n        }\n        cm.state.pasteIncoming = +new Date();\n        input.fastPoll();\n      });\n      function prepareCopyCut(e) {\n        if (signalDOMEvent(cm, e)) {\n          return;\n        }\n        if (cm.somethingSelected()) {\n          setLastCopied({ lineWise: false, text: cm.getSelections() });\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          setLastCopied({ lineWise: true, text: ranges.text });\n          if (e.type == \"cut\") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = \"\";\n            te2.value = ranges.text.join(\"\\n\");\n            selectInput(te2);\n          }\n        }\n        if (e.type == \"cut\") {\n          cm.state.cutIncoming = +new Date();\n        }\n      }\n      on(te2, \"cut\", prepareCopyCut);\n      on(te2, \"copy\", prepareCopyCut);\n      on(display.scroller, \"paste\", function(e) {\n        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n          return;\n        }\n        if (!te2.dispatchEvent) {\n          cm.state.pasteIncoming = +new Date();\n          input.focus();\n          return;\n        }\n        var event = new Event(\"paste\");\n        event.clipboardData = e.clipboardData;\n        te2.dispatchEvent(event);\n      });\n      on(display.lineSpace, \"selectstart\", function(e) {\n        if (!eventInWidget(display, e)) {\n          e_preventDefault(e);\n        }\n      });\n      on(te2, \"compositionstart\", function() {\n        var start2 = cm.getCursor(\"from\");\n        if (input.composing) {\n          input.composing.range.clear();\n        }\n        input.composing = {\n          start: start2,\n          range: cm.markText(start2, cm.getCursor(\"to\"), { className: \"CodeMirror-composing\" })\n        };\n      });\n      on(te2, \"compositionend\", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    };\n    TextareaInput.prototype.createField = function(_display) {\n      this.wrapper = hiddenTextarea();\n      this.textarea = this.wrapper.firstChild;\n    };\n    TextareaInput.prototype.screenReaderLabelChanged = function(label) {\n      if (label) {\n        this.textarea.setAttribute(\"aria-label\", label);\n      } else {\n        this.textarea.removeAttribute(\"aria-label\");\n      }\n    };\n    TextareaInput.prototype.prepareSelection = function() {\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result2 = prepareSelection(cm);\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result2.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));\n        result2.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));\n      }\n      return result2;\n    };\n    TextareaInput.prototype.showSelection = function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + \"px\";\n        this.wrapper.style.left = drawn.teLeft + \"px\";\n      }\n    };\n    TextareaInput.prototype.reset = function(typing) {\n      if (this.contextMenuPending || this.composing) {\n        return;\n      }\n      var cm = this.cm;\n      if (cm.somethingSelected()) {\n        this.prevInput = \"\";\n        var content = cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) {\n          selectInput(this.textarea);\n        }\n        if (ie2 && ie_version >= 9) {\n          this.hasSelection = content;\n        }\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = \"\";\n        if (ie2 && ie_version >= 9) {\n          this.hasSelection = null;\n        }\n      }\n    };\n    TextareaInput.prototype.getField = function() {\n      return this.textarea;\n    };\n    TextareaInput.prototype.supportsTouch = function() {\n      return false;\n    };\n    TextareaInput.prototype.focus = function() {\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n        try {\n          this.textarea.focus();\n        } catch (e) {\n        }\n      }\n    };\n    TextareaInput.prototype.blur = function() {\n      this.textarea.blur();\n    };\n    TextareaInput.prototype.resetPosition = function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    };\n    TextareaInput.prototype.receivedFocus = function() {\n      this.slowPoll();\n    };\n    TextareaInput.prototype.slowPoll = function() {\n      var this$1$1 = this;\n      if (this.pollingFast) {\n        return;\n      }\n      this.polling.set(this.cm.options.pollInterval, function() {\n        this$1$1.poll();\n        if (this$1$1.cm.state.focused) {\n          this$1$1.slowPoll();\n        }\n      });\n    };\n    TextareaInput.prototype.fastPoll = function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p2() {\n        var changed = input.poll();\n        if (!changed && !missed) {\n          missed = true;\n          input.polling.set(60, p2);\n        } else {\n          input.pollingFast = false;\n          input.slowPoll();\n        }\n      }\n      input.polling.set(20, p2);\n    };\n    TextareaInput.prototype.poll = function() {\n      var this$1$1 = this;\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n        return false;\n      }\n      var text3 = input.value;\n      if (text3 == prevInput && !cm.somethingSelected()) {\n        return false;\n      }\n      if (ie2 && ie_version >= 9 && this.hasSelection === text3 || mac && /[\\uf700-\\uf7ff]/.test(text3)) {\n        cm.display.input.reset();\n        return false;\n      }\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text3.charCodeAt(0);\n        if (first == 8203 && !prevInput) {\n          prevInput = \"\\u200B\";\n        }\n        if (first == 8666) {\n          this.reset();\n          return this.cm.execCommand(\"undo\");\n        }\n      }\n      var same = 0, l2 = Math.min(prevInput.length, text3.length);\n      while (same < l2 && prevInput.charCodeAt(same) == text3.charCodeAt(same)) {\n        ++same;\n      }\n      runInOp(cm, function() {\n        applyTextInput(cm, text3.slice(same), prevInput.length - same, null, this$1$1.composing ? \"*compose\" : null);\n        if (text3.length > 1e3 || text3.indexOf(\"\\n\") > -1) {\n          input.value = this$1$1.prevInput = \"\";\n        } else {\n          this$1$1.prevInput = text3;\n        }\n        if (this$1$1.composing) {\n          this$1$1.composing.range.clear();\n          this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor(\"to\"), { className: \"CodeMirror-composing\" });\n        }\n      });\n      return true;\n    };\n    TextareaInput.prototype.ensurePolled = function() {\n      if (this.pollingFast && this.poll()) {\n        this.pollingFast = false;\n      }\n    };\n    TextareaInput.prototype.onKeyPress = function() {\n      if (ie2 && ie_version >= 9) {\n        this.hasSelection = null;\n      }\n      this.fastPoll();\n    };\n    TextareaInput.prototype.onContextMenu = function(e) {\n      var input = this, cm = input.cm, display = cm.display, te2 = input.textarea;\n      if (input.contextMenuPending) {\n        input.contextMenuPending();\n      }\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) {\n        return;\n      }\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1) {\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n      }\n      var oldCSS = te2.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n      input.wrapper.style.cssText = \"position: static\";\n      te2.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie2 ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      var oldScrollY;\n      if (webkit) {\n        oldScrollY = window.scrollY;\n      }\n      display.input.focus();\n      if (webkit) {\n        window.scrollTo(null, oldScrollY);\n      }\n      display.input.reset();\n      if (!cm.somethingSelected()) {\n        te2.value = input.prevInput = \" \";\n      }\n      input.contextMenuPending = rehide;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n      function prepareSelectAllHack() {\n        if (te2.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = \"\\u200B\" + (selected ? te2.value : \"\");\n          te2.value = \"\\u21DA\";\n          te2.value = extval;\n          input.prevInput = selected ? \"\" : \"\\u200B\";\n          te2.selectionStart = 1;\n          te2.selectionEnd = extval.length;\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      function rehide() {\n        if (input.contextMenuPending != rehide) {\n          return;\n        }\n        input.contextMenuPending = false;\n        input.wrapper.style.cssText = oldWrapperCSS;\n        te2.style.cssText = oldCSS;\n        if (ie2 && ie_version < 9) {\n          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n        }\n        if (te2.selectionStart != null) {\n          if (!ie2 || ie2 && ie_version < 9) {\n            prepareSelectAllHack();\n          }\n          var i2 = 0, poll = function() {\n            if (display.selForContextMenu == cm.doc.sel && te2.selectionStart == 0 && te2.selectionEnd > 0 && input.prevInput == \"\\u200B\") {\n              operation(cm, selectAll)(cm);\n            } else if (i2++ < 10) {\n              display.detectingSelectAll = setTimeout(poll, 500);\n            } else {\n              display.selForContextMenu = null;\n              display.input.reset();\n            }\n          };\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n      if (ie2 && ie_version >= 9) {\n        prepareSelectAllHack();\n      }\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = function() {\n          off(window, \"mouseup\", mouseup);\n          setTimeout(rehide, 20);\n        };\n        on(window, \"mouseup\", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    };\n    TextareaInput.prototype.readOnlyChanged = function(val) {\n      if (!val) {\n        this.reset();\n      }\n      this.textarea.disabled = val == \"nocursor\";\n      this.textarea.readOnly = !!val;\n    };\n    TextareaInput.prototype.setUneditable = function() {\n    };\n    TextareaInput.prototype.needsContentAttribute = false;\n    function fromTextArea(textarea, options) {\n      options = options ? copyObj(options) : {};\n      options.value = textarea.value;\n      if (!options.tabindex && textarea.tabIndex) {\n        options.tabindex = textarea.tabIndex;\n      }\n      if (!options.placeholder && textarea.placeholder) {\n        options.placeholder = textarea.placeholder;\n      }\n      if (options.autofocus == null) {\n        var hasFocus = activeElt();\n        options.autofocus = hasFocus == textarea || textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n      }\n      function save() {\n        textarea.value = cm.getValue();\n      }\n      var realSubmit;\n      if (textarea.form) {\n        on(textarea.form, \"submit\", save);\n        if (!options.leaveSubmitMethodAlone) {\n          var form = textarea.form;\n          realSubmit = form.submit;\n          try {\n            var wrappedSubmit = form.submit = function() {\n              save();\n              form.submit = realSubmit;\n              form.submit();\n              form.submit = wrappedSubmit;\n            };\n          } catch (e) {\n          }\n        }\n      }\n      options.finishInit = function(cm2) {\n        cm2.save = save;\n        cm2.getTextArea = function() {\n          return textarea;\n        };\n        cm2.toTextArea = function() {\n          cm2.toTextArea = isNaN;\n          save();\n          textarea.parentNode.removeChild(cm2.getWrapperElement());\n          textarea.style.display = \"\";\n          if (textarea.form) {\n            off(textarea.form, \"submit\", save);\n            if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\") {\n              textarea.form.submit = realSubmit;\n            }\n          }\n        };\n      };\n      textarea.style.display = \"none\";\n      var cm = CodeMirror(function(node) {\n        return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n      }, options);\n      return cm;\n    }\n    function addLegacyProps(CodeMirror2) {\n      CodeMirror2.off = off;\n      CodeMirror2.on = on;\n      CodeMirror2.wheelEventPixels = wheelEventPixels;\n      CodeMirror2.Doc = Doc;\n      CodeMirror2.splitLines = splitLinesAuto;\n      CodeMirror2.countColumn = countColumn;\n      CodeMirror2.findColumn = findColumn;\n      CodeMirror2.isWordChar = isWordCharBasic;\n      CodeMirror2.Pass = Pass;\n      CodeMirror2.signal = signal;\n      CodeMirror2.Line = Line;\n      CodeMirror2.changeEnd = changeEnd;\n      CodeMirror2.scrollbarModel = scrollbarModel;\n      CodeMirror2.Pos = Pos;\n      CodeMirror2.cmpPos = cmp;\n      CodeMirror2.modes = modes;\n      CodeMirror2.mimeModes = mimeModes;\n      CodeMirror2.resolveMode = resolveMode;\n      CodeMirror2.getMode = getMode;\n      CodeMirror2.modeExtensions = modeExtensions;\n      CodeMirror2.extendMode = extendMode;\n      CodeMirror2.copyState = copyState;\n      CodeMirror2.startState = startState;\n      CodeMirror2.innerMode = innerMode;\n      CodeMirror2.commands = commands;\n      CodeMirror2.keyMap = keyMap2;\n      CodeMirror2.keyName = keyName;\n      CodeMirror2.isModifierKey = isModifierKey;\n      CodeMirror2.lookupKey = lookupKey;\n      CodeMirror2.normalizeKeyMap = normalizeKeyMap;\n      CodeMirror2.StringStream = StringStream;\n      CodeMirror2.SharedTextMarker = SharedTextMarker;\n      CodeMirror2.TextMarker = TextMarker;\n      CodeMirror2.LineWidget = LineWidget;\n      CodeMirror2.e_preventDefault = e_preventDefault;\n      CodeMirror2.e_stopPropagation = e_stopPropagation;\n      CodeMirror2.e_stop = e_stop;\n      CodeMirror2.addClass = addClass;\n      CodeMirror2.contains = contains;\n      CodeMirror2.rmClass = rmClass;\n      CodeMirror2.keyNames = keyNames;\n    }\n    defineOptions(CodeMirror);\n    addEditorMethods(CodeMirror);\n    var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n    for (var prop2 in Doc.prototype) {\n      if (Doc.prototype.hasOwnProperty(prop2) && indexOf(dontDelegate, prop2) < 0) {\n        CodeMirror.prototype[prop2] = function(method) {\n          return function() {\n            return method.apply(this.doc, arguments);\n          };\n        }(Doc.prototype[prop2]);\n      }\n    }\n    eventMixin(Doc);\n    CodeMirror.inputStyles = { \"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput };\n    CodeMirror.defineMode = function(name2) {\n      if (!CodeMirror.defaults.mode && name2 != \"null\") {\n        CodeMirror.defaults.mode = name2;\n      }\n      defineMode.apply(this, arguments);\n    };\n    CodeMirror.defineMIME = defineMIME;\n    CodeMirror.defineMode(\"null\", function() {\n      return { token: function(stream) {\n        return stream.skipToEnd();\n      } };\n    });\n    CodeMirror.defineMIME(\"text/plain\", \"null\");\n    CodeMirror.defineExtension = function(name2, func) {\n      CodeMirror.prototype[name2] = func;\n    };\n    CodeMirror.defineDocExtension = function(name2, func) {\n      Doc.prototype[name2] = func;\n    };\n    CodeMirror.fromTextArea = fromTextArea;\n    addLegacyProps(CodeMirror);\n    CodeMirror.version = \"5.65.1\";\n    return CodeMirror;\n  });\n})(codemirror$2);\nvar codemirror = codemirror$2.exports;\nvar codemirror$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": codemirror\n}, [codemirror$2.exports]));\nvar showHint$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    var HINT_ELEMENT_CLASS = \"CodeMirror-hint\";\n    var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n    CodeMirror.showHint = function(cm, getHints, options) {\n      if (!getHints)\n        return cm.showHint(options);\n      if (options && options.async)\n        getHints.async = true;\n      var newOpts = { hint: getHints };\n      if (options)\n        for (var prop2 in options)\n          newOpts[prop2] = options[prop2];\n      return cm.showHint(newOpts);\n    };\n    CodeMirror.defineExtension(\"showHint\", function(options) {\n      options = parseOptions(this, this.getCursor(\"start\"), options);\n      var selections = this.listSelections();\n      if (selections.length > 1)\n        return;\n      if (this.somethingSelected()) {\n        if (!options.hint.supportsSelection)\n          return;\n        for (var i = 0; i < selections.length; i++)\n          if (selections[i].head.line != selections[i].anchor.line)\n            return;\n      }\n      if (this.state.completionActive)\n        this.state.completionActive.close();\n      var completion = this.state.completionActive = new Completion(this, options);\n      if (!completion.options.hint)\n        return;\n      CodeMirror.signal(this, \"startCompletion\", this);\n      completion.update(true);\n    });\n    CodeMirror.defineExtension(\"closeHint\", function() {\n      if (this.state.completionActive)\n        this.state.completionActive.close();\n    });\n    function Completion(cm, options) {\n      this.cm = cm;\n      this.options = options;\n      this.widget = null;\n      this.debounce = 0;\n      this.tick = 0;\n      this.startPos = this.cm.getCursor(\"start\");\n      this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n      if (this.options.updateOnCursorActivity) {\n        var self2 = this;\n        cm.on(\"cursorActivity\", this.activityFunc = function() {\n          self2.cursorActivity();\n        });\n      }\n    }\n    var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n      return setTimeout(fn, 1e3 / 60);\n    };\n    var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n    Completion.prototype = {\n      close: function() {\n        if (!this.active())\n          return;\n        this.cm.state.completionActive = null;\n        this.tick = null;\n        if (this.options.updateOnCursorActivity) {\n          this.cm.off(\"cursorActivity\", this.activityFunc);\n        }\n        if (this.widget && this.data)\n          CodeMirror.signal(this.data, \"close\");\n        if (this.widget)\n          this.widget.close();\n        CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n      },\n      active: function() {\n        return this.cm.state.completionActive == this;\n      },\n      pick: function(data, i) {\n        var completion = data.list[i], self2 = this;\n        this.cm.operation(function() {\n          if (completion.hint)\n            completion.hint(self2.cm, data, completion);\n          else\n            self2.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, \"complete\");\n          CodeMirror.signal(data, \"pick\", completion);\n          self2.cm.scrollIntoView();\n        });\n        if (this.options.closeOnPick) {\n          this.close();\n        }\n      },\n      cursorActivity: function() {\n        if (this.debounce) {\n          cancelAnimationFrame(this.debounce);\n          this.debounce = 0;\n        }\n        var identStart = this.startPos;\n        if (this.data) {\n          identStart = this.data.from;\n        }\n        var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n        if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n          this.close();\n        } else {\n          var self2 = this;\n          this.debounce = requestAnimationFrame(function() {\n            self2.update();\n          });\n          if (this.widget)\n            this.widget.disable();\n        }\n      },\n      update: function(first) {\n        if (this.tick == null)\n          return;\n        var self2 = this, myTick = ++this.tick;\n        fetchHints(this.options.hint, this.cm, this.options, function(data) {\n          if (self2.tick == myTick)\n            self2.finishUpdate(data, first);\n        });\n      },\n      finishUpdate: function(data, first) {\n        if (this.data)\n          CodeMirror.signal(this.data, \"update\");\n        var picked = this.widget && this.widget.picked || first && this.options.completeSingle;\n        if (this.widget)\n          this.widget.close();\n        this.data = data;\n        if (data && data.list.length) {\n          if (picked && data.list.length == 1) {\n            this.pick(data, 0);\n          } else {\n            this.widget = new Widget(this, data);\n            CodeMirror.signal(data, \"shown\");\n          }\n        }\n      }\n    };\n    function parseOptions(cm, pos, options) {\n      var editor = cm.options.hintOptions;\n      var out = {};\n      for (var prop2 in defaultOptions2)\n        out[prop2] = defaultOptions2[prop2];\n      if (editor) {\n        for (var prop2 in editor)\n          if (editor[prop2] !== void 0)\n            out[prop2] = editor[prop2];\n      }\n      if (options) {\n        for (var prop2 in options)\n          if (options[prop2] !== void 0)\n            out[prop2] = options[prop2];\n      }\n      if (out.hint.resolve)\n        out.hint = out.hint.resolve(cm, pos);\n      return out;\n    }\n    function getText(completion) {\n      if (typeof completion == \"string\")\n        return completion;\n      else\n        return completion.text;\n    }\n    function buildKeyMap(completion, handle) {\n      var baseMap = {\n        Up: function() {\n          handle.moveFocus(-1);\n        },\n        Down: function() {\n          handle.moveFocus(1);\n        },\n        PageUp: function() {\n          handle.moveFocus(-handle.menuSize() + 1, true);\n        },\n        PageDown: function() {\n          handle.moveFocus(handle.menuSize() - 1, true);\n        },\n        Home: function() {\n          handle.setFocus(0);\n        },\n        End: function() {\n          handle.setFocus(handle.length - 1);\n        },\n        Enter: handle.pick,\n        Tab: handle.pick,\n        Esc: handle.close\n      };\n      var mac = /Mac/.test(navigator.platform);\n      if (mac) {\n        baseMap[\"Ctrl-P\"] = function() {\n          handle.moveFocus(-1);\n        };\n        baseMap[\"Ctrl-N\"] = function() {\n          handle.moveFocus(1);\n        };\n      }\n      var custom = completion.options.customKeys;\n      var ourMap = custom ? {} : baseMap;\n      function addBinding(key2, val) {\n        var bound;\n        if (typeof val != \"string\")\n          bound = function(cm) {\n            return val(cm, handle);\n          };\n        else if (baseMap.hasOwnProperty(val))\n          bound = baseMap[val];\n        else\n          bound = val;\n        ourMap[key2] = bound;\n      }\n      if (custom) {\n        for (var key in custom)\n          if (custom.hasOwnProperty(key))\n            addBinding(key, custom[key]);\n      }\n      var extra = completion.options.extraKeys;\n      if (extra) {\n        for (var key in extra)\n          if (extra.hasOwnProperty(key))\n            addBinding(key, extra[key]);\n      }\n      return ourMap;\n    }\n    function getHintElement(hintsElement, el2) {\n      while (el2 && el2 != hintsElement) {\n        if (el2.nodeName.toUpperCase() === \"LI\" && el2.parentNode == hintsElement)\n          return el2;\n        el2 = el2.parentNode;\n      }\n    }\n    function Widget(completion, data) {\n      this.id = \"cm-complete-\" + Math.floor(Math.random(1e6));\n      this.completion = completion;\n      this.data = data;\n      this.picked = false;\n      var widget = this, cm = completion.cm;\n      var ownerDocument = cm.getInputField().ownerDocument;\n      var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n      var hints = this.hints = ownerDocument.createElement(\"ul\");\n      hints.setAttribute(\"role\", \"listbox\");\n      hints.setAttribute(\"aria-expanded\", \"true\");\n      hints.id = this.id;\n      var theme = completion.cm.options.theme;\n      hints.className = \"CodeMirror-hints \" + theme;\n      this.selectedHint = data.selectedHint || 0;\n      var completions = data.list;\n      for (var i = 0; i < completions.length; ++i) {\n        var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n        var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n        if (cur.className != null)\n          className = cur.className + \" \" + className;\n        elt.className = className;\n        if (i == this.selectedHint)\n          elt.setAttribute(\"aria-selected\", \"true\");\n        elt.id = this.id + \"-\" + i;\n        elt.setAttribute(\"role\", \"option\");\n        if (cur.render)\n          cur.render(elt, data, cur);\n        else\n          elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n        elt.hintId = i;\n      }\n      var container = completion.options.container || ownerDocument.body;\n      var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n      var left = pos.left, top2 = pos.bottom, below = true;\n      var offsetLeft = 0, offsetTop = 0;\n      if (container !== ownerDocument.body) {\n        var isContainerPositioned = [\"absolute\", \"relative\", \"fixed\"].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n        var offsetParent = isContainerPositioned ? container : container.offsetParent;\n        var offsetParentPosition = offsetParent.getBoundingClientRect();\n        var bodyPosition = ownerDocument.body.getBoundingClientRect();\n        offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;\n        offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;\n      }\n      hints.style.left = left - offsetLeft + \"px\";\n      hints.style.top = top2 - offsetTop + \"px\";\n      var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n      var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n      container.appendChild(hints);\n      cm.getInputField().setAttribute(\"aria-autocomplete\", \"list\");\n      cm.getInputField().setAttribute(\"aria-owns\", this.id);\n      cm.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint);\n      var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n      var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n      var startScroll;\n      setTimeout(function() {\n        startScroll = cm.getScrollInfo();\n      });\n      var overlapY = box.bottom - winH;\n      if (overlapY > 0) {\n        var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);\n        if (curTop - height > 0) {\n          hints.style.top = (top2 = pos.top - height - offsetTop) + \"px\";\n          below = false;\n        } else if (height > winH) {\n          hints.style.height = winH - 5 + \"px\";\n          hints.style.top = (top2 = pos.bottom - box.top - offsetTop) + \"px\";\n          var cursor = cm.getCursor();\n          if (data.from.ch != cursor.ch) {\n            pos = cm.cursorCoords(cursor);\n            hints.style.left = (left = pos.left - offsetLeft) + \"px\";\n            box = hints.getBoundingClientRect();\n          }\n        }\n      }\n      var overlapX = box.right - winW;\n      if (scrolls)\n        overlapX += cm.display.nativeBarWidth;\n      if (overlapX > 0) {\n        if (box.right - box.left > winW) {\n          hints.style.width = winW - 5 + \"px\";\n          overlapX -= box.right - box.left - winW;\n        }\n        hints.style.left = (left = pos.left - overlapX - offsetLeft) + \"px\";\n      }\n      if (scrolls)\n        for (var node = hints.firstChild; node; node = node.nextSibling)\n          node.style.paddingRight = cm.display.nativeBarWidth + \"px\";\n      cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n        moveFocus: function(n2, avoidWrap) {\n          widget.changeActive(widget.selectedHint + n2, avoidWrap);\n        },\n        setFocus: function(n2) {\n          widget.changeActive(n2);\n        },\n        menuSize: function() {\n          return widget.screenAmount();\n        },\n        length: completions.length,\n        close: function() {\n          completion.close();\n        },\n        pick: function() {\n          widget.pick();\n        },\n        data\n      }));\n      if (completion.options.closeOnUnfocus) {\n        var closingOnBlur;\n        cm.on(\"blur\", this.onBlur = function() {\n          closingOnBlur = setTimeout(function() {\n            completion.close();\n          }, 100);\n        });\n        cm.on(\"focus\", this.onFocus = function() {\n          clearTimeout(closingOnBlur);\n        });\n      }\n      cm.on(\"scroll\", this.onScroll = function() {\n        var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n        if (!startScroll)\n          startScroll = cm.getScrollInfo();\n        var newTop = top2 + startScroll.top - curScroll.top;\n        var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n        if (!below)\n          point += hints.offsetHeight;\n        if (point <= editor.top || point >= editor.bottom)\n          return completion.close();\n        hints.style.top = newTop + \"px\";\n        hints.style.left = left + startScroll.left - curScroll.left + \"px\";\n      });\n      CodeMirror.on(hints, \"dblclick\", function(e) {\n        var t2 = getHintElement(hints, e.target || e.srcElement);\n        if (t2 && t2.hintId != null) {\n          widget.changeActive(t2.hintId);\n          widget.pick();\n        }\n      });\n      CodeMirror.on(hints, \"click\", function(e) {\n        var t2 = getHintElement(hints, e.target || e.srcElement);\n        if (t2 && t2.hintId != null) {\n          widget.changeActive(t2.hintId);\n          if (completion.options.completeOnSingleClick)\n            widget.pick();\n        }\n      });\n      CodeMirror.on(hints, \"mousedown\", function() {\n        setTimeout(function() {\n          cm.focus();\n        }, 20);\n      });\n      var selectedHintRange = this.getSelectedHintRange();\n      if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n        this.scrollToActive();\n      }\n      CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n      return true;\n    }\n    Widget.prototype = {\n      close: function() {\n        if (this.completion.widget != this)\n          return;\n        this.completion.widget = null;\n        if (this.hints.parentNode)\n          this.hints.parentNode.removeChild(this.hints);\n        this.completion.cm.removeKeyMap(this.keyMap);\n        var input = this.completion.cm.getInputField();\n        input.removeAttribute(\"aria-activedescendant\");\n        input.removeAttribute(\"aria-owns\");\n        var cm = this.completion.cm;\n        if (this.completion.options.closeOnUnfocus) {\n          cm.off(\"blur\", this.onBlur);\n          cm.off(\"focus\", this.onFocus);\n        }\n        cm.off(\"scroll\", this.onScroll);\n      },\n      disable: function() {\n        this.completion.cm.removeKeyMap(this.keyMap);\n        var widget = this;\n        this.keyMap = { Enter: function() {\n          widget.picked = true;\n        } };\n        this.completion.cm.addKeyMap(this.keyMap);\n      },\n      pick: function() {\n        this.completion.pick(this.data, this.selectedHint);\n      },\n      changeActive: function(i, avoidWrap) {\n        if (i >= this.data.list.length)\n          i = avoidWrap ? this.data.list.length - 1 : 0;\n        else if (i < 0)\n          i = avoidWrap ? 0 : this.data.list.length - 1;\n        if (this.selectedHint == i)\n          return;\n        var node = this.hints.childNodes[this.selectedHint];\n        if (node) {\n          node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n          node.removeAttribute(\"aria-selected\");\n        }\n        node = this.hints.childNodes[this.selectedHint = i];\n        node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n        node.setAttribute(\"aria-selected\", \"true\");\n        this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", node.id);\n        this.scrollToActive();\n        CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n      },\n      scrollToActive: function() {\n        var selectedHintRange = this.getSelectedHintRange();\n        var node1 = this.hints.childNodes[selectedHintRange.from];\n        var node2 = this.hints.childNodes[selectedHintRange.to];\n        var firstNode = this.hints.firstChild;\n        if (node1.offsetTop < this.hints.scrollTop)\n          this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n        else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n          this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n      },\n      screenAmount: function() {\n        return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n      },\n      getSelectedHintRange: function() {\n        var margin = this.completion.options.scrollMargin || 0;\n        return {\n          from: Math.max(0, this.selectedHint - margin),\n          to: Math.min(this.data.list.length - 1, this.selectedHint + margin)\n        };\n      }\n    };\n    function applicableHelpers(cm, helpers2) {\n      if (!cm.somethingSelected())\n        return helpers2;\n      var result2 = [];\n      for (var i = 0; i < helpers2.length; i++)\n        if (helpers2[i].supportsSelection)\n          result2.push(helpers2[i]);\n      return result2;\n    }\n    function fetchHints(hint2, cm, options, callback) {\n      if (hint2.async) {\n        hint2(cm, callback, options);\n      } else {\n        var result2 = hint2(cm, options);\n        if (result2 && result2.then)\n          result2.then(callback);\n        else\n          callback(result2);\n      }\n    }\n    function resolveAutoHints(cm, pos) {\n      var helpers2 = cm.getHelpers(pos, \"hint\"), words;\n      if (helpers2.length) {\n        var resolved = function(cm2, callback, options) {\n          var app = applicableHelpers(cm2, helpers2);\n          function run(i) {\n            if (i == app.length)\n              return callback(null);\n            fetchHints(app[i], cm2, options, function(result2) {\n              if (result2 && result2.list.length > 0)\n                callback(result2);\n              else\n                run(i + 1);\n            });\n          }\n          run(0);\n        };\n        resolved.async = true;\n        resolved.supportsSelection = true;\n        return resolved;\n      } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n        return function(cm2) {\n          return CodeMirror.hint.fromList(cm2, { words });\n        };\n      } else if (CodeMirror.hint.anyword) {\n        return function(cm2, options) {\n          return CodeMirror.hint.anyword(cm2, options);\n        };\n      } else {\n        return function() {\n        };\n      }\n    }\n    CodeMirror.registerHelper(\"hint\", \"auto\", {\n      resolve: resolveAutoHints\n    });\n    CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n      var cur = cm.getCursor(), token2 = cm.getTokenAt(cur);\n      var term, from = CodeMirror.Pos(cur.line, token2.start), to = cur;\n      if (token2.start < cur.ch && /\\w/.test(token2.string.charAt(cur.ch - token2.start - 1))) {\n        term = token2.string.substr(0, cur.ch - token2.start);\n      } else {\n        term = \"\";\n        from = cur;\n      }\n      var found = [];\n      for (var i = 0; i < options.words.length; i++) {\n        var word2 = options.words[i];\n        if (word2.slice(0, term.length) == term)\n          found.push(word2);\n      }\n      if (found.length)\n        return { list: found, from, to };\n    });\n    CodeMirror.commands.autocomplete = CodeMirror.showHint;\n    var defaultOptions2 = {\n      hint: CodeMirror.hint.auto,\n      completeSingle: true,\n      alignWithWord: true,\n      closeCharacters: /[\\s()\\[\\]{};:>,]/,\n      closeOnPick: true,\n      closeOnUnfocus: true,\n      updateOnCursorActivity: true,\n      completeOnSingleClick: true,\n      container: null,\n      customKeys: null,\n      extraKeys: null,\n      paddingForScrollbar: true,\n      moveOnOverlap: true\n    };\n    CodeMirror.defineOption(\"hintOptions\", null);\n  });\n})();\nvar showHint = showHint$2.exports;\nvar showHint$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": showHint\n}, [showHint$2.exports]));\nvar matchbrackets$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);\n    var Pos = CodeMirror.Pos;\n    var matching = { \"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\" };\n    function bracketRegex(config2) {\n      return config2 && config2.bracketRegex || /[(){}[\\]]/;\n    }\n    function findMatchingBracket(cm, where, config2) {\n      var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n      var afterCursor = config2 && config2.afterCursor;\n      if (afterCursor == null)\n        afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);\n      var re2 = bracketRegex(config2);\n      var match2 = !afterCursor && pos >= 0 && re2.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re2.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n      if (!match2)\n        return null;\n      var dir = match2.charAt(1) == \">\" ? 1 : -1;\n      if (config2 && config2.strict && dir > 0 != (pos == where.ch))\n        return null;\n      var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n      var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config2);\n      if (found == null)\n        return null;\n      return {\n        from: Pos(where.line, pos),\n        to: found && found.pos,\n        match: found && found.ch == match2.charAt(0),\n        forward: dir > 0\n      };\n    }\n    function scanForBracket(cm, where, dir, style, config2) {\n      var maxScanLen = config2 && config2.maxScanLineLength || 1e4;\n      var maxScanLines = config2 && config2.maxScanLines || 1e3;\n      var stack = [];\n      var re2 = bracketRegex(config2);\n      var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n      for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n          continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end2 = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n          continue;\n        if (lineNo == where.line)\n          pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end2; pos += dir) {\n          var ch2 = line.charAt(pos);\n          if (re2.test(ch2) && (style === void 0 || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n            var match2 = matching[ch2];\n            if (match2 && match2.charAt(1) == \">\" == dir > 0)\n              stack.push(ch2);\n            else if (!stack.length)\n              return { pos: Pos(lineNo, pos), ch: ch2 };\n            else\n              stack.pop();\n          }\n        }\n      }\n      return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n    }\n    function matchBrackets(cm, autoclear, config2) {\n      var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config2 && config2.highlightNonMatching;\n      var marks = [], ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var match2 = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config2);\n        if (match2 && (match2.match || highlightNonMatching !== false) && cm.getLine(match2.from.line).length <= maxHighlightLen) {\n          var style = match2.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n          marks.push(cm.markText(match2.from, Pos(match2.from.line, match2.from.ch + 1), { className: style }));\n          if (match2.to && cm.getLine(match2.to.line).length <= maxHighlightLen)\n            marks.push(cm.markText(match2.to, Pos(match2.to.line, match2.to.ch + 1), { className: style }));\n        }\n      }\n      if (marks.length) {\n        if (ie_lt8 && cm.state.focused)\n          cm.focus();\n        var clear = function() {\n          cm.operation(function() {\n            for (var i2 = 0; i2 < marks.length; i2++)\n              marks[i2].clear();\n          });\n        };\n        if (autoclear)\n          setTimeout(clear, 800);\n        else\n          return clear;\n      }\n    }\n    function doMatchBrackets(cm) {\n      cm.operation(function() {\n        if (cm.state.matchBrackets.currentlyHighlighted) {\n          cm.state.matchBrackets.currentlyHighlighted();\n          cm.state.matchBrackets.currentlyHighlighted = null;\n        }\n        cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n      });\n    }\n    function clearHighlighted(cm) {\n      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n    }\n    CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.off(\"cursorActivity\", doMatchBrackets);\n        cm.off(\"focus\", doMatchBrackets);\n        cm.off(\"blur\", clearHighlighted);\n        clearHighlighted(cm);\n      }\n      if (val) {\n        cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n        cm.on(\"cursorActivity\", doMatchBrackets);\n        cm.on(\"focus\", doMatchBrackets);\n        cm.on(\"blur\", clearHighlighted);\n      }\n    });\n    CodeMirror.defineExtension(\"matchBrackets\", function() {\n      matchBrackets(this, true);\n    });\n    CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config2, oldConfig) {\n      if (oldConfig || typeof config2 == \"boolean\") {\n        if (!oldConfig) {\n          config2 = config2 ? { strict: true } : null;\n        } else {\n          oldConfig.strict = config2;\n          config2 = oldConfig;\n        }\n      }\n      return findMatchingBracket(this, pos, config2);\n    });\n    CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config2) {\n      return scanForBracket(this, pos, dir, style, config2);\n    });\n  });\n})();\nvar matchbrackets = matchbrackets$2.exports;\nvar matchbrackets$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": matchbrackets\n}, [matchbrackets$2.exports]));\nvar closebrackets$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    var defaults2 = {\n      pairs: `()[]{}''\"\"`,\n      closeBefore: `)]}'\":;>`,\n      triples: \"\",\n      explode: \"[]{}\"\n    };\n    var Pos = CodeMirror.Pos;\n    CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.removeKeyMap(keyMap2);\n        cm.state.closeBrackets = null;\n      }\n      if (val) {\n        ensureBound(getOption(val, \"pairs\"));\n        cm.state.closeBrackets = val;\n        cm.addKeyMap(keyMap2);\n      }\n    });\n    function getOption(conf, name2) {\n      if (name2 == \"pairs\" && typeof conf == \"string\")\n        return conf;\n      if (typeof conf == \"object\" && conf[name2] != null)\n        return conf[name2];\n      return defaults2[name2];\n    }\n    var keyMap2 = { Backspace: handleBackspace, Enter: handleEnter };\n    function ensureBound(chars) {\n      for (var i = 0; i < chars.length; i++) {\n        var ch2 = chars.charAt(i), key = \"'\" + ch2 + \"'\";\n        if (!keyMap2[key])\n          keyMap2[key] = handler(ch2);\n      }\n    }\n    ensureBound(defaults2.pairs + \"`\");\n    function handler(ch2) {\n      return function(cm) {\n        return handleChar(cm, ch2);\n      };\n    }\n    function getConfig(cm) {\n      var deflt = cm.state.closeBrackets;\n      if (!deflt || deflt.override)\n        return deflt;\n      var mode2 = cm.getModeAt(cm.getCursor());\n      return mode2.closeBrackets || deflt;\n    }\n    function handleBackspace(cm) {\n      var conf = getConfig(cm);\n      if (!conf || cm.getOption(\"disableInput\"))\n        return CodeMirror.Pass;\n      var pairs = getOption(conf, \"pairs\");\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty())\n          return CodeMirror.Pass;\n        var around = charsAround(cm, ranges[i].head);\n        if (!around || pairs.indexOf(around) % 2 != 0)\n          return CodeMirror.Pass;\n      }\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var cur = ranges[i].head;\n        cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), \"+delete\");\n      }\n    }\n    function handleEnter(cm) {\n      var conf = getConfig(cm);\n      var explode = conf && getOption(conf, \"explode\");\n      if (!explode || cm.getOption(\"disableInput\"))\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty())\n          return CodeMirror.Pass;\n        var around = charsAround(cm, ranges[i].head);\n        if (!around || explode.indexOf(around) % 2 != 0)\n          return CodeMirror.Pass;\n      }\n      cm.operation(function() {\n        var linesep = cm.lineSeparator() || \"\\n\";\n        cm.replaceSelection(linesep + linesep, null);\n        moveSel(cm, -1);\n        ranges = cm.listSelections();\n        for (var i2 = 0; i2 < ranges.length; i2++) {\n          var line = ranges[i2].head.line;\n          cm.indentLine(line, null, true);\n          cm.indentLine(line + 1, null, true);\n        }\n      });\n    }\n    function moveSel(cm, dir) {\n      var newRanges = [], ranges = cm.listSelections(), primary = 0;\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i];\n        if (range2.head == cm.getCursor())\n          primary = i;\n        var pos = range2.head.ch || dir > 0 ? { line: range2.head.line, ch: range2.head.ch + dir } : { line: range2.head.line - 1 };\n        newRanges.push({ anchor: pos, head: pos });\n      }\n      cm.setSelections(newRanges, primary);\n    }\n    function contractSelection(sel) {\n      var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n      return {\n        anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n        head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))\n      };\n    }\n    function handleChar(cm, ch2) {\n      var conf = getConfig(cm);\n      if (!conf || cm.getOption(\"disableInput\"))\n        return CodeMirror.Pass;\n      var pairs = getOption(conf, \"pairs\");\n      var pos = pairs.indexOf(ch2);\n      if (pos == -1)\n        return CodeMirror.Pass;\n      var closeBefore = getOption(conf, \"closeBefore\");\n      var triples = getOption(conf, \"triples\");\n      var identical2 = pairs.charAt(pos + 1) == ch2;\n      var ranges = cm.listSelections();\n      var opening = pos % 2 == 0;\n      var type2;\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i], cur = range2.head, curType;\n        var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n        if (opening && !range2.empty()) {\n          curType = \"surround\";\n        } else if ((identical2 || !opening) && next == ch2) {\n          if (identical2 && stringStartsAfter(cm, cur))\n            curType = \"both\";\n          else if (triples.indexOf(ch2) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch2 + ch2 + ch2)\n            curType = \"skipThree\";\n          else\n            curType = \"skip\";\n        } else if (identical2 && cur.ch > 1 && triples.indexOf(ch2) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch2 + ch2) {\n          if (cur.ch > 2 && /\\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2))))\n            return CodeMirror.Pass;\n          curType = \"addFour\";\n        } else if (identical2) {\n          var prev = cur.ch == 0 ? \" \" : cm.getRange(Pos(cur.line, cur.ch - 1), cur);\n          if (!CodeMirror.isWordChar(next) && prev != ch2 && !CodeMirror.isWordChar(prev))\n            curType = \"both\";\n          else\n            return CodeMirror.Pass;\n        } else if (opening && (next.length === 0 || /\\s/.test(next) || closeBefore.indexOf(next) > -1)) {\n          curType = \"both\";\n        } else {\n          return CodeMirror.Pass;\n        }\n        if (!type2)\n          type2 = curType;\n        else if (type2 != curType)\n          return CodeMirror.Pass;\n      }\n      var left = pos % 2 ? pairs.charAt(pos - 1) : ch2;\n      var right = pos % 2 ? ch2 : pairs.charAt(pos + 1);\n      cm.operation(function() {\n        if (type2 == \"skip\") {\n          moveSel(cm, 1);\n        } else if (type2 == \"skipThree\") {\n          moveSel(cm, 3);\n        } else if (type2 == \"surround\") {\n          var sels = cm.getSelections();\n          for (var i2 = 0; i2 < sels.length; i2++)\n            sels[i2] = left + sels[i2] + right;\n          cm.replaceSelections(sels, \"around\");\n          sels = cm.listSelections().slice();\n          for (var i2 = 0; i2 < sels.length; i2++)\n            sels[i2] = contractSelection(sels[i2]);\n          cm.setSelections(sels);\n        } else if (type2 == \"both\") {\n          cm.replaceSelection(left + right, null);\n          cm.triggerElectric(left + right);\n          moveSel(cm, -1);\n        } else if (type2 == \"addFour\") {\n          cm.replaceSelection(left + left + left + left, \"before\");\n          moveSel(cm, 1);\n        }\n      });\n    }\n    function charsAround(cm, pos) {\n      var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));\n      return str.length == 2 ? str : null;\n    }\n    function stringStartsAfter(cm, pos) {\n      var token2 = cm.getTokenAt(Pos(pos.line, pos.ch + 1));\n      return /\\bstring/.test(token2.type) && token2.start == pos.ch && (pos.ch == 0 || !/\\bstring/.test(cm.getTokenTypeAt(pos)));\n    }\n  });\n})();\nvar closebrackets = closebrackets$2.exports;\nvar closebrackets$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": closebrackets\n}, [closebrackets$2.exports]));\nvar braceFold$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    function bracketFolding(pairs) {\n      return function(cm, start2) {\n        var line = start2.line, lineText = cm.getLine(line);\n        function findOpening(pair) {\n          var tokenType;\n          for (var at = start2.ch, pass = 0; ; ) {\n            var found2 = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);\n            if (found2 == -1) {\n              if (pass == 1)\n                break;\n              pass = 1;\n              at = lineText.length;\n              continue;\n            }\n            if (pass == 1 && found2 < start2.ch)\n              break;\n            tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found2 + 1));\n            if (!/^(comment|string)/.test(tokenType))\n              return { ch: found2 + 1, tokenType, pair };\n            at = found2 - 1;\n          }\n        }\n        function findRange(found2) {\n          var count = 1, lastLine = cm.lastLine(), end2, startCh = found2.ch, endCh;\n          outer:\n            for (var i2 = line; i2 <= lastLine; ++i2) {\n              var text3 = cm.getLine(i2), pos = i2 == line ? startCh : 0;\n              for (; ; ) {\n                var nextOpen = text3.indexOf(found2.pair[0], pos), nextClose = text3.indexOf(found2.pair[1], pos);\n                if (nextOpen < 0)\n                  nextOpen = text3.length;\n                if (nextClose < 0)\n                  nextClose = text3.length;\n                pos = Math.min(nextOpen, nextClose);\n                if (pos == text3.length)\n                  break;\n                if (cm.getTokenTypeAt(CodeMirror.Pos(i2, pos + 1)) == found2.tokenType) {\n                  if (pos == nextOpen)\n                    ++count;\n                  else if (!--count) {\n                    end2 = i2;\n                    endCh = pos;\n                    break outer;\n                  }\n                }\n                ++pos;\n              }\n            }\n          if (end2 == null || line == end2)\n            return null;\n          return {\n            from: CodeMirror.Pos(line, startCh),\n            to: CodeMirror.Pos(end2, endCh)\n          };\n        }\n        var found = [];\n        for (var i = 0; i < pairs.length; i++) {\n          var open = findOpening(pairs[i]);\n          if (open)\n            found.push(open);\n        }\n        found.sort(function(a, b) {\n          return a.ch - b.ch;\n        });\n        for (var i = 0; i < found.length; i++) {\n          var range2 = findRange(found[i]);\n          if (range2)\n            return range2;\n        }\n        return null;\n      };\n    }\n    CodeMirror.registerHelper(\"fold\", \"brace\", bracketFolding([[\"{\", \"}\"], [\"[\", \"]\"]]));\n    CodeMirror.registerHelper(\"fold\", \"brace-paren\", bracketFolding([[\"{\", \"}\"], [\"[\", \"]\"], [\"(\", \")\"]]));\n    CodeMirror.registerHelper(\"fold\", \"import\", function(cm, start2) {\n      function hasImport(line) {\n        if (line < cm.firstLine() || line > cm.lastLine())\n          return null;\n        var start3 = cm.getTokenAt(CodeMirror.Pos(line, 1));\n        if (!/\\S/.test(start3.string))\n          start3 = cm.getTokenAt(CodeMirror.Pos(line, start3.end + 1));\n        if (start3.type != \"keyword\" || start3.string != \"import\")\n          return null;\n        for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n          var text3 = cm.getLine(i), semi2 = text3.indexOf(\";\");\n          if (semi2 != -1)\n            return { startCh: start3.end, end: CodeMirror.Pos(i, semi2) };\n        }\n      }\n      var startLine = start2.line, has2 = hasImport(startLine), prev;\n      if (!has2 || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)\n        return null;\n      for (var end2 = has2.end; ; ) {\n        var next = hasImport(end2.line + 1);\n        if (next == null)\n          break;\n        end2 = next.end;\n      }\n      return { from: cm.clipPos(CodeMirror.Pos(startLine, has2.startCh + 1)), to: end2 };\n    });\n    CodeMirror.registerHelper(\"fold\", \"include\", function(cm, start2) {\n      function hasInclude(line) {\n        if (line < cm.firstLine() || line > cm.lastLine())\n          return null;\n        var start3 = cm.getTokenAt(CodeMirror.Pos(line, 1));\n        if (!/\\S/.test(start3.string))\n          start3 = cm.getTokenAt(CodeMirror.Pos(line, start3.end + 1));\n        if (start3.type == \"meta\" && start3.string.slice(0, 8) == \"#include\")\n          return start3.start + 8;\n      }\n      var startLine = start2.line, has2 = hasInclude(startLine);\n      if (has2 == null || hasInclude(startLine - 1) != null)\n        return null;\n      for (var end2 = startLine; ; ) {\n        var next = hasInclude(end2 + 1);\n        if (next == null)\n          break;\n        ++end2;\n      }\n      return {\n        from: CodeMirror.Pos(startLine, has2 + 1),\n        to: cm.clipPos(CodeMirror.Pos(end2))\n      };\n    });\n  });\n})();\nvar braceFold = braceFold$2.exports;\nvar braceFold$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": braceFold\n}, [braceFold$2.exports]));\nvar foldgutter$2 = { exports: {} };\nvar foldcode = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    function doFold(cm, pos, options, force) {\n      if (options && options.call) {\n        var finder = options;\n        options = null;\n      } else {\n        var finder = getOption(cm, options, \"rangeFinder\");\n      }\n      if (typeof pos == \"number\")\n        pos = CodeMirror.Pos(pos, 0);\n      var minSize = getOption(cm, options, \"minFoldSize\");\n      function getRange2(allowFolded) {\n        var range3 = finder(cm, pos);\n        if (!range3 || range3.to.line - range3.from.line < minSize)\n          return null;\n        if (force === \"fold\")\n          return range3;\n        var marks = cm.findMarksAt(range3.from);\n        for (var i = 0; i < marks.length; ++i) {\n          if (marks[i].__isFold) {\n            if (!allowFolded)\n              return null;\n            range3.cleared = true;\n            marks[i].clear();\n          }\n        }\n        return range3;\n      }\n      var range2 = getRange2(true);\n      if (getOption(cm, options, \"scanUp\"))\n        while (!range2 && pos.line > cm.firstLine()) {\n          pos = CodeMirror.Pos(pos.line - 1, 0);\n          range2 = getRange2(false);\n        }\n      if (!range2 || range2.cleared || force === \"unfold\")\n        return;\n      var myWidget = makeWidget(cm, options, range2);\n      CodeMirror.on(myWidget, \"mousedown\", function(e) {\n        myRange.clear();\n        CodeMirror.e_preventDefault(e);\n      });\n      var myRange = cm.markText(range2.from, range2.to, {\n        replacedWith: myWidget,\n        clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n        __isFold: true\n      });\n      myRange.on(\"clear\", function(from, to) {\n        CodeMirror.signal(cm, \"unfold\", cm, from, to);\n      });\n      CodeMirror.signal(cm, \"fold\", cm, range2.from, range2.to);\n    }\n    function makeWidget(cm, options, range2) {\n      var widget = getOption(cm, options, \"widget\");\n      if (typeof widget == \"function\") {\n        widget = widget(range2.from, range2.to);\n      }\n      if (typeof widget == \"string\") {\n        var text3 = document.createTextNode(widget);\n        widget = document.createElement(\"span\");\n        widget.appendChild(text3);\n        widget.className = \"CodeMirror-foldmarker\";\n      } else if (widget) {\n        widget = widget.cloneNode(true);\n      }\n      return widget;\n    }\n    CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n      return function(cm, pos) {\n        doFold(cm, pos, { rangeFinder, widget });\n      };\n    };\n    CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n      doFold(this, pos, options, force);\n    });\n    CodeMirror.defineExtension(\"isFolded\", function(pos) {\n      var marks = this.findMarksAt(pos);\n      for (var i = 0; i < marks.length; ++i)\n        if (marks[i].__isFold)\n          return true;\n    });\n    CodeMirror.commands.toggleFold = function(cm) {\n      cm.foldCode(cm.getCursor());\n    };\n    CodeMirror.commands.fold = function(cm) {\n      cm.foldCode(cm.getCursor(), null, \"fold\");\n    };\n    CodeMirror.commands.unfold = function(cm) {\n      cm.foldCode(cm.getCursor(), { scanUp: false }, \"unfold\");\n    };\n    CodeMirror.commands.foldAll = function(cm) {\n      cm.operation(function() {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n          cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"fold\");\n      });\n    };\n    CodeMirror.commands.unfoldAll = function(cm) {\n      cm.operation(function() {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n          cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"unfold\");\n      });\n    };\n    CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n      var funcs = Array.prototype.slice.call(arguments, 0);\n      return function(cm, start2) {\n        for (var i = 0; i < funcs.length; ++i) {\n          var found = funcs[i](cm, start2);\n          if (found)\n            return found;\n        }\n      };\n    });\n    CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start2) {\n      var helpers2 = cm.getHelpers(start2, \"fold\");\n      for (var i = 0; i < helpers2.length; i++) {\n        var cur = helpers2[i](cm, start2);\n        if (cur)\n          return cur;\n      }\n    });\n    var defaultOptions2 = {\n      rangeFinder: CodeMirror.fold.auto,\n      widget: \"\\u2194\",\n      minFoldSize: 0,\n      scanUp: false,\n      clearOnEnter: true\n    };\n    CodeMirror.defineOption(\"foldOptions\", null);\n    function getOption(cm, options, name2) {\n      if (options && options[name2] !== void 0)\n        return options[name2];\n      var editorOptions = cm.options.foldOptions;\n      if (editorOptions && editorOptions[name2] !== void 0)\n        return editorOptions[name2];\n      return defaultOptions2[name2];\n    }\n    CodeMirror.defineExtension(\"foldOption\", function(options, name2) {\n      return getOption(this, options, name2);\n    });\n  });\n})();\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports, foldcode.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.clearGutter(cm.state.foldGutter.options.gutter);\n        cm.state.foldGutter = null;\n        cm.off(\"gutterClick\", onGutterClick);\n        cm.off(\"changes\", onChange);\n        cm.off(\"viewportChange\", onViewportChange);\n        cm.off(\"fold\", onFold);\n        cm.off(\"unfold\", onFold);\n        cm.off(\"swapDoc\", onChange);\n      }\n      if (val) {\n        cm.state.foldGutter = new State(parseOptions(val));\n        updateInViewport(cm);\n        cm.on(\"gutterClick\", onGutterClick);\n        cm.on(\"changes\", onChange);\n        cm.on(\"viewportChange\", onViewportChange);\n        cm.on(\"fold\", onFold);\n        cm.on(\"unfold\", onFold);\n        cm.on(\"swapDoc\", onChange);\n      }\n    });\n    var Pos = CodeMirror.Pos;\n    function State(options) {\n      this.options = options;\n      this.from = this.to = 0;\n    }\n    function parseOptions(opts) {\n      if (opts === true)\n        opts = {};\n      if (opts.gutter == null)\n        opts.gutter = \"CodeMirror-foldgutter\";\n      if (opts.indicatorOpen == null)\n        opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n      if (opts.indicatorFolded == null)\n        opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n      return opts;\n    }\n    function isFolded(cm, line) {\n      var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold) {\n          var fromPos = marks[i].find(-1);\n          if (fromPos && fromPos.line === line)\n            return marks[i];\n        }\n      }\n    }\n    function marker2(spec) {\n      if (typeof spec == \"string\") {\n        var elt = document.createElement(\"div\");\n        elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n        return elt;\n      } else {\n        return spec.cloneNode(true);\n      }\n    }\n    function updateFoldInfo(cm, from, to) {\n      var opts = cm.state.foldGutter.options, cur = from - 1;\n      var minSize = cm.foldOption(opts, \"minFoldSize\");\n      var func = cm.foldOption(opts, \"rangeFinder\");\n      var clsFolded = typeof opts.indicatorFolded == \"string\" && classTest(opts.indicatorFolded);\n      var clsOpen = typeof opts.indicatorOpen == \"string\" && classTest(opts.indicatorOpen);\n      cm.eachLine(from, to, function(line) {\n        ++cur;\n        var mark = null;\n        var old = line.gutterMarkers;\n        if (old)\n          old = old[opts.gutter];\n        if (isFolded(cm, cur)) {\n          if (clsFolded && old && clsFolded.test(old.className))\n            return;\n          mark = marker2(opts.indicatorFolded);\n        } else {\n          var pos = Pos(cur, 0);\n          var range2 = func && func(cm, pos);\n          if (range2 && range2.to.line - range2.from.line >= minSize) {\n            if (clsOpen && old && clsOpen.test(old.className))\n              return;\n            mark = marker2(opts.indicatorOpen);\n          }\n        }\n        if (!mark && !old)\n          return;\n        cm.setGutterMarker(line, opts.gutter, mark);\n      });\n    }\n    function classTest(cls) {\n      return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n    }\n    function updateInViewport(cm) {\n      var vp = cm.getViewport(), state = cm.state.foldGutter;\n      if (!state)\n        return;\n      cm.operation(function() {\n        updateFoldInfo(cm, vp.from, vp.to);\n      });\n      state.from = vp.from;\n      state.to = vp.to;\n    }\n    function onGutterClick(cm, line, gutter) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      if (gutter != opts.gutter)\n        return;\n      var folded = isFolded(cm, line);\n      if (folded)\n        folded.clear();\n      else\n        cm.foldCode(Pos(line, 0), opts);\n    }\n    function onChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      state.from = state.to = 0;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function() {\n        updateInViewport(cm);\n      }, opts.foldOnChangeTimeSpan || 600);\n    }\n    function onViewportChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function() {\n        var vp = cm.getViewport();\n        if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n          updateInViewport(cm);\n        } else {\n          cm.operation(function() {\n            if (vp.from < state.from) {\n              updateFoldInfo(cm, vp.from, state.from);\n              state.from = vp.from;\n            }\n            if (vp.to > state.to) {\n              updateFoldInfo(cm, state.to, vp.to);\n              state.to = vp.to;\n            }\n          });\n        }\n      }, opts.updateViewportTimeSpan || 400);\n    }\n    function onFold(cm, from) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var line = from.line;\n      if (line >= state.from && line < state.to)\n        updateFoldInfo(cm, line, line + 1);\n    }\n  });\n})();\nvar foldgutter = foldgutter$2.exports;\nvar foldgutter$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": foldgutter\n}, [foldgutter$2.exports]));\nvar lint$6 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    var GUTTER_ID = \"CodeMirror-lint-markers\";\n    var LINT_LINE_ID = \"CodeMirror-lint-line-\";\n    function showTooltip(cm, e, content) {\n      var tt = document.createElement(\"div\");\n      tt.className = \"CodeMirror-lint-tooltip cm-s-\" + cm.options.theme;\n      tt.appendChild(content.cloneNode(true));\n      if (cm.state.lint.options.selfContain)\n        cm.getWrapperElement().appendChild(tt);\n      else\n        document.body.appendChild(tt);\n      function position(e2) {\n        if (!tt.parentNode)\n          return CodeMirror.off(document, \"mousemove\", position);\n        tt.style.top = Math.max(0, e2.clientY - tt.offsetHeight - 5) + \"px\";\n        tt.style.left = e2.clientX + 5 + \"px\";\n      }\n      CodeMirror.on(document, \"mousemove\", position);\n      position(e);\n      if (tt.style.opacity != null)\n        tt.style.opacity = 1;\n      return tt;\n    }\n    function rm(elt) {\n      if (elt.parentNode)\n        elt.parentNode.removeChild(elt);\n    }\n    function hideTooltip(tt) {\n      if (!tt.parentNode)\n        return;\n      if (tt.style.opacity == null)\n        rm(tt);\n      tt.style.opacity = 0;\n      setTimeout(function() {\n        rm(tt);\n      }, 600);\n    }\n    function showTooltipFor(cm, e, content, node) {\n      var tooltip = showTooltip(cm, e, content);\n      function hide() {\n        CodeMirror.off(node, \"mouseout\", hide);\n        if (tooltip) {\n          hideTooltip(tooltip);\n          tooltip = null;\n        }\n      }\n      var poll = setInterval(function() {\n        if (tooltip)\n          for (var n2 = node; ; n2 = n2.parentNode) {\n            if (n2 && n2.nodeType == 11)\n              n2 = n2.host;\n            if (n2 == document.body)\n              return;\n            if (!n2) {\n              hide();\n              break;\n            }\n          }\n        if (!tooltip)\n          return clearInterval(poll);\n      }, 400);\n      CodeMirror.on(node, \"mouseout\", hide);\n    }\n    function LintState(cm, conf, hasGutter) {\n      this.marked = [];\n      if (conf instanceof Function)\n        conf = { getAnnotations: conf };\n      if (!conf || conf === true)\n        conf = {};\n      this.options = {};\n      this.linterOptions = conf.options || {};\n      for (var prop2 in defaults2)\n        this.options[prop2] = defaults2[prop2];\n      for (var prop2 in conf) {\n        if (defaults2.hasOwnProperty(prop2)) {\n          if (conf[prop2] != null)\n            this.options[prop2] = conf[prop2];\n        } else if (!conf.options) {\n          this.linterOptions[prop2] = conf[prop2];\n        }\n      }\n      this.timeout = null;\n      this.hasGutter = hasGutter;\n      this.onMouseOver = function(e) {\n        onMouseOver2(cm, e);\n      };\n      this.waitingFor = 0;\n    }\n    var defaults2 = {\n      highlightLines: false,\n      tooltips: true,\n      delay: 500,\n      lintOnChange: true,\n      getAnnotations: null,\n      async: false,\n      selfContain: null,\n      formatAnnotation: null,\n      onUpdateLinting: null\n    };\n    function clearMarks(cm) {\n      var state = cm.state.lint;\n      if (state.hasGutter)\n        cm.clearGutter(GUTTER_ID);\n      if (state.options.highlightLines)\n        clearErrorLines(cm);\n      for (var i = 0; i < state.marked.length; ++i)\n        state.marked[i].clear();\n      state.marked.length = 0;\n    }\n    function clearErrorLines(cm) {\n      cm.eachLine(function(line) {\n        var has2 = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n        if (has2)\n          cm.removeLineClass(line, \"wrap\", has2[0]);\n      });\n    }\n    function makeMarker(cm, labels, severity, multiple, tooltips) {\n      var marker2 = document.createElement(\"div\"), inner = marker2;\n      marker2.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-\" + severity;\n      if (multiple) {\n        inner = marker2.appendChild(document.createElement(\"div\"));\n        inner.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-multiple\";\n      }\n      if (tooltips != false)\n        CodeMirror.on(inner, \"mouseover\", function(e) {\n          showTooltipFor(cm, e, labels, inner);\n        });\n      return marker2;\n    }\n    function getMaxSeverity(a, b) {\n      if (a == \"error\")\n        return a;\n      else\n        return b;\n    }\n    function groupByLine(annotations2) {\n      var lines = [];\n      for (var i = 0; i < annotations2.length; ++i) {\n        var ann = annotations2[i], line = ann.from.line;\n        (lines[line] || (lines[line] = [])).push(ann);\n      }\n      return lines;\n    }\n    function annotationTooltip(ann) {\n      var severity = ann.severity;\n      if (!severity)\n        severity = \"error\";\n      var tip = document.createElement(\"div\");\n      tip.className = \"CodeMirror-lint-message CodeMirror-lint-message-\" + severity;\n      if (typeof ann.messageHTML != \"undefined\") {\n        tip.innerHTML = ann.messageHTML;\n      } else {\n        tip.appendChild(document.createTextNode(ann.message));\n      }\n      return tip;\n    }\n    function lintAsync(cm, getAnnotations) {\n      var state = cm.state.lint;\n      var id2 = ++state.waitingFor;\n      function abort() {\n        id2 = -1;\n        cm.off(\"change\", abort);\n      }\n      cm.on(\"change\", abort);\n      getAnnotations(cm.getValue(), function(annotations2, arg2) {\n        cm.off(\"change\", abort);\n        if (state.waitingFor != id2)\n          return;\n        if (arg2 && annotations2 instanceof CodeMirror)\n          annotations2 = arg2;\n        cm.operation(function() {\n          updateLinting(cm, annotations2);\n        });\n      }, state.linterOptions, cm);\n    }\n    function startLinting(cm) {\n      var state = cm.state.lint;\n      if (!state)\n        return;\n      var options = state.options;\n      var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n      if (!getAnnotations)\n        return;\n      if (options.async || getAnnotations.async) {\n        lintAsync(cm, getAnnotations);\n      } else {\n        var annotations2 = getAnnotations(cm.getValue(), state.linterOptions, cm);\n        if (!annotations2)\n          return;\n        if (annotations2.then)\n          annotations2.then(function(issues) {\n            cm.operation(function() {\n              updateLinting(cm, issues);\n            });\n          });\n        else\n          cm.operation(function() {\n            updateLinting(cm, annotations2);\n          });\n      }\n    }\n    function updateLinting(cm, annotationsNotSorted) {\n      var state = cm.state.lint;\n      if (!state)\n        return;\n      var options = state.options;\n      clearMarks(cm);\n      var annotations2 = groupByLine(annotationsNotSorted);\n      for (var line = 0; line < annotations2.length; ++line) {\n        var anns = annotations2[line];\n        if (!anns)\n          continue;\n        var message = [];\n        anns = anns.filter(function(item) {\n          return message.indexOf(item.message) > -1 ? false : message.push(item.message);\n        });\n        var maxSeverity = null;\n        var tipLabel = state.hasGutter && document.createDocumentFragment();\n        for (var i = 0; i < anns.length; ++i) {\n          var ann = anns[i];\n          var severity = ann.severity;\n          if (!severity)\n            severity = \"error\";\n          maxSeverity = getMaxSeverity(maxSeverity, severity);\n          if (options.formatAnnotation)\n            ann = options.formatAnnotation(ann);\n          if (state.hasGutter)\n            tipLabel.appendChild(annotationTooltip(ann));\n          if (ann.to)\n            state.marked.push(cm.markText(ann.from, ann.to, {\n              className: \"CodeMirror-lint-mark CodeMirror-lint-mark-\" + severity,\n              __annotation: ann\n            }));\n        }\n        if (state.hasGutter)\n          cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations2[line].length > 1, options.tooltips));\n        if (options.highlightLines)\n          cm.addLineClass(line, \"wrap\", LINT_LINE_ID + maxSeverity);\n      }\n      if (options.onUpdateLinting)\n        options.onUpdateLinting(annotationsNotSorted, annotations2, cm);\n    }\n    function onChange(cm) {\n      var state = cm.state.lint;\n      if (!state)\n        return;\n      clearTimeout(state.timeout);\n      state.timeout = setTimeout(function() {\n        startLinting(cm);\n      }, state.options.delay);\n    }\n    function popupTooltips(cm, annotations2, e) {\n      var target2 = e.target || e.srcElement;\n      var tooltip = document.createDocumentFragment();\n      for (var i = 0; i < annotations2.length; i++) {\n        var ann = annotations2[i];\n        tooltip.appendChild(annotationTooltip(ann));\n      }\n      showTooltipFor(cm, e, tooltip, target2);\n    }\n    function onMouseOver2(cm, e) {\n      var target2 = e.target || e.srcElement;\n      if (!/\\bCodeMirror-lint-mark-/.test(target2.className))\n        return;\n      var box = target2.getBoundingClientRect(), x2 = (box.left + box.right) / 2, y2 = (box.top + box.bottom) / 2;\n      var spans = cm.findMarksAt(cm.coordsChar({ left: x2, top: y2 }, \"client\"));\n      var annotations2 = [];\n      for (var i = 0; i < spans.length; ++i) {\n        var ann = spans[i].__annotation;\n        if (ann)\n          annotations2.push(ann);\n      }\n      if (annotations2.length)\n        popupTooltips(cm, annotations2, e);\n    }\n    CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        clearMarks(cm);\n        if (cm.state.lint.options.lintOnChange !== false)\n          cm.off(\"change\", onChange);\n        CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n        clearTimeout(cm.state.lint.timeout);\n        delete cm.state.lint;\n      }\n      if (val) {\n        var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n        for (var i = 0; i < gutters.length; ++i)\n          if (gutters[i] == GUTTER_ID)\n            hasLintGutter = true;\n        var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n        if (state.options.lintOnChange)\n          cm.on(\"change\", onChange);\n        if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n          CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n        startLinting(cm);\n      }\n    });\n    CodeMirror.defineExtension(\"performLint\", function() {\n      startLinting(this);\n    });\n  });\n})();\nvar lint$4 = lint$6.exports;\nvar lint$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": lint$4\n}, [lint$6.exports]));\nvar searchcursor$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    var Pos = CodeMirror.Pos;\n    function regexpFlags(regexp) {\n      var flags = regexp.flags;\n      return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\") + (regexp.global ? \"g\" : \"\") + (regexp.multiline ? \"m\" : \"\");\n    }\n    function ensureFlags(regexp, flags) {\n      var current = regexpFlags(regexp), target2 = current;\n      for (var i = 0; i < flags.length; i++)\n        if (target2.indexOf(flags.charAt(i)) == -1)\n          target2 += flags.charAt(i);\n      return current == target2 ? regexp : new RegExp(regexp.source, target2);\n    }\n    function maybeMultiline(regexp) {\n      return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source);\n    }\n    function searchRegexpForward(doc, regexp, start2) {\n      regexp = ensureFlags(regexp, \"g\");\n      for (var line = start2.line, ch2 = start2.ch, last = doc.lastLine(); line <= last; line++, ch2 = 0) {\n        regexp.lastIndex = ch2;\n        var string2 = doc.getLine(line), match2 = regexp.exec(string2);\n        if (match2)\n          return {\n            from: Pos(line, match2.index),\n            to: Pos(line, match2.index + match2[0].length),\n            match: match2\n          };\n      }\n    }\n    function searchRegexpForwardMultiline(doc, regexp, start2) {\n      if (!maybeMultiline(regexp))\n        return searchRegexpForward(doc, regexp, start2);\n      regexp = ensureFlags(regexp, \"gm\");\n      var string2, chunk = 1;\n      for (var line = start2.line, last = doc.lastLine(); line <= last; ) {\n        for (var i = 0; i < chunk; i++) {\n          if (line > last)\n            break;\n          var curLine = doc.getLine(line++);\n          string2 = string2 == null ? curLine : string2 + \"\\n\" + curLine;\n        }\n        chunk = chunk * 2;\n        regexp.lastIndex = start2.ch;\n        var match2 = regexp.exec(string2);\n        if (match2) {\n          var before = string2.slice(0, match2.index).split(\"\\n\"), inside = match2[0].split(\"\\n\");\n          var startLine = start2.line + before.length - 1, startCh = before[before.length - 1].length;\n          return {\n            from: Pos(startLine, startCh),\n            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n            match: match2\n          };\n        }\n      }\n    }\n    function lastMatchIn(string2, regexp, endMargin) {\n      var match2, from = 0;\n      while (from <= string2.length) {\n        regexp.lastIndex = from;\n        var newMatch = regexp.exec(string2);\n        if (!newMatch)\n          break;\n        var end2 = newMatch.index + newMatch[0].length;\n        if (end2 > string2.length - endMargin)\n          break;\n        if (!match2 || end2 > match2.index + match2[0].length)\n          match2 = newMatch;\n        from = newMatch.index + 1;\n      }\n      return match2;\n    }\n    function searchRegexpBackward(doc, regexp, start2) {\n      regexp = ensureFlags(regexp, \"g\");\n      for (var line = start2.line, ch2 = start2.ch, first = doc.firstLine(); line >= first; line--, ch2 = -1) {\n        var string2 = doc.getLine(line);\n        var match2 = lastMatchIn(string2, regexp, ch2 < 0 ? 0 : string2.length - ch2);\n        if (match2)\n          return {\n            from: Pos(line, match2.index),\n            to: Pos(line, match2.index + match2[0].length),\n            match: match2\n          };\n      }\n    }\n    function searchRegexpBackwardMultiline(doc, regexp, start2) {\n      if (!maybeMultiline(regexp))\n        return searchRegexpBackward(doc, regexp, start2);\n      regexp = ensureFlags(regexp, \"gm\");\n      var string2, chunkSize = 1, endMargin = doc.getLine(start2.line).length - start2.ch;\n      for (var line = start2.line, first = doc.firstLine(); line >= first; ) {\n        for (var i = 0; i < chunkSize && line >= first; i++) {\n          var curLine = doc.getLine(line--);\n          string2 = string2 == null ? curLine : curLine + \"\\n\" + string2;\n        }\n        chunkSize *= 2;\n        var match2 = lastMatchIn(string2, regexp, endMargin);\n        if (match2) {\n          var before = string2.slice(0, match2.index).split(\"\\n\"), inside = match2[0].split(\"\\n\");\n          var startLine = line + before.length, startCh = before[before.length - 1].length;\n          return {\n            from: Pos(startLine, startCh),\n            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n            match: match2\n          };\n        }\n      }\n    }\n    var doFold, noFold;\n    if (String.prototype.normalize) {\n      doFold = function(str) {\n        return str.normalize(\"NFD\").toLowerCase();\n      };\n      noFold = function(str) {\n        return str.normalize(\"NFD\");\n      };\n    } else {\n      doFold = function(str) {\n        return str.toLowerCase();\n      };\n      noFold = function(str) {\n        return str;\n      };\n    }\n    function adjustPos(orig, folded, pos, foldFunc) {\n      if (orig.length == folded.length)\n        return pos;\n      for (var min = 0, max = pos + Math.max(0, orig.length - folded.length); ; ) {\n        if (min == max)\n          return min;\n        var mid2 = min + max >> 1;\n        var len = foldFunc(orig.slice(0, mid2)).length;\n        if (len == pos)\n          return mid2;\n        else if (len > pos)\n          max = mid2;\n        else\n          min = mid2 + 1;\n      }\n    }\n    function searchStringForward(doc, query, start2, caseFold) {\n      if (!query.length)\n        return null;\n      var fold = caseFold ? doFold : noFold;\n      var lines = fold(query).split(/\\r|\\n\\r?/);\n      search:\n        for (var line = start2.line, ch2 = start2.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch2 = 0) {\n          var orig = doc.getLine(line).slice(ch2), string2 = fold(orig);\n          if (lines.length == 1) {\n            var found = string2.indexOf(lines[0]);\n            if (found == -1)\n              continue search;\n            var start2 = adjustPos(orig, string2, found, fold) + ch2;\n            return {\n              from: Pos(line, adjustPos(orig, string2, found, fold) + ch2),\n              to: Pos(line, adjustPos(orig, string2, found + lines[0].length, fold) + ch2)\n            };\n          } else {\n            var cutFrom = string2.length - lines[0].length;\n            if (string2.slice(cutFrom) != lines[0])\n              continue search;\n            for (var i = 1; i < lines.length - 1; i++)\n              if (fold(doc.getLine(line + i)) != lines[i])\n                continue search;\n            var end2 = doc.getLine(line + lines.length - 1), endString = fold(end2), lastLine = lines[lines.length - 1];\n            if (endString.slice(0, lastLine.length) != lastLine)\n              continue search;\n            return {\n              from: Pos(line, adjustPos(orig, string2, cutFrom, fold) + ch2),\n              to: Pos(line + lines.length - 1, adjustPos(end2, endString, lastLine.length, fold))\n            };\n          }\n        }\n    }\n    function searchStringBackward(doc, query, start2, caseFold) {\n      if (!query.length)\n        return null;\n      var fold = caseFold ? doFold : noFold;\n      var lines = fold(query).split(/\\r|\\n\\r?/);\n      search:\n        for (var line = start2.line, ch2 = start2.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch2 = -1) {\n          var orig = doc.getLine(line);\n          if (ch2 > -1)\n            orig = orig.slice(0, ch2);\n          var string2 = fold(orig);\n          if (lines.length == 1) {\n            var found = string2.lastIndexOf(lines[0]);\n            if (found == -1)\n              continue search;\n            return {\n              from: Pos(line, adjustPos(orig, string2, found, fold)),\n              to: Pos(line, adjustPos(orig, string2, found + lines[0].length, fold))\n            };\n          } else {\n            var lastLine = lines[lines.length - 1];\n            if (string2.slice(0, lastLine.length) != lastLine)\n              continue search;\n            for (var i = 1, start2 = line - lines.length + 1; i < lines.length - 1; i++)\n              if (fold(doc.getLine(start2 + i)) != lines[i])\n                continue search;\n            var top2 = doc.getLine(line + 1 - lines.length), topString = fold(top2);\n            if (topString.slice(topString.length - lines[0].length) != lines[0])\n              continue search;\n            return {\n              from: Pos(line + 1 - lines.length, adjustPos(top2, topString, top2.length - lines[0].length, fold)),\n              to: Pos(line, adjustPos(orig, string2, lastLine.length, fold))\n            };\n          }\n        }\n    }\n    function SearchCursor(doc, query, pos, options) {\n      this.atOccurrence = false;\n      this.afterEmptyMatch = false;\n      this.doc = doc;\n      pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n      this.pos = { from: pos, to: pos };\n      var caseFold;\n      if (typeof options == \"object\") {\n        caseFold = options.caseFold;\n      } else {\n        caseFold = options;\n        options = null;\n      }\n      if (typeof query == \"string\") {\n        if (caseFold == null)\n          caseFold = false;\n        this.matches = function(reverse, pos2) {\n          return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos2, caseFold);\n        };\n      } else {\n        query = ensureFlags(query, \"gm\");\n        if (!options || options.multiline !== false)\n          this.matches = function(reverse, pos2) {\n            return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos2);\n          };\n        else\n          this.matches = function(reverse, pos2) {\n            return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos2);\n          };\n      }\n    }\n    SearchCursor.prototype = {\n      findNext: function() {\n        return this.find(false);\n      },\n      findPrevious: function() {\n        return this.find(true);\n      },\n      find: function(reverse) {\n        var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n        if (this.afterEmptyMatch && this.atOccurrence) {\n          head = Pos(head.line, head.ch);\n          if (reverse) {\n            head.ch--;\n            if (head.ch < 0) {\n              head.line--;\n              head.ch = (this.doc.getLine(head.line) || \"\").length;\n            }\n          } else {\n            head.ch++;\n            if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n              head.ch = 0;\n              head.line++;\n            }\n          }\n          if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n            return this.atOccurrence = false;\n          }\n        }\n        var result2 = this.matches(reverse, head);\n        this.afterEmptyMatch = result2 && CodeMirror.cmpPos(result2.from, result2.to) == 0;\n        if (result2) {\n          this.pos = result2;\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        } else {\n          var end2 = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);\n          this.pos = { from: end2, to: end2 };\n          return this.atOccurrence = false;\n        }\n      },\n      from: function() {\n        if (this.atOccurrence)\n          return this.pos.from;\n      },\n      to: function() {\n        if (this.atOccurrence)\n          return this.pos.to;\n      },\n      replace: function(newText, origin) {\n        if (!this.atOccurrence)\n          return;\n        var lines = CodeMirror.splitLines(newText);\n        this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n        this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n      }\n    };\n    CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n      return new SearchCursor(this.doc, query, pos, caseFold);\n    });\n    CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n      return new SearchCursor(this, query, pos, caseFold);\n    });\n    CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n      var ranges = [];\n      var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n      while (cur.findNext()) {\n        if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0)\n          break;\n        ranges.push({ anchor: cur.from(), head: cur.to() });\n      }\n      if (ranges.length)\n        this.setSelections(ranges, 0);\n    });\n  });\n})();\nvar searchcursor = searchcursor$2.exports;\nvar searchcursor$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": searchcursor\n}, [searchcursor$2.exports]));\nvar jumpToLine$2 = { exports: {} };\nvar dialog$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    function dialogDiv(cm, template, bottom2) {\n      var wrap2 = cm.getWrapperElement();\n      var dialog2;\n      dialog2 = wrap2.appendChild(document.createElement(\"div\"));\n      if (bottom2)\n        dialog2.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n      else\n        dialog2.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n      if (typeof template == \"string\") {\n        dialog2.innerHTML = template;\n      } else {\n        dialog2.appendChild(template);\n      }\n      CodeMirror.addClass(wrap2, \"dialog-opened\");\n      return dialog2;\n    }\n    function closeNotification(cm, newVal) {\n      if (cm.state.currentNotificationClose)\n        cm.state.currentNotificationClose();\n      cm.state.currentNotificationClose = newVal;\n    }\n    CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n      if (!options)\n        options = {};\n      closeNotification(this, null);\n      var dialog2 = dialogDiv(this, template, options.bottom);\n      var closed = false, me2 = this;\n      function close(newVal) {\n        if (typeof newVal == \"string\") {\n          inp.value = newVal;\n        } else {\n          if (closed)\n            return;\n          closed = true;\n          CodeMirror.rmClass(dialog2.parentNode, \"dialog-opened\");\n          dialog2.parentNode.removeChild(dialog2);\n          me2.focus();\n          if (options.onClose)\n            options.onClose(dialog2);\n        }\n      }\n      var inp = dialog2.getElementsByTagName(\"input\")[0], button;\n      if (inp) {\n        inp.focus();\n        if (options.value) {\n          inp.value = options.value;\n          if (options.selectValueOnOpen !== false) {\n            inp.select();\n          }\n        }\n        if (options.onInput)\n          CodeMirror.on(inp, \"input\", function(e) {\n            options.onInput(e, inp.value, close);\n          });\n        if (options.onKeyUp)\n          CodeMirror.on(inp, \"keyup\", function(e) {\n            options.onKeyUp(e, inp.value, close);\n          });\n        CodeMirror.on(inp, \"keydown\", function(e) {\n          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n            return;\n          }\n          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n            inp.blur();\n            CodeMirror.e_stop(e);\n            close();\n          }\n          if (e.keyCode == 13)\n            callback(inp.value, e);\n        });\n        if (options.closeOnBlur !== false)\n          CodeMirror.on(dialog2, \"focusout\", function(evt) {\n            if (evt.relatedTarget !== null)\n              close();\n          });\n      } else if (button = dialog2.getElementsByTagName(\"button\")[0]) {\n        CodeMirror.on(button, \"click\", function() {\n          close();\n          me2.focus();\n        });\n        if (options.closeOnBlur !== false)\n          CodeMirror.on(button, \"blur\", close);\n        button.focus();\n      }\n      return close;\n    });\n    CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n      closeNotification(this, null);\n      var dialog2 = dialogDiv(this, template, options && options.bottom);\n      var buttons = dialog2.getElementsByTagName(\"button\");\n      var closed = false, me2 = this, blurring = 1;\n      function close() {\n        if (closed)\n          return;\n        closed = true;\n        CodeMirror.rmClass(dialog2.parentNode, \"dialog-opened\");\n        dialog2.parentNode.removeChild(dialog2);\n        me2.focus();\n      }\n      buttons[0].focus();\n      for (var i = 0; i < buttons.length; ++i) {\n        var b = buttons[i];\n        (function(callback) {\n          CodeMirror.on(b, \"click\", function(e) {\n            CodeMirror.e_preventDefault(e);\n            close();\n            if (callback)\n              callback(me2);\n          });\n        })(callbacks[i]);\n        CodeMirror.on(b, \"blur\", function() {\n          --blurring;\n          setTimeout(function() {\n            if (blurring <= 0)\n              close();\n          }, 200);\n        });\n        CodeMirror.on(b, \"focus\", function() {\n          ++blurring;\n        });\n      }\n    });\n    CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n      closeNotification(this, close);\n      var dialog2 = dialogDiv(this, template, options && options.bottom);\n      var closed = false, doneTimer;\n      var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5e3;\n      function close() {\n        if (closed)\n          return;\n        closed = true;\n        clearTimeout(doneTimer);\n        CodeMirror.rmClass(dialog2.parentNode, \"dialog-opened\");\n        dialog2.parentNode.removeChild(dialog2);\n      }\n      CodeMirror.on(dialog2, \"click\", function(e) {\n        CodeMirror.e_preventDefault(e);\n        close();\n      });\n      if (duration)\n        doneTimer = setTimeout(close, duration);\n      return close;\n    });\n  });\n})();\nvar dialog = dialog$2.exports;\nvar dialog$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": dialog\n}, [dialog$2.exports]));\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports, dialog$2.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineOption(\"search\", { bottom: false });\n    function dialog2(cm, text3, shortText, deflt, f) {\n      if (cm.openDialog)\n        cm.openDialog(text3, f, { value: deflt, selectValueOnOpen: true, bottom: cm.options.search.bottom });\n      else\n        f(prompt(shortText, deflt));\n    }\n    function getJumpDialog(cm) {\n      return cm.phrase(\"Jump to line:\") + ' <input type=\"text\" style=\"width: 10em\" class=\"CodeMirror-search-field\"/> <span style=\"color: #888\" class=\"CodeMirror-search-hint\">' + cm.phrase(\"(Use line:column or scroll% syntax)\") + \"</span>\";\n    }\n    function interpretLine(cm, string2) {\n      var num2 = Number(string2);\n      if (/^[-+]/.test(string2))\n        return cm.getCursor().line + num2;\n      else\n        return num2 - 1;\n    }\n    CodeMirror.commands.jumpToLine = function(cm) {\n      var cur = cm.getCursor();\n      dialog2(cm, getJumpDialog(cm), cm.phrase(\"Jump to line:\"), cur.line + 1 + \":\" + cur.ch, function(posStr) {\n        if (!posStr)\n          return;\n        var match2;\n        if (match2 = /^\\s*([\\+\\-]?\\d+)\\s*\\:\\s*(\\d+)\\s*$/.exec(posStr)) {\n          cm.setCursor(interpretLine(cm, match2[1]), Number(match2[2]));\n        } else if (match2 = /^\\s*([\\+\\-]?\\d+(\\.\\d+)?)\\%\\s*/.exec(posStr)) {\n          var line = Math.round(cm.lineCount() * Number(match2[1]) / 100);\n          if (/^[-+]/.test(match2[1]))\n            line = cur.line + line + 1;\n          cm.setCursor(line - 1, cur.ch);\n        } else if (match2 = /^\\s*\\:?\\s*([\\+\\-]?\\d+)\\s*/.exec(posStr)) {\n          cm.setCursor(interpretLine(cm, match2[1]), cur.ch);\n        }\n      });\n    };\n    CodeMirror.keyMap[\"default\"][\"Alt-G\"] = \"jumpToLine\";\n  });\n})();\nvar jumpToLine = jumpToLine$2.exports;\nvar jumpToLine$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": jumpToLine\n}, [jumpToLine$2.exports]));\nvar sublime$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports, searchcursor$2.exports, matchbrackets$2.exports);\n  })(function(CodeMirror) {\n    var cmds = CodeMirror.commands;\n    var Pos = CodeMirror.Pos;\n    function findPosSubword(doc, start2, dir) {\n      if (dir < 0 && start2.ch == 0)\n        return doc.clipPos(Pos(start2.line - 1));\n      var line = doc.getLine(start2.line);\n      if (dir > 0 && start2.ch >= line.length)\n        return doc.clipPos(Pos(start2.line + 1, 0));\n      var state = \"start\", type2, startPos = start2.ch;\n      for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n        var next = line.charAt(dir < 0 ? pos - 1 : pos);\n        var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n        if (cat == \"w\" && next.toUpperCase() == next)\n          cat = \"W\";\n        if (state == \"start\") {\n          if (cat != \"o\") {\n            state = \"in\";\n            type2 = cat;\n          } else\n            startPos = pos + dir;\n        } else if (state == \"in\") {\n          if (type2 != cat) {\n            if (type2 == \"w\" && cat == \"W\" && dir < 0)\n              pos--;\n            if (type2 == \"W\" && cat == \"w\" && dir > 0) {\n              if (pos == startPos + 1) {\n                type2 = \"w\";\n                continue;\n              } else\n                pos--;\n            }\n            break;\n          }\n        }\n      }\n      return Pos(start2.line, pos);\n    }\n    function moveSubword(cm, dir) {\n      cm.extendSelectionsBy(function(range2) {\n        if (cm.display.shift || cm.doc.extend || range2.empty())\n          return findPosSubword(cm.doc, range2.head, dir);\n        else\n          return dir < 0 ? range2.from() : range2.to();\n      });\n    }\n    cmds.goSubwordLeft = function(cm) {\n      moveSubword(cm, -1);\n    };\n    cmds.goSubwordRight = function(cm) {\n      moveSubword(cm, 1);\n    };\n    cmds.scrollLineUp = function(cm) {\n      var info2 = cm.getScrollInfo();\n      if (!cm.somethingSelected()) {\n        var visibleBottomLine = cm.lineAtHeight(info2.top + info2.clientHeight, \"local\");\n        if (cm.getCursor().line >= visibleBottomLine)\n          cm.execCommand(\"goLineUp\");\n      }\n      cm.scrollTo(null, info2.top - cm.defaultTextHeight());\n    };\n    cmds.scrollLineDown = function(cm) {\n      var info2 = cm.getScrollInfo();\n      if (!cm.somethingSelected()) {\n        var visibleTopLine = cm.lineAtHeight(info2.top, \"local\") + 1;\n        if (cm.getCursor().line <= visibleTopLine)\n          cm.execCommand(\"goLineDown\");\n      }\n      cm.scrollTo(null, info2.top + cm.defaultTextHeight());\n    };\n    cmds.splitSelectionByLine = function(cm) {\n      var ranges = cm.listSelections(), lineRanges = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var from = ranges[i].from(), to = ranges[i].to();\n        for (var line = from.line; line <= to.line; ++line)\n          if (!(to.line > from.line && line == to.line && to.ch == 0))\n            lineRanges.push({\n              anchor: line == from.line ? from : Pos(line, 0),\n              head: line == to.line ? to : Pos(line)\n            });\n      }\n      cm.setSelections(lineRanges, 0);\n    };\n    cmds.singleSelectionTop = function(cm) {\n      var range2 = cm.listSelections()[0];\n      cm.setSelection(range2.anchor, range2.head, { scroll: false });\n    };\n    cmds.selectLine = function(cm) {\n      var ranges = cm.listSelections(), extended = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i];\n        extended.push({\n          anchor: Pos(range2.from().line, 0),\n          head: Pos(range2.to().line + 1, 0)\n        });\n      }\n      cm.setSelections(extended);\n    };\n    function insertLine(cm, above) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      cm.operation(function() {\n        var len = cm.listSelections().length, newSelection = [], last = -1;\n        for (var i = 0; i < len; i++) {\n          var head = cm.listSelections()[i].head;\n          if (head.line <= last)\n            continue;\n          var at = Pos(head.line + (above ? 0 : 1), 0);\n          cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n          cm.indentLine(at.line, null, true);\n          newSelection.push({ head: at, anchor: at });\n          last = head.line + 1;\n        }\n        cm.setSelections(newSelection);\n      });\n      cm.execCommand(\"indentAuto\");\n    }\n    cmds.insertLineAfter = function(cm) {\n      return insertLine(cm, false);\n    };\n    cmds.insertLineBefore = function(cm) {\n      return insertLine(cm, true);\n    };\n    function wordAt(cm, pos) {\n      var start2 = pos.ch, end2 = start2, line = cm.getLine(pos.line);\n      while (start2 && CodeMirror.isWordChar(line.charAt(start2 - 1)))\n        --start2;\n      while (end2 < line.length && CodeMirror.isWordChar(line.charAt(end2)))\n        ++end2;\n      return { from: Pos(pos.line, start2), to: Pos(pos.line, end2), word: line.slice(start2, end2) };\n    }\n    cmds.selectNextOccurrence = function(cm) {\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n      if (CodeMirror.cmpPos(from, to) == 0) {\n        var word2 = wordAt(cm, from);\n        if (!word2.word)\n          return;\n        cm.setSelection(word2.from, word2.to);\n        fullWord = true;\n      } else {\n        var text3 = cm.getRange(from, to);\n        var query = fullWord ? new RegExp(\"\\\\b\" + text3 + \"\\\\b\") : text3;\n        var cur = cm.getSearchCursor(query, to);\n        var found = cur.findNext();\n        if (!found) {\n          cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n          found = cur.findNext();\n        }\n        if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))\n          return;\n        cm.addSelection(cur.from(), cur.to());\n      }\n      if (fullWord)\n        cm.state.sublimeFindFullWord = cm.doc.sel;\n    };\n    cmds.skipAndSelectNextOccurrence = function(cm) {\n      var prevAnchor = cm.getCursor(\"anchor\"), prevHead = cm.getCursor(\"head\");\n      cmds.selectNextOccurrence(cm);\n      if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {\n        cm.doc.setSelections(cm.doc.listSelections().filter(function(sel) {\n          return sel.anchor != prevAnchor || sel.head != prevHead;\n        }));\n      }\n    };\n    function addCursorToSelection(cm, dir) {\n      var ranges = cm.listSelections(), newRanges = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i];\n        var newAnchor = cm.findPosV(range2.anchor, dir, \"line\", range2.anchor.goalColumn);\n        var newHead = cm.findPosV(range2.head, dir, \"line\", range2.head.goalColumn);\n        newAnchor.goalColumn = range2.anchor.goalColumn != null ? range2.anchor.goalColumn : cm.cursorCoords(range2.anchor, \"div\").left;\n        newHead.goalColumn = range2.head.goalColumn != null ? range2.head.goalColumn : cm.cursorCoords(range2.head, \"div\").left;\n        var newRange = { anchor: newAnchor, head: newHead };\n        newRanges.push(range2);\n        newRanges.push(newRange);\n      }\n      cm.setSelections(newRanges);\n    }\n    cmds.addCursorToPrevLine = function(cm) {\n      addCursorToSelection(cm, -1);\n    };\n    cmds.addCursorToNextLine = function(cm) {\n      addCursorToSelection(cm, 1);\n    };\n    function isSelectedRange(ranges, from, to) {\n      for (var i = 0; i < ranges.length; i++)\n        if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 && CodeMirror.cmpPos(ranges[i].to(), to) == 0)\n          return true;\n      return false;\n    }\n    var mirror = \"(){}[]\";\n    function selectBetweenBrackets(cm) {\n      var ranges = cm.listSelections(), newRanges = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i], pos = range2.head, opening = cm.scanForBracket(pos, -1);\n        if (!opening)\n          return false;\n        for (; ; ) {\n          var closing = cm.scanForBracket(pos, 1);\n          if (!closing)\n            return false;\n          if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n            var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n            if (CodeMirror.cmpPos(startPos, range2.from()) == 0 && CodeMirror.cmpPos(closing.pos, range2.to()) == 0) {\n              opening = cm.scanForBracket(opening.pos, -1);\n              if (!opening)\n                return false;\n            } else {\n              newRanges.push({ anchor: startPos, head: closing.pos });\n              break;\n            }\n          }\n          pos = Pos(closing.pos.line, closing.pos.ch + 1);\n        }\n      }\n      cm.setSelections(newRanges);\n      return true;\n    }\n    cmds.selectScope = function(cm) {\n      selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n    };\n    cmds.selectBetweenBrackets = function(cm) {\n      if (!selectBetweenBrackets(cm))\n        return CodeMirror.Pass;\n    };\n    function puncType(type2) {\n      return !type2 ? null : /\\bpunctuation\\b/.test(type2) ? type2 : void 0;\n    }\n    cmds.goToBracket = function(cm) {\n      cm.extendSelectionsBy(function(range2) {\n        var next = cm.scanForBracket(range2.head, 1, puncType(cm.getTokenTypeAt(range2.head)));\n        if (next && CodeMirror.cmpPos(next.pos, range2.head) != 0)\n          return next.pos;\n        var prev = cm.scanForBracket(range2.head, -1, puncType(cm.getTokenTypeAt(Pos(range2.head.line, range2.head.ch + 1))));\n        return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range2.head;\n      });\n    };\n    cmds.swapLineUp = function(cm) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i], from = range2.from().line - 1, to = range2.to().line;\n        newSels.push({\n          anchor: Pos(range2.anchor.line - 1, range2.anchor.ch),\n          head: Pos(range2.head.line - 1, range2.head.ch)\n        });\n        if (range2.to().ch == 0 && !range2.empty())\n          --to;\n        if (from > at)\n          linesToMove.push(from, to);\n        else if (linesToMove.length)\n          linesToMove[linesToMove.length - 1] = to;\n        at = to;\n      }\n      cm.operation(function() {\n        for (var i2 = 0; i2 < linesToMove.length; i2 += 2) {\n          var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];\n          var line = cm.getLine(from2);\n          cm.replaceRange(\"\", Pos(from2, 0), Pos(from2 + 1, 0), \"+swapLine\");\n          if (to2 > cm.lastLine())\n            cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n          else\n            cm.replaceRange(line + \"\\n\", Pos(to2, 0), null, \"+swapLine\");\n        }\n        cm.setSelections(newSels);\n        cm.scrollIntoView();\n      });\n    };\n    cmds.swapLineDown = function(cm) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var range2 = ranges[i], from = range2.to().line + 1, to = range2.from().line;\n        if (range2.to().ch == 0 && !range2.empty())\n          from--;\n        if (from < at)\n          linesToMove.push(from, to);\n        else if (linesToMove.length)\n          linesToMove[linesToMove.length - 1] = to;\n        at = to;\n      }\n      cm.operation(function() {\n        for (var i2 = linesToMove.length - 2; i2 >= 0; i2 -= 2) {\n          var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];\n          var line = cm.getLine(from2);\n          if (from2 == cm.lastLine())\n            cm.replaceRange(\"\", Pos(from2 - 1), Pos(from2), \"+swapLine\");\n          else\n            cm.replaceRange(\"\", Pos(from2, 0), Pos(from2 + 1, 0), \"+swapLine\");\n          cm.replaceRange(line + \"\\n\", Pos(to2, 0), null, \"+swapLine\");\n        }\n        cm.scrollIntoView();\n      });\n    };\n    cmds.toggleCommentIndented = function(cm) {\n      cm.toggleComment({ indent: true });\n    };\n    cmds.joinLines = function(cm) {\n      var ranges = cm.listSelections(), joined = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i], from = range2.from();\n        var start2 = from.line, end2 = range2.to().line;\n        while (i < ranges.length - 1 && ranges[i + 1].from().line == end2)\n          end2 = ranges[++i].to().line;\n        joined.push({ start: start2, end: end2, anchor: !range2.empty() && from });\n      }\n      cm.operation(function() {\n        var offset = 0, ranges2 = [];\n        for (var i2 = 0; i2 < joined.length; i2++) {\n          var obj = joined[i2];\n          var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n          for (var line = obj.start; line <= obj.end; line++) {\n            var actual = line - offset;\n            if (line == obj.end)\n              head = Pos(actual, cm.getLine(actual).length + 1);\n            if (actual < cm.lastLine()) {\n              cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n              ++offset;\n            }\n          }\n          ranges2.push({ anchor: anchor || head, head });\n        }\n        cm.setSelections(ranges2, 0);\n      });\n    };\n    cmds.duplicateLine = function(cm) {\n      cm.operation(function() {\n        var rangeCount = cm.listSelections().length;\n        for (var i = 0; i < rangeCount; i++) {\n          var range2 = cm.listSelections()[i];\n          if (range2.empty())\n            cm.replaceRange(cm.getLine(range2.head.line) + \"\\n\", Pos(range2.head.line, 0));\n          else\n            cm.replaceRange(cm.getRange(range2.from(), range2.to()), range2.from());\n        }\n        cm.scrollIntoView();\n      });\n    };\n    function sortLines(cm, caseSensitive, direction) {\n      if (cm.isReadOnly())\n        return CodeMirror.Pass;\n      var ranges = cm.listSelections(), toSort = [], selected;\n      for (var i = 0; i < ranges.length; i++) {\n        var range2 = ranges[i];\n        if (range2.empty())\n          continue;\n        var from = range2.from().line, to = range2.to().line;\n        while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n          to = ranges[++i].to().line;\n        if (!ranges[i].to().ch)\n          to--;\n        toSort.push(from, to);\n      }\n      if (toSort.length)\n        selected = true;\n      else\n        toSort.push(cm.firstLine(), cm.lastLine());\n      cm.operation(function() {\n        var ranges2 = [];\n        for (var i2 = 0; i2 < toSort.length; i2 += 2) {\n          var from2 = toSort[i2], to2 = toSort[i2 + 1];\n          var start2 = Pos(from2, 0), end2 = Pos(to2);\n          var lines = cm.getRange(start2, end2, false);\n          if (caseSensitive)\n            lines.sort(function(a, b) {\n              return a < b ? -direction : a == b ? 0 : direction;\n            });\n          else\n            lines.sort(function(a, b) {\n              var au = a.toUpperCase(), bu = b.toUpperCase();\n              if (au != bu) {\n                a = au;\n                b = bu;\n              }\n              return a < b ? -direction : a == b ? 0 : direction;\n            });\n          cm.replaceRange(lines, start2, end2);\n          if (selected)\n            ranges2.push({ anchor: start2, head: Pos(to2 + 1, 0) });\n        }\n        if (selected)\n          cm.setSelections(ranges2, 0);\n      });\n    }\n    cmds.sortLines = function(cm) {\n      sortLines(cm, true, 1);\n    };\n    cmds.reverseSortLines = function(cm) {\n      sortLines(cm, true, -1);\n    };\n    cmds.sortLinesInsensitive = function(cm) {\n      sortLines(cm, false, 1);\n    };\n    cmds.reverseSortLinesInsensitive = function(cm) {\n      sortLines(cm, false, -1);\n    };\n    cmds.nextBookmark = function(cm) {\n      var marks = cm.state.sublimeBookmarks;\n      if (marks)\n        while (marks.length) {\n          var current = marks.shift();\n          var found = current.find();\n          if (found) {\n            marks.push(current);\n            return cm.setSelection(found.from, found.to);\n          }\n        }\n    };\n    cmds.prevBookmark = function(cm) {\n      var marks = cm.state.sublimeBookmarks;\n      if (marks)\n        while (marks.length) {\n          marks.unshift(marks.pop());\n          var found = marks[marks.length - 1].find();\n          if (!found)\n            marks.pop();\n          else\n            return cm.setSelection(found.from, found.to);\n        }\n    };\n    cmds.toggleBookmark = function(cm) {\n      var ranges = cm.listSelections();\n      var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n      for (var i = 0; i < ranges.length; i++) {\n        var from = ranges[i].from(), to = ranges[i].to();\n        var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n        for (var j = 0; j < found.length; j++) {\n          if (found[j].sublimeBookmark) {\n            found[j].clear();\n            for (var k = 0; k < marks.length; k++)\n              if (marks[k] == found[j])\n                marks.splice(k--, 1);\n            break;\n          }\n        }\n        if (j == found.length)\n          marks.push(cm.markText(from, to, { sublimeBookmark: true, clearWhenEmpty: false }));\n      }\n    };\n    cmds.clearBookmarks = function(cm) {\n      var marks = cm.state.sublimeBookmarks;\n      if (marks)\n        for (var i = 0; i < marks.length; i++)\n          marks[i].clear();\n      marks.length = 0;\n    };\n    cmds.selectBookmarks = function(cm) {\n      var marks = cm.state.sublimeBookmarks, ranges = [];\n      if (marks)\n        for (var i = 0; i < marks.length; i++) {\n          var found = marks[i].find();\n          if (!found)\n            marks.splice(i--, 0);\n          else\n            ranges.push({ anchor: found.from, head: found.to });\n        }\n      if (ranges.length)\n        cm.setSelections(ranges, 0);\n    };\n    function modifyWordOrSelection(cm, mod) {\n      cm.operation(function() {\n        var ranges = cm.listSelections(), indices = [], replacements2 = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var range2 = ranges[i];\n          if (range2.empty()) {\n            indices.push(i);\n            replacements2.push(\"\");\n          } else\n            replacements2.push(mod(cm.getRange(range2.from(), range2.to())));\n        }\n        cm.replaceSelections(replacements2, \"around\", \"case\");\n        for (var i = indices.length - 1, at; i >= 0; i--) {\n          var range2 = ranges[indices[i]];\n          if (at && CodeMirror.cmpPos(range2.head, at) > 0)\n            continue;\n          var word2 = wordAt(cm, range2.head);\n          at = word2.from;\n          cm.replaceRange(mod(word2.word), word2.from, word2.to);\n        }\n      });\n    }\n    cmds.smartBackspace = function(cm) {\n      if (cm.somethingSelected())\n        return CodeMirror.Pass;\n      cm.operation(function() {\n        var cursors = cm.listSelections();\n        var indentUnit = cm.getOption(\"indentUnit\");\n        for (var i = cursors.length - 1; i >= 0; i--) {\n          var cursor = cursors[i].head;\n          var toStartOfLine = cm.getRange({ line: cursor.line, ch: 0 }, cursor);\n          var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n          var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n          if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n            var prevIndent = new Pos(cursor.line, CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n            if (prevIndent.ch != cursor.ch)\n              deletePos = prevIndent;\n          }\n          cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n        }\n      });\n    };\n    cmds.delLineRight = function(cm) {\n      cm.operation(function() {\n        var ranges = cm.listSelections();\n        for (var i = ranges.length - 1; i >= 0; i--)\n          cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n        cm.scrollIntoView();\n      });\n    };\n    cmds.upcaseAtCursor = function(cm) {\n      modifyWordOrSelection(cm, function(str) {\n        return str.toUpperCase();\n      });\n    };\n    cmds.downcaseAtCursor = function(cm) {\n      modifyWordOrSelection(cm, function(str) {\n        return str.toLowerCase();\n      });\n    };\n    cmds.setSublimeMark = function(cm) {\n      if (cm.state.sublimeMark)\n        cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n    };\n    cmds.selectToSublimeMark = function(cm) {\n      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n      if (found)\n        cm.setSelection(cm.getCursor(), found);\n    };\n    cmds.deleteToSublimeMark = function(cm) {\n      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n      if (found) {\n        var from = cm.getCursor(), to = found;\n        if (CodeMirror.cmpPos(from, to) > 0) {\n          var tmp = to;\n          to = from;\n          from = tmp;\n        }\n        cm.state.sublimeKilled = cm.getRange(from, to);\n        cm.replaceRange(\"\", from, to);\n      }\n    };\n    cmds.swapWithSublimeMark = function(cm) {\n      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n      if (found) {\n        cm.state.sublimeMark.clear();\n        cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n        cm.setCursor(found);\n      }\n    };\n    cmds.sublimeYank = function(cm) {\n      if (cm.state.sublimeKilled != null)\n        cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n    };\n    cmds.showInCenter = function(cm) {\n      var pos = cm.cursorCoords(null, \"local\");\n      cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n    };\n    function getTarget(cm) {\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (CodeMirror.cmpPos(from, to) == 0) {\n        var word2 = wordAt(cm, from);\n        if (!word2.word)\n          return;\n        from = word2.from;\n        to = word2.to;\n      }\n      return { from, to, query: cm.getRange(from, to), word: word2 };\n    }\n    function findAndGoTo(cm, forward) {\n      var target2 = getTarget(cm);\n      if (!target2)\n        return;\n      var query = target2.query;\n      var cur = cm.getSearchCursor(query, forward ? target2.to : target2.from);\n      if (forward ? cur.findNext() : cur.findPrevious()) {\n        cm.setSelection(cur.from(), cur.to());\n      } else {\n        cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));\n        if (forward ? cur.findNext() : cur.findPrevious())\n          cm.setSelection(cur.from(), cur.to());\n        else if (target2.word)\n          cm.setSelection(target2.from, target2.to);\n      }\n    }\n    cmds.findUnder = function(cm) {\n      findAndGoTo(cm, true);\n    };\n    cmds.findUnderPrevious = function(cm) {\n      findAndGoTo(cm, false);\n    };\n    cmds.findAllUnder = function(cm) {\n      var target2 = getTarget(cm);\n      if (!target2)\n        return;\n      var cur = cm.getSearchCursor(target2.query);\n      var matches = [];\n      var primaryIndex = -1;\n      while (cur.findNext()) {\n        matches.push({ anchor: cur.from(), head: cur.to() });\n        if (cur.from().line <= target2.from.line && cur.from().ch <= target2.from.ch)\n          primaryIndex++;\n      }\n      cm.setSelections(matches, primaryIndex);\n    };\n    var keyMap2 = CodeMirror.keyMap;\n    keyMap2.macSublime = {\n      \"Cmd-Left\": \"goLineStartSmart\",\n      \"Shift-Tab\": \"indentLess\",\n      \"Shift-Ctrl-K\": \"deleteLine\",\n      \"Alt-Q\": \"wrapLines\",\n      \"Ctrl-Left\": \"goSubwordLeft\",\n      \"Ctrl-Right\": \"goSubwordRight\",\n      \"Ctrl-Alt-Up\": \"scrollLineUp\",\n      \"Ctrl-Alt-Down\": \"scrollLineDown\",\n      \"Cmd-L\": \"selectLine\",\n      \"Shift-Cmd-L\": \"splitSelectionByLine\",\n      \"Esc\": \"singleSelectionTop\",\n      \"Cmd-Enter\": \"insertLineAfter\",\n      \"Shift-Cmd-Enter\": \"insertLineBefore\",\n      \"Cmd-D\": \"selectNextOccurrence\",\n      \"Shift-Cmd-Space\": \"selectScope\",\n      \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n      \"Cmd-M\": \"goToBracket\",\n      \"Cmd-Ctrl-Up\": \"swapLineUp\",\n      \"Cmd-Ctrl-Down\": \"swapLineDown\",\n      \"Cmd-/\": \"toggleCommentIndented\",\n      \"Cmd-J\": \"joinLines\",\n      \"Shift-Cmd-D\": \"duplicateLine\",\n      \"F5\": \"sortLines\",\n      \"Shift-F5\": \"reverseSortLines\",\n      \"Cmd-F5\": \"sortLinesInsensitive\",\n      \"Shift-Cmd-F5\": \"reverseSortLinesInsensitive\",\n      \"F2\": \"nextBookmark\",\n      \"Shift-F2\": \"prevBookmark\",\n      \"Cmd-F2\": \"toggleBookmark\",\n      \"Shift-Cmd-F2\": \"clearBookmarks\",\n      \"Alt-F2\": \"selectBookmarks\",\n      \"Backspace\": \"smartBackspace\",\n      \"Cmd-K Cmd-D\": \"skipAndSelectNextOccurrence\",\n      \"Cmd-K Cmd-K\": \"delLineRight\",\n      \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n      \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n      \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n      \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n      \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n      \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n      \"Cmd-K Cmd-Y\": \"sublimeYank\",\n      \"Cmd-K Cmd-C\": \"showInCenter\",\n      \"Cmd-K Cmd-G\": \"clearBookmarks\",\n      \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n      \"Cmd-K Cmd-1\": \"foldAll\",\n      \"Cmd-K Cmd-0\": \"unfoldAll\",\n      \"Cmd-K Cmd-J\": \"unfoldAll\",\n      \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n      \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n      \"Cmd-F3\": \"findUnder\",\n      \"Shift-Cmd-F3\": \"findUnderPrevious\",\n      \"Alt-F3\": \"findAllUnder\",\n      \"Shift-Cmd-[\": \"fold\",\n      \"Shift-Cmd-]\": \"unfold\",\n      \"Cmd-I\": \"findIncremental\",\n      \"Shift-Cmd-I\": \"findIncrementalReverse\",\n      \"Cmd-H\": \"replace\",\n      \"F3\": \"findNext\",\n      \"Shift-F3\": \"findPrev\",\n      \"fallthrough\": \"macDefault\"\n    };\n    CodeMirror.normalizeKeyMap(keyMap2.macSublime);\n    keyMap2.pcSublime = {\n      \"Shift-Tab\": \"indentLess\",\n      \"Shift-Ctrl-K\": \"deleteLine\",\n      \"Alt-Q\": \"wrapLines\",\n      \"Ctrl-T\": \"transposeChars\",\n      \"Alt-Left\": \"goSubwordLeft\",\n      \"Alt-Right\": \"goSubwordRight\",\n      \"Ctrl-Up\": \"scrollLineUp\",\n      \"Ctrl-Down\": \"scrollLineDown\",\n      \"Ctrl-L\": \"selectLine\",\n      \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n      \"Esc\": \"singleSelectionTop\",\n      \"Ctrl-Enter\": \"insertLineAfter\",\n      \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n      \"Ctrl-D\": \"selectNextOccurrence\",\n      \"Shift-Ctrl-Space\": \"selectScope\",\n      \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n      \"Ctrl-M\": \"goToBracket\",\n      \"Shift-Ctrl-Up\": \"swapLineUp\",\n      \"Shift-Ctrl-Down\": \"swapLineDown\",\n      \"Ctrl-/\": \"toggleCommentIndented\",\n      \"Ctrl-J\": \"joinLines\",\n      \"Shift-Ctrl-D\": \"duplicateLine\",\n      \"F9\": \"sortLines\",\n      \"Shift-F9\": \"reverseSortLines\",\n      \"Ctrl-F9\": \"sortLinesInsensitive\",\n      \"Shift-Ctrl-F9\": \"reverseSortLinesInsensitive\",\n      \"F2\": \"nextBookmark\",\n      \"Shift-F2\": \"prevBookmark\",\n      \"Ctrl-F2\": \"toggleBookmark\",\n      \"Shift-Ctrl-F2\": \"clearBookmarks\",\n      \"Alt-F2\": \"selectBookmarks\",\n      \"Backspace\": \"smartBackspace\",\n      \"Ctrl-K Ctrl-D\": \"skipAndSelectNextOccurrence\",\n      \"Ctrl-K Ctrl-K\": \"delLineRight\",\n      \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n      \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n      \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n      \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n      \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n      \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n      \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n      \"Ctrl-K Ctrl-C\": \"showInCenter\",\n      \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n      \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n      \"Ctrl-K Ctrl-1\": \"foldAll\",\n      \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n      \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n      \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n      \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n      \"Ctrl-F3\": \"findUnder\",\n      \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n      \"Alt-F3\": \"findAllUnder\",\n      \"Shift-Ctrl-[\": \"fold\",\n      \"Shift-Ctrl-]\": \"unfold\",\n      \"Ctrl-I\": \"findIncremental\",\n      \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n      \"Ctrl-H\": \"replace\",\n      \"F3\": \"findNext\",\n      \"Shift-F3\": \"findPrev\",\n      \"fallthrough\": \"pcDefault\"\n    };\n    CodeMirror.normalizeKeyMap(keyMap2.pcSublime);\n    var mac = keyMap2.default == keyMap2.macDefault;\n    keyMap2.sublime = mac ? keyMap2.macSublime : keyMap2.pcSublime;\n  });\n})();\nvar sublime = sublime$2.exports;\nvar sublime$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": sublime\n}, [sublime$2.exports]));\nvar comment$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    var noOptions = {};\n    var nonWS = /[^\\s\\u00a0]/;\n    var Pos = CodeMirror.Pos, cmp = CodeMirror.cmpPos;\n    function firstNonWS(str) {\n      var found = str.search(nonWS);\n      return found == -1 ? 0 : found;\n    }\n    CodeMirror.commands.toggleComment = function(cm) {\n      cm.toggleComment();\n    };\n    CodeMirror.defineExtension(\"toggleComment\", function(options) {\n      if (!options)\n        options = noOptions;\n      var cm = this;\n      var minLine = Infinity, ranges = this.listSelections(), mode2 = null;\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var from = ranges[i].from(), to = ranges[i].to();\n        if (from.line >= minLine)\n          continue;\n        if (to.line >= minLine)\n          to = Pos(minLine, 0);\n        minLine = from.line;\n        if (mode2 == null) {\n          if (cm.uncomment(from, to, options))\n            mode2 = \"un\";\n          else {\n            cm.lineComment(from, to, options);\n            mode2 = \"line\";\n          }\n        } else if (mode2 == \"un\") {\n          cm.uncomment(from, to, options);\n        } else {\n          cm.lineComment(from, to, options);\n        }\n      }\n    });\n    function probablyInsideString(cm, pos, line) {\n      return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line);\n    }\n    function getMode(cm, pos) {\n      var mode2 = cm.getMode();\n      return mode2.useInnerComments === false || !mode2.innerMode ? mode2 : cm.getModeAt(pos);\n    }\n    CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self2 = this, mode2 = getMode(self2, from);\n      var firstLine = self2.getLine(from.line);\n      if (firstLine == null || probablyInsideString(self2, from, firstLine))\n        return;\n      var commentString = options.lineComment || mode2.lineComment;\n      if (!commentString) {\n        if (options.blockCommentStart || mode2.blockCommentStart) {\n          options.fullLines = true;\n          self2.blockComment(from, to, options);\n        }\n        return;\n      }\n      var end2 = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self2.lastLine() + 1);\n      var pad = options.padding == null ? \" \" : options.padding;\n      var blankLines = options.commentBlankLines || from.line == to.line;\n      self2.operation(function() {\n        if (options.indent) {\n          var baseString = null;\n          for (var i = from.line; i < end2; ++i) {\n            var line = self2.getLine(i);\n            var whitespace = line.slice(0, firstNonWS(line));\n            if (baseString == null || baseString.length > whitespace.length) {\n              baseString = whitespace;\n            }\n          }\n          for (var i = from.line; i < end2; ++i) {\n            var line = self2.getLine(i), cut = baseString.length;\n            if (!blankLines && !nonWS.test(line))\n              continue;\n            if (line.slice(0, cut) != baseString)\n              cut = firstNonWS(line);\n            self2.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n          }\n        } else {\n          for (var i = from.line; i < end2; ++i) {\n            if (blankLines || nonWS.test(self2.getLine(i)))\n              self2.replaceRange(commentString + pad, Pos(i, 0));\n          }\n        }\n      });\n    });\n    CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self2 = this, mode2 = getMode(self2, from);\n      var startString = options.blockCommentStart || mode2.blockCommentStart;\n      var endString = options.blockCommentEnd || mode2.blockCommentEnd;\n      if (!startString || !endString) {\n        if ((options.lineComment || mode2.lineComment) && options.fullLines != false)\n          self2.lineComment(from, to, options);\n        return;\n      }\n      if (/\\bcomment\\b/.test(self2.getTokenTypeAt(Pos(from.line, 0))))\n        return;\n      var end2 = Math.min(to.line, self2.lastLine());\n      if (end2 != from.line && to.ch == 0 && nonWS.test(self2.getLine(end2)))\n        --end2;\n      var pad = options.padding == null ? \" \" : options.padding;\n      if (from.line > end2)\n        return;\n      self2.operation(function() {\n        if (options.fullLines != false) {\n          var lastLineHasText = nonWS.test(self2.getLine(end2));\n          self2.replaceRange(pad + endString, Pos(end2));\n          self2.replaceRange(startString + pad, Pos(from.line, 0));\n          var lead = options.blockCommentLead || mode2.blockCommentLead;\n          if (lead != null) {\n            for (var i = from.line + 1; i <= end2; ++i)\n              if (i != end2 || lastLineHasText)\n                self2.replaceRange(lead + pad, Pos(i, 0));\n          }\n        } else {\n          var atCursor = cmp(self2.getCursor(\"to\"), to) == 0, empty2 = !self2.somethingSelected();\n          self2.replaceRange(endString, to);\n          if (atCursor)\n            self2.setSelection(empty2 ? to : self2.getCursor(\"from\"), to);\n          self2.replaceRange(startString, from);\n        }\n      });\n    });\n    CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n      if (!options)\n        options = noOptions;\n      var self2 = this, mode2 = getMode(self2, from);\n      var end2 = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self2.lastLine()), start2 = Math.min(from.line, end2);\n      var lineString = options.lineComment || mode2.lineComment, lines = [];\n      var pad = options.padding == null ? \" \" : options.padding, didSomething;\n      lineComment: {\n        if (!lineString)\n          break lineComment;\n        for (var i = start2; i <= end2; ++i) {\n          var line = self2.getLine(i);\n          var found = line.indexOf(lineString);\n          if (found > -1 && !/comment/.test(self2.getTokenTypeAt(Pos(i, found + 1))))\n            found = -1;\n          if (found == -1 && nonWS.test(line))\n            break lineComment;\n          if (found > -1 && nonWS.test(line.slice(0, found)))\n            break lineComment;\n          lines.push(line);\n        }\n        self2.operation(function() {\n          for (var i2 = start2; i2 <= end2; ++i2) {\n            var line2 = lines[i2 - start2];\n            var pos = line2.indexOf(lineString), endPos = pos + lineString.length;\n            if (pos < 0)\n              continue;\n            if (line2.slice(endPos, endPos + pad.length) == pad)\n              endPos += pad.length;\n            didSomething = true;\n            self2.replaceRange(\"\", Pos(i2, pos), Pos(i2, endPos));\n          }\n        });\n        if (didSomething)\n          return true;\n      }\n      var startString = options.blockCommentStart || mode2.blockCommentStart;\n      var endString = options.blockCommentEnd || mode2.blockCommentEnd;\n      if (!startString || !endString)\n        return false;\n      var lead = options.blockCommentLead || mode2.blockCommentLead;\n      var startLine = self2.getLine(start2), open = startLine.indexOf(startString);\n      if (open == -1)\n        return false;\n      var endLine = end2 == start2 ? startLine : self2.getLine(end2);\n      var close = endLine.indexOf(endString, end2 == start2 ? open + startString.length : 0);\n      var insideStart = Pos(start2, open + 1), insideEnd = Pos(end2, close + 1);\n      if (close == -1 || !/comment/.test(self2.getTokenTypeAt(insideStart)) || !/comment/.test(self2.getTokenTypeAt(insideEnd)) || self2.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n        return false;\n      var lastStart = startLine.lastIndexOf(startString, from.ch);\n      var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n      if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch)\n        return false;\n      firstEnd = endLine.indexOf(endString, to.ch);\n      var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n      lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;\n      if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch)\n        return false;\n      self2.operation(function() {\n        self2.replaceRange(\"\", Pos(end2, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end2, close + endString.length));\n        var openEnd = open + startString.length;\n        if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad)\n          openEnd += pad.length;\n        self2.replaceRange(\"\", Pos(start2, open), Pos(start2, openEnd));\n        if (lead)\n          for (var i2 = start2 + 1; i2 <= end2; ++i2) {\n            var line2 = self2.getLine(i2), found2 = line2.indexOf(lead);\n            if (found2 == -1 || nonWS.test(line2.slice(0, found2)))\n              continue;\n            var foundEnd = found2 + lead.length;\n            if (pad && line2.slice(foundEnd, foundEnd + pad.length) == pad)\n              foundEnd += pad.length;\n            self2.replaceRange(\"\", Pos(i2, found2), Pos(i2, foundEnd));\n          }\n      });\n      return true;\n    });\n  });\n})();\nvar comment = comment$2.exports;\nvar comment$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": comment\n}, [comment$2.exports]));\nvar search$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports, searchcursor$2.exports, dialog$2.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineOption(\"search\", { bottom: false });\n    function searchOverlay(query, caseInsensitive) {\n      if (typeof query == \"string\")\n        query = new RegExp(query.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\"), caseInsensitive ? \"gi\" : \"g\");\n      else if (!query.global)\n        query = new RegExp(query.source, query.ignoreCase ? \"gi\" : \"g\");\n      return { token: function(stream) {\n        query.lastIndex = stream.pos;\n        var match2 = query.exec(stream.string);\n        if (match2 && match2.index == stream.pos) {\n          stream.pos += match2[0].length || 1;\n          return \"searching\";\n        } else if (match2) {\n          stream.pos = match2.index;\n        } else {\n          stream.skipToEnd();\n        }\n      } };\n    }\n    function SearchState() {\n      this.posFrom = this.posTo = this.lastQuery = this.query = null;\n      this.overlay = null;\n    }\n    function getSearchState(cm) {\n      return cm.state.search || (cm.state.search = new SearchState());\n    }\n    function queryCaseInsensitive(query) {\n      return typeof query == \"string\" && query == query.toLowerCase();\n    }\n    function getSearchCursor(cm, query, pos) {\n      return cm.getSearchCursor(query, pos, { caseFold: queryCaseInsensitive(query), multiline: true });\n    }\n    function persistentDialog(cm, text3, deflt, onEnter, onKeyDown2) {\n      cm.openDialog(text3, onEnter, {\n        value: deflt,\n        selectValueOnOpen: true,\n        closeOnEnter: false,\n        onClose: function() {\n          clearSearch(cm);\n        },\n        onKeyDown: onKeyDown2,\n        bottom: cm.options.search.bottom\n      });\n    }\n    function dialog2(cm, text3, shortText, deflt, f) {\n      if (cm.openDialog)\n        cm.openDialog(text3, f, { value: deflt, selectValueOnOpen: true, bottom: cm.options.search.bottom });\n      else\n        f(prompt(shortText, deflt));\n    }\n    function confirmDialog(cm, text3, shortText, fs) {\n      if (cm.openConfirm)\n        cm.openConfirm(text3, fs);\n      else if (confirm(shortText))\n        fs[0]();\n    }\n    function parseString(string2) {\n      return string2.replace(/\\\\([nrt\\\\])/g, function(match2, ch2) {\n        if (ch2 == \"n\")\n          return \"\\n\";\n        if (ch2 == \"r\")\n          return \"\\r\";\n        if (ch2 == \"t\")\n          return \"\t\";\n        if (ch2 == \"\\\\\")\n          return \"\\\\\";\n        return match2;\n      });\n    }\n    function parseQuery2(query) {\n      var isRE = query.match(/^\\/(.*)\\/([a-z]*)$/);\n      if (isRE) {\n        try {\n          query = new RegExp(isRE[1], isRE[2].indexOf(\"i\") == -1 ? \"\" : \"i\");\n        } catch (e) {\n        }\n      } else {\n        query = parseString(query);\n      }\n      if (typeof query == \"string\" ? query == \"\" : query.test(\"\"))\n        query = /x^/;\n      return query;\n    }\n    function startSearch(cm, state, query) {\n      state.queryText = query;\n      state.query = parseQuery2(query);\n      cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));\n      state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));\n      cm.addOverlay(state.overlay);\n      if (cm.showMatchesOnScrollbar) {\n        if (state.annotate) {\n          state.annotate.clear();\n          state.annotate = null;\n        }\n        state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));\n      }\n    }\n    function doSearch(cm, rev, persistent, immediate) {\n      var state = getSearchState(cm);\n      if (state.query)\n        return findNext(cm, rev);\n      var q2 = cm.getSelection() || state.lastQuery;\n      if (q2 instanceof RegExp && q2.source == \"x^\")\n        q2 = null;\n      if (persistent && cm.openDialog) {\n        var hiding = null;\n        var searchNext = function(query, event) {\n          CodeMirror.e_stop(event);\n          if (!query)\n            return;\n          if (query != state.queryText) {\n            startSearch(cm, state, query);\n            state.posFrom = state.posTo = cm.getCursor();\n          }\n          if (hiding)\n            hiding.style.opacity = 1;\n          findNext(cm, event.shiftKey, function(_, to) {\n            var dialog3;\n            if (to.line < 3 && document.querySelector && (dialog3 = cm.display.wrapper.querySelector(\".CodeMirror-dialog\")) && dialog3.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, \"window\").top)\n              (hiding = dialog3).style.opacity = 0.4;\n          });\n        };\n        persistentDialog(cm, getQueryDialog(cm), q2, searchNext, function(event, query) {\n          var keyName = CodeMirror.keyName(event);\n          var extra = cm.getOption(\"extraKeys\"), cmd = extra && extra[keyName] || CodeMirror.keyMap[cm.getOption(\"keyMap\")][keyName];\n          if (cmd == \"findNext\" || cmd == \"findPrev\" || cmd == \"findPersistentNext\" || cmd == \"findPersistentPrev\") {\n            CodeMirror.e_stop(event);\n            startSearch(cm, getSearchState(cm), query);\n            cm.execCommand(cmd);\n          } else if (cmd == \"find\" || cmd == \"findPersistent\") {\n            CodeMirror.e_stop(event);\n            searchNext(query, event);\n          }\n        });\n        if (immediate && q2) {\n          startSearch(cm, state, q2);\n          findNext(cm, rev);\n        }\n      } else {\n        dialog2(cm, getQueryDialog(cm), \"Search for:\", q2, function(query) {\n          if (query && !state.query)\n            cm.operation(function() {\n              startSearch(cm, state, query);\n              state.posFrom = state.posTo = cm.getCursor();\n              findNext(cm, rev);\n            });\n        });\n      }\n    }\n    function findNext(cm, rev, callback) {\n      cm.operation(function() {\n        var state = getSearchState(cm);\n        var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);\n        if (!cursor.find(rev)) {\n          cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));\n          if (!cursor.find(rev))\n            return;\n        }\n        cm.setSelection(cursor.from(), cursor.to());\n        cm.scrollIntoView({ from: cursor.from(), to: cursor.to() }, 20);\n        state.posFrom = cursor.from();\n        state.posTo = cursor.to();\n        if (callback)\n          callback(cursor.from(), cursor.to());\n      });\n    }\n    function clearSearch(cm) {\n      cm.operation(function() {\n        var state = getSearchState(cm);\n        state.lastQuery = state.query;\n        if (!state.query)\n          return;\n        state.query = state.queryText = null;\n        cm.removeOverlay(state.overlay);\n        if (state.annotate) {\n          state.annotate.clear();\n          state.annotate = null;\n        }\n      });\n    }\n    function el2(tag, attrs) {\n      var element = tag ? document.createElement(tag) : document.createDocumentFragment();\n      for (var key in attrs) {\n        element[key] = attrs[key];\n      }\n      for (var i = 2; i < arguments.length; i++) {\n        var child = arguments[i];\n        element.appendChild(typeof child == \"string\" ? document.createTextNode(child) : child);\n      }\n      return element;\n    }\n    function getQueryDialog(cm) {\n      return el2(\"\", null, el2(\"span\", { className: \"CodeMirror-search-label\" }, cm.phrase(\"Search:\")), \" \", el2(\"input\", { type: \"text\", \"style\": \"width: 10em\", className: \"CodeMirror-search-field\" }), \" \", el2(\"span\", { style: \"color: #888\", className: \"CodeMirror-search-hint\" }, cm.phrase(\"(Use /re/ syntax for regexp search)\")));\n    }\n    function getReplaceQueryDialog(cm) {\n      return el2(\"\", null, \" \", el2(\"input\", { type: \"text\", \"style\": \"width: 10em\", className: \"CodeMirror-search-field\" }), \" \", el2(\"span\", { style: \"color: #888\", className: \"CodeMirror-search-hint\" }, cm.phrase(\"(Use /re/ syntax for regexp search)\")));\n    }\n    function getReplacementQueryDialog(cm) {\n      return el2(\"\", null, el2(\"span\", { className: \"CodeMirror-search-label\" }, cm.phrase(\"With:\")), \" \", el2(\"input\", { type: \"text\", \"style\": \"width: 10em\", className: \"CodeMirror-search-field\" }));\n    }\n    function getDoReplaceConfirm(cm) {\n      return el2(\"\", null, el2(\"span\", { className: \"CodeMirror-search-label\" }, cm.phrase(\"Replace?\")), \" \", el2(\"button\", {}, cm.phrase(\"Yes\")), \" \", el2(\"button\", {}, cm.phrase(\"No\")), \" \", el2(\"button\", {}, cm.phrase(\"All\")), \" \", el2(\"button\", {}, cm.phrase(\"Stop\")));\n    }\n    function replaceAll(cm, query, text3) {\n      cm.operation(function() {\n        for (var cursor = getSearchCursor(cm, query); cursor.findNext(); ) {\n          if (typeof query != \"string\") {\n            var match2 = cm.getRange(cursor.from(), cursor.to()).match(query);\n            cursor.replace(text3.replace(/\\$(\\d)/g, function(_, i) {\n              return match2[i];\n            }));\n          } else\n            cursor.replace(text3);\n        }\n      });\n    }\n    function replace2(cm, all) {\n      if (cm.getOption(\"readOnly\"))\n        return;\n      var query = cm.getSelection() || getSearchState(cm).lastQuery;\n      var dialogText = all ? cm.phrase(\"Replace all:\") : cm.phrase(\"Replace:\");\n      var fragment = el2(\"\", null, el2(\"span\", { className: \"CodeMirror-search-label\" }, dialogText), getReplaceQueryDialog(cm));\n      dialog2(cm, fragment, dialogText, query, function(query2) {\n        if (!query2)\n          return;\n        query2 = parseQuery2(query2);\n        dialog2(cm, getReplacementQueryDialog(cm), cm.phrase(\"Replace with:\"), \"\", function(text3) {\n          text3 = parseString(text3);\n          if (all) {\n            replaceAll(cm, query2, text3);\n          } else {\n            clearSearch(cm);\n            var cursor = getSearchCursor(cm, query2, cm.getCursor(\"from\"));\n            var advance = function() {\n              var start2 = cursor.from(), match2;\n              if (!(match2 = cursor.findNext())) {\n                cursor = getSearchCursor(cm, query2);\n                if (!(match2 = cursor.findNext()) || start2 && cursor.from().line == start2.line && cursor.from().ch == start2.ch)\n                  return;\n              }\n              cm.setSelection(cursor.from(), cursor.to());\n              cm.scrollIntoView({ from: cursor.from(), to: cursor.to() });\n              confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase(\"Replace?\"), [\n                function() {\n                  doReplace(match2);\n                },\n                advance,\n                function() {\n                  replaceAll(cm, query2, text3);\n                }\n              ]);\n            };\n            var doReplace = function(match2) {\n              cursor.replace(typeof query2 == \"string\" ? text3 : text3.replace(/\\$(\\d)/g, function(_, i) {\n                return match2[i];\n              }));\n              advance();\n            };\n            advance();\n          }\n        });\n      });\n    }\n    CodeMirror.commands.find = function(cm) {\n      clearSearch(cm);\n      doSearch(cm);\n    };\n    CodeMirror.commands.findPersistent = function(cm) {\n      clearSearch(cm);\n      doSearch(cm, false, true);\n    };\n    CodeMirror.commands.findPersistentNext = function(cm) {\n      doSearch(cm, false, true, true);\n    };\n    CodeMirror.commands.findPersistentPrev = function(cm) {\n      doSearch(cm, true, true, true);\n    };\n    CodeMirror.commands.findNext = doSearch;\n    CodeMirror.commands.findPrev = function(cm) {\n      doSearch(cm, true);\n    };\n    CodeMirror.commands.clearSearch = clearSearch;\n    CodeMirror.commands.replace = replace2;\n    CodeMirror.commands.replaceAll = function(cm) {\n      replace2(cm, true);\n    };\n  });\n})();\nvar search = search$2.exports;\nvar search$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": search\n}, [search$2.exports]));\nvar hint$3 = {};\nvar require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(esm);\nvar __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(hint$3, \"__esModule\", { value: true });\nvar codemirror_1$a = __importDefault$c(codemirror$2.exports);\nvar graphql_language_service_1$4 = require$$1$1;\ncodemirror_1$a.default.registerHelper(\"hint\", \"graphql\", function(editor, options) {\n  var schema = options.schema;\n  if (!schema) {\n    return;\n  }\n  var cur = editor.getCursor();\n  var token2 = editor.getTokenAt(cur);\n  var tokenStart = token2.type !== null && /\"|\\w/.test(token2.string[0]) ? token2.start : token2.end;\n  var position = new graphql_language_service_1$4.Position(cur.line, tokenStart);\n  var rawResults = graphql_language_service_1$4.getAutocompleteSuggestions(schema, editor.getValue(), position, token2, options.externalFragments);\n  var results = {\n    list: rawResults.map(function(item) {\n      return {\n        text: item.label,\n        type: item.type,\n        description: item.documentation,\n        isDeprecated: item.isDeprecated,\n        deprecationReason: item.deprecationReason\n      };\n    }),\n    from: { line: cur.line, ch: tokenStart },\n    to: { line: cur.line, ch: token2.end }\n  };\n  if (results && results.list && results.list.length > 0) {\n    results.from = codemirror_1$a.default.Pos(results.from.line, results.from.ch);\n    results.to = codemirror_1$a.default.Pos(results.to.line, results.to.ch);\n    codemirror_1$a.default.signal(editor, \"hasCompletion\", editor, results, token2);\n  }\n  return results;\n});\nvar hint$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": hint$3\n}, [hint$3]));\nvar lint$3 = {};\nvar __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(lint$3, \"__esModule\", { value: true });\nvar codemirror_1$9 = __importDefault$b(codemirror$2.exports);\nvar graphql_language_service_1$3 = require$$1$1;\nvar SEVERITY = [\"error\", \"warning\", \"information\", \"hint\"];\nvar TYPE = {\n  \"GraphQL: Validation\": \"validation\",\n  \"GraphQL: Deprecation\": \"deprecation\",\n  \"GraphQL: Syntax\": \"syntax\"\n};\ncodemirror_1$9.default.registerHelper(\"lint\", \"graphql\", function(text3, options) {\n  var schema = options.schema;\n  var rawResults = graphql_language_service_1$3.getDiagnostics(text3, schema, options.validationRules, void 0, options.externalFragments);\n  var results = rawResults.map(function(error2) {\n    return {\n      message: error2.message,\n      severity: error2.severity ? SEVERITY[error2.severity - 1] : SEVERITY[0],\n      type: error2.source ? TYPE[error2.source] : void 0,\n      from: codemirror_1$9.default.Pos(error2.range.start.line, error2.range.start.character),\n      to: codemirror_1$9.default.Pos(error2.range.end.line, error2.range.end.character)\n    };\n  });\n  return results;\n});\nvar lint$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": lint$3\n}, [lint$3]));\nvar info$1 = {};\nvar getTypeInfo$2 = {};\nvar require$$1 = /* @__PURE__ */ getAugmentedNamespace(introspection);\nvar forEachState$1 = {};\nObject.defineProperty(forEachState$1, \"__esModule\", { value: true });\nfunction forEachState(stack, fn) {\n  var reverseStateStack = [];\n  var state = stack;\n  while (state && state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (var i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\nforEachState$1.default = forEachState;\nvar __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(getTypeInfo$2, \"__esModule\", { value: true });\nvar graphql_1$4 = require$$1$2;\nvar introspection_1 = require$$1;\nvar forEachState_1$1 = __importDefault$a(forEachState$1);\nfunction getTypeInfo$1(schema, tokenState) {\n  var info2 = {\n    schema,\n    type: null,\n    parentType: null,\n    inputType: null,\n    directiveDef: null,\n    fieldDef: null,\n    argDef: null,\n    argDefs: null,\n    objectFieldDefs: null\n  };\n  forEachState_1$1.default(tokenState, function(state) {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n        info2.type = schema.getQueryType();\n        break;\n      case \"Mutation\":\n        info2.type = schema.getMutationType();\n        break;\n      case \"Subscription\":\n        info2.type = schema.getSubscriptionType();\n        break;\n      case \"InlineFragment\":\n      case \"FragmentDefinition\":\n        if (state.type) {\n          info2.type = schema.getType(state.type);\n        }\n        break;\n      case \"Field\":\n      case \"AliasedField\":\n        info2.fieldDef = info2.type && state.name ? getFieldDef(schema, info2.parentType, state.name) : null;\n        info2.type = info2.fieldDef && info2.fieldDef.type;\n        break;\n      case \"SelectionSet\":\n        info2.parentType = info2.type ? graphql_1$4.getNamedType(info2.type) : null;\n        break;\n      case \"Directive\":\n        info2.directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case \"Arguments\":\n        var parentDef = state.prevState ? state.prevState.kind === \"Field\" ? info2.fieldDef : state.prevState.kind === \"Directive\" ? info2.directiveDef : state.prevState.kind === \"AliasedField\" ? state.prevState.name && getFieldDef(schema, info2.parentType, state.prevState.name) : null : null;\n        info2.argDefs = parentDef ? parentDef.args : null;\n        break;\n      case \"Argument\":\n        info2.argDef = null;\n        if (info2.argDefs) {\n          for (var i = 0; i < info2.argDefs.length; i++) {\n            if (info2.argDefs[i].name === state.name) {\n              info2.argDef = info2.argDefs[i];\n              break;\n            }\n          }\n        }\n        info2.inputType = info2.argDef && info2.argDef.type;\n        break;\n      case \"EnumValue\":\n        var enumType = info2.inputType ? graphql_1$4.getNamedType(info2.inputType) : null;\n        info2.enumValue = enumType instanceof graphql_1$4.GraphQLEnumType ? find(enumType.getValues(), function(val) {\n          return val.value === state.name;\n        }) : null;\n        break;\n      case \"ListValue\":\n        var nullableType = info2.inputType ? graphql_1$4.getNullableType(info2.inputType) : null;\n        info2.inputType = nullableType instanceof graphql_1$4.GraphQLList ? nullableType.ofType : null;\n        break;\n      case \"ObjectValue\":\n        var objectType = info2.inputType ? graphql_1$4.getNamedType(info2.inputType) : null;\n        info2.objectFieldDefs = objectType instanceof graphql_1$4.GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case \"ObjectField\":\n        var objectField = state.name && info2.objectFieldDefs ? info2.objectFieldDefs[state.name] : null;\n        info2.inputType = objectField && objectField.type;\n        break;\n      case \"NamedType\":\n        info2.type = state.name ? schema.getType(state.name) : null;\n        break;\n    }\n  });\n  return info2;\n}\ngetTypeInfo$2.default = getTypeInfo$1;\nfunction getFieldDef(schema, type2, fieldName) {\n  if (fieldName === introspection_1.SchemaMetaFieldDef.name && schema.getQueryType() === type2) {\n    return introspection_1.SchemaMetaFieldDef;\n  }\n  if (fieldName === introspection_1.TypeMetaFieldDef.name && schema.getQueryType() === type2) {\n    return introspection_1.TypeMetaFieldDef;\n  }\n  if (fieldName === introspection_1.TypeNameMetaFieldDef.name && graphql_1$4.isCompositeType(type2)) {\n    return introspection_1.TypeNameMetaFieldDef;\n  }\n  if (type2 && type2.getFields) {\n    return type2.getFields()[fieldName];\n  }\n}\nfunction find(array, predicate) {\n  for (var i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return array[i];\n    }\n  }\n}\nvar SchemaReference = {};\nObject.defineProperty(SchemaReference, \"__esModule\", { value: true });\nSchemaReference.getTypeReference = SchemaReference.getEnumValueReference = SchemaReference.getArgumentReference = SchemaReference.getDirectiveReference = SchemaReference.getFieldReference = void 0;\nvar graphql_1$3 = require$$1$2;\nfunction getFieldReference(typeInfo) {\n  return {\n    kind: \"Field\",\n    schema: typeInfo.schema,\n    field: typeInfo.fieldDef,\n    type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType\n  };\n}\nSchemaReference.getFieldReference = getFieldReference;\nfunction getDirectiveReference(typeInfo) {\n  return {\n    kind: \"Directive\",\n    schema: typeInfo.schema,\n    directive: typeInfo.directiveDef\n  };\n}\nSchemaReference.getDirectiveReference = getDirectiveReference;\nfunction getArgumentReference(typeInfo) {\n  return typeInfo.directiveDef ? {\n    kind: \"Argument\",\n    schema: typeInfo.schema,\n    argument: typeInfo.argDef,\n    directive: typeInfo.directiveDef\n  } : {\n    kind: \"Argument\",\n    schema: typeInfo.schema,\n    argument: typeInfo.argDef,\n    field: typeInfo.fieldDef,\n    type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType\n  };\n}\nSchemaReference.getArgumentReference = getArgumentReference;\nfunction getEnumValueReference(typeInfo) {\n  return {\n    kind: \"EnumValue\",\n    value: typeInfo.enumValue || void 0,\n    type: typeInfo.inputType ? graphql_1$3.getNamedType(typeInfo.inputType) : void 0\n  };\n}\nSchemaReference.getEnumValueReference = getEnumValueReference;\nfunction getTypeReference(typeInfo, type2) {\n  return {\n    kind: \"Type\",\n    schema: typeInfo.schema,\n    type: type2 || typeInfo.type\n  };\n}\nSchemaReference.getTypeReference = getTypeReference;\nfunction isMetaField(fieldDef) {\n  return fieldDef.name.slice(0, 2) === \"__\";\n}\nvar infoAddon$1 = {};\nvar __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(infoAddon$1, \"__esModule\", { value: true });\nvar codemirror_1$8 = __importDefault$9(codemirror$2.exports);\ncodemirror_1$8.default.defineOption(\"info\", false, function(cm, options, old) {\n  if (old && old !== codemirror_1$8.default.Init) {\n    var oldOnMouseOver = cm.state.info.onMouseOver;\n    codemirror_1$8.default.off(cm.getWrapperElement(), \"mouseover\", oldOnMouseOver);\n    clearTimeout(cm.state.info.hoverTimeout);\n    delete cm.state.info;\n  }\n  if (options) {\n    var state = cm.state.info = createState(options);\n    state.onMouseOver = onMouseOver$1.bind(null, cm);\n    codemirror_1$8.default.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n  }\n});\nfunction createState(options) {\n  return {\n    options: options instanceof Function ? { render: options } : options === true ? {} : options\n  };\n}\nfunction getHoverTime(cm) {\n  var options = cm.state.info.options;\n  return options && options.hoverTime || 500;\n}\nfunction onMouseOver$1(cm, e) {\n  var state = cm.state.info;\n  var target2 = e.target || e.srcElement;\n  if (!(target2 instanceof HTMLElement)) {\n    return;\n  }\n  if (target2.nodeName !== \"SPAN\" || state.hoverTimeout !== void 0) {\n    return;\n  }\n  var box = target2.getBoundingClientRect();\n  var onMouseMove = function() {\n    clearTimeout(state.hoverTimeout);\n    state.hoverTimeout = setTimeout(onHover, hoverTime);\n  };\n  var onMouseOut2 = function() {\n    codemirror_1$8.default.off(document, \"mousemove\", onMouseMove);\n    codemirror_1$8.default.off(cm.getWrapperElement(), \"mouseout\", onMouseOut2);\n    clearTimeout(state.hoverTimeout);\n    state.hoverTimeout = void 0;\n  };\n  var onHover = function() {\n    codemirror_1$8.default.off(document, \"mousemove\", onMouseMove);\n    codemirror_1$8.default.off(cm.getWrapperElement(), \"mouseout\", onMouseOut2);\n    state.hoverTimeout = void 0;\n    onMouseHover(cm, box);\n  };\n  var hoverTime = getHoverTime(cm);\n  state.hoverTimeout = setTimeout(onHover, hoverTime);\n  codemirror_1$8.default.on(document, \"mousemove\", onMouseMove);\n  codemirror_1$8.default.on(cm.getWrapperElement(), \"mouseout\", onMouseOut2);\n}\nfunction onMouseHover(cm, box) {\n  var pos = cm.coordsChar({\n    left: (box.left + box.right) / 2,\n    top: (box.top + box.bottom) / 2\n  });\n  var state = cm.state.info;\n  var options = state.options;\n  var render = options.render || cm.getHelper(pos, \"info\");\n  if (render) {\n    var token2 = cm.getTokenAt(pos, true);\n    if (token2) {\n      var info2 = render(token2, options, cm, pos);\n      if (info2) {\n        showPopup(cm, box, info2);\n      }\n    }\n  }\n}\nfunction showPopup(cm, box, info2) {\n  var popup = document.createElement(\"div\");\n  popup.className = \"CodeMirror-info\";\n  popup.appendChild(info2);\n  document.body.appendChild(popup);\n  var popupBox = popup.getBoundingClientRect();\n  var popupStyle = window.getComputedStyle(popup);\n  var popupWidth = popupBox.right - popupBox.left + parseFloat(popupStyle.marginLeft) + parseFloat(popupStyle.marginRight);\n  var popupHeight = popupBox.bottom - popupBox.top + parseFloat(popupStyle.marginTop) + parseFloat(popupStyle.marginBottom);\n  var topPos = box.bottom;\n  if (popupHeight > window.innerHeight - box.bottom - 15 && box.top > window.innerHeight - box.bottom) {\n    topPos = box.top - popupHeight;\n  }\n  if (topPos < 0) {\n    topPos = box.bottom;\n  }\n  var leftPos = Math.max(0, window.innerWidth - popupWidth - 15);\n  if (leftPos > box.left) {\n    leftPos = box.left;\n  }\n  popup.style.opacity = \"1\";\n  popup.style.top = topPos + \"px\";\n  popup.style.left = leftPos + \"px\";\n  var popupTimeout;\n  var onMouseOverPopup = function() {\n    clearTimeout(popupTimeout);\n  };\n  var onMouseOut2 = function() {\n    clearTimeout(popupTimeout);\n    popupTimeout = setTimeout(hidePopup, 200);\n  };\n  var hidePopup = function() {\n    codemirror_1$8.default.off(popup, \"mouseover\", onMouseOverPopup);\n    codemirror_1$8.default.off(popup, \"mouseout\", onMouseOut2);\n    codemirror_1$8.default.off(cm.getWrapperElement(), \"mouseout\", onMouseOut2);\n    if (popup.style.opacity) {\n      popup.style.opacity = \"0\";\n      setTimeout(function() {\n        if (popup.parentNode) {\n          popup.parentNode.removeChild(popup);\n        }\n      }, 600);\n    } else if (popup.parentNode) {\n      popup.parentNode.removeChild(popup);\n    }\n  };\n  codemirror_1$8.default.on(popup, \"mouseover\", onMouseOverPopup);\n  codemirror_1$8.default.on(popup, \"mouseout\", onMouseOut2);\n  codemirror_1$8.default.on(cm.getWrapperElement(), \"mouseout\", onMouseOut2);\n}\nvar infoAddon = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": infoAddon$1\n}, [infoAddon$1]));\nvar __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(info$1, \"__esModule\", { value: true });\nvar graphql_1$2 = require$$1$2;\nvar codemirror_1$7 = __importDefault$8(codemirror$2.exports);\nvar getTypeInfo_1$1 = __importDefault$8(getTypeInfo$2);\nvar SchemaReference_1$1 = SchemaReference;\ncodemirror_1$7.default.registerHelper(\"info\", \"graphql\", function(token2, options) {\n  if (!options.schema || !token2.state) {\n    return;\n  }\n  var state = token2.state;\n  var kind2 = state.kind;\n  var step = state.step;\n  var typeInfo = getTypeInfo_1$1.default(options.schema, token2.state);\n  if (kind2 === \"Field\" && step === 0 && typeInfo.fieldDef || kind2 === \"AliasedField\" && step === 2 && typeInfo.fieldDef) {\n    var into = document.createElement(\"div\");\n    renderField(into, typeInfo, options);\n    renderDescription(into, options, typeInfo.fieldDef);\n    return into;\n  } else if (kind2 === \"Directive\" && step === 1 && typeInfo.directiveDef) {\n    var into = document.createElement(\"div\");\n    renderDirective(into, typeInfo, options);\n    renderDescription(into, options, typeInfo.directiveDef);\n    return into;\n  } else if (kind2 === \"Argument\" && step === 0 && typeInfo.argDef) {\n    var into = document.createElement(\"div\");\n    renderArg(into, typeInfo, options);\n    renderDescription(into, options, typeInfo.argDef);\n    return into;\n  } else if (kind2 === \"EnumValue\" && typeInfo.enumValue && typeInfo.enumValue.description) {\n    var into = document.createElement(\"div\");\n    renderEnumValue(into, typeInfo, options);\n    renderDescription(into, options, typeInfo.enumValue);\n    return into;\n  } else if (kind2 === \"NamedType\" && typeInfo.type && typeInfo.type.description) {\n    var into = document.createElement(\"div\");\n    renderType(into, typeInfo, options, typeInfo.type);\n    renderDescription(into, options, typeInfo.type);\n    return into;\n  }\n});\nfunction renderField(into, typeInfo, options) {\n  renderQualifiedField(into, typeInfo, options);\n  renderTypeAnnotation(into, typeInfo, options, typeInfo.type);\n}\nfunction renderQualifiedField(into, typeInfo, options) {\n  var _a2;\n  var fieldName = ((_a2 = typeInfo.fieldDef) === null || _a2 === void 0 ? void 0 : _a2.name) || \"\";\n  if (fieldName.slice(0, 2) !== \"__\") {\n    renderType(into, typeInfo, options, typeInfo.parentType);\n    text2(into, \".\");\n  }\n  text2(into, fieldName, \"field-name\", options, SchemaReference_1$1.getFieldReference(typeInfo));\n}\nfunction renderDirective(into, typeInfo, options) {\n  var _a2;\n  var name2 = \"@\" + (((_a2 = typeInfo.directiveDef) === null || _a2 === void 0 ? void 0 : _a2.name) || \"\");\n  text2(into, name2, \"directive-name\", options, SchemaReference_1$1.getDirectiveReference(typeInfo));\n}\nfunction renderArg(into, typeInfo, options) {\n  var _a2;\n  if (typeInfo.directiveDef) {\n    renderDirective(into, typeInfo, options);\n  } else if (typeInfo.fieldDef) {\n    renderQualifiedField(into, typeInfo, options);\n  }\n  var name2 = ((_a2 = typeInfo.argDef) === null || _a2 === void 0 ? void 0 : _a2.name) || \"\";\n  text2(into, \"(\");\n  text2(into, name2, \"arg-name\", options, SchemaReference_1$1.getArgumentReference(typeInfo));\n  renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);\n  text2(into, \")\");\n}\nfunction renderTypeAnnotation(into, typeInfo, options, t2) {\n  text2(into, \": \");\n  renderType(into, typeInfo, options, t2);\n}\nfunction renderEnumValue(into, typeInfo, options) {\n  var _a2;\n  var name2 = ((_a2 = typeInfo.enumValue) === null || _a2 === void 0 ? void 0 : _a2.name) || \"\";\n  renderType(into, typeInfo, options, typeInfo.inputType);\n  text2(into, \".\");\n  text2(into, name2, \"enum-value\", options, SchemaReference_1$1.getEnumValueReference(typeInfo));\n}\nfunction renderType(into, typeInfo, options, t2) {\n  if (t2 instanceof graphql_1$2.GraphQLNonNull) {\n    renderType(into, typeInfo, options, t2.ofType);\n    text2(into, \"!\");\n  } else if (t2 instanceof graphql_1$2.GraphQLList) {\n    text2(into, \"[\");\n    renderType(into, typeInfo, options, t2.ofType);\n    text2(into, \"]\");\n  } else {\n    text2(into, (t2 === null || t2 === void 0 ? void 0 : t2.name) || \"\", \"type-name\", options, SchemaReference_1$1.getTypeReference(typeInfo, t2));\n  }\n}\nfunction renderDescription(into, options, def) {\n  var description = def.description;\n  if (description) {\n    var descriptionDiv = document.createElement(\"div\");\n    descriptionDiv.className = \"info-description\";\n    if (options.renderDescription) {\n      descriptionDiv.innerHTML = options.renderDescription(description);\n    } else {\n      descriptionDiv.appendChild(document.createTextNode(description));\n    }\n    into.appendChild(descriptionDiv);\n  }\n  renderDeprecation(into, options, def);\n}\nfunction renderDeprecation(into, options, def) {\n  var reason = def.deprecationReason;\n  if (reason) {\n    var deprecationDiv = document.createElement(\"div\");\n    deprecationDiv.className = \"info-deprecation\";\n    if (options.renderDescription) {\n      deprecationDiv.innerHTML = options.renderDescription(reason);\n    } else {\n      deprecationDiv.appendChild(document.createTextNode(reason));\n    }\n    var label = document.createElement(\"span\");\n    label.className = \"info-deprecation-label\";\n    label.appendChild(document.createTextNode(\"Deprecated: \"));\n    deprecationDiv.insertBefore(label, deprecationDiv.firstChild);\n    into.appendChild(deprecationDiv);\n  }\n}\nfunction text2(into, content, className, options, ref) {\n  if (className === void 0) {\n    className = \"\";\n  }\n  if (options === void 0) {\n    options = { onClick: null };\n  }\n  if (ref === void 0) {\n    ref = null;\n  }\n  if (className) {\n    var onClick_1 = options.onClick;\n    var node = void 0;\n    if (onClick_1) {\n      node = document.createElement(\"a\");\n      node.href = \"javascript:void 0\";\n      node.addEventListener(\"click\", function(e) {\n        onClick_1(ref, e);\n      });\n    } else {\n      node = document.createElement(\"span\");\n    }\n    node.className = className;\n    node.appendChild(document.createTextNode(content));\n    into.appendChild(node);\n  } else {\n    into.appendChild(document.createTextNode(content));\n  }\n}\nvar info = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": info$1\n}, [info$1]));\nvar jump$1 = {};\nvar jumpAddon = {};\nvar __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(jumpAddon, \"__esModule\", { value: true });\nvar codemirror_1$6 = __importDefault$7(codemirror$2.exports);\ncodemirror_1$6.default.defineOption(\"jump\", false, function(cm, options, old) {\n  if (old && old !== codemirror_1$6.default.Init) {\n    var oldOnMouseOver = cm.state.jump.onMouseOver;\n    codemirror_1$6.default.off(cm.getWrapperElement(), \"mouseover\", oldOnMouseOver);\n    var oldOnMouseOut = cm.state.jump.onMouseOut;\n    codemirror_1$6.default.off(cm.getWrapperElement(), \"mouseout\", oldOnMouseOut);\n    codemirror_1$6.default.off(document, \"keydown\", cm.state.jump.onKeyDown);\n    delete cm.state.jump;\n  }\n  if (options) {\n    var state = cm.state.jump = {\n      options,\n      onMouseOver: onMouseOver.bind(null, cm),\n      onMouseOut: onMouseOut.bind(null, cm),\n      onKeyDown: onKeyDown.bind(null, cm)\n    };\n    codemirror_1$6.default.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n    codemirror_1$6.default.on(cm.getWrapperElement(), \"mouseout\", state.onMouseOut);\n    codemirror_1$6.default.on(document, \"keydown\", state.onKeyDown);\n  }\n});\nfunction onMouseOver(cm, event) {\n  var target2 = event.target || event.srcElement;\n  if (!(target2 instanceof HTMLElement)) {\n    return;\n  }\n  if ((target2 === null || target2 === void 0 ? void 0 : target2.nodeName) !== \"SPAN\") {\n    return;\n  }\n  var box = target2.getBoundingClientRect();\n  var cursor = {\n    left: (box.left + box.right) / 2,\n    top: (box.top + box.bottom) / 2\n  };\n  cm.state.jump.cursor = cursor;\n  if (cm.state.jump.isHoldingModifier) {\n    enableJumpMode(cm);\n  }\n}\nfunction onMouseOut(cm) {\n  if (!cm.state.jump.isHoldingModifier && cm.state.jump.cursor) {\n    cm.state.jump.cursor = null;\n    return;\n  }\n  if (cm.state.jump.isHoldingModifier && cm.state.jump.marker) {\n    disableJumpMode(cm);\n  }\n}\nfunction onKeyDown(cm, event) {\n  if (cm.state.jump.isHoldingModifier || !isJumpModifier(event.key)) {\n    return;\n  }\n  cm.state.jump.isHoldingModifier = true;\n  if (cm.state.jump.cursor) {\n    enableJumpMode(cm);\n  }\n  var onKeyUp = function(upEvent) {\n    if (upEvent.code !== event.code) {\n      return;\n    }\n    cm.state.jump.isHoldingModifier = false;\n    if (cm.state.jump.marker) {\n      disableJumpMode(cm);\n    }\n    codemirror_1$6.default.off(document, \"keyup\", onKeyUp);\n    codemirror_1$6.default.off(document, \"click\", onClick);\n    cm.off(\"mousedown\", onMouseDown);\n  };\n  var onClick = function(clickEvent) {\n    var destination = cm.state.jump.destination;\n    if (destination) {\n      cm.state.jump.options.onClick(destination, clickEvent);\n    }\n  };\n  var onMouseDown = function(_, downEvent) {\n    if (cm.state.jump.destination) {\n      downEvent.codemirrorIgnore = true;\n    }\n  };\n  codemirror_1$6.default.on(document, \"keyup\", onKeyUp);\n  codemirror_1$6.default.on(document, \"click\", onClick);\n  cm.on(\"mousedown\", onMouseDown);\n}\nvar isMac = typeof navigator !== \"undefined\" && navigator && navigator.appVersion.indexOf(\"Mac\") !== -1;\nfunction isJumpModifier(key) {\n  return key === (isMac ? \"Meta\" : \"Control\");\n}\nfunction enableJumpMode(cm) {\n  if (cm.state.jump.marker) {\n    return;\n  }\n  var cursor = cm.state.jump.cursor;\n  var pos = cm.coordsChar(cursor);\n  var token2 = cm.getTokenAt(pos, true);\n  var options = cm.state.jump.options;\n  var getDestination = options.getDestination || cm.getHelper(pos, \"jump\");\n  if (getDestination) {\n    var destination = getDestination(token2, options, cm);\n    if (destination) {\n      var marker2 = cm.markText({ line: pos.line, ch: token2.start }, { line: pos.line, ch: token2.end }, { className: \"CodeMirror-jump-token\" });\n      cm.state.jump.marker = marker2;\n      cm.state.jump.destination = destination;\n    }\n  }\n}\nfunction disableJumpMode(cm) {\n  var marker2 = cm.state.jump.marker;\n  cm.state.jump.marker = null;\n  cm.state.jump.destination = null;\n  marker2.clear();\n}\nvar __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(jump$1, \"__esModule\", { value: true });\nvar codemirror_1$5 = __importDefault$6(codemirror$2.exports);\nvar getTypeInfo_1 = __importDefault$6(getTypeInfo$2);\nvar SchemaReference_1 = SchemaReference;\ncodemirror_1$5.default.registerHelper(\"jump\", \"graphql\", function(token2, options) {\n  if (!options.schema || !options.onClick || !token2.state) {\n    return;\n  }\n  var state = token2.state;\n  var kind2 = state.kind;\n  var step = state.step;\n  var typeInfo = getTypeInfo_1.default(options.schema, state);\n  if (kind2 === \"Field\" && step === 0 && typeInfo.fieldDef || kind2 === \"AliasedField\" && step === 2 && typeInfo.fieldDef) {\n    return SchemaReference_1.getFieldReference(typeInfo);\n  } else if (kind2 === \"Directive\" && step === 1 && typeInfo.directiveDef) {\n    return SchemaReference_1.getDirectiveReference(typeInfo);\n  } else if (kind2 === \"Argument\" && step === 0 && typeInfo.argDef) {\n    return SchemaReference_1.getArgumentReference(typeInfo);\n  } else if (kind2 === \"EnumValue\" && typeInfo.enumValue) {\n    return SchemaReference_1.getEnumValueReference(typeInfo);\n  } else if (kind2 === \"NamedType\" && typeInfo.type) {\n    return SchemaReference_1.getTypeReference(typeInfo);\n  }\n});\nvar jump = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": jump$1\n}, [jump$1]));\nvar mode$5 = {};\nvar modeFactory = {};\nvar modeIndent = {};\nObject.defineProperty(modeIndent, \"__esModule\", { value: true });\nfunction indent$2(state, textAfter) {\n  var _a2, _b;\n  var levels = state.levels;\n  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);\n  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);\n}\nmodeIndent.default = indent$2;\nvar __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(modeFactory, \"__esModule\", { value: true });\nvar graphql_language_service_1$2 = require$$1$1;\nvar mode_indent_1 = __importDefault$5(modeIndent);\nvar graphqlModeFactory = function(config2) {\n  var parser = graphql_language_service_1$2.onlineParser({\n    eatWhitespace: function(stream) {\n      return stream.eatWhile(graphql_language_service_1$2.isIgnored);\n    },\n    lexRules: graphql_language_service_1$2.LexRules,\n    parseRules: graphql_language_service_1$2.ParseRules,\n    editorConfig: { tabSize: config2.tabSize }\n  });\n  return {\n    config: config2,\n    startState: parser.startState,\n    token: parser.token,\n    indent: mode_indent_1.default,\n    electricInput: /^\\s*[})\\]]/,\n    fold: \"brace\",\n    lineComment: \"#\",\n    closeBrackets: {\n      pairs: '()[]{}\"\"',\n      explode: \"()[]{}\"\n    }\n  };\n};\nmodeFactory.default = graphqlModeFactory;\nvar __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(mode$5, \"__esModule\", { value: true });\nvar codemirror_1$4 = __importDefault$4(codemirror$2.exports);\nvar mode_factory_1 = __importDefault$4(modeFactory);\ncodemirror_1$4.default.defineMode(\"graphql\", mode_factory_1.default);\nvar mode$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": mode$5\n}, [mode$5]));\nvar hint$1 = {};\nvar hintList$1 = {};\nObject.defineProperty(hintList$1, \"__esModule\", { value: true });\nfunction hintList(cursor, token2, list3) {\n  var hints = filterAndSortList(list3, normalizeText(token2.string));\n  if (!hints) {\n    return;\n  }\n  var tokenStart = token2.type !== null && /\"|\\w/.test(token2.string[0]) ? token2.start : token2.end;\n  return {\n    list: hints,\n    from: { line: cursor.line, ch: tokenStart },\n    to: { line: cursor.line, ch: token2.end }\n  };\n}\nhintList$1.default = hintList;\nfunction filterAndSortList(list3, text3) {\n  if (!text3) {\n    return filterNonEmpty(list3, function(entry) {\n      return !entry.isDeprecated;\n    });\n  }\n  var byProximity = list3.map(function(entry) {\n    return {\n      proximity: getProximity(normalizeText(entry.text), text3),\n      entry\n    };\n  });\n  var conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, function(pair) {\n    return pair.proximity <= 2;\n  }), function(pair) {\n    return !pair.entry.isDeprecated;\n  });\n  var sortedMatches = conciseMatches.sort(function(a, b) {\n    return (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.text.length - b.entry.text.length;\n  });\n  return sortedMatches.map(function(pair) {\n    return pair.entry;\n  });\n}\nfunction filterNonEmpty(array, predicate) {\n  var filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\nfunction normalizeText(text3) {\n  return text3.toLowerCase().replace(/\\W/g, \"\");\n}\nfunction getProximity(suggestion, text3) {\n  var proximity = lexicalDistance(text3, suggestion);\n  if (suggestion.length > text3.length) {\n    proximity -= suggestion.length - text3.length - 1;\n    proximity += suggestion.indexOf(text3) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\nfunction lexicalDistance(a, b) {\n  var i;\n  var j;\n  var d = [];\n  var aLength = a.length;\n  var bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      var cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\nvar __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(hint$1, \"__esModule\", { value: true });\nvar codemirror_1$3 = __importDefault$3(codemirror$2.exports);\nvar graphql_1$1 = require$$1$2;\nvar forEachState_1 = __importDefault$3(forEachState$1);\nvar hintList_1 = __importDefault$3(hintList$1);\ncodemirror_1$3.default.registerHelper(\"hint\", \"graphql-variables\", function(editor, options) {\n  var cur = editor.getCursor();\n  var token2 = editor.getTokenAt(cur);\n  var results = getVariablesHint(cur, token2, options);\n  if (results && results.list && results.list.length > 0) {\n    results.from = codemirror_1$3.default.Pos(results.from.line, results.from.ch);\n    results.to = codemirror_1$3.default.Pos(results.to.line, results.to.ch);\n    codemirror_1$3.default.signal(editor, \"hasCompletion\", editor, results, token2);\n  }\n  return results;\n});\nfunction getVariablesHint(cur, token2, options) {\n  var state = token2.state.kind === \"Invalid\" ? token2.state.prevState : token2.state;\n  var kind2 = state.kind;\n  var step = state.step;\n  if (kind2 === \"Document\" && step === 0) {\n    return hintList_1.default(cur, token2, [{ text: \"{\" }]);\n  }\n  var variableToType = options.variableToType;\n  if (!variableToType) {\n    return;\n  }\n  var typeInfo = getTypeInfo(variableToType, token2.state);\n  if (kind2 === \"Document\" || kind2 === \"Variable\" && step === 0) {\n    var variableNames = Object.keys(variableToType);\n    return hintList_1.default(cur, token2, variableNames.map(function(name2) {\n      return {\n        text: '\"' + name2 + '\": ',\n        type: variableToType[name2]\n      };\n    }));\n  }\n  if (kind2 === \"ObjectValue\" || kind2 === \"ObjectField\" && step === 0) {\n    if (typeInfo.fields) {\n      var inputFields = Object.keys(typeInfo.fields).map(function(fieldName) {\n        return typeInfo.fields[fieldName];\n      });\n      return hintList_1.default(cur, token2, inputFields.map(function(field) {\n        return {\n          text: '\"' + field.name + '\": ',\n          type: field.type,\n          description: field.description\n        };\n      }));\n    }\n  }\n  if (kind2 === \"StringValue\" || kind2 === \"NumberValue\" || kind2 === \"BooleanValue\" || kind2 === \"NullValue\" || kind2 === \"ListValue\" && step === 1 || kind2 === \"ObjectField\" && step === 2 || kind2 === \"Variable\" && step === 2) {\n    var namedInputType_1 = typeInfo.type ? graphql_1$1.getNamedType(typeInfo.type) : void 0;\n    if (namedInputType_1 instanceof graphql_1$1.GraphQLInputObjectType) {\n      return hintList_1.default(cur, token2, [{ text: \"{\" }]);\n    } else if (namedInputType_1 instanceof graphql_1$1.GraphQLEnumType) {\n      var values = namedInputType_1.getValues();\n      return hintList_1.default(cur, token2, values.map(function(value) {\n        return {\n          text: '\"' + value.name + '\"',\n          type: namedInputType_1,\n          description: value.description\n        };\n      }));\n    } else if (namedInputType_1 === graphql_1$1.GraphQLBoolean) {\n      return hintList_1.default(cur, token2, [\n        { text: \"true\", type: graphql_1$1.GraphQLBoolean, description: \"Not false.\" },\n        { text: \"false\", type: graphql_1$1.GraphQLBoolean, description: \"Not true.\" }\n      ]);\n    }\n  }\n}\nfunction getTypeInfo(variableToType, tokenState) {\n  var info2 = {\n    type: null,\n    fields: null\n  };\n  forEachState_1.default(tokenState, function(state) {\n    if (state.kind === \"Variable\") {\n      info2.type = variableToType[state.name];\n    } else if (state.kind === \"ListValue\") {\n      var nullableType = info2.type ? graphql_1$1.getNullableType(info2.type) : void 0;\n      info2.type = nullableType instanceof graphql_1$1.GraphQLList ? nullableType.ofType : null;\n    } else if (state.kind === \"ObjectValue\") {\n      var objectType = info2.type ? graphql_1$1.getNamedType(info2.type) : void 0;\n      info2.fields = objectType instanceof graphql_1$1.GraphQLInputObjectType ? objectType.getFields() : null;\n    } else if (state.kind === \"ObjectField\") {\n      var objectField = state.name && info2.fields ? info2.fields[state.name] : null;\n      info2.type = objectField && objectField.type;\n    }\n  });\n  return info2;\n}\nvar hint = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": hint$1\n}, [hint$1]));\nvar lint$1 = {};\nvar jsonParse$1 = {};\nObject.defineProperty(jsonParse$1, \"__esModule\", { value: true });\nfunction jsonParse(str) {\n  string = str;\n  strLen = str.length;\n  start = end = lastEnd = -1;\n  ch();\n  lex();\n  var ast2 = parseObj();\n  expect(\"EOF\");\n  return ast2;\n}\njsonParse$1.default = jsonParse;\nvar string;\nvar strLen;\nvar start;\nvar end;\nvar lastEnd;\nvar code2;\nvar kind;\nfunction parseObj() {\n  var nodeStart = start;\n  var members = [];\n  expect(\"{\");\n  if (!skip(\"}\")) {\n    do {\n      members.push(parseMember());\n    } while (skip(\",\"));\n    expect(\"}\");\n  }\n  return {\n    kind: \"Object\",\n    start: nodeStart,\n    end: lastEnd,\n    members\n  };\n}\nfunction parseMember() {\n  var nodeStart = start;\n  var key = kind === \"String\" ? curToken() : null;\n  expect(\"String\");\n  expect(\":\");\n  var value = parseVal();\n  return {\n    kind: \"Member\",\n    start: nodeStart,\n    end: lastEnd,\n    key,\n    value\n  };\n}\nfunction parseArr() {\n  var nodeStart = start;\n  var values = [];\n  expect(\"[\");\n  if (!skip(\"]\")) {\n    do {\n      values.push(parseVal());\n    } while (skip(\",\"));\n    expect(\"]\");\n  }\n  return {\n    kind: \"Array\",\n    start: nodeStart,\n    end: lastEnd,\n    values\n  };\n}\nfunction parseVal() {\n  switch (kind) {\n    case \"[\":\n      return parseArr();\n    case \"{\":\n      return parseObj();\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n    case \"Null\":\n      var token2 = curToken();\n      lex();\n      return token2;\n  }\n  expect(\"Value\");\n}\nfunction curToken() {\n  return { kind, start, end, value: JSON.parse(string.slice(start, end)) };\n}\nfunction expect(str) {\n  if (kind === str) {\n    lex();\n    return;\n  }\n  var found;\n  if (kind === \"EOF\") {\n    found = \"[end of file]\";\n  } else if (end - start > 1) {\n    found = \"`\" + string.slice(start, end) + \"`\";\n  } else {\n    var match2 = string.slice(start).match(/^.+?\\b/);\n    found = \"`\" + (match2 ? match2[0] : string[start]) + \"`\";\n  }\n  throw syntaxError(\"Expected \" + str + \" but found \" + found + \".\");\n}\nfunction syntaxError(message) {\n  return { message, start, end };\n}\nfunction skip(k) {\n  if (kind === k) {\n    lex();\n    return true;\n  }\n}\nfunction ch() {\n  if (end < strLen) {\n    end++;\n    code2 = end === strLen ? 0 : string.charCodeAt(end);\n  }\n  return code2;\n}\nfunction lex() {\n  lastEnd = end;\n  while (code2 === 9 || code2 === 10 || code2 === 13 || code2 === 32) {\n    ch();\n  }\n  if (code2 === 0) {\n    kind = \"EOF\";\n    return;\n  }\n  start = end;\n  switch (code2) {\n    case 34:\n      kind = \"String\";\n      return readString();\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      kind = \"Number\";\n      return readNumber();\n    case 102:\n      if (string.slice(start, start + 5) !== \"false\") {\n        break;\n      }\n      end += 4;\n      ch();\n      kind = \"Boolean\";\n      return;\n    case 110:\n      if (string.slice(start, start + 4) !== \"null\") {\n        break;\n      }\n      end += 3;\n      ch();\n      kind = \"Null\";\n      return;\n    case 116:\n      if (string.slice(start, start + 4) !== \"true\") {\n        break;\n      }\n      end += 3;\n      ch();\n      kind = \"Boolean\";\n      return;\n  }\n  kind = string[start];\n  ch();\n}\nfunction readString() {\n  ch();\n  while (code2 !== 34 && code2 > 31) {\n    if (code2 === 92) {\n      code2 = ch();\n      switch (code2) {\n        case 34:\n        case 47:\n        case 92:\n        case 98:\n        case 102:\n        case 110:\n        case 114:\n        case 116:\n          ch();\n          break;\n        case 117:\n          ch();\n          readHex();\n          readHex();\n          readHex();\n          readHex();\n          break;\n        default:\n          throw syntaxError(\"Bad character escape sequence.\");\n      }\n    } else if (end === strLen) {\n      throw syntaxError(\"Unterminated string.\");\n    } else {\n      ch();\n    }\n  }\n  if (code2 === 34) {\n    ch();\n    return;\n  }\n  throw syntaxError(\"Unterminated string.\");\n}\nfunction readHex() {\n  if (code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102) {\n    return ch();\n  }\n  throw syntaxError(\"Expected hexadecimal digit.\");\n}\nfunction readNumber() {\n  if (code2 === 45) {\n    ch();\n  }\n  if (code2 === 48) {\n    ch();\n  } else {\n    readDigits();\n  }\n  if (code2 === 46) {\n    ch();\n    readDigits();\n  }\n  if (code2 === 69 || code2 === 101) {\n    code2 = ch();\n    if (code2 === 43 || code2 === 45) {\n      ch();\n    }\n    readDigits();\n  }\n}\nfunction readDigits() {\n  if (code2 < 48 || code2 > 57) {\n    throw syntaxError(\"Expected decimal digit.\");\n  }\n  do {\n    ch();\n  } while (code2 >= 48 && code2 <= 57);\n}\nvar __read = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {\n  var m2 = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m2)\n    return o;\n  var i = m2.call(o), r2, ar = [], e;\n  try {\n    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)\n      ar.push(r2.value);\n  } catch (error2) {\n    e = { error: error2 };\n  } finally {\n    try {\n      if (r2 && !r2.done && (m2 = i[\"return\"]))\n        m2.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n};\nvar __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(lint$1, \"__esModule\", { value: true });\nvar codemirror_1$2 = __importDefault$2(codemirror$2.exports);\nvar graphql_1 = require$$1$2;\nvar jsonParse_1 = __importDefault$2(jsonParse$1);\ncodemirror_1$2.default.registerHelper(\"lint\", \"graphql-variables\", function(text3, options, editor) {\n  if (!text3) {\n    return [];\n  }\n  var ast2;\n  try {\n    ast2 = jsonParse_1.default(text3);\n  } catch (syntaxError2) {\n    if (syntaxError2.stack) {\n      throw syntaxError2;\n    }\n    return [lintError(editor, syntaxError2, syntaxError2.message)];\n  }\n  var variableToType = options.variableToType;\n  if (!variableToType) {\n    return [];\n  }\n  return validateVariables(editor, variableToType, ast2);\n});\nfunction validateVariables(editor, variableToType, variablesAST) {\n  var errors2 = [];\n  variablesAST.members.forEach(function(member) {\n    var _a2;\n    if (member) {\n      var variableName = (_a2 = member.key) === null || _a2 === void 0 ? void 0 : _a2.value;\n      var type2 = variableToType[variableName];\n      if (!type2) {\n        errors2.push(lintError(editor, member.key, 'Variable \"$' + variableName + '\" does not appear in any GraphQL query.'));\n      } else {\n        validateValue(type2, member.value).forEach(function(_a3) {\n          var _b = __read(_a3, 2), node = _b[0], message = _b[1];\n          errors2.push(lintError(editor, node, message));\n        });\n      }\n    }\n  });\n  return errors2;\n}\nfunction validateValue(type2, valueAST) {\n  if (!type2 || !valueAST) {\n    return [];\n  }\n  if (type2 instanceof graphql_1.GraphQLNonNull) {\n    if (valueAST.kind === \"Null\") {\n      return [[valueAST, 'Type \"' + type2 + '\" is non-nullable and cannot be null.']];\n    }\n    return validateValue(type2.ofType, valueAST);\n  }\n  if (valueAST.kind === \"Null\") {\n    return [];\n  }\n  if (type2 instanceof graphql_1.GraphQLList) {\n    var itemType_1 = type2.ofType;\n    if (valueAST.kind === \"Array\") {\n      var values = valueAST.values || [];\n      return mapCat(values, function(item) {\n        return validateValue(itemType_1, item);\n      });\n    }\n    return validateValue(itemType_1, valueAST);\n  }\n  if (type2 instanceof graphql_1.GraphQLInputObjectType) {\n    if (valueAST.kind !== \"Object\") {\n      return [[valueAST, 'Type \"' + type2 + '\" must be an Object.']];\n    }\n    var providedFields_1 = /* @__PURE__ */ Object.create(null);\n    var fieldErrors_1 = mapCat(valueAST.members, function(member) {\n      var _a2;\n      var fieldName = (_a2 = member === null || member === void 0 ? void 0 : member.key) === null || _a2 === void 0 ? void 0 : _a2.value;\n      providedFields_1[fieldName] = true;\n      var inputField = type2.getFields()[fieldName];\n      if (!inputField) {\n        return [\n          [\n            member.key,\n            'Type \"' + type2 + '\" does not have a field \"' + fieldName + '\".'\n          ]\n        ];\n      }\n      var fieldType = inputField ? inputField.type : void 0;\n      return validateValue(fieldType, member.value);\n    });\n    Object.keys(type2.getFields()).forEach(function(fieldName) {\n      if (!providedFields_1[fieldName]) {\n        var fieldType = type2.getFields()[fieldName].type;\n        if (fieldType instanceof graphql_1.GraphQLNonNull) {\n          fieldErrors_1.push([\n            valueAST,\n            'Object of type \"' + type2 + '\" is missing required field \"' + fieldName + '\".'\n          ]);\n        }\n      }\n    });\n    return fieldErrors_1;\n  }\n  if (type2.name === \"Boolean\" && valueAST.kind !== \"Boolean\" || type2.name === \"String\" && valueAST.kind !== \"String\" || type2.name === \"ID\" && valueAST.kind !== \"Number\" && valueAST.kind !== \"String\" || type2.name === \"Float\" && valueAST.kind !== \"Number\" || type2.name === \"Int\" && (valueAST.kind !== \"Number\" || (valueAST.value | 0) !== valueAST.value)) {\n    return [[valueAST, 'Expected value of type \"' + type2 + '\".']];\n  }\n  if (type2 instanceof graphql_1.GraphQLEnumType || type2 instanceof graphql_1.GraphQLScalarType) {\n    if (valueAST.kind !== \"String\" && valueAST.kind !== \"Number\" && valueAST.kind !== \"Boolean\" && valueAST.kind !== \"Null\" || isNullish(type2.parseValue(valueAST.value))) {\n      return [[valueAST, 'Expected value of type \"' + type2 + '\".']];\n    }\n  }\n  return [];\n}\nfunction lintError(editor, node, message) {\n  return {\n    message,\n    severity: \"error\",\n    type: \"validation\",\n    from: editor.posFromIndex(node.start),\n    to: editor.posFromIndex(node.end)\n  };\n}\nfunction isNullish(value) {\n  return value === null || value === void 0 || value !== value;\n}\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\nvar lint = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": lint$1\n}, [lint$1]));\nvar mode$3 = {};\nvar __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(mode$3, \"__esModule\", { value: true });\nvar codemirror_1$1 = __importDefault$1(codemirror$2.exports);\nvar graphql_language_service_1$1 = require$$1$1;\ncodemirror_1$1.default.defineMode(\"graphql-variables\", function(config2) {\n  var parser = graphql_language_service_1$1.onlineParser({\n    eatWhitespace: function(stream) {\n      return stream.eatSpace();\n    },\n    lexRules: LexRules$1,\n    parseRules: ParseRules$1,\n    editorConfig: { tabSize: config2.tabSize }\n  });\n  return {\n    config: config2,\n    startState: parser.startState,\n    token: parser.token,\n    indent: indent$1,\n    electricInput: /^\\s*[}\\]]/,\n    fold: \"brace\",\n    closeBrackets: {\n      pairs: '[]{}\"\"',\n      explode: \"[]{}\"\n    }\n  };\n});\nfunction indent$1(state, textAfter) {\n  var _a2, _b;\n  var levels = state.levels;\n  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);\n  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);\n}\nvar LexRules$1 = {\n  Punctuation: /^\\[|]|\\{|\\}|:|,/,\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  String: /^\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?/,\n  Keyword: /^true|false|null/\n};\nvar ParseRules$1 = {\n  Document: [graphql_language_service_1$1.p(\"{\"), graphql_language_service_1$1.list(\"Variable\", graphql_language_service_1$1.opt(graphql_language_service_1$1.p(\",\"))), graphql_language_service_1$1.p(\"}\")],\n  Variable: [namedKey(\"variable\"), graphql_language_service_1$1.p(\":\"), \"Value\"],\n  Value: function(token2) {\n    switch (token2.kind) {\n      case \"Number\":\n        return \"NumberValue\";\n      case \"String\":\n        return \"StringValue\";\n      case \"Punctuation\":\n        switch (token2.value) {\n          case \"[\":\n            return \"ListValue\";\n          case \"{\":\n            return \"ObjectValue\";\n        }\n        return null;\n      case \"Keyword\":\n        switch (token2.value) {\n          case \"true\":\n          case \"false\":\n            return \"BooleanValue\";\n          case \"null\":\n            return \"NullValue\";\n        }\n        return null;\n    }\n  },\n  NumberValue: [graphql_language_service_1$1.t(\"Number\", \"number\")],\n  StringValue: [graphql_language_service_1$1.t(\"String\", \"string\")],\n  BooleanValue: [graphql_language_service_1$1.t(\"Keyword\", \"builtin\")],\n  NullValue: [graphql_language_service_1$1.t(\"Keyword\", \"keyword\")],\n  ListValue: [graphql_language_service_1$1.p(\"[\"), graphql_language_service_1$1.list(\"Value\", graphql_language_service_1$1.opt(graphql_language_service_1$1.p(\",\"))), graphql_language_service_1$1.p(\"]\")],\n  ObjectValue: [graphql_language_service_1$1.p(\"{\"), graphql_language_service_1$1.list(\"ObjectField\", graphql_language_service_1$1.opt(graphql_language_service_1$1.p(\",\"))), graphql_language_service_1$1.p(\"}\")],\n  ObjectField: [namedKey(\"attribute\"), graphql_language_service_1$1.p(\":\"), \"Value\"]\n};\nfunction namedKey(style) {\n  return {\n    style,\n    match: function(token2) {\n      return token2.kind === \"String\";\n    },\n    update: function(state, token2) {\n      state.name = token2.value.slice(1, -1);\n    }\n  };\n}\nvar mode$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": mode$3\n}, [mode$3]));\nvar javascript$2 = { exports: {} };\n(function(module2, exports) {\n  (function(mod) {\n    mod(codemirror$2.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineMode(\"javascript\", function(config2, parserConfig) {\n      var indentUnit = config2.indentUnit;\n      var statementIndent = parserConfig.statementIndent;\n      var jsonldMode = parserConfig.jsonld;\n      var jsonMode = parserConfig.json || jsonldMode;\n      var trackScope = parserConfig.trackScope !== false;\n      var isTS = parserConfig.typescript;\n      var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n      var keywords = function() {\n        function kw(type3) {\n          return { type: type3, style: \"keyword\" };\n        }\n        var A2 = kw(\"keyword a\"), B2 = kw(\"keyword b\"), C2 = kw(\"keyword c\"), D2 = kw(\"keyword d\");\n        var operator = kw(\"operator\"), atom = { type: \"atom\", style: \"atom\" };\n        return {\n          \"if\": kw(\"if\"),\n          \"while\": A2,\n          \"with\": A2,\n          \"else\": B2,\n          \"do\": B2,\n          \"try\": B2,\n          \"finally\": B2,\n          \"return\": D2,\n          \"break\": D2,\n          \"continue\": D2,\n          \"new\": kw(\"new\"),\n          \"delete\": C2,\n          \"void\": C2,\n          \"throw\": C2,\n          \"debugger\": kw(\"debugger\"),\n          \"var\": kw(\"var\"),\n          \"const\": kw(\"var\"),\n          \"let\": kw(\"var\"),\n          \"function\": kw(\"function\"),\n          \"catch\": kw(\"catch\"),\n          \"for\": kw(\"for\"),\n          \"switch\": kw(\"switch\"),\n          \"case\": kw(\"case\"),\n          \"default\": kw(\"default\"),\n          \"in\": operator,\n          \"typeof\": operator,\n          \"instanceof\": operator,\n          \"true\": atom,\n          \"false\": atom,\n          \"null\": atom,\n          \"undefined\": atom,\n          \"NaN\": atom,\n          \"Infinity\": atom,\n          \"this\": kw(\"this\"),\n          \"class\": kw(\"class\"),\n          \"super\": kw(\"atom\"),\n          \"yield\": C2,\n          \"export\": kw(\"export\"),\n          \"import\": kw(\"import\"),\n          \"extends\": C2,\n          \"await\": C2\n        };\n      }();\n      var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n      function readRegexp(stream) {\n        var escaped = false, next, inSet = false;\n        while ((next = stream.next()) != null) {\n          if (!escaped) {\n            if (next == \"/\" && !inSet)\n              return;\n            if (next == \"[\")\n              inSet = true;\n            else if (inSet && next == \"]\")\n              inSet = false;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n      }\n      var type2, content;\n      function ret(tp, style, cont2) {\n        type2 = tp;\n        content = cont2;\n        return style;\n      }\n      function tokenBase(stream, state) {\n        var ch2 = stream.next();\n        if (ch2 == '\"' || ch2 == \"'\") {\n          state.tokenize = tokenString(ch2);\n          return state.tokenize(stream, state);\n        } else if (ch2 == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n          return ret(\"number\", \"number\");\n        } else if (ch2 == \".\" && stream.match(\"..\")) {\n          return ret(\"spread\", \"meta\");\n        } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch2)) {\n          return ret(ch2);\n        } else if (ch2 == \"=\" && stream.eat(\">\")) {\n          return ret(\"=>\", \"operator\");\n        } else if (ch2 == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n          return ret(\"number\", \"number\");\n        } else if (/\\d/.test(ch2)) {\n          stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n          return ret(\"number\", \"number\");\n        } else if (ch2 == \"/\") {\n          if (stream.eat(\"*\")) {\n            state.tokenize = tokenComment;\n            return tokenComment(stream, state);\n          } else if (stream.eat(\"/\")) {\n            stream.skipToEnd();\n            return ret(\"comment\", \"comment\");\n          } else if (expressionAllowed(stream, state, 1)) {\n            readRegexp(stream);\n            stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n            return ret(\"regexp\", \"string-2\");\n          } else {\n            stream.eat(\"=\");\n            return ret(\"operator\", \"operator\", stream.current());\n          }\n        } else if (ch2 == \"`\") {\n          state.tokenize = tokenQuasi;\n          return tokenQuasi(stream, state);\n        } else if (ch2 == \"#\" && stream.peek() == \"!\") {\n          stream.skipToEnd();\n          return ret(\"meta\", \"meta\");\n        } else if (ch2 == \"#\" && stream.eatWhile(wordRE)) {\n          return ret(\"variable\", \"property\");\n        } else if (ch2 == \"<\" && stream.match(\"!--\") || ch2 == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start))) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else if (isOperatorChar.test(ch2)) {\n          if (ch2 != \">\" || !state.lexical || state.lexical.type != \">\") {\n            if (stream.eat(\"=\")) {\n              if (ch2 == \"!\" || ch2 == \"=\")\n                stream.eat(\"=\");\n            } else if (/[<>*+\\-|&?]/.test(ch2)) {\n              stream.eat(ch2);\n              if (ch2 == \">\")\n                stream.eat(ch2);\n            }\n          }\n          if (ch2 == \"?\" && stream.eat(\".\"))\n            return ret(\".\");\n          return ret(\"operator\", \"operator\", stream.current());\n        } else if (wordRE.test(ch2)) {\n          stream.eatWhile(wordRE);\n          var word2 = stream.current();\n          if (state.lastType != \".\") {\n            if (keywords.propertyIsEnumerable(word2)) {\n              var kw = keywords[word2];\n              return ret(kw.type, kw.style, word2);\n            }\n            if (word2 == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n              return ret(\"async\", \"keyword\", word2);\n          }\n          return ret(\"variable\", \"variable\", word2);\n        }\n      }\n      function tokenString(quote) {\n        return function(stream, state) {\n          var escaped = false, next;\n          if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)) {\n            state.tokenize = tokenBase;\n            return ret(\"jsonld-keyword\", \"meta\");\n          }\n          while ((next = stream.next()) != null) {\n            if (next == quote && !escaped)\n              break;\n            escaped = !escaped && next == \"\\\\\";\n          }\n          if (!escaped)\n            state.tokenize = tokenBase;\n          return ret(\"string\", \"string\");\n        };\n      }\n      function tokenComment(stream, state) {\n        var maybeEnd = false, ch2;\n        while (ch2 = stream.next()) {\n          if (ch2 == \"/\" && maybeEnd) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          maybeEnd = ch2 == \"*\";\n        }\n        return ret(\"comment\", \"comment\");\n      }\n      function tokenQuasi(stream, state) {\n        var escaped = false, next;\n        while ((next = stream.next()) != null) {\n          if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n            state.tokenize = tokenBase;\n            break;\n          }\n          escaped = !escaped && next == \"\\\\\";\n        }\n        return ret(\"quasi\", \"string-2\", stream.current());\n      }\n      var brackets = \"([{}])\";\n      function findFatArrow(stream, state) {\n        if (state.fatArrowAt)\n          state.fatArrowAt = null;\n        var arrow = stream.string.indexOf(\"=>\", stream.start);\n        if (arrow < 0)\n          return;\n        if (isTS) {\n          var m2 = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n          if (m2)\n            arrow = m2.index;\n        }\n        var depth = 0, sawSomething = false;\n        for (var pos = arrow - 1; pos >= 0; --pos) {\n          var ch2 = stream.string.charAt(pos);\n          var bracket = brackets.indexOf(ch2);\n          if (bracket >= 0 && bracket < 3) {\n            if (!depth) {\n              ++pos;\n              break;\n            }\n            if (--depth == 0) {\n              if (ch2 == \"(\")\n                sawSomething = true;\n              break;\n            }\n          } else if (bracket >= 3 && bracket < 6) {\n            ++depth;\n          } else if (wordRE.test(ch2)) {\n            sawSomething = true;\n          } else if (/[\"'\\/`]/.test(ch2)) {\n            for (; ; --pos) {\n              if (pos == 0)\n                return;\n              var next = stream.string.charAt(pos - 1);\n              if (next == ch2 && stream.string.charAt(pos - 2) != \"\\\\\") {\n                pos--;\n                break;\n              }\n            }\n          } else if (sawSomething && !depth) {\n            ++pos;\n            break;\n          }\n        }\n        if (sawSomething && !depth)\n          state.fatArrowAt = pos;\n      }\n      var atomicTypes = {\n        \"atom\": true,\n        \"number\": true,\n        \"variable\": true,\n        \"string\": true,\n        \"regexp\": true,\n        \"this\": true,\n        \"import\": true,\n        \"jsonld-keyword\": true\n      };\n      function JSLexical(indented, column, type3, align, prev, info2) {\n        this.indented = indented;\n        this.column = column;\n        this.type = type3;\n        this.prev = prev;\n        this.info = info2;\n        if (align != null)\n          this.align = align;\n      }\n      function inScope(state, varname) {\n        if (!trackScope)\n          return false;\n        for (var v2 = state.localVars; v2; v2 = v2.next)\n          if (v2.name == varname)\n            return true;\n        for (var cx2 = state.context; cx2; cx2 = cx2.prev) {\n          for (var v2 = cx2.vars; v2; v2 = v2.next)\n            if (v2.name == varname)\n              return true;\n        }\n      }\n      function parseJS(state, style, type3, content2, stream) {\n        var cc2 = state.cc;\n        cx.state = state;\n        cx.stream = stream;\n        cx.marked = null, cx.cc = cc2;\n        cx.style = style;\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = true;\n        while (true) {\n          var combinator = cc2.length ? cc2.pop() : jsonMode ? expression : statement;\n          if (combinator(type3, content2)) {\n            while (cc2.length && cc2[cc2.length - 1].lex)\n              cc2.pop()();\n            if (cx.marked)\n              return cx.marked;\n            if (type3 == \"variable\" && inScope(state, content2))\n              return \"variable-2\";\n            return style;\n          }\n        }\n      }\n      var cx = { state: null, column: null, marked: null, cc: null };\n      function pass() {\n        for (var i = arguments.length - 1; i >= 0; i--)\n          cx.cc.push(arguments[i]);\n      }\n      function cont() {\n        pass.apply(null, arguments);\n        return true;\n      }\n      function inList(name2, list3) {\n        for (var v2 = list3; v2; v2 = v2.next)\n          if (v2.name == name2)\n            return true;\n        return false;\n      }\n      function register(varname) {\n        var state = cx.state;\n        cx.marked = \"def\";\n        if (!trackScope)\n          return;\n        if (state.context) {\n          if (state.lexical.info == \"var\" && state.context && state.context.block) {\n            var newContext = registerVarScoped(varname, state.context);\n            if (newContext != null) {\n              state.context = newContext;\n              return;\n            }\n          } else if (!inList(varname, state.localVars)) {\n            state.localVars = new Var(varname, state.localVars);\n            return;\n          }\n        }\n        if (parserConfig.globalVars && !inList(varname, state.globalVars))\n          state.globalVars = new Var(varname, state.globalVars);\n      }\n      function registerVarScoped(varname, context) {\n        if (!context) {\n          return null;\n        } else if (context.block) {\n          var inner = registerVarScoped(varname, context.prev);\n          if (!inner)\n            return null;\n          if (inner == context.prev)\n            return context;\n          return new Context(inner, context.vars, true);\n        } else if (inList(varname, context.vars)) {\n          return context;\n        } else {\n          return new Context(context.prev, new Var(varname, context.vars), false);\n        }\n      }\n      function isModifier(name2) {\n        return name2 == \"public\" || name2 == \"private\" || name2 == \"protected\" || name2 == \"abstract\" || name2 == \"readonly\";\n      }\n      function Context(prev, vars, block4) {\n        this.prev = prev;\n        this.vars = vars;\n        this.block = block4;\n      }\n      function Var(name2, next) {\n        this.name = name2;\n        this.next = next;\n      }\n      var defaultVars = new Var(\"this\", new Var(\"arguments\", null));\n      function pushcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n        cx.state.localVars = defaultVars;\n      }\n      function pushblockcontext() {\n        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n        cx.state.localVars = null;\n      }\n      pushcontext.lex = pushblockcontext.lex = true;\n      function popcontext() {\n        cx.state.localVars = cx.state.context.vars;\n        cx.state.context = cx.state.context.prev;\n      }\n      popcontext.lex = true;\n      function pushlex(type3, info2) {\n        var result2 = function() {\n          var state = cx.state, indent2 = state.indented;\n          if (state.lexical.type == \"stat\")\n            indent2 = state.lexical.indented;\n          else\n            for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n              indent2 = outer.indented;\n          state.lexical = new JSLexical(indent2, cx.stream.column(), type3, null, state.lexical, info2);\n        };\n        result2.lex = true;\n        return result2;\n      }\n      function poplex() {\n        var state = cx.state;\n        if (state.lexical.prev) {\n          if (state.lexical.type == \")\")\n            state.indented = state.lexical.indented;\n          state.lexical = state.lexical.prev;\n        }\n      }\n      poplex.lex = true;\n      function expect2(wanted) {\n        function exp(type3) {\n          if (type3 == wanted)\n            return cont();\n          else if (wanted == \";\" || type3 == \"}\" || type3 == \")\" || type3 == \"]\")\n            return pass();\n          else\n            return cont(exp);\n        }\n        return exp;\n      }\n      function statement(type3, value) {\n        if (type3 == \"var\")\n          return cont(pushlex(\"vardef\", value), vardef, expect2(\";\"), poplex);\n        if (type3 == \"keyword a\")\n          return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n        if (type3 == \"keyword b\")\n          return cont(pushlex(\"form\"), statement, poplex);\n        if (type3 == \"keyword d\")\n          return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect2(\";\"), poplex);\n        if (type3 == \"debugger\")\n          return cont(expect2(\";\"));\n        if (type3 == \"{\")\n          return cont(pushlex(\"}\"), pushblockcontext, block3, poplex, popcontext);\n        if (type3 == \";\")\n          return cont();\n        if (type3 == \"if\") {\n          if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n            cx.state.cc.pop()();\n          return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n        }\n        if (type3 == \"function\")\n          return cont(functiondef);\n        if (type3 == \"for\")\n          return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n        if (type3 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\", type3 == \"class\" ? type3 : value), className, poplex);\n        }\n        if (type3 == \"variable\") {\n          if (isTS && value == \"declare\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n            cx.marked = \"keyword\";\n            if (value == \"enum\")\n              return cont(enumdef);\n            else if (value == \"type\")\n              return cont(typename, expect2(\"operator\"), typeexpr, expect2(\";\"));\n            else\n              return cont(pushlex(\"form\"), pattern, expect2(\"{\"), pushlex(\"}\"), block3, poplex, poplex);\n          } else if (isTS && value == \"namespace\") {\n            cx.marked = \"keyword\";\n            return cont(pushlex(\"form\"), expression, statement, poplex);\n          } else if (isTS && value == \"abstract\") {\n            cx.marked = \"keyword\";\n            return cont(statement);\n          } else {\n            return cont(pushlex(\"stat\"), maybelabel);\n          }\n        }\n        if (type3 == \"switch\")\n          return cont(pushlex(\"form\"), parenExpr, expect2(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext, block3, poplex, poplex, popcontext);\n        if (type3 == \"case\")\n          return cont(expression, expect2(\":\"));\n        if (type3 == \"default\")\n          return cont(expect2(\":\"));\n        if (type3 == \"catch\")\n          return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n        if (type3 == \"export\")\n          return cont(pushlex(\"stat\"), afterExport, poplex);\n        if (type3 == \"import\")\n          return cont(pushlex(\"stat\"), afterImport, poplex);\n        if (type3 == \"async\")\n          return cont(statement);\n        if (value == \"@\")\n          return cont(expression, statement);\n        return pass(pushlex(\"stat\"), expression, expect2(\";\"), poplex);\n      }\n      function maybeCatchBinding(type3) {\n        if (type3 == \"(\")\n          return cont(funarg, expect2(\")\"));\n      }\n      function expression(type3, value) {\n        return expressionInner(type3, value, false);\n      }\n      function expressionNoComma(type3, value) {\n        return expressionInner(type3, value, true);\n      }\n      function parenExpr(type3) {\n        if (type3 != \"(\")\n          return pass();\n        return cont(pushlex(\")\"), maybeexpression, expect2(\")\"), poplex);\n      }\n      function expressionInner(type3, value, noComma) {\n        if (cx.state.fatArrowAt == cx.stream.start) {\n          var body = noComma ? arrowBodyNoComma : arrowBody;\n          if (type3 == \"(\")\n            return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect2(\"=>\"), body, popcontext);\n          else if (type3 == \"variable\")\n            return pass(pushcontext, pattern, expect2(\"=>\"), body, popcontext);\n        }\n        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n        if (atomicTypes.hasOwnProperty(type3))\n          return cont(maybeop);\n        if (type3 == \"function\")\n          return cont(functiondef, maybeop);\n        if (type3 == \"class\" || isTS && value == \"interface\") {\n          cx.marked = \"keyword\";\n          return cont(pushlex(\"form\"), classExpression, poplex);\n        }\n        if (type3 == \"keyword c\" || type3 == \"async\")\n          return cont(noComma ? expressionNoComma : expression);\n        if (type3 == \"(\")\n          return cont(pushlex(\")\"), maybeexpression, expect2(\")\"), poplex, maybeop);\n        if (type3 == \"operator\" || type3 == \"spread\")\n          return cont(noComma ? expressionNoComma : expression);\n        if (type3 == \"[\")\n          return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n        if (type3 == \"{\")\n          return contCommasep(objprop, \"}\", null, maybeop);\n        if (type3 == \"quasi\")\n          return pass(quasi, maybeop);\n        if (type3 == \"new\")\n          return cont(maybeTarget(noComma));\n        return cont();\n      }\n      function maybeexpression(type3) {\n        if (type3.match(/[;\\}\\)\\],]/))\n          return pass();\n        return pass(expression);\n      }\n      function maybeoperatorComma(type3, value) {\n        if (type3 == \",\")\n          return cont(maybeexpression);\n        return maybeoperatorNoComma(type3, value, false);\n      }\n      function maybeoperatorNoComma(type3, value, noComma) {\n        var me2 = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n        var expr = noComma == false ? expression : expressionNoComma;\n        if (type3 == \"=>\")\n          return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n        if (type3 == \"operator\") {\n          if (/\\+\\+|--/.test(value) || isTS && value == \"!\")\n            return cont(me2);\n          if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n            return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me2);\n          if (value == \"?\")\n            return cont(expression, expect2(\":\"), expr);\n          return cont(expr);\n        }\n        if (type3 == \"quasi\") {\n          return pass(quasi, me2);\n        }\n        if (type3 == \";\")\n          return;\n        if (type3 == \"(\")\n          return contCommasep(expressionNoComma, \")\", \"call\", me2);\n        if (type3 == \".\")\n          return cont(property, me2);\n        if (type3 == \"[\")\n          return cont(pushlex(\"]\"), maybeexpression, expect2(\"]\"), poplex, me2);\n        if (isTS && value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr, me2);\n        }\n        if (type3 == \"regexp\") {\n          cx.state.lastType = cx.marked = \"operator\";\n          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n          return cont(expr);\n        }\n      }\n      function quasi(type3, value) {\n        if (type3 != \"quasi\")\n          return pass();\n        if (value.slice(value.length - 2) != \"${\")\n          return cont(quasi);\n        return cont(maybeexpression, continueQuasi);\n      }\n      function continueQuasi(type3) {\n        if (type3 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasi);\n        }\n      }\n      function arrowBody(type3) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type3 == \"{\" ? statement : expression);\n      }\n      function arrowBodyNoComma(type3) {\n        findFatArrow(cx.stream, cx.state);\n        return pass(type3 == \"{\" ? statement : expressionNoComma);\n      }\n      function maybeTarget(noComma) {\n        return function(type3) {\n          if (type3 == \".\")\n            return cont(noComma ? targetNoComma : target2);\n          else if (type3 == \"variable\" && isTS)\n            return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);\n          else\n            return pass(noComma ? expressionNoComma : expression);\n        };\n      }\n      function target2(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorComma);\n        }\n      }\n      function targetNoComma(_, value) {\n        if (value == \"target\") {\n          cx.marked = \"keyword\";\n          return cont(maybeoperatorNoComma);\n        }\n      }\n      function maybelabel(type3) {\n        if (type3 == \":\")\n          return cont(poplex, statement);\n        return pass(maybeoperatorComma, expect2(\";\"), poplex);\n      }\n      function property(type3) {\n        if (type3 == \"variable\") {\n          cx.marked = \"property\";\n          return cont();\n        }\n      }\n      function objprop(type3, value) {\n        if (type3 == \"async\") {\n          cx.marked = \"property\";\n          return cont(objprop);\n        } else if (type3 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          if (value == \"get\" || value == \"set\")\n            return cont(getterSetter);\n          var m2;\n          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m2 = cx.stream.match(/^\\s*:\\s*/, false)))\n            cx.state.fatArrowAt = cx.stream.pos + m2[0].length;\n          return cont(afterprop);\n        } else if (type3 == \"number\" || type3 == \"string\") {\n          cx.marked = jsonldMode ? \"property\" : cx.style + \" property\";\n          return cont(afterprop);\n        } else if (type3 == \"jsonld-keyword\") {\n          return cont(afterprop);\n        } else if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type3 == \"[\") {\n          return cont(expression, maybetype, expect2(\"]\"), afterprop);\n        } else if (type3 == \"spread\") {\n          return cont(expressionNoComma, afterprop);\n        } else if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(objprop);\n        } else if (type3 == \":\") {\n          return pass(afterprop);\n        }\n      }\n      function getterSetter(type3) {\n        if (type3 != \"variable\")\n          return pass(afterprop);\n        cx.marked = \"property\";\n        return cont(functiondef);\n      }\n      function afterprop(type3) {\n        if (type3 == \":\")\n          return cont(expressionNoComma);\n        if (type3 == \"(\")\n          return pass(functiondef);\n      }\n      function commasep(what, end2, sep) {\n        function proceed(type3, value) {\n          if (sep ? sep.indexOf(type3) > -1 : type3 == \",\") {\n            var lex2 = cx.state.lexical;\n            if (lex2.info == \"call\")\n              lex2.pos = (lex2.pos || 0) + 1;\n            return cont(function(type4, value2) {\n              if (type4 == end2 || value2 == end2)\n                return pass();\n              return pass(what);\n            }, proceed);\n          }\n          if (type3 == end2 || value == end2)\n            return cont();\n          if (sep && sep.indexOf(\";\") > -1)\n            return pass(what);\n          return cont(expect2(end2));\n        }\n        return function(type3, value) {\n          if (type3 == end2 || value == end2)\n            return cont();\n          return pass(what, proceed);\n        };\n      }\n      function contCommasep(what, end2, info2) {\n        for (var i = 3; i < arguments.length; i++)\n          cx.cc.push(arguments[i]);\n        return cont(pushlex(end2, info2), commasep(what, end2), poplex);\n      }\n      function block3(type3) {\n        if (type3 == \"}\")\n          return cont();\n        return pass(statement, block3);\n      }\n      function maybetype(type3, value) {\n        if (isTS) {\n          if (type3 == \":\")\n            return cont(typeexpr);\n          if (value == \"?\")\n            return cont(maybetype);\n        }\n      }\n      function maybetypeOrIn(type3, value) {\n        if (isTS && (type3 == \":\" || value == \"in\"))\n          return cont(typeexpr);\n      }\n      function mayberettype(type3) {\n        if (isTS && type3 == \":\") {\n          if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false))\n            return cont(expression, isKW, typeexpr);\n          else\n            return cont(typeexpr);\n        }\n      }\n      function isKW(_, value) {\n        if (value == \"is\") {\n          cx.marked = \"keyword\";\n          return cont();\n        }\n      }\n      function typeexpr(type3, value) {\n        if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n          cx.marked = \"keyword\";\n          return cont(value == \"typeof\" ? expressionNoComma : typeexpr);\n        }\n        if (type3 == \"variable\" || value == \"void\") {\n          cx.marked = \"type\";\n          return cont(afterType);\n        }\n        if (value == \"|\" || value == \"&\")\n          return cont(typeexpr);\n        if (type3 == \"string\" || type3 == \"number\" || type3 == \"atom\")\n          return cont(afterType);\n        if (type3 == \"[\")\n          return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType);\n        if (type3 == \"{\")\n          return cont(pushlex(\"}\"), typeprops, poplex, afterType);\n        if (type3 == \"(\")\n          return cont(commasep(typearg, \")\"), maybeReturnType, afterType);\n        if (type3 == \"<\")\n          return cont(commasep(typeexpr, \">\"), typeexpr);\n        if (type3 == \"quasi\") {\n          return pass(quasiType, afterType);\n        }\n      }\n      function maybeReturnType(type3) {\n        if (type3 == \"=>\")\n          return cont(typeexpr);\n      }\n      function typeprops(type3) {\n        if (type3.match(/[\\}\\)\\]]/))\n          return cont();\n        if (type3 == \",\" || type3 == \";\")\n          return cont(typeprops);\n        return pass(typeprop, typeprops);\n      }\n      function typeprop(type3, value) {\n        if (type3 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(typeprop);\n        } else if (value == \"?\" || type3 == \"number\" || type3 == \"string\") {\n          return cont(typeprop);\n        } else if (type3 == \":\") {\n          return cont(typeexpr);\n        } else if (type3 == \"[\") {\n          return cont(expect2(\"variable\"), maybetypeOrIn, expect2(\"]\"), typeprop);\n        } else if (type3 == \"(\") {\n          return pass(functiondecl, typeprop);\n        } else if (!type3.match(/[;\\}\\)\\],]/)) {\n          return cont();\n        }\n      }\n      function quasiType(type3, value) {\n        if (type3 != \"quasi\")\n          return pass();\n        if (value.slice(value.length - 2) != \"${\")\n          return cont(quasiType);\n        return cont(typeexpr, continueQuasiType);\n      }\n      function continueQuasiType(type3) {\n        if (type3 == \"}\") {\n          cx.marked = \"string-2\";\n          cx.state.tokenize = tokenQuasi;\n          return cont(quasiType);\n        }\n      }\n      function typearg(type3, value) {\n        if (type3 == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\")\n          return cont(typearg);\n        if (type3 == \":\")\n          return cont(typeexpr);\n        if (type3 == \"spread\")\n          return cont(typearg);\n        return pass(typeexpr);\n      }\n      function afterType(type3, value) {\n        if (value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n        if (value == \"|\" || type3 == \".\" || value == \"&\")\n          return cont(typeexpr);\n        if (type3 == \"[\")\n          return cont(typeexpr, expect2(\"]\"), afterType);\n        if (value == \"extends\" || value == \"implements\") {\n          cx.marked = \"keyword\";\n          return cont(typeexpr);\n        }\n        if (value == \"?\")\n          return cont(typeexpr, expect2(\":\"), typeexpr);\n      }\n      function maybeTypeArgs(_, value) {\n        if (value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType);\n      }\n      function typeparam() {\n        return pass(typeexpr, maybeTypeDefault);\n      }\n      function maybeTypeDefault(_, value) {\n        if (value == \"=\")\n          return cont(typeexpr);\n      }\n      function vardef(_, value) {\n        if (value == \"enum\") {\n          cx.marked = \"keyword\";\n          return cont(enumdef);\n        }\n        return pass(pattern, maybetype, maybeAssign, vardefCont);\n      }\n      function pattern(type3, value) {\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(pattern);\n        }\n        if (type3 == \"variable\") {\n          register(value);\n          return cont();\n        }\n        if (type3 == \"spread\")\n          return cont(pattern);\n        if (type3 == \"[\")\n          return contCommasep(eltpattern, \"]\");\n        if (type3 == \"{\")\n          return contCommasep(proppattern, \"}\");\n      }\n      function proppattern(type3, value) {\n        if (type3 == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n          register(value);\n          return cont(maybeAssign);\n        }\n        if (type3 == \"variable\")\n          cx.marked = \"property\";\n        if (type3 == \"spread\")\n          return cont(pattern);\n        if (type3 == \"}\")\n          return pass();\n        if (type3 == \"[\")\n          return cont(expression, expect2(\"]\"), expect2(\":\"), proppattern);\n        return cont(expect2(\":\"), pattern, maybeAssign);\n      }\n      function eltpattern() {\n        return pass(pattern, maybeAssign);\n      }\n      function maybeAssign(_type, value) {\n        if (value == \"=\")\n          return cont(expressionNoComma);\n      }\n      function vardefCont(type3) {\n        if (type3 == \",\")\n          return cont(vardef);\n      }\n      function maybeelse(type3, value) {\n        if (type3 == \"keyword b\" && value == \"else\")\n          return cont(pushlex(\"form\", \"else\"), statement, poplex);\n      }\n      function forspec(type3, value) {\n        if (value == \"await\")\n          return cont(forspec);\n        if (type3 == \"(\")\n          return cont(pushlex(\")\"), forspec1, poplex);\n      }\n      function forspec1(type3) {\n        if (type3 == \"var\")\n          return cont(vardef, forspec2);\n        if (type3 == \"variable\")\n          return cont(forspec2);\n        return pass(forspec2);\n      }\n      function forspec2(type3, value) {\n        if (type3 == \")\")\n          return cont();\n        if (type3 == \";\")\n          return cont(forspec2);\n        if (value == \"in\" || value == \"of\") {\n          cx.marked = \"keyword\";\n          return cont(expression, forspec2);\n        }\n        return pass(expression, forspec2);\n      }\n      function functiondef(type3, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondef);\n        }\n        if (type3 == \"variable\") {\n          register(value);\n          return cont(functiondef);\n        }\n        if (type3 == \"(\")\n          return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n        if (isTS && value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef);\n      }\n      function functiondecl(type3, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(functiondecl);\n        }\n        if (type3 == \"variable\") {\n          register(value);\n          return cont(functiondecl);\n        }\n        if (type3 == \"(\")\n          return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n        if (isTS && value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl);\n      }\n      function typename(type3, value) {\n        if (type3 == \"keyword\" || type3 == \"variable\") {\n          cx.marked = \"type\";\n          return cont(typename);\n        } else if (value == \"<\") {\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex);\n        }\n      }\n      function funarg(type3, value) {\n        if (value == \"@\")\n          cont(expression, funarg);\n        if (type3 == \"spread\")\n          return cont(funarg);\n        if (isTS && isModifier(value)) {\n          cx.marked = \"keyword\";\n          return cont(funarg);\n        }\n        if (isTS && type3 == \"this\")\n          return cont(maybetype, maybeAssign);\n        return pass(pattern, maybetype, maybeAssign);\n      }\n      function classExpression(type3, value) {\n        if (type3 == \"variable\")\n          return className(type3, value);\n        return classNameAfter(type3, value);\n      }\n      function className(type3, value) {\n        if (type3 == \"variable\") {\n          register(value);\n          return cont(classNameAfter);\n        }\n      }\n      function classNameAfter(type3, value) {\n        if (value == \"<\")\n          return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter);\n        if (value == \"extends\" || value == \"implements\" || isTS && type3 == \",\") {\n          if (value == \"implements\")\n            cx.marked = \"keyword\";\n          return cont(isTS ? typeexpr : expression, classNameAfter);\n        }\n        if (type3 == \"{\")\n          return cont(pushlex(\"}\"), classBody, poplex);\n      }\n      function classBody(type3, value) {\n        if (type3 == \"async\" || type3 == \"variable\" && (value == \"static\" || value == \"get\" || value == \"set\" || isTS && isModifier(value)) && cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false)) {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n        if (type3 == \"variable\" || cx.style == \"keyword\") {\n          cx.marked = \"property\";\n          return cont(classfield, classBody);\n        }\n        if (type3 == \"number\" || type3 == \"string\")\n          return cont(classfield, classBody);\n        if (type3 == \"[\")\n          return cont(expression, maybetype, expect2(\"]\"), classfield, classBody);\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(classBody);\n        }\n        if (isTS && type3 == \"(\")\n          return pass(functiondecl, classBody);\n        if (type3 == \";\" || type3 == \",\")\n          return cont(classBody);\n        if (type3 == \"}\")\n          return cont();\n        if (value == \"@\")\n          return cont(expression, classBody);\n      }\n      function classfield(type3, value) {\n        if (value == \"!\")\n          return cont(classfield);\n        if (value == \"?\")\n          return cont(classfield);\n        if (type3 == \":\")\n          return cont(typeexpr, maybeAssign);\n        if (value == \"=\")\n          return cont(expressionNoComma);\n        var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\";\n        return pass(isInterface ? functiondecl : functiondef);\n      }\n      function afterExport(type3, value) {\n        if (value == \"*\") {\n          cx.marked = \"keyword\";\n          return cont(maybeFrom, expect2(\";\"));\n        }\n        if (value == \"default\") {\n          cx.marked = \"keyword\";\n          return cont(expression, expect2(\";\"));\n        }\n        if (type3 == \"{\")\n          return cont(commasep(exportField, \"}\"), maybeFrom, expect2(\";\"));\n        return pass(statement);\n      }\n      function exportField(type3, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(expect2(\"variable\"));\n        }\n        if (type3 == \"variable\")\n          return pass(expressionNoComma, exportField);\n      }\n      function afterImport(type3) {\n        if (type3 == \"string\")\n          return cont();\n        if (type3 == \"(\")\n          return pass(expression);\n        if (type3 == \".\")\n          return pass(maybeoperatorComma);\n        return pass(importSpec, maybeMoreImports, maybeFrom);\n      }\n      function importSpec(type3, value) {\n        if (type3 == \"{\")\n          return contCommasep(importSpec, \"}\");\n        if (type3 == \"variable\")\n          register(value);\n        if (value == \"*\")\n          cx.marked = \"keyword\";\n        return cont(maybeAs);\n      }\n      function maybeMoreImports(type3) {\n        if (type3 == \",\")\n          return cont(importSpec, maybeMoreImports);\n      }\n      function maybeAs(_type, value) {\n        if (value == \"as\") {\n          cx.marked = \"keyword\";\n          return cont(importSpec);\n        }\n      }\n      function maybeFrom(_type, value) {\n        if (value == \"from\") {\n          cx.marked = \"keyword\";\n          return cont(expression);\n        }\n      }\n      function arrayLiteral(type3) {\n        if (type3 == \"]\")\n          return cont();\n        return pass(commasep(expressionNoComma, \"]\"));\n      }\n      function enumdef() {\n        return pass(pushlex(\"form\"), pattern, expect2(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex);\n      }\n      function enummember() {\n        return pass(pattern, maybeAssign);\n      }\n      function isContinuedStatement(state, textAfter) {\n        return state.lastType == \"operator\" || state.lastType == \",\" || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n      }\n      function expressionAllowed(stream, state, backUp) {\n        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n      }\n      return {\n        startState: function(basecolumn) {\n          var state = {\n            tokenize: tokenBase,\n            lastType: \"sof\",\n            cc: [],\n            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n            localVars: parserConfig.localVars,\n            context: parserConfig.localVars && new Context(null, null, false),\n            indented: basecolumn || 0\n          };\n          if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n            state.globalVars = parserConfig.globalVars;\n          return state;\n        },\n        token: function(stream, state) {\n          if (stream.sol()) {\n            if (!state.lexical.hasOwnProperty(\"align\"))\n              state.lexical.align = false;\n            state.indented = stream.indentation();\n            findFatArrow(stream, state);\n          }\n          if (state.tokenize != tokenComment && stream.eatSpace())\n            return null;\n          var style = state.tokenize(stream, state);\n          if (type2 == \"comment\")\n            return style;\n          state.lastType = type2 == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type2;\n          return parseJS(state, style, type2, content, stream);\n        },\n        indent: function(state, textAfter) {\n          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)\n            return CodeMirror.Pass;\n          if (state.tokenize != tokenBase)\n            return 0;\n          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top2;\n          if (!/^\\s*else\\b/.test(textAfter))\n            for (var i = state.cc.length - 1; i >= 0; --i) {\n              var c = state.cc[i];\n              if (c == poplex)\n                lexical = lexical.prev;\n              else if (c != maybeelse && c != popcontext)\n                break;\n            }\n          while ((lexical.type == \"stat\" || lexical.type == \"form\") && (firstChar == \"}\" || (top2 = state.cc[state.cc.length - 1]) && (top2 == maybeoperatorComma || top2 == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))\n            lexical = lexical.prev;\n          if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n            lexical = lexical.prev;\n          var type3 = lexical.type, closing = firstChar == type3;\n          if (type3 == \"vardef\")\n            return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n          else if (type3 == \"form\" && firstChar == \"{\")\n            return lexical.indented;\n          else if (type3 == \"form\")\n            return lexical.indented + indentUnit;\n          else if (type3 == \"stat\")\n            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n          else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n            return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n          else if (lexical.align)\n            return lexical.column + (closing ? 0 : 1);\n          else\n            return lexical.indented + (closing ? 0 : indentUnit);\n        },\n        electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n        blockCommentStart: jsonMode ? null : \"/*\",\n        blockCommentEnd: jsonMode ? null : \"*/\",\n        blockCommentContinue: jsonMode ? null : \" * \",\n        lineComment: jsonMode ? null : \"//\",\n        fold: \"brace\",\n        closeBrackets: \"()[]{}''\\\"\\\"``\",\n        helperType: jsonMode ? \"json\" : \"javascript\",\n        jsonldMode,\n        jsonMode,\n        expressionAllowed,\n        skipExpression: function(state) {\n          parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null));\n        }\n      };\n    });\n    CodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n    CodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n    CodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true });\n    CodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\n    CodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n    CodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n  });\n})();\nvar javascript = javascript$2.exports;\nvar javascript$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": javascript\n}, [javascript$2.exports]));\nvar mode$1 = {};\nvar __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {\n  return mod && mod.__esModule ? mod : { \"default\": mod };\n};\nObject.defineProperty(mode$1, \"__esModule\", { value: true });\nvar codemirror_1 = __importDefault(codemirror$2.exports);\nvar graphql_language_service_1 = require$$1$1;\ncodemirror_1.default.defineMode(\"graphql-results\", function(config2) {\n  var parser = graphql_language_service_1.onlineParser({\n    eatWhitespace: function(stream) {\n      return stream.eatSpace();\n    },\n    lexRules: LexRules,\n    parseRules: ParseRules,\n    editorConfig: { tabSize: config2.tabSize }\n  });\n  return {\n    config: config2,\n    startState: parser.startState,\n    token: parser.token,\n    indent,\n    electricInput: /^\\s*[}\\]]/,\n    fold: \"brace\",\n    closeBrackets: {\n      pairs: '[]{}\"\"',\n      explode: \"[]{}\"\n    }\n  };\n});\nfunction indent(state, textAfter) {\n  var _a2, _b;\n  var levels = state.levels;\n  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);\n  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);\n}\nvar LexRules = {\n  Punctuation: /^\\[|]|\\{|\\}|:|,/,\n  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,\n  String: /^\"(?:[^\"\\\\]|\\\\(?:\"|\\/|\\\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*\"?/,\n  Keyword: /^true|false|null/\n};\nvar ParseRules = {\n  Document: [graphql_language_service_1.p(\"{\"), graphql_language_service_1.list(\"Entry\", graphql_language_service_1.p(\",\")), graphql_language_service_1.p(\"}\")],\n  Entry: [graphql_language_service_1.t(\"String\", \"def\"), graphql_language_service_1.p(\":\"), \"Value\"],\n  Value: function(token2) {\n    switch (token2.kind) {\n      case \"Number\":\n        return \"NumberValue\";\n      case \"String\":\n        return \"StringValue\";\n      case \"Punctuation\":\n        switch (token2.value) {\n          case \"[\":\n            return \"ListValue\";\n          case \"{\":\n            return \"ObjectValue\";\n        }\n        return null;\n      case \"Keyword\":\n        switch (token2.value) {\n          case \"true\":\n          case \"false\":\n            return \"BooleanValue\";\n          case \"null\":\n            return \"NullValue\";\n        }\n        return null;\n    }\n  },\n  NumberValue: [graphql_language_service_1.t(\"Number\", \"number\")],\n  StringValue: [graphql_language_service_1.t(\"String\", \"string\")],\n  BooleanValue: [graphql_language_service_1.t(\"Keyword\", \"builtin\")],\n  NullValue: [graphql_language_service_1.t(\"Keyword\", \"keyword\")],\n  ListValue: [graphql_language_service_1.p(\"[\"), graphql_language_service_1.list(\"Value\", graphql_language_service_1.p(\",\")), graphql_language_service_1.p(\"]\")],\n  ObjectValue: [graphql_language_service_1.p(\"{\"), graphql_language_service_1.list(\"ObjectField\", graphql_language_service_1.p(\",\")), graphql_language_service_1.p(\"}\")],\n  ObjectField: [graphql_language_service_1.t(\"String\", \"property\"), graphql_language_service_1.p(\":\"), \"Value\"]\n};\nvar mode = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": mode$1\n}, [mode$1]));\nexport { renderYogaGraphiQL };\n";
const css = ".graphiql-container,.graphiql-container button,.graphiql-container input{color:#141823;font-family:system,-apple-system,San Francisco,\".SFNSDisplay-Regular\",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:14px}.graphiql-container{display:flex;flex-direction:row;height:100%;margin:0;overflow:hidden;width:100%}.graphiql-container .editorWrap{display:flex;flex-direction:column;flex:1;overflow-x:hidden}.graphiql-container .title{font-size:18px}.graphiql-container .title em{font-family:georgia;font-size:19px}.graphiql-container .topBarWrap{display:flex;flex-direction:row}.graphiql-container .topBar{align-items:center;background:linear-gradient(#f7f7f7,#e2e2e2);border-bottom:1px solid #d0d0d0;cursor:default;display:flex;flex-direction:row;flex:1;height:34px;overflow-y:visible;padding:7px 14px 6px;user-select:none}.graphiql-container .toolbar{overflow-x:visible;display:flex}.graphiql-container .docExplorerShow,.graphiql-container .historyShow{background:linear-gradient(#f7f7f7,#e2e2e2);border-radius:0;border-bottom:1px solid #d0d0d0;border-right:none;border-top:none;color:#3b5998;cursor:pointer;font-size:14px;margin:0;padding:2px 20px 0 18px}.graphiql-container .docExplorerShow{border-left:1px solid rgba(0,0,0,.2)}.graphiql-container .historyShow{border-right:1px solid rgba(0,0,0,.2);border-left:0}.graphiql-container .docExplorerShow:before{border-left:2px solid #3b5998;border-top:2px solid #3b5998;content:\"\";display:inline-block;height:9px;margin:0 3px -1px 0;position:relative;transform:rotate(-45deg);width:9px}.graphiql-container .editorBar{display:flex;flex-direction:row;flex:1;max-height:100%}.graphiql-container .queryWrap{display:flex;flex-direction:column;flex:1}.graphiql-container .resultWrap{border-left:solid 1px #e0e0e0;display:flex;flex-direction:column;flex:1;flex-basis:1em;position:relative}.graphiql-container .docExplorerWrap,.graphiql-container .historyPaneWrap{background:white;box-shadow:0 0 8px #00000026;position:relative;z-index:3}.graphiql-container .historyPaneWrap{min-width:230px;z-index:5}.graphiql-container .docExplorerResizer{cursor:col-resize;height:100%;left:-5px;position:absolute;top:0;width:10px;z-index:10}.graphiql-container .docExplorerHide{cursor:pointer;font-size:18px;margin:-7px -8px -6px 0;padding:18px 16px 15px 12px;background:0;border:0;line-height:14px}.graphiql-container div .query-editor{flex:1;position:relative}.graphiql-container .secondary-editor{display:flex;flex-direction:column;height:30px;position:relative}.graphiql-container .secondary-editor-title{background:#eeeeee;border-bottom:1px solid #d6d6d6;border-top:1px solid #e0e0e0;color:#777;font-variant:small-caps;font-weight:700;letter-spacing:1px;line-height:14px;padding:6px 0 8px 43px;text-transform:lowercase;user-select:none}.graphiql-container .codemirrorWrap,.graphiql-container .result-window{flex:1;height:100%;position:relative}.graphiql-container .footer{background:#f6f7f8;border-left:1px solid #e0e0e0;border-top:1px solid #e0e0e0;margin-left:12px;position:relative}.graphiql-container .footer:before{background:#eeeeee;bottom:0;content:\" \";left:-13px;position:absolute;top:-1px;width:12px}.result-window .CodeMirror.cm-s-graphiql{background:#f6f7f8}.graphiql-container .result-window .CodeMirror-gutters{background-color:#eee;border-color:#e0e0e0;cursor:col-resize}.graphiql-container .result-window .CodeMirror-foldgutter,.graphiql-container .result-window .CodeMirror-foldgutter-open:after,.graphiql-container .result-window .CodeMirror-foldgutter-folded:after{padding-left:3px}.graphiql-container .toolbar-button{background:#fdfdfd;background:linear-gradient(#f9f9f9,#ececec);border:0;border-radius:3px;box-shadow:inset 0 0 0 1px #0003,0 1px #ffffffb3,inset 0 1px #fff;color:#555;cursor:pointer;display:inline-block;margin:0 5px;padding:3px 11px 5px;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;max-width:150px}.graphiql-container .toolbar-button:active{background:linear-gradient(#ececec,#d5d5d5);box-shadow:0 1px #ffffffb3,inset 0 0 0 1px #0000001a,inset 0 1px 1px 1px #0000001f,inset 0 0 5px #0000001a}.graphiql-container .toolbar-button.error{background:linear-gradient(#fdf3f3,#e6d6d7);color:#b00}.graphiql-container .toolbar-button-group{margin:0 5px;white-space:nowrap}.graphiql-container .toolbar-button-group>*{margin:0}.graphiql-container .toolbar-button-group>*:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.graphiql-container .toolbar-button-group>*:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0;margin-left:-1px}.graphiql-container .execute-button-wrap{height:34px;margin:0 14px 0 28px;position:relative}.graphiql-container .execute-button{background:linear-gradient(#fdfdfd,#d2d3d6);border-radius:17px;border:1px solid rgba(0,0,0,.25);box-shadow:0 1px #fff;cursor:pointer;fill:#444;height:34px;margin:0;padding:0;width:34px}.graphiql-container .execute-button svg{pointer-events:none}.graphiql-container .execute-button:active{background:linear-gradient(#e6e6e6,#c3c3c3);box-shadow:0 1px #fff,inset 0 0 2px #0003,inset 0 0 6px #0000001a}.graphiql-container .toolbar-menu,.graphiql-container .toolbar-select{position:relative}.graphiql-container .execute-options,.graphiql-container .toolbar-menu-items,.graphiql-container .toolbar-select-options{background:#fff;box-shadow:0 0 0 1px #0000001a,0 2px 4px #00000040;margin:0;padding:6px 0;position:absolute;z-index:100}.graphiql-container .execute-options{min-width:100px;top:37px;left:-1px}.graphiql-container .toolbar-menu-items{left:1px;margin-top:-1px;min-width:110%;top:100%;visibility:hidden}.graphiql-container .toolbar-menu-items.open{visibility:visible}.graphiql-container .toolbar-select-options{left:0;min-width:100%;top:-5px;visibility:hidden}.graphiql-container .toolbar-select-options.open{visibility:visible}.graphiql-container .execute-options>li,.graphiql-container .toolbar-menu-items>li,.graphiql-container .toolbar-select-options>li{cursor:pointer;display:block;margin:none;max-width:300px;overflow:hidden;padding:2px 20px 4px 11px;white-space:nowrap}.graphiql-container .execute-options>li.selected,.graphiql-container .toolbar-menu-items>li.hover,.graphiql-container .toolbar-menu-items>li:active,.graphiql-container .toolbar-menu-items>li:hover,.graphiql-container .toolbar-select-options>li.hover,.graphiql-container .toolbar-select-options>li:active,.graphiql-container .toolbar-select-options>li:hover,.graphiql-container .history-contents>li:hover,.graphiql-container .history-contents>li:active{background:#e10098;color:#fff}.graphiql-container .toolbar-select-options>li>svg{display:inline;fill:#666;margin:0 -6px 0 6px;pointer-events:none;vertical-align:middle}.graphiql-container .toolbar-select-options>li.hover>svg,.graphiql-container .toolbar-select-options>li:active>svg,.graphiql-container .toolbar-select-options>li:hover>svg{fill:#fff}.graphiql-container .CodeMirror-scroll{overflow-scrolling:touch}.graphiql-container .CodeMirror{color:#141823;font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;font-size:13px;height:100%;left:0;position:absolute;top:0;width:100%}.graphiql-container .CodeMirror-lines{padding:20px 0}.CodeMirror-hint-information .content{box-orient:vertical;color:#141823;display:flex;font-family:system,-apple-system,San Francisco,\".SFNSDisplay-Regular\",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:13px;line-clamp:3;line-height:16px;max-height:48px;overflow:hidden;text-overflow:-o-ellipsis-lastline}.CodeMirror-hint-information .content p:first-child{margin-top:0}.CodeMirror-hint-information .content p:last-child{margin-bottom:0}.CodeMirror-hint-information .infoType{color:#ca9800;cursor:pointer;display:inline;margin-right:.5em}.autoInsertedLeaf.cm-property{animation-duration:6s;animation-name:insertionFade;border-bottom:2px solid rgba(255,255,255,0);border-radius:2px;margin:-2px -4px -1px;padding:2px 4px 1px}@keyframes insertionFade{0%,to{background:rgba(255,255,255,0);border-color:#fff0}15%,85%{background:#fbffc9;border-color:#f0f3c0}}div.CodeMirror-lint-tooltip{background-color:#fff;border-radius:2px;border:0;color:#141823;box-shadow:0 1px 3px #00000073;font-size:13px;line-height:16px;max-width:430px;opacity:0;padding:8px 10px;transition:opacity .15s;white-space:pre-wrap}div.CodeMirror-lint-tooltip>*{padding-left:23px}div.CodeMirror-lint-tooltip>*+*{margin-top:12px}.graphiql-container .variable-editor-title-text{cursor:pointer;display:inline-block;color:gray}.graphiql-container .variable-editor-title-text.active{color:#000}.graphiql-container .tabs{height:42px;background-image:linear-gradient(#f7f7f7,#e2e2e2);display:flex;align-items:center}.graphiql-container .tab{position:relative;cursor:pointer;display:flex;align-items:center;justify-content:center;padding-top:0;padding-right:6px;padding-left:14px;height:100%;color:#0009;border-left:1px solid lightgray;border-top-style:none;border-bottom-style:none;border-right-style:none}.graphiql-container .tab:first-child:nth-last-child(2){padding-right:14px}.graphiql-container .tab:hover{background-image:linear-gradient(rgba(245,245,245,.7),rgba(215,215,215,1));color:#000c}.graphiql-container .tab.active{background-image:linear-gradient(rgba(233,233,233,.7),rgba(205,205,205,1));color:#000}.graphiql-container .tab .close{display:inline-block;cursor:pointer;border:none;background:transparent;margin-left:6px;padding:3px 6px;border-radius:4px}.graphiql-container .tab:hover .close,.graphiql-container .tab.active .close{opacity:1}.graphiql-container .tab .close:before{content:\"\\2715\";display:inline-block;font-weight:700;font-size:12px;color:#000000b3;height:14px}.graphiql-container .tab .close:hover{background:rgba(0,0,0,.08)}.graphiql-container .tab .close:active{background:rgba(0,0,0,.12)}.graphiql-container .tab-add{display:flex;align-items:center;justify-content:center;border:none;background:transparent;line-height:1;font-size:26px;padding:0 8px 3px;height:30px;border-radius:4px;color:#00000080;margin-left:6px;cursor:pointer}.graphiql-container .tab-add:hover{background:rgba(0,0,0,.06)}.graphiql-container .tab-add:active{background:rgba(0,0,0,.1)}.graphiql-container .CodeMirror-foldmarker{border-radius:4px;background:#08f;background:linear-gradient(#43a8ff,#0f83e8);box-shadow:0 1px 1px #0003,inset 0 0 0 1px #0000001a;color:#fff;font-family:arial;font-size:12px;line-height:0;margin:0 3px;padding:0 4px 1px;text-shadow:0 -1px rgba(0,0,0,.1)}.graphiql-container div.CodeMirror span.CodeMirror-matchingbracket{color:#555;text-decoration:underline}.graphiql-container div.CodeMirror span.CodeMirror-nonmatchingbracket{color:red}.cm-comment{color:#666}.cm-punctuation{color:#555}.cm-keyword{color:#b11a04}.cm-def{color:#d2054e}.cm-property{color:#1f61a0}.cm-qualifier{color:#1c92a9}.cm-attribute{color:#8b2bb9}.cm-number{color:#2882f9}.cm-string{color:#d64292}.cm-builtin{color:#d47509}.cm-string-2{color:#0b7fc7}.cm-variable{color:#397d13}.cm-meta{color:#b33086}.cm-atom{color:#ca9800}.CodeMirror{color:#000;font-family:monospace;height:300px}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{color:#666;min-width:20px;padding:0 3px 0 5px;text-align:right;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#666}.CodeMirror .CodeMirror-cursor{border-left:1px solid black}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.CodeMirror.cm-fat-cursor div.CodeMirror-cursor{background:#7e7;border:0;width:auto}.CodeMirror.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{animation:blink 1.06s steps(1) infinite;border:0;width:auto}@keyframes blink{0%{background:#7e7}50%{background:none}to{background:#7e7}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#666}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-s-default .cm-hr{color:#666}.cm-s-default .cm-link{color:#00c}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-error,.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{background:white;overflow:hidden;position:relative}.CodeMirror-scroll{height:100%;margin-bottom:-30px;margin-right:-30px;outline:none;overflow:scroll!important;padding-bottom:30px;position:relative}.CodeMirror-sizer{border-right:30px solid transparent;position:relative}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{display:none;position:absolute;z-index:6}.CodeMirror-vscrollbar{overflow-x:hidden;overflow-y:scroll;right:0;top:0}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-x:scroll;overflow-y:hidden}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{min-height:100%;position:absolute;left:0;top:0;z-index:3}.CodeMirror-gutter{display:inline-block;height:100%;margin-bottom:-30px;vertical-align:top;white-space:normal}.CodeMirror-gutter-wrapper{background:none!important;border:none!important;position:absolute;z-index:4}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{cursor:default;position:absolute;z-index:4}.CodeMirror-gutter-wrapper{user-select:none}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-webkit-tap-highlight-color:transparent;background:transparent;border-radius:0;border-width:0;color:inherit;font-family:inherit;font-size:inherit;font-variant-ligatures:none;line-height:inherit;margin:0;overflow:visible;position:relative;white-space:pre;word-wrap:normal;z-index:2}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{overflow:auto;position:relative;z-index:2}.CodeMirror-code{outline:none}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber{box-sizing:content-box}.CodeMirror-measure{height:0;overflow:hidden;position:absolute;visibility:hidden;width:100%}.CodeMirror-cursor{position:absolute}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{position:relative;visibility:hidden;z-index:3}div.CodeMirror-dragcursors,.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:\"\"}span.CodeMirror-selectedtext{background:none}.CodeMirror-dialog{background:inherit;color:inherit;left:0;right:0;overflow:hidden;padding:.1em .8em;position:absolute;z-index:15}.CodeMirror-dialog-top{border-bottom:1px solid #eee;top:0}.CodeMirror-dialog-bottom{border-top:1px solid #eee;bottom:0}.CodeMirror-dialog input{background:transparent;border:1px solid #d3d6db;color:inherit;font-family:monospace;outline:none;width:20em}.CodeMirror-dialog button{font-size:70%}.CodeMirror-foldmarker{color:#00f;cursor:pointer;font-family:arial;line-height:.3;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-open,.CodeMirror-foldgutter-folded{cursor:pointer}.CodeMirror-foldgutter-open:after{content:\"\\25be\"}.CodeMirror-foldgutter-folded:after{content:\"\\25b8\"}.CodeMirror-info{background:white;border-radius:2px;box-shadow:0 1px 3px #00000073;box-sizing:border-box;color:#555;font-family:system,-apple-system,San Francisco,\".SFNSDisplay-Regular\",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:13px;line-height:16px;margin:8px -8px;max-width:400px;opacity:0;overflow:hidden;padding:8px;position:fixed;transition:opacity .15s;z-index:50}.CodeMirror-info :first-child{margin-top:0}.CodeMirror-info :last-child{margin-bottom:0}.CodeMirror-info p{margin:1em 0}.CodeMirror-info .info-description{color:#777;line-height:16px;margin-top:1em;max-height:80px;overflow:hidden}.CodeMirror-info .info-deprecation{background:#fffae8;box-shadow:inset 0 1px 1px -1px #bfb063;color:#867f70;line-height:16px;margin:8px -8px -8px;max-height:80px;overflow:hidden;padding:8px}.CodeMirror-info .info-deprecation-label{color:#c79b2e;cursor:default;display:block;font-size:9px;font-weight:700;letter-spacing:1px;line-height:1;padding-bottom:5px;text-transform:uppercase;user-select:none}.CodeMirror-info .info-deprecation-label+*{margin-top:0}.CodeMirror-info a{text-decoration:none}.CodeMirror-info a:hover{text-decoration:underline}.CodeMirror-info .type-name{color:#ca9800}.CodeMirror-info .field-name{color:#1f61a0}.CodeMirror-info .enum-value{color:#0b7fc7}.CodeMirror-info .arg-name{color:#8b2bb9}.CodeMirror-info .directive-name{color:#b33086}.CodeMirror-jump-token{text-decoration:underline;cursor:pointer}.CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:infobackground;border-radius:4px;border:1px solid black;color:infotext;font-family:monospace;font-size:10pt;max-width:600px;opacity:0;overflow:hidden;padding:2px 5px;position:fixed;transition:opacity .4s;white-space:pre-wrap;z-index:100}.CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning{background-position:left bottom;background-repeat:repeat-x}.CodeMirror-lint-mark-error{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==)}.CodeMirror-lint-mark-warning{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=)}.CodeMirror-lint-marker-error,.CodeMirror-lint-marker-warning{background-position:center center;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;position:relative;vertical-align:middle;width:16px}.CodeMirror-lint-message-error,.CodeMirror-lint-message-warning{background-position:top left;background-repeat:no-repeat;padding-left:18px}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=)}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=)}.CodeMirror-lint-marker-multiple{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC);background-position:right bottom;background-repeat:no-repeat;width:100%;height:100%}.graphiql-container .spinner-container{height:36px;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%);width:36px;z-index:10}.graphiql-container .spinner{animation:rotation .6s infinite linear;border-bottom:6px solid rgba(150,150,150,.15);border-left:6px solid rgba(150,150,150,.15);border-radius:100%;border-right:6px solid rgba(150,150,150,.15);border-top:6px solid rgba(150,150,150,.8);display:inline-block;height:24px;position:absolute;vertical-align:middle;width:24px}@keyframes rotation{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.CodeMirror-hints{background:white;box-shadow:0 1px 3px #00000073;font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;font-size:13px;list-style:none;margin:0;max-height:14.5em;overflow:hidden;overflow-y:auto;padding:0;position:absolute;z-index:10}.CodeMirror-hint{border-top:solid 1px #f7f7f7;color:#141823;cursor:pointer;margin:0;max-width:300px;overflow:hidden;padding:2px 6px;white-space:pre}li.CodeMirror-hint-active{background-color:#08f;border-top-color:#fff;color:#fff}.CodeMirror-hint-information{border-top:solid 1px #c0c0c0;max-width:300px;padding:4px 6px;position:relative;z-index:1}.CodeMirror-hint-information:first-child{border-bottom:solid 1px #c0c0c0;border-top:none;margin-bottom:-1px}.CodeMirror-hint-deprecation{background:#fffae8;box-shadow:inset 0 1px 1px -1px #bfb063;color:#867f70;font-family:system,-apple-system,San Francisco,\".SFNSDisplay-Regular\",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;font-size:13px;line-height:16px;margin-top:4px;max-height:80px;overflow:hidden;padding:6px}.CodeMirror-hint-deprecation .deprecation-label{color:#c79b2e;cursor:default;display:block;font-size:9px;font-weight:700;letter-spacing:1px;line-height:1;padding-bottom:5px;text-transform:uppercase;user-select:none}.CodeMirror-hint-deprecation .deprecation-label+*{margin-top:0}.CodeMirror-hint-deprecation :last-child{margin-bottom:0}.graphiql-container .doc-explorer{background:white}.graphiql-container .doc-explorer-title-bar,.graphiql-container .history-title-bar{cursor:default;display:flex;height:34px;line-height:14px;padding:8px 8px 5px;position:relative;user-select:none}.graphiql-container .doc-explorer-title,.graphiql-container .history-title{flex:1;font-weight:700;overflow-x:hidden;padding:10px 0 10px 10px;text-align:center;text-overflow:ellipsis;user-select:text;white-space:nowrap}.graphiql-container .doc-explorer-back{color:#3b5998;cursor:pointer;margin:-7px 0 -6px -8px;overflow-x:hidden;padding:17px 12px 16px 16px;text-overflow:ellipsis;white-space:nowrap;background:0;border:0;line-height:14px}.doc-explorer-narrow .doc-explorer-back{width:0}.graphiql-container .doc-explorer-back:before{border-left:2px solid #3b5998;border-top:2px solid #3b5998;content:\"\";display:inline-block;height:9px;margin:0 3px -1px 0;position:relative;transform:rotate(-45deg);width:9px}.graphiql-container .doc-explorer-rhs{position:relative}.graphiql-container .doc-explorer-contents,.graphiql-container .history-contents{background-color:#fff;border-top:1px solid #d6d6d6;bottom:0;left:0;overflow-y:auto;padding:20px 15px;position:absolute;right:0;top:47px}.graphiql-container .doc-explorer-contents{min-width:300px}.graphiql-container .doc-type-description p:first-child,.graphiql-container .doc-type-description blockquote:first-child{margin-top:0}.graphiql-container .doc-explorer-contents a{cursor:pointer;text-decoration:none}.graphiql-container .doc-explorer-contents a:hover{text-decoration:underline}.graphiql-container .doc-value-description>:first-child{margin-top:4px}.graphiql-container .doc-value-description>:last-child{margin-bottom:4px}.graphiql-container .doc-type-description code,.graphiql-container .doc-type-description pre,.graphiql-container .doc-category code,.graphiql-container .doc-category pre{--saf-0: rgba(var(--sk_foreground_low, 29, 28, 29), .13);font-size:12px;line-height:1.50001;font-variant-ligatures:none;white-space:pre;white-space:pre-wrap;word-wrap:break-word;word-break:normal;-webkit-tab-size:4;-moz-tab-size:4;tab-size:4}.graphiql-container .doc-type-description code,.graphiql-container .doc-category code{padding:2px 3px 1px;border:1px solid var(--saf-0);border-radius:3px;background-color:rgba(var(--sk_foreground_min, 29, 28, 29),.04);color:#e01e5a;background-color:#fff}.graphiql-container .doc-category{margin:20px 0}.graphiql-container .doc-category-title{border-bottom:1px solid #e0e0e0;color:#777;cursor:default;font-size:14px;font-variant:small-caps;font-weight:700;letter-spacing:1px;margin:0 -15px 10px 0;padding:10px 0;user-select:none}.graphiql-container .doc-category-item{margin:12px 0;color:#555}.graphiql-container .keyword{color:#b11a04}.graphiql-container .type-name{color:#ca9800}.graphiql-container .field-name{color:#1f61a0}.graphiql-container .field-short-description{color:#666;margin-left:5px;overflow:hidden;text-overflow:ellipsis}.graphiql-container .enum-value{color:#0b7fc7}.graphiql-container .arg-name{color:#8b2bb9}.graphiql-container .arg{display:block;margin-left:1em}.graphiql-container .arg:first-child:last-child,.graphiql-container .arg:first-child:nth-last-child(2),.graphiql-container .arg:first-child:nth-last-child(2)~.arg{display:inherit;margin:inherit}.graphiql-container .arg:first-child:nth-last-child(2):after{content:\", \"}.graphiql-container .arg-default-value{color:#43a047}.graphiql-container .doc-deprecation{background:#fffae8;box-shadow:inset 0 0 1px #bfb063;color:#867f70;line-height:16px;margin:8px -8px;max-height:80px;overflow:hidden;padding:8px;border-radius:3px}.graphiql-container .doc-deprecation:before{content:\"Deprecated:\";color:#c79b2e;cursor:default;display:block;font-size:9px;font-weight:700;letter-spacing:1px;line-height:1;padding-bottom:5px;text-transform:uppercase;user-select:none}.graphiql-container .doc-deprecation>:first-child{margin-top:0}.graphiql-container .doc-deprecation>:last-child{margin-bottom:0}.graphiql-container .show-btn{-webkit-appearance:initial;display:block;border-radius:3px;border:solid 1px #ccc;text-align:center;padding:8px 12px 10px;width:100%;box-sizing:border-box;background:#fbfcfc;color:#555;cursor:pointer}.graphiql-container .search-box{border-bottom:1px solid #d3d6db;display:flex;align-items:center;font-size:14px;margin:-15px -15px 12px 0;position:relative}.graphiql-container .search-box-icon{cursor:pointer;display:block;font-size:24px;transform:rotate(-45deg);user-select:none}.graphiql-container .search-box .search-box-clear{background-color:#d0d0d0;border-radius:12px;color:#fff;cursor:pointer;font-size:11px;padding:1px 5px 2px;position:absolute;right:3px;user-select:none;border:0}.graphiql-container .search-box .search-box-clear:hover{background-color:#b9b9b9}.graphiql-container .search-box>input{border:none;box-sizing:border-box;font-size:14px;outline:none;padding:6px 24px 8px 20px;width:100%}.graphiql-container .error-container{font-weight:700;left:0;letter-spacing:1px;opacity:.5;position:absolute;right:0;text-align:center;text-transform:uppercase;top:50%;transform:translateY(-50%)}.graphiql-container .history-contents{font-family:Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace}.graphiql-container .history-contents{margin:0;padding:0}.graphiql-container .history-contents li{align-items:center;display:flex;font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin:0;padding:8px;border-bottom:1px solid #e0e0e0}.graphiql-container .history-contents li button:not(.history-label){display:none;margin-left:10px}.graphiql-container .history-contents li:hover button:not(.history-label),.graphiql-container .history-contents li:focus-within button:not(.history-label){display:inline-block}.graphiql-container .history-contents input,.graphiql-container .history-contents button{padding:0;background:0;border:0;font-size:inherit;font-family:inherit;line-height:14px;color:inherit}.graphiql-container .history-contents input{flex-grow:1}.graphiql-container .history-contents input::placeholder{color:inherit}.graphiql-container .history-contents button{cursor:pointer;text-align:left}.graphiql-container .history-contents .history-label{flex-grow:1;overflow:hidden;text-overflow:ellipsis}body,html{margin:0}.graphiql-container{height:100vh;width:100vw}.graphiql-explorer-node{margin-left:3px}.graphiql-explorer-root .graphiql-operation-title-bar{display:flex;align-items:center}.graphiql-explorer-root .graphiql-operation-title-bar input{min-width:11ch}.graphiql-container .docExplorerShowReverse{border-right:1px solid rgba(0,0,0,.2)!important}.docExplorerShowReverse:before{display:none!important}.docExplorerShowReverse:after{border-left:2px solid #3b5998;border-top:2px solid #3b5998;content:\"\";display:inline-block;height:9px;margin:0 0 -1px 3px;position:relative;transform:rotate(135deg);width:9px}.graphiql-explorer-root input{background-color:#282d34!important;padding-left:5px}.graphiql-explorer-actions select{background-color:#282d34!important;color:#fff;margin-left:5px}.graphiql-explorer-root div:first-child{overflow:auto!important}.graphiql-operation-title-bar{background-color:transparent}.CodeMirror{background:#282d34!important}.graphiql-container .doc-explorer-contents,.graphiql-container .history-contents{background-color:#21262b;border-top:1px solid #181a1f}.graphiql-container .doc-explorer-contents .graphiql-explorer-node svg{margin-right:5px!important}.graphiql-container .doc-explorer-contents .graphiql-explorer-node path{fill:#e0dddd!important}.graphiql-container .toolbar-button{background:#1c2125!important;box-shadow:none!important;color:#fff!important;border:1px solid #181a1f!important}.graphiql-container .toolbar-button:hover{color:#c7c7c7!important}.graphiql-container .result-window .CodeMirror-gutters{background:#282d33;border:none!important}.graphiql-container .resultWrap{border-left:solid 1px #181a1f}.graphiql-container .variable-editor-title{background:#21262b;border-bottom:1px solid #181a1f;border-top:1px solid #181a1f;color:#cacdd3}.graphiql-container .topBar{background:#21262b;border-color:#181a1f}.graphiql-container .docExplorerHide{color:#fff}.graphiql-container .docExplorerHide:hover{color:#c7c7c7}.graphiql-container .doc-explorer-title,.graphiql-container .history-title,.doc-explorer-back{color:#cacdd3!important}.graphiql-container .doc-explorer{background:#21262b}.graphiql-container .docExplorerWrap,.graphiql-container .historyPaneWrap{box-shadow:none}.graphiql-container .docExplorerShow{border-left:none}.graphiql-container .docExplorerShow,.graphiql-container .historyShow{background:#21262b;border-bottom:1px solid #181a1e;color:#cacdd3}.graphiql-container .docExplorerShow:before,.graphiql-container .doc-explorer-back:before{border-color:#cacdd3}.graphiql-container .search-box{margin:auto auto 10px;border:none}.graphiql-container .search-box input{background:#1e2127;padding-left:28px}.graphiql-container .search-box .search-box-clear,.graphiql-container .search-box .search-box-clear:hover{background:#1d2126}.graphiql-container .search-box:before{color:#c1c4ca;font-size:21px;left:8px}.search-box-icon{position:absolute;padding-left:5px}.graphiql-container,.graphiql-container button,.graphiql-container input{color:#9299a7}.CodeMirror-gutters{border:none!important;background-color:#282d33}.graphiql-container .execute-button{background:#21262b;border:1px solid rgb(91,98,107);box-shadow:none!important;fill:#c9ccd2}.graphiql-container .execute-button:hover{fill:#999ba0}.graphiql-container .history-contents p{border:none}.graphiql-container .historyPaneWrap{background:#21262b}.graphiql-container .execute-options>li.selected,.graphiql-container .toolbar-menu-items>li.hover,.graphiql-container .toolbar-menu-items>li:active,.graphiql-container .toolbar-menu-items>li:hover,.graphiql-container .toolbar-select-options>li.hover,.graphiql-container .toolbar-select-options>li:active,.graphiql-container .toolbar-select-options>li:hover,.graphiql-container .history-contents>p:hover,.graphiql-container .history-contents>p:active{background:#383c41}.graphiql-container .doc-category-title{border-bottom:1px solid #181a1f;color:#cacdd3}.graphiql-container .field-name{color:#0083c7}.graphiql-container .type-name{color:#ff6d5d}.graphiql-container .keyword{color:#9ea5b0}.graphiql-container .arg-name{color:#0083c7}.graphiql-container .doc-category-item{color:#ff9f4c}.graphiql-container .variable-editor-title-text.active{color:#fff}.cm-property{color:#0083c7}.cm-number{color:#97b1aa}.cm-string{color:#00917d}.cm-builtin{color:#da8aff}.cm-variable{color:#f9f871}.cm-attribute{color:#00b8ff}.cm-def{color:#9f51d9}.cm-punctuation{color:#c7c7c7!important}.doc-type-description code{color:#cc3932;background-color:#383c41!important}.cm-keyword{color:#ff6d5d}.cm-atom{color:#ff9f4c}a{color:#7b9ad4}.CodeMirror .CodeMirror-cursor{border-left:1px solid white}.CodeMirror-lint-tooltip{background:#1a1e22!important;color:red}.CodeMirror-hints{background:#21262a;box-shadow:0 16px 13px -10px #0000004d}.CodeMirror-hint{border-top:solid 1px #212629;color:#a45300}.CodeMirror-hint-information{border-top:solid 1px #181a1e}li.CodeMirror-hint-active{background-color:#262c2f;border-top-color:#212629;color:#d17825}.CodeMirror-hint-information .content{color:#a4abb7}.graphiql-container .tabs{background:#21262b}.graphiql-container .tabs .tab,.graphiql-container .tab-add,.graphiql-container .tab .close:before{background:#1c2125;color:#ffffffb3}.graphiql-container .tab-add:hover,.graphiql-container .tabs .tab:hover{color:#ffffffe6}.graphiql-container .tabs .tab.active,.graphiql-container .tab.active .close:before{color:#fff}.graphiql-container .tabs .tab{border-color:#9299a74d}.graphiql-container .tabs .tab:first-child{border:none}\n";

const renderGraphiQL = (opts) => /* HTML */ `
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8" />
      <title>${(opts === null || opts === void 0 ? void 0 : opts.title) || 'Yoga GraphiQL'}</title>
      <link rel="icon" href="https://www.graphql-yoga.com/favicon.ico" />
      <style>
        ${css}
      </style>
    </head>
    <body id="body" class="no-focus-outline">
      <noscript>You need to enable JavaScript to run this app.</noscript>
      <div id="root"></div>

      <script>
        // Polyfills until we can change DataLoader
        if (globalThis.window?.setImmediate == null) {
          //@ts-ignore
          globalThis.window.setImmediate = setTimeout
          globalThis.global = globalThis
        }
      </script>
      <script type="module">
        ${js}
        renderYogaGraphiQL(
          window.document.querySelector('#root'),
          ${JSON.stringify(opts !== null && opts !== void 0 ? opts : {})},
        )
      </script>
    </body>
  </html>
`;

exports.renderGraphiQL = renderGraphiQL;
