import { envelop, enableIf, useSchema, useLogger, useExtendContext, useMaskedErrors } from '@envelop/core';
export * from '@envelop/core';
export { EnvelopError as GraphQLYogaError } from '@envelop/core';
import chalk from 'chalk';
import { inspect, isAsyncIterable } from '@graphql-tools/utils';
import { GraphQLError, getOperationAST, isSchema, print } from 'graphql';
import { useValidationCache } from '@envelop/validation-cache';
import { useParserCache } from '@envelop/parser-cache';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { renderGraphiQL } from '@graphql-yoga/render-graphiql';
export { renderGraphiQL } from '@graphql-yoga/render-graphiql';
import { Response, ReadableStream, fetch, Request } from 'cross-undici-fetch';
import { dset } from 'dset';
export * from '@graphql-yoga/subscription';

const warnColor = chalk.keyword(`orange`);
const infoColor = chalk.cyan;
const errorColor = chalk.red;
const debugColor = chalk.magenta;
const titleBold = chalk.bold;
const isDebug = () => (typeof process === 'object' ? process.env.DEBUG : false);
function getPrefix() {
    return titleBold(`🧘 Yoga -`);
}
function getLoggerMessage(...args) {
    return args
        .map((arg) => (typeof arg === 'string' ? arg : inspect(arg)))
        .join(` `);
}
const defaultYogaLogger = {
    debug(...args) {
        if (isDebug()) {
            const message = getLoggerMessage(...args);
            const fullMessage = `${getPrefix()} 🐛 ${debugColor(message)}`;
            // Some environments don't have other console methods
            if (console.debug) {
                console.debug(fullMessage);
            }
            else {
                console.log(fullMessage);
            }
        }
    },
    info(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `${getPrefix()} 💡 ${infoColor(message)}`;
        if (console.info) {
            console.info(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
    warn(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `${getPrefix()} ⚠️ ${warnColor(message)}`;
        if (console.warn) {
            console.warn(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
    error(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `${getPrefix()} ❌ ${errorColor(message)}`;
        if (console.error) {
            console.error(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
};

function shouldRenderGraphiQL({ headers, method }) {
    var _a;
    return method === 'GET' && !!((_a = headers === null || headers === void 0 ? void 0 : headers.get('accept')) === null || _a === void 0 ? void 0 : _a.includes('text/html'));
}

const GETRequestParser = {
    is: (request) => request.method === 'GET',
    parse: async (request) => {
        const url = new URL(request.url);
        const operationName = url.searchParams.get('operationName') || undefined;
        const query = url.searchParams.get('query') || undefined;
        const variables = url.searchParams.get('variables') || undefined;
        const extensions = url.searchParams.get('extensions') || undefined;
        return {
            operationName,
            query,
            variables: variables ? JSON.parse(variables) : undefined,
            extensions: extensions ? JSON.parse(extensions) : undefined,
        };
    },
};
const POSTRequestParser = {
    is: (request) => request.method === 'POST',
    parse: async (request) => {
        const requestBody = await request.json();
        return {
            operationName: requestBody.operationName,
            query: requestBody.query,
            variables: requestBody.variables,
            extensions: requestBody.extensions,
        };
    },
};
const POSTMultipartFormDataRequestParser = {
    is: (request) => {
        var _a;
        return request.method === 'POST' &&
            !!((_a = request.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.startsWith('multipart/form-data'));
    },
    parse: async (request) => {
        var _a, _b;
        const requestBody = await request.formData();
        const operationsStr = ((_a = requestBody.get('operations')) === null || _a === void 0 ? void 0 : _a.toString()) || '{}';
        const operations = JSON.parse(operationsStr);
        const mapStr = ((_b = requestBody.get('map')) === null || _b === void 0 ? void 0 : _b.toString()) || '{}';
        const map = JSON.parse(mapStr);
        for (const fileIndex in map) {
            const file = requestBody.get(fileIndex);
            const [path] = map[fileIndex];
            dset(operations, path, file);
        }
        return {
            operationName: operations.operationName,
            query: operations.query,
            variables: operations.variables,
            extensions: operations.extensions,
        };
    },
};
function buildGetGraphQLParameters(parsers) {
    return async function getGraphQLParameters(request) {
        for (const parser of parsers) {
            if (parser.is(request)) {
                return parser.parse(request);
            }
        }
        return {
            operationName: undefined,
            query: undefined,
            variables: undefined,
            extensions: undefined,
        };
    };
}
const getGraphQLParameters = buildGetGraphQLParameters([
    GETRequestParser,
    POSTMultipartFormDataRequestParser,
    POSTRequestParser,
]);

let encodeString;
if ('Buffer' in globalThis) {
    encodeString = (str) => Buffer.from(str, 'utf-8');
}
else {
    const textEncoder = new TextEncoder();
    encodeString = (str) => textEncoder.encode(str);
}

function getRegularResponse(executionResult, extraHeaders) {
    const responseBody = JSON.stringify(executionResult);
    const decodedString = encodeString(responseBody);
    const headersInit = {
        ...extraHeaders,
        'Content-Type': 'application/json',
        'Content-Length': decodedString.byteLength.toString(),
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    return new Response(decodedString, responseInit);
}
function getMultipartResponse(asyncExecutionResult, extraHeaders) {
    const headersInit = {
        ...extraHeaders,
        Connection: 'keep-alive',
        'Content-Type': 'multipart/mixed; boundary="-"',
        'Transfer-Encoding': 'chunked',
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new ReadableStream({
        start(controller) {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
            controller.enqueue(encodeString(`---`));
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (value != null) {
                controller.enqueue(encodeString('\r\n'));
                controller.enqueue(encodeString('Content-Type: application/json; charset=utf-8\r\n'));
                const chunk = JSON.stringify(value);
                const encodedChunk = encodeString(chunk);
                controller.enqueue(encodeString('Content-Length: ' + encodedChunk.byteLength + '\r\n'));
                controller.enqueue(encodeString('\r\n'));
                controller.enqueue(encodedChunk);
                if (value.hasNext) {
                    controller.enqueue(encodeString('\r\n---'));
                }
            }
            if (done) {
                controller.enqueue(encodeString('\r\n-----\r\n'));
                controller.close();
            }
        },
        async cancel(e) {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
        },
    });
    return new Response(readableStream, responseInit);
}
function getPushResponse(asyncExecutionResult, extraHeaders) {
    const headersInit = {
        ...extraHeaders,
        'Content-Type': 'text/event-stream',
        Connection: 'keep-alive',
        'Cache-Control': 'no-cache',
        'Content-Encoding': 'none',
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new ReadableStream({
        start() {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (value != null) {
                const chunk = JSON.stringify(value);
                controller.enqueue(encodeString(`data: ${chunk}\n\n`));
            }
            if (done) {
                controller.close();
            }
        },
        async cancel(e) {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
        },
    });
    return new Response(readableStream, responseInit);
}
async function* getSingleResult(payload) {
    yield payload;
}
function getErrorResponse({ status = 500, headers, errors, isEventStream, }) {
    const payload = {
        data: null,
        errors,
    };
    if (isEventStream) {
        return getPushResponse(getSingleResult(payload), headers);
    }
    return new Response(JSON.stringify(payload), {
        status,
        headers: {
            ...headers,
            'Content-Type': 'application/json',
        },
    });
}

async function parseQuery(query, parse) {
    if (typeof query !== 'string' && query.kind === 'Document') {
        return query;
    }
    return parse(query);
}
const getExecutableOperation = (document, operationName) => {
    const operation = getOperationAST(document, operationName);
    if (!operation) {
        throw new Error('Could not determine what operation to execute.');
    }
    return operation;
};
const processRequest = async ({ contextFactory, execute, operationName, parse, query, request, schema, subscribe, validate, variables, extraHeaders, }) => {
    let contextValue;
    let document;
    let operation;
    const isEventStream = request.headers.get('accept') === 'text/event-stream';
    try {
        if (request.method !== 'GET' && request.method !== 'POST') {
            return getErrorResponse({
                status: 405,
                headers: {
                    Allow: 'GET, POST',
                    ...extraHeaders,
                },
                errors: [
                    new GraphQLError('GraphQL only supports GET and POST requests.'),
                ],
                isEventStream,
            });
        }
        if (query == null) {
            return getErrorResponse({
                status: 400,
                errors: [new GraphQLError('Must provide query string.')],
                isEventStream,
                headers: extraHeaders,
            });
        }
        try {
            document = await parseQuery(query, parse);
        }
        catch (e) {
            return getErrorResponse({
                status: 400,
                errors: [e],
                isEventStream,
                headers: extraHeaders,
            });
        }
        const validationErrors = validate(schema, document);
        if (validationErrors.length > 0) {
            return getErrorResponse({
                status: 400,
                errors: validationErrors,
                isEventStream,
                headers: extraHeaders,
            });
        }
        operation = getExecutableOperation(document, operationName);
        if (operation.operation === 'mutation' && request.method === 'GET') {
            return getErrorResponse({
                status: 405,
                errors: [
                    new GraphQLError('Can only perform a mutation operation from a POST request.'),
                ],
                headers: {
                    Allow: 'POST',
                    ...extraHeaders,
                },
                isEventStream,
            });
        }
        let variableValues;
        try {
            if (variables) {
                variableValues =
                    typeof variables === 'string' ? JSON.parse(variables) : variables;
            }
        }
        catch (_error) {
            return getErrorResponse({
                errors: [new GraphQLError('Variables are invalid JSON.')],
                status: 400,
                isEventStream,
                headers: extraHeaders,
            });
        }
        contextValue = await contextFactory();
        const executionArgs = {
            schema,
            document,
            contextValue,
            variableValues,
            operationName,
        };
        if (operation.operation === 'subscription') {
            const result = await subscribe(executionArgs);
            // If errors are encountered while subscribing to the operation, an execution result
            // instead of an AsyncIterable.
            if (isAsyncIterable(result)) {
                return getPushResponse(result, extraHeaders);
            }
            else {
                if (isEventStream) {
                    return getPushResponse(result, extraHeaders);
                }
                else {
                    return getRegularResponse(result, extraHeaders);
                }
            }
        }
        else {
            const result = await execute(executionArgs);
            // Operations that use @defer, @stream and @live will return an `AsyncIterable` instead of an
            // execution result.
            if (isAsyncIterable(result)) {
                return isEventStream
                    ? getPushResponse(result, extraHeaders)
                    : getMultipartResponse(result, extraHeaders);
            }
            else {
                return getRegularResponse(result, extraHeaders);
            }
        }
    }
    catch (error) {
        const errors = [
            error instanceof GraphQLError
                ? error
                : new GraphQLError(error.message, undefined, undefined, undefined, undefined, error),
        ];
        return getErrorResponse({
            status: 500,
            errors,
            isEventStream,
            headers: extraHeaders,
        });
    }
};

function getDefaultSchema() {
    return makeExecutableSchema({
        typeDefs: /* GraphQL */ `
      """
      Greetings from GraphQL Yoga!
      """
      type Query {
        greetings: String
      }
      type Subscription {
        """
        Current Time
        """
        time: String
      }
    `,
        resolvers: {
            Query: {
                greetings: () => 'This is the `greetings` field of the root `Query` type',
            },
            Subscription: {
                time: {
                    subscribe: async function* () {
                        while (true) {
                            yield { time: new Date().toISOString() };
                            await new Promise((resolve) => setTimeout(resolve, 1000));
                        }
                    },
                },
            },
        },
    });
}
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */
class YogaServer {
    constructor(options) {
        var _a, _b;
        this.corsOptionsFactory = () => ({});
        this.id = Date.now().toString();
        this.handleRequest = async (request, ...args) => {
            const serverContext = args[0];
            try {
                if (request.method === 'OPTIONS') {
                    return this.handleOptions(request, ...args);
                }
                const requestUrl = new URL(request.url);
                if (requestUrl.pathname.endsWith('/health')) {
                    return new Response(`{ "message": "alive" }`, {
                        status: 200,
                        headers: {
                            'Content-Type': 'application/json',
                            'x-yoga-id': this.id,
                        },
                    });
                }
                if (requestUrl.pathname.endsWith('/readiness')) {
                    const readinessResponse = await fetch(request.url.replace('/readiness', '/health'));
                    if (readinessResponse.status === 200 &&
                        readinessResponse.headers.get('x-yoga-id') === this.id) {
                        return new Response(`{ "message": "ready" }`, {
                            status: 200,
                            headers: {
                                'Content-Type': 'application/json',
                            },
                        });
                    }
                    throw new Error(`Readiness check failed with status ${readinessResponse.status}`);
                }
                this.logger.debug(`Checking if GraphiQL Request`);
                if (shouldRenderGraphiQL(request)) {
                    const graphiqlOptions = this.graphiqlOptionsFactory(request, ...args);
                    if (graphiqlOptions) {
                        const graphiQLBody = renderGraphiQL(graphiqlOptions);
                        return new Response(graphiQLBody, {
                            headers: {
                                'Content-Type': 'text/html',
                            },
                            status: 200,
                        });
                    }
                }
                this.logger.debug(`Extracting GraphQL Parameters`);
                const { query, variables, operationName, extensions } = await getGraphQLParameters(request);
                const initialContext = {
                    request,
                    query,
                    variables,
                    operationName,
                    extensions,
                    ...serverContext,
                };
                const { execute, validate, subscribe, parse, contextFactory, schema } = this.getEnveloped(initialContext);
                this.logger.debug(`Processing Request`);
                const corsHeaders = this.getCORSResponseHeaders(request, initialContext);
                const response = await processRequest({
                    request,
                    query,
                    variables,
                    operationName,
                    execute,
                    validate,
                    subscribe,
                    parse,
                    contextFactory,
                    schema,
                    extraHeaders: corsHeaders,
                });
                return response;
            }
            catch (err) {
                this.logger.error(err.message, err.stack, err);
                const response = new Response(err.message, {
                    status: 500,
                    statusText: 'Internal Server Error',
                });
                return response;
            }
        };
        this.fetch = (input, init) => {
            let request;
            if (typeof input === 'string') {
                request = new Request(input, init);
            }
            else {
                request = input;
            }
            return this.handleRequest(request, init);
        };
        // FetchEvent is not available in all envs
        this.fetchEventListener = (event) => event.respondWith(this.handleRequest(event.request, event));
        const schema = (options === null || options === void 0 ? void 0 : options.schema)
            ? isSchema(options.schema)
                ? options.schema
                : makeExecutableSchema({
                    typeDefs: options.schema.typeDefs,
                    resolvers: options.schema.resolvers,
                })
            : getDefaultSchema();
        const logger = (options === null || options === void 0 ? void 0 : options.logging) != null ? options.logging : true;
        this.logger =
            typeof logger === 'boolean'
                ? logger === true
                    ? defaultYogaLogger
                    : {
                        debug: () => { },
                        error: () => { },
                        warn: () => { },
                        info: () => { },
                    }
                : logger;
        const maskedErrors = (_a = options === null || options === void 0 ? void 0 : options.maskedErrors) !== null && _a !== void 0 ? _a : true;
        this.getEnveloped = envelop({
            plugins: [
                // Use the schema provided by the user
                enableIf(schema != null, useSchema(schema)),
                // Performance things
                enableIf((options === null || options === void 0 ? void 0 : options.parserCache) !== false, () => useParserCache(typeof (options === null || options === void 0 ? void 0 : options.parserCache) === 'object'
                    ? options === null || options === void 0 ? void 0 : options.parserCache
                    : undefined)),
                enableIf((options === null || options === void 0 ? void 0 : options.validationCache) !== false, () => useValidationCache({
                    cache: typeof (options === null || options === void 0 ? void 0 : options.validationCache) === 'object'
                        ? options === null || options === void 0 ? void 0 : options.validationCache
                        : undefined,
                })),
                // Log events - useful for debugging purposes
                enableIf(logger !== false, useLogger({
                    logFn: (eventName, events) => {
                        this.logger.debug(eventName);
                        switch (eventName) {
                            case 'execute-start':
                                const { query, variables, operationName, } = events.args.contextValue;
                                this.logger.debug(query, 'query');
                                this.logger.debug(operationName, 'headers');
                                this.logger.debug(variables, 'variables');
                                break;
                            case 'execute-end':
                                this.logger.debug(events.result, 'response');
                                break;
                        }
                    },
                })),
                enableIf((options === null || options === void 0 ? void 0 : options.context) != null, useExtendContext(async (initialContext) => {
                    if (options === null || options === void 0 ? void 0 : options.context) {
                        if (typeof options.context === 'function') {
                            return options.context(initialContext);
                        }
                        else {
                            return options.context;
                        }
                    }
                })),
                ...((_b = options === null || options === void 0 ? void 0 : options.plugins) !== null && _b !== void 0 ? _b : []),
                enableIf(!!maskedErrors, useMaskedErrors(typeof maskedErrors === 'object' ? maskedErrors : undefined)),
            ],
        });
        if ((options === null || options === void 0 ? void 0 : options.cors) != null) {
            if (typeof options.cors === 'function') {
                this.corsOptionsFactory = options.cors;
            }
            else if (typeof options.cors === 'object') {
                const corsOptions = {
                    ...options.cors,
                };
                this.corsOptionsFactory = () => corsOptions;
            }
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.graphiql) === 'function') {
            this.graphiqlOptionsFactory = options.graphiql;
        }
        else if (typeof (options === null || options === void 0 ? void 0 : options.graphiql) === 'object') {
            this.graphiqlOptionsFactory = () => options.graphiql;
        }
        else if ((options === null || options === void 0 ? void 0 : options.graphiql) === false) {
            this.graphiqlOptionsFactory = () => false;
        }
        else {
            this.graphiqlOptionsFactory = () => ({});
        }
    }
    getCORSResponseHeaders(request, ...args) {
        const corsOptions = this.corsOptionsFactory(request, ...args);
        const headers = {};
        headers['Access-Control-Allow-Origin'] = corsOptions.origin
            ? corsOptions.origin.join(', ')
            : request.headers.get('origin') || '*';
        headers['Access-Control-Allow-Methods'] = corsOptions.methods
            ? corsOptions.methods.join(', ')
            : request.headers.get('access-control-request-method') ||
                'GET, POST, OPTIONS';
        headers['Access-Control-Allow-Headers'] = corsOptions.allowedHeaders
            ? corsOptions.allowedHeaders.join(', ')
            : request.headers.get('access-control-request-headers') ||
                'content-type, content-length, accept-encoding';
        headers['Access-Control-Allow-Credentials'] =
            corsOptions.credentials == false ? 'false' : 'true';
        if (corsOptions.exposedHeaders) {
            headers['Access-Control-Expose-Headers'] =
                corsOptions.exposedHeaders.join(', ');
        }
        if (corsOptions.maxAge) {
            headers['Access-Control-Max-Age'] = corsOptions.maxAge.toString();
        }
        headers['Server'] = 'GraphQL Yoga';
        return headers;
    }
    handleOptions(request, ...args) {
        const headers = this.getCORSResponseHeaders(request, ...args);
        const optionsResponse = new Response(null, {
            status: 204,
            headers,
        });
        return optionsResponse;
    }
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    async inject({ document, variables, operationName, headers, serverContext, }) {
        const request = new Request('http://localhost/graphql', {
            method: 'POST',
            headers,
            body: JSON.stringify({
                query: document &&
                    (typeof document === 'string' ? document : print(document)),
                variables,
                operationName,
            }),
        });
        const response = await this.handleRequest(request, serverContext);
        let executionResult = null;
        if (response.headers.get('content-type') === 'application/json') {
            executionResult = await response.json();
        }
        return {
            response,
            executionResult,
        };
    }
    start() {
        self.addEventListener('fetch', this.fetchEventListener);
    }
    stop() {
        self.removeEventListener('fetch', this.fetchEventListener);
    }
}
function createServer(options) {
    const server = new YogaServer(options);
    // TODO: Will be removed once we get rid of classes
    const fnHandler = (input) => {
        if (input.request) {
            return server.handleRequest(input.request, input);
        }
        else {
            return server.handleRequest(input, undefined);
        }
    };
    return new Proxy(fnHandler, {
        get: (_, prop) => {
            if (server[prop]) {
                if (server[prop].bind) {
                    return server[prop].bind(server);
                }
                return server[prop];
            }
            else if (fnHandler[prop]) {
                if (fnHandler[prop].bind) {
                    return fnHandler[prop].bind(fnHandler);
                }
                return fnHandler[prop];
            }
        },
        apply(_, __, [input]) {
            return fnHandler(input);
        },
    });
}

export { YogaServer, createServer, defaultYogaLogger, getDefaultSchema, shouldRenderGraphiQL };
